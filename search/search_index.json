{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started Robonomics platform provides tools for working with the robot economy network. Robonomics allow designers of smart cities and industry 4.0 zones to build trust among the autonomous robots services , provide direct user access via dapp for ordering products from autonomous factories and services of urban sensor networks. This in turn will allow us to put in place a decentralized system that globally monitors the activities of cyber physical systems. Find more in Robonomics whitepaper The following chart describes what place Robonomics takes in the scenario. What the documentation contains Get Weather on Fuji Mountain Demo Easy way to try Robonomics yourself here ! I'm interested in using Robonomics services Take a look at the Robonomics Dapp . Get familiar with the statistic, average miner reward etc. Try out existing services I'm a Dapp developer There are Robonomics-js library and dapp template The documentation is in Learn section I'm a robotics engineer Check out cases section and start developing by examples","title":"Getting Started"},{"location":"#getting-started","text":"Robonomics platform provides tools for working with the robot economy network. Robonomics allow designers of smart cities and industry 4.0 zones to build trust among the autonomous robots services , provide direct user access via dapp for ordering products from autonomous factories and services of urban sensor networks. This in turn will allow us to put in place a decentralized system that globally monitors the activities of cyber physical systems. Find more in Robonomics whitepaper The following chart describes what place Robonomics takes in the scenario.","title":"Getting Started"},{"location":"#what-the-documentation-contains","text":"","title":"What the documentation contains"},{"location":"#get-weather-on-fuji-mountain-demo","text":"Easy way to try Robonomics yourself here !","title":"Get Weather on Fuji Mountain Demo"},{"location":"#im-interested-in-using-robonomics-services","text":"Take a look at the Robonomics Dapp . Get familiar with the statistic, average miner reward etc. Try out existing services","title":"I'm interested in using Robonomics services"},{"location":"#im-a-dapp-developer","text":"There are Robonomics-js library and dapp template The documentation is in Learn section","title":"I'm a Dapp developer"},{"location":"#im-a-robotics-engineer","text":"Check out cases section and start developing by examples","title":"I'm a robotics engineer"},{"location":"community/","text":"Community Here you can learn how to get involved in the Robonomics Network Community. There are many ways to contribute to Robonomics Network: you can contribute directly based on your skills and professional background, you can attend an event, join the conversation online or watch for our latest news and release. For Developers Robonomics' code base and new releases on GitHub Ask your technical question on Riot For Researchers & Academics Read Robonomics White Paper and our scientific articles If you have a background in mathematics, cryptography, or economics you might be interested for collaboration with us, write us to research@aira.life For All, even non-technical Get familiar with Robonomics services and statistics in dApp - open in browser with Metamask Read our blog Stay tuned by following us on Twitter If you are not a developer or a researcher, you can start with other suggestions for getting involeved in Robonomics Network Community. If you want to organize a meetup in your city, write content about Robonomics, translate Robonomics content into your native language, write to community@aira.life","title":"Community"},{"location":"community/#community","text":"Here you can learn how to get involved in the Robonomics Network Community. There are many ways to contribute to Robonomics Network: you can contribute directly based on your skills and professional background, you can attend an event, join the conversation online or watch for our latest news and release.","title":"Community"},{"location":"community/#for-developers","text":"Robonomics' code base and new releases on GitHub Ask your technical question on Riot","title":"For Developers"},{"location":"community/#for-researchers-academics","text":"Read Robonomics White Paper and our scientific articles If you have a background in mathematics, cryptography, or economics you might be interested for collaboration with us, write us to research@aira.life","title":"For Researchers &amp; Academics"},{"location":"community/#for-all-even-non-technical","text":"Get familiar with Robonomics services and statistics in dApp - open in browser with Metamask Read our blog Stay tuned by following us on Twitter If you are not a developer or a researcher, you can start with other suggestions for getting involeved in Robonomics Network Community. If you want to organize a meetup in your city, write content about Robonomics, translate Robonomics content into your native language, write to community@aira.life","title":"For All, even non-technical"},{"location":"contributing/","text":"Contributing Main Airalab repositories aira - AIRA client. robonomics_comm - Robonomics communication stack robonomics_contracts - smart contracts of Robonomics network Please choose a corresponding repository for reporting an issue! Found a bug? Make sure the bug was not already reported - check GitHub Issues . If there is no open issue addressing the problem, open a new one . Be sure to include a title and clear description , as much relevant information as possible. Also, you can open an issue if you have a proposal for improvements. Wrote a patch that fixes a bug? Open a new GitHub pull request with the patch. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable. Please don't fix whitespace, format code, or make a purely cosmetic patch Thanks!","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#main-airalab-repositories","text":"aira - AIRA client. robonomics_comm - Robonomics communication stack robonomics_contracts - smart contracts of Robonomics network Please choose a corresponding repository for reporting an issue!","title":"Main Airalab repositories"},{"location":"contributing/#found-a-bug","text":"Make sure the bug was not already reported - check GitHub Issues . If there is no open issue addressing the problem, open a new one . Be sure to include a title and clear description , as much relevant information as possible. Also, you can open an issue if you have a proposal for improvements.","title":"Found a bug?"},{"location":"contributing/#wrote-a-patch-that-fixes-a-bug","text":"Open a new GitHub pull request with the patch. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable. Please don't fix whitespace, format code, or make a purely cosmetic patch Thanks!","title":"Wrote a patch that fixes a bug?"},{"location":"glossary/","text":"Glossary Agent In terms of Robonomics Network agent is a program module that uses IPFS or blockchain or both interfaces of the network and does some actual work. Usually it's represented as a ROS package and it may connect (but not necessarily) a real cyber-physical system to the Robonomics Network. Cyber-physical system It is a combination of a physical mechanism that is usually called a robot and a program algorithm that controls the behavior of the mechanism Dapp It is a short form for Decentralized application. Usually it is a single page web based application that helps to interact with an agent IPFS According to the official documentation \"IPFS is a distributed system for storing and accessing files, websites, applications, and data\". For more detail how it works go to the official website. Lighthouse A lighthouse is an autonomous workflow that allows us to distribute the running time of providers that serve a single broadcast channel. For more information read Robonomics Whitepaper section 5.2 Sidechain Ethereum based blockchain network with Proof-of-Authority consensus owned by Airalab","title":"Glossary"},{"location":"glossary/#glossary","text":"","title":"Glossary"},{"location":"glossary/#agent","text":"In terms of Robonomics Network agent is a program module that uses IPFS or blockchain or both interfaces of the network and does some actual work. Usually it's represented as a ROS package and it may connect (but not necessarily) a real cyber-physical system to the Robonomics Network.","title":"Agent"},{"location":"glossary/#cyber-physical-system","text":"It is a combination of a physical mechanism that is usually called a robot and a program algorithm that controls the behavior of the mechanism","title":"Cyber-physical system"},{"location":"glossary/#dapp","text":"It is a short form for Decentralized application. Usually it is a single page web based application that helps to interact with an agent","title":"Dapp"},{"location":"glossary/#ipfs","text":"According to the official documentation \"IPFS is a distributed system for storing and accessing files, websites, applications, and data\". For more detail how it works go to the official website.","title":"IPFS"},{"location":"glossary/#lighthouse","text":"A lighthouse is an autonomous workflow that allows us to distribute the running time of providers that serve a single broadcast channel. For more information read Robonomics Whitepaper section 5.2","title":"Lighthouse"},{"location":"glossary/#sidechain","text":"Ethereum based blockchain network with Proof-of-Authority consensus owned by Airalab","title":"Sidechain"},{"location":"r_and_d/","text":"R&D Based on Robonomics Network [EN] For 4 years, the Robonomics project participants completed 13 R&D projects in the process of writing the current version of the Robonomics platform, including: Launching a drone under the control of a decentralized computer. Management of a fleet of drones in a decentralized network. Tokenization of data from IoT devices. Digital markets for robots. Industrial zone management with capital. Drones, sensors, and blockchain for monitoring the quality of water on the Volga. Citizens' Observatories networks. Robot artist Gaka-chu. Issuance of green certificates based on the data from renewable energy sources. Roadspace negotiation for autonomous cars. Blockchain in the tasks of the chemical industry. Control of equipment maintenance process by supply chain participants based on IoT data. Robot as a service in service robotics. [RU] \u0417\u0430 4 \u0433\u043e\u0434\u0430 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0438 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0420\u043e\u0431\u043e\u043d\u043e\u043c\u0438\u043a\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u043b\u0438 13 R&D \u043f\u0440\u043e\u0435\u043a\u0442\u043e\u0432 \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b \u0420\u043e\u0431\u043e\u043d\u043e\u043c\u0438\u043a\u0430. \u041e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441\u043e \u0441\u043f\u0438\u0441\u043a\u043e\u043c \u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u043d\u0430\u043c\u0438 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0435\u0432 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f web3+robotics: \u0417\u0430\u043f\u0443\u0441\u043a \u0434\u0440\u043e\u043d\u0430 \u043f\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u0435\u043c \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u0430. \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0444\u043b\u043e\u0442\u043e\u043c \u0434\u0440\u043e\u043d\u043e\u0432 \u0432 \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u0441\u0435\u0442\u0438. \u0422\u043e\u043a\u0435\u043d\u0438\u0437\u0430\u0446\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 IoT \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432. \u0426\u0438\u0444\u0440\u043e\u0432\u044b\u0435 \u0440\u044b\u043d\u043a\u0438 \u0434\u043b\u044f \u0440\u043e\u0431\u043e\u0442\u043e\u0432. \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0437\u043e\u043d\u043e\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043a\u0430\u043f\u0438\u0442\u0430\u043b\u0430. \u0414\u0440\u043e\u043d\u044b, \u0441\u0435\u043d\u0441\u043e\u0440\u044b \u0438 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d \u0434\u043b\u044f \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0432\u043e\u0434\u044b \u043d\u0430 \u0412\u043e\u043b\u0433\u0435. \u0413\u0440\u0430\u0436\u0434\u0430\u043d\u0441\u043a\u0438\u0435 \u0441\u0435\u043d\u0441\u043e\u0440\u043d\u044b\u0435 \u0441\u0435\u0442\u0438. \u0420\u043e\u0431\u043e\u0442-\u0445\u0443\u0434\u043e\u0436\u043d\u0438\u043a Gaka-chu. \u0412\u044b\u043f\u0443\u0441\u043a \u0437\u0435\u043b\u0435\u043d\u044b\u0445 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 \u0412\u0418\u042d. \u0422\u043e\u0440\u0433\u043e\u0432\u043b\u044f \u043c\u0430\u0448\u0438\u043d \u0437\u0430 \u043c\u0435\u0441\u0442\u043e \u043d\u0430 \u0434\u043e\u0440\u043e\u0433\u0435. \u0411\u043b\u043e\u043a\u0447\u0435\u0439\u043d \u0432 \u0437\u0430\u0434\u0430\u0447\u0430\u0445 \u0445\u0438\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043f\u0440\u043e\u043c\u044b\u0448\u043b\u0435\u043d\u043d\u043e\u0441\u0442\u0438. \u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c \u0438\u0437\u043d\u043e\u0441\u0430 \u043e\u0431\u043e\u0440\u0443\u0434\u043e\u0432\u0430\u043d\u0438\u044f \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\u043c\u0438 \u0446\u0435\u043f\u043e\u0447\u043a\u0438 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 IoT. \u0420\u043e\u0431\u043e\u0442, \u043a\u0430\u043a \u0443\u0441\u043b\u0443\u0433\u0430 \u0432 \u0441\u0435\u0440\u0432\u0438\u0441\u043d\u043e\u0439 \u0440\u043e\u0431\u043e\u0442\u043e\u0442\u0435\u0445\u043d\u0438\u043a\u0435.","title":"R&D based on Robonomics Network"},{"location":"r_and_d/#rd-based-on-robonomics-network","text":"","title":"R&amp;D Based on Robonomics Network"},{"location":"r_and_d/#en","text":"For 4 years, the Robonomics project participants completed 13 R&D projects in the process of writing the current version of the Robonomics platform, including: Launching a drone under the control of a decentralized computer. Management of a fleet of drones in a decentralized network. Tokenization of data from IoT devices. Digital markets for robots. Industrial zone management with capital. Drones, sensors, and blockchain for monitoring the quality of water on the Volga. Citizens' Observatories networks. Robot artist Gaka-chu. Issuance of green certificates based on the data from renewable energy sources. Roadspace negotiation for autonomous cars. Blockchain in the tasks of the chemical industry. Control of equipment maintenance process by supply chain participants based on IoT data. Robot as a service in service robotics.","title":"[EN]"},{"location":"r_and_d/#ru","text":"\u0417\u0430 4 \u0433\u043e\u0434\u0430 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0438 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0420\u043e\u0431\u043e\u043d\u043e\u043c\u0438\u043a\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u043b\u0438 13 R&D \u043f\u0440\u043e\u0435\u043a\u0442\u043e\u0432 \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b \u0420\u043e\u0431\u043e\u043d\u043e\u043c\u0438\u043a\u0430. \u041e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441\u043e \u0441\u043f\u0438\u0441\u043a\u043e\u043c \u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u043d\u0430\u043c\u0438 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0435\u0432 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f web3+robotics: \u0417\u0430\u043f\u0443\u0441\u043a \u0434\u0440\u043e\u043d\u0430 \u043f\u043e\u0434 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u0435\u043c \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u0430. \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0444\u043b\u043e\u0442\u043e\u043c \u0434\u0440\u043e\u043d\u043e\u0432 \u0432 \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u0441\u0435\u0442\u0438. \u0422\u043e\u043a\u0435\u043d\u0438\u0437\u0430\u0446\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 IoT \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432. \u0426\u0438\u0444\u0440\u043e\u0432\u044b\u0435 \u0440\u044b\u043d\u043a\u0438 \u0434\u043b\u044f \u0440\u043e\u0431\u043e\u0442\u043e\u0432. \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0437\u043e\u043d\u043e\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043a\u0430\u043f\u0438\u0442\u0430\u043b\u0430. \u0414\u0440\u043e\u043d\u044b, \u0441\u0435\u043d\u0441\u043e\u0440\u044b \u0438 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d \u0434\u043b\u044f \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0432\u043e\u0434\u044b \u043d\u0430 \u0412\u043e\u043b\u0433\u0435. \u0413\u0440\u0430\u0436\u0434\u0430\u043d\u0441\u043a\u0438\u0435 \u0441\u0435\u043d\u0441\u043e\u0440\u043d\u044b\u0435 \u0441\u0435\u0442\u0438. \u0420\u043e\u0431\u043e\u0442-\u0445\u0443\u0434\u043e\u0436\u043d\u0438\u043a Gaka-chu. \u0412\u044b\u043f\u0443\u0441\u043a \u0437\u0435\u043b\u0435\u043d\u044b\u0445 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0432 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 \u0412\u0418\u042d. \u0422\u043e\u0440\u0433\u043e\u0432\u043b\u044f \u043c\u0430\u0448\u0438\u043d \u0437\u0430 \u043c\u0435\u0441\u0442\u043e \u043d\u0430 \u0434\u043e\u0440\u043e\u0433\u0435. \u0411\u043b\u043e\u043a\u0447\u0435\u0439\u043d \u0432 \u0437\u0430\u0434\u0430\u0447\u0430\u0445 \u0445\u0438\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043f\u0440\u043e\u043c\u044b\u0448\u043b\u0435\u043d\u043d\u043e\u0441\u0442\u0438. \u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c \u0438\u0437\u043d\u043e\u0441\u0430 \u043e\u0431\u043e\u0440\u0443\u0434\u043e\u0432\u0430\u043d\u0438\u044f \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\u043c\u0438 \u0446\u0435\u043f\u043e\u0447\u043a\u0438 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 IoT. \u0420\u043e\u0431\u043e\u0442, \u043a\u0430\u043a \u0443\u0441\u043b\u0443\u0433\u0430 \u0432 \u0441\u0435\u0440\u0432\u0438\u0441\u043d\u043e\u0439 \u0440\u043e\u0431\u043e\u0442\u043e\u0442\u0435\u0445\u043d\u0438\u043a\u0435.","title":"[RU]"},{"location":"robonomics-js/","text":"Robonomics-js Robonomics-js is a simple Javascript library for working with Robonomics network Installation npm install robonomics-js --save or yarn add robonomics-js Dependencies Web3 version 1.2.4 Ipfs version 0.34.0 Usage Creates a Robonomics instance const options = {...}; const robonomics = new Robonomics ( options ); options The object of properties: options.web3 An instance of web3.js : // metamask const options = { web3 : new Web3 ( window . ethereum ), ... }; // infura const options = { web3 : new Web3 ( new Web3 . providers . WebsocketProvider ( \"wss://mainnet.infura.io/ws/v3/0b2f2a5026264b57b6d698b480332e89\" ) ), ... }; options.messageProvider This is an instance of MessageProviderIpfs which uses a js-ipfs node with pubsub support const ipfs = new Ipfs ({ repo : 'robonomics-example' , relay : { enabled : true , hop : { enabled : true } }, EXPERIMENTAL : { pubsub : true }, config : { Addresses : { Swarm : [ '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star' , '/dns4/1.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/' , '/dns4/2.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/' , '/dns4/3.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/' ] }, Bootstrap : [ '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd' , '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3' , '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm' , '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64' , '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic' , '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6' , '/dns4/1.pubsub.aira.life/tcp/443/wss/ipfs/QmdfQmbmXt6sqjZyowxPUsmvBsgSGQjm4VXrV7WGy62dv8' , '/dns4/2.pubsub.aira.life/tcp/443/wss/ipfs/QmPTFt7GJ2MfDuVYwJJTULr6EnsQtGVp8ahYn9NSyoxmd9' , '/dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw' ] } }) const options = { messageProvider : new MessageProviderIpfs ( ipfs ), ... }; options.account This is an account object which will be used to sign messages. It's necessary to specify either account address (that one must be unlocked) or a private key (the address will be recovered from the given private key). Option isSignPrefix tells whether or not a prefix must be appended. Default is true . const options = { account : { address : '0x0000000000000000000000000000000000000000' , privateKey : '0x0000000000000000000000000000000000000000000000000000' , isSignPrefix : true }, ... }; options.ens This is a ens contract object. This one is not required. If it's necessary you may specify address of the contract if the network is not set to mainnet. suffix may be sid for sidechain or eth for mainnet. eth is default. version is the version of Robonomics Network. Default is the latest deployed version. const options = { ens : { address : '0x314159265dD8dbb310642f98f50C066173C1259b' , suffix : 'eth' , version : 5 }, ... }; options.lighthouse ENS name of a lighthouse, not required. Default is airalab.lighthouse.5.robonomics.eth . It's possible to specify only the first part of the name, like airalab . const options = { lighthouse : 'airalab.lighthouse.5.robonomics.eth' , ... }; It's necessary to wait until full initialization const options = {...}; const robonomics = new Robonomics ( options ); robonomics . ready (). then (() => { console . log ( 'Robonomics instance ready' ) }) API Messages Demand The message specification const demand = { // REQUIRED model : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\" , // ipfs hash of the model objective : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\" , // ipfs hash of the objective token : robonomics . xrt . address , // payment token address cost : 1 , // cost deadline : 9999999 , // until which block demand is valid // NOT REQUIRED lighthouse : \"0x0000000000000000000000000000000000000000\" , // lighthouse address, by default the initialization address validator : \"0x0000000000000000000000000000000000000000\" , // validator address if necessary validatorFee : 0 , // validator fee nonce : 1 // index number }; robonomics.sendDemand Signing and broadcasting the demand message. A liability is returned as promise robonomics . sendDemand ( demand ). then ( liability => { console . log ( liability . address ); }); robonomics.onDemand Listens to demand messages with a defined model. If model is null returns any demand message. robonomics . onDemand ( model , message => { console . log ( message ); }); Offer The message specification const offer = { // REQUIRED model : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\" , // ipfs hash of the model objective : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\" , // ipfs hash of the objective token : robonomics . xrt . address , // payment token address cost : 1 , // cost deadline : 9999999 , // until which block demand is valid // NOT REQUIRED lighthouse : \"0x0000000000000000000000000000000000000000\" , // lighthouse address, by default the initialization address lighthouseFee : 0 , // lighthouse fee validator : \"0x0000000000000000000000000000000000000000\" , // validator address if necessary nonce : 1 // index number }; robonomics.sendOffer Signs and broadcasts an offer message. A liability is returned as promise robonomics . sendOffer ( offer ). then ( liability => { console . log ( liability . address ); }); robonomics.onOffer Listens to offer messages with a defined model. If model is null returns any offer message robonomics . onOffer ( model , message => { console . log ( message ); }); Result The message specification const result = { // REQUIRED liability : \"0x0000000000000000000000000000000000000000\" , // liability contract address success : true , // status of the task result : \"QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg\" // ipfs hash of the rosbag log file }; robonomics.sendResult Signs and broadcasts a result message robonomics . sendResult ( result ). then (() => { console . log ( \"ok\" ); }); robonomics.onResult Listens to result messages. These results may be not valid. Valid results are stored in a liability contract robonomics . onResult ( result => { console . log ( result ); }); Smart Contracts Liability liability.getInfo Return a property object of the contract liability . getInfo (). then ( data => { console . log ( data ); /* { model, objective, result, token, cost, lighthouseFee, validatorFee, demandHash, offerHash, promisor, promisee, lighthouse, validator, isSuccess, isFinalized } */ }); liability.onResult Waits until a liability is finished. Returns a result liability . onResult (). then ( result => { console . log ( result ); }); Lighthouse robonomics.lighthouse.getInfo Returns a property object of the contract robonomics . lighthouse . getInfo (). then ( data => { console . log ( data ); /* { minimalStake, timeoutInBlocks, keepAliveBlock, marker, quota } */ }); robonomics.lighthouse.getProviders Returns a list of providers on the lighthouse robonomics . lighthouse . getProviders (). then ( list => { console . log ( list ); }); Creation of a new lighthouse const minimalFreeze = 1000 // Wn const timeout = 25 // blocks const name = 'mylighthouse' // lighthouse name robonomics . factory . methods . createLighthouse ( minimalFreeze , timeout , name ). send ({ from : robonomics . account . address }) . then (( tx ) => console . log ( tx )) robonomics . factory . onLighthouse (( lighthouse ) => { console . log ( lighthouse . name ) }) Become a provider Preliminarily you must call approve for the tokens XRT const name = \"mylighthouse\" ; // lighthouse name const stake = 1000 ; // Wn robonomics . lighthouse . methods . refill ( stake ) . send ({ from : robonomics . account . address }) . then ( tx => console . log ( tx )); Token robonomics.xrt.getInfo Returns property object of the token robonomics . xrt . getInfo (). then ( data => { console . log ( data ); /* { name, totalSupply, decimals, symbol } */ }); Check balance robonomics . xrt . methods . balanceOf ( robonomics . account . address ) . call () . then ( balance => console . log ( balance )); Check allowance robonomics . xrt . methods . allowance ( robonomics . account . address , robonomics . factory . address ) . call () . then ( allowance => console . log ( allowance )); Approve robonomics . xrt . methods . approve ( robonomics . lighthouse . address , 100 ) . send ({ from : robonomics . account . address }) . then ( tx => console . log ( tx )); Links Website Minimal template of dApp dApp example","title":"Robonomics-js"},{"location":"robonomics-js/#robonomics-js","text":"Robonomics-js is a simple Javascript library for working with Robonomics network","title":"Robonomics-js"},{"location":"robonomics-js/#installation","text":"npm install robonomics-js --save or yarn add robonomics-js","title":"Installation"},{"location":"robonomics-js/#dependencies","text":"Web3 version 1.2.4 Ipfs version 0.34.0","title":"Dependencies"},{"location":"robonomics-js/#usage","text":"Creates a Robonomics instance const options = {...}; const robonomics = new Robonomics ( options );","title":"Usage"},{"location":"robonomics-js/#options","text":"The object of properties: options.web3 An instance of web3.js : // metamask const options = { web3 : new Web3 ( window . ethereum ), ... }; // infura const options = { web3 : new Web3 ( new Web3 . providers . WebsocketProvider ( \"wss://mainnet.infura.io/ws/v3/0b2f2a5026264b57b6d698b480332e89\" ) ), ... }; options.messageProvider This is an instance of MessageProviderIpfs which uses a js-ipfs node with pubsub support const ipfs = new Ipfs ({ repo : 'robonomics-example' , relay : { enabled : true , hop : { enabled : true } }, EXPERIMENTAL : { pubsub : true }, config : { Addresses : { Swarm : [ '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star' , '/dns4/1.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/' , '/dns4/2.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/' , '/dns4/3.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/' ] }, Bootstrap : [ '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd' , '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3' , '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm' , '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64' , '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic' , '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6' , '/dns4/1.pubsub.aira.life/tcp/443/wss/ipfs/QmdfQmbmXt6sqjZyowxPUsmvBsgSGQjm4VXrV7WGy62dv8' , '/dns4/2.pubsub.aira.life/tcp/443/wss/ipfs/QmPTFt7GJ2MfDuVYwJJTULr6EnsQtGVp8ahYn9NSyoxmd9' , '/dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw' ] } }) const options = { messageProvider : new MessageProviderIpfs ( ipfs ), ... }; options.account This is an account object which will be used to sign messages. It's necessary to specify either account address (that one must be unlocked) or a private key (the address will be recovered from the given private key). Option isSignPrefix tells whether or not a prefix must be appended. Default is true . const options = { account : { address : '0x0000000000000000000000000000000000000000' , privateKey : '0x0000000000000000000000000000000000000000000000000000' , isSignPrefix : true }, ... }; options.ens This is a ens contract object. This one is not required. If it's necessary you may specify address of the contract if the network is not set to mainnet. suffix may be sid for sidechain or eth for mainnet. eth is default. version is the version of Robonomics Network. Default is the latest deployed version. const options = { ens : { address : '0x314159265dD8dbb310642f98f50C066173C1259b' , suffix : 'eth' , version : 5 }, ... }; options.lighthouse ENS name of a lighthouse, not required. Default is airalab.lighthouse.5.robonomics.eth . It's possible to specify only the first part of the name, like airalab . const options = { lighthouse : 'airalab.lighthouse.5.robonomics.eth' , ... }; It's necessary to wait until full initialization const options = {...}; const robonomics = new Robonomics ( options ); robonomics . ready (). then (() => { console . log ( 'Robonomics instance ready' ) })","title":"options"},{"location":"robonomics-js/#api","text":"","title":"API"},{"location":"robonomics-js/#messages","text":"","title":"Messages"},{"location":"robonomics-js/#demand","text":"The message specification const demand = { // REQUIRED model : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\" , // ipfs hash of the model objective : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\" , // ipfs hash of the objective token : robonomics . xrt . address , // payment token address cost : 1 , // cost deadline : 9999999 , // until which block demand is valid // NOT REQUIRED lighthouse : \"0x0000000000000000000000000000000000000000\" , // lighthouse address, by default the initialization address validator : \"0x0000000000000000000000000000000000000000\" , // validator address if necessary validatorFee : 0 , // validator fee nonce : 1 // index number }; robonomics.sendDemand Signing and broadcasting the demand message. A liability is returned as promise robonomics . sendDemand ( demand ). then ( liability => { console . log ( liability . address ); }); robonomics.onDemand Listens to demand messages with a defined model. If model is null returns any demand message. robonomics . onDemand ( model , message => { console . log ( message ); });","title":"Demand"},{"location":"robonomics-js/#offer","text":"The message specification const offer = { // REQUIRED model : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\" , // ipfs hash of the model objective : \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\" , // ipfs hash of the objective token : robonomics . xrt . address , // payment token address cost : 1 , // cost deadline : 9999999 , // until which block demand is valid // NOT REQUIRED lighthouse : \"0x0000000000000000000000000000000000000000\" , // lighthouse address, by default the initialization address lighthouseFee : 0 , // lighthouse fee validator : \"0x0000000000000000000000000000000000000000\" , // validator address if necessary nonce : 1 // index number }; robonomics.sendOffer Signs and broadcasts an offer message. A liability is returned as promise robonomics . sendOffer ( offer ). then ( liability => { console . log ( liability . address ); }); robonomics.onOffer Listens to offer messages with a defined model. If model is null returns any offer message robonomics . onOffer ( model , message => { console . log ( message ); });","title":"Offer"},{"location":"robonomics-js/#result","text":"The message specification const result = { // REQUIRED liability : \"0x0000000000000000000000000000000000000000\" , // liability contract address success : true , // status of the task result : \"QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg\" // ipfs hash of the rosbag log file }; robonomics.sendResult Signs and broadcasts a result message robonomics . sendResult ( result ). then (() => { console . log ( \"ok\" ); }); robonomics.onResult Listens to result messages. These results may be not valid. Valid results are stored in a liability contract robonomics . onResult ( result => { console . log ( result ); });","title":"Result"},{"location":"robonomics-js/#smart-contracts","text":"","title":"Smart Contracts"},{"location":"robonomics-js/#liability","text":"liability.getInfo Return a property object of the contract liability . getInfo (). then ( data => { console . log ( data ); /* { model, objective, result, token, cost, lighthouseFee, validatorFee, demandHash, offerHash, promisor, promisee, lighthouse, validator, isSuccess, isFinalized } */ }); liability.onResult Waits until a liability is finished. Returns a result liability . onResult (). then ( result => { console . log ( result ); });","title":"Liability"},{"location":"robonomics-js/#lighthouse","text":"robonomics.lighthouse.getInfo Returns a property object of the contract robonomics . lighthouse . getInfo (). then ( data => { console . log ( data ); /* { minimalStake, timeoutInBlocks, keepAliveBlock, marker, quota } */ }); robonomics.lighthouse.getProviders Returns a list of providers on the lighthouse robonomics . lighthouse . getProviders (). then ( list => { console . log ( list ); });","title":"Lighthouse"},{"location":"robonomics-js/#creation-of-a-new-lighthouse","text":"const minimalFreeze = 1000 // Wn const timeout = 25 // blocks const name = 'mylighthouse' // lighthouse name robonomics . factory . methods . createLighthouse ( minimalFreeze , timeout , name ). send ({ from : robonomics . account . address }) . then (( tx ) => console . log ( tx )) robonomics . factory . onLighthouse (( lighthouse ) => { console . log ( lighthouse . name ) })","title":"Creation of a new lighthouse"},{"location":"robonomics-js/#become-a-provider","text":"Preliminarily you must call approve for the tokens XRT const name = \"mylighthouse\" ; // lighthouse name const stake = 1000 ; // Wn robonomics . lighthouse . methods . refill ( stake ) . send ({ from : robonomics . account . address }) . then ( tx => console . log ( tx ));","title":"Become a provider"},{"location":"robonomics-js/#token","text":"robonomics.xrt.getInfo Returns property object of the token robonomics . xrt . getInfo (). then ( data => { console . log ( data ); /* { name, totalSupply, decimals, symbol } */ });","title":"Token"},{"location":"robonomics-js/#check-balance","text":"robonomics . xrt . methods . balanceOf ( robonomics . account . address ) . call () . then ( balance => console . log ( balance ));","title":"Check balance"},{"location":"robonomics-js/#check-allowance","text":"robonomics . xrt . methods . allowance ( robonomics . account . address , robonomics . factory . address ) . call () . then ( allowance => console . log ( allowance ));","title":"Check allowance"},{"location":"robonomics-js/#approve","text":"robonomics . xrt . methods . approve ( robonomics . lighthouse . address , 100 ) . send ({ from : robonomics . account . address }) . then ( tx => console . log ( tx ));","title":"Approve"},{"location":"robonomics-js/#links","text":"Website Minimal template of dApp dApp example","title":"Links"},{"location":"agent_development/examples/","text":"Examples Useful pieces of code and a few scenarios All source code is here Broadcast Demand Broadcast Offer Trader Trader with ACL Open Sensor Data","title":"Examples"},{"location":"agent_development/examples/#examples","text":"Useful pieces of code and a few scenarios All source code is here Broadcast Demand Broadcast Offer Trader Trader with ACL Open Sensor Data","title":"Examples"},{"location":"agent_development/market_messages/","text":"Market Messages Market messages is used for exchange Demand and Offer information. It also used for delivery Result messages with liability execution reports. Note This is spec for Robonomics Generation 5 . Currently for message delivery is used IPFS PubSub broadcaster. IPFS PubSub topic is set according to Lighthouse ENS name. Messages content Robonomics market message use JSON data format. Demand Field ROS Type Description model ipfs_common/Multihash CPS behavioral model identifier objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file token ethereum_common/Address Operational token address cost ethereum_common/UInt256 CPS behavioral model execution cost lighthouse ethereum_common/Address Lighthouse contract address validator ethereum_common/Address Observing network address validatorFee ethereum_common/UInt256 Observing network fee deadline ethereum_common/UInt256 Deadline block number nonce ethereum_common/UInt256 Robonomics message counter sender ethereum_common/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature Offer Field ROS Type Description model ipfs_commom/Multihash CPS behavioral model identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model execution cost validator ethereum_commom/Address Observing network address lighthouse ethereum_commom/Address Lighthouse contract address lighthouseFee ethereum_commom/UInt256 Liability creation fee deadline ethereum_commom/UInt256 Deadline block number nonce ethereum_commom/UInt256 Robonomics message counter sender ethereum_commom/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature Result Field ROS Type Description liability ethereum_commom/Address Liability contract address result ipfs_commom/Multihash Liability result multihash success std_msgs/Bool Is liability executed successful signature std_msgs/UInt8[] Sender\u2019s Ethereum signature Messages signing Before signing the messages is packed using abi.encodePacked solidity finction and hashed by Keccak_256. demandHash = keccak256 ( abi . encodePacked ( _model , _objective , _token , _cost , _lighthouse , _validator , _validator_fee , _deadline , IFactory ( factory ). nonceOf ( _sender ) , _sender )); Note nonce parameter is counted by factory smart contract and incremented for each created liability smart contract. Message hash are signed using Ethereum secp256k1 signature .","title":"Market Messages"},{"location":"agent_development/market_messages/#market-messages","text":"Market messages is used for exchange Demand and Offer information. It also used for delivery Result messages with liability execution reports. Note This is spec for Robonomics Generation 5 . Currently for message delivery is used IPFS PubSub broadcaster. IPFS PubSub topic is set according to Lighthouse ENS name.","title":"Market Messages"},{"location":"agent_development/market_messages/#messages-content","text":"Robonomics market message use JSON data format.","title":"Messages content"},{"location":"agent_development/market_messages/#demand","text":"Field ROS Type Description model ipfs_common/Multihash CPS behavioral model identifier objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file token ethereum_common/Address Operational token address cost ethereum_common/UInt256 CPS behavioral model execution cost lighthouse ethereum_common/Address Lighthouse contract address validator ethereum_common/Address Observing network address validatorFee ethereum_common/UInt256 Observing network fee deadline ethereum_common/UInt256 Deadline block number nonce ethereum_common/UInt256 Robonomics message counter sender ethereum_common/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature","title":"Demand"},{"location":"agent_development/market_messages/#offer","text":"Field ROS Type Description model ipfs_commom/Multihash CPS behavioral model identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model execution cost validator ethereum_commom/Address Observing network address lighthouse ethereum_commom/Address Lighthouse contract address lighthouseFee ethereum_commom/UInt256 Liability creation fee deadline ethereum_commom/UInt256 Deadline block number nonce ethereum_commom/UInt256 Robonomics message counter sender ethereum_commom/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature","title":"Offer"},{"location":"agent_development/market_messages/#result","text":"Field ROS Type Description liability ethereum_commom/Address Liability contract address result ipfs_commom/Multihash Liability result multihash success std_msgs/Bool Is liability executed successful signature std_msgs/UInt8[] Sender\u2019s Ethereum signature","title":"Result"},{"location":"agent_development/market_messages/#messages-signing","text":"Before signing the messages is packed using abi.encodePacked solidity finction and hashed by Keccak_256. demandHash = keccak256 ( abi . encodePacked ( _model , _objective , _token , _cost , _lighthouse , _validator , _validator_fee , _deadline , IFactory ( factory ). nonceOf ( _sender ) , _sender )); Note nonce parameter is counted by factory smart contract and incremented for each created liability smart contract. Message hash are signed using Ethereum secp256k1 signature .","title":"Messages signing"},{"location":"agent_development/api/ethereum_common/","text":"Ethereum Common The packages contains two launch files: erc20.launch and signer.launch . The last one is included in Robonomics Liability . Below is the description for erc20 node which contains utils for convenient work with Ethereum accounts and XRT token. ROS Parameters ~web3_http_provider Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545 ~erc20_token ERC20 token to work with. Type is string , defaults to xrt.5.robonomics.eth ~factory_contract The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth ~ens_contract The checksumed address of ENS registry. The type is string , defaults to \"\" ~keyfile Path to keyfile. The type is string , defaults to \"\" . Required parameter ~keyfile_password_file Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter Published topics /eth/event/transfer (ethereum_common/TransferEvent) The event ethereum_common/TransferEvent is emitted after the transfer of tokens was made /eth/event/approval (ethereum_common/ApprovalEvent) The event ethereum_common/ApprovalEvent is emitted after the approval of tokens was made Services /eth/accounts (ethereum_common/Accounts) List of available Ethereum accounts. See ethereum_common/Accounts /eth/account_eth_balance (ethereum_common/AccountBalance) Returns the balance of the given address in Wei. See ethereum_common/AccountBalance /eth/eth_balance (ethereum_common/Balance) Returns the balance of the default address. See :ref: Ethereum-common-Balance.srv /eth/current_block (ethereum_common/BlockNumber) Returns current block number. See :ref: Ethereum-common-BlockNumber.srv /eth/transfer (ethereum_common/Transfer) Transfers tokens from the default account to a given one. See :ref: Ethereum-common-Transfer.srv /eth/transfer_from (ethereum_common/TransferFrom) Transfers tokens from a given account to another one. See :ref: Ethereum-common-TransferFrom.srv /eth/approve (ethereum_common/Approve) Approves tokens from the default account to a given one. See :ref: Ethereum-common-Approve.srv /eth/account_xrt_balance (ethereum_common/AccountBalance) Returns the XRT balance of a given account. See :ref: Ethereum-common-AccountBalance.srv /eth/xrt_balance (ethereum_common/Balance) Return the XRT balance of the default account. See :ref: Ethereum-common-Balance.srv /eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance) Returns how much one account is allowed to spend from another account. See :ref: Ethereum-common-AccountToAddressAllowance.srv /eth/xrt_allowance (ethereum_common/Allowance) Returns how much the Factory is allowed to spend from the default account. See :ref: Ethereum-common-Allowance.srv","title":"Ethereum Common"},{"location":"agent_development/api/ethereum_common/#ethereum-common","text":"The packages contains two launch files: erc20.launch and signer.launch . The last one is included in Robonomics Liability . Below is the description for erc20 node which contains utils for convenient work with Ethereum accounts and XRT token.","title":"Ethereum Common"},{"location":"agent_development/api/ethereum_common/#ros-parameters","text":"","title":"ROS Parameters"},{"location":"agent_development/api/ethereum_common/#web3_http_provider","text":"Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545","title":"~web3_http_provider"},{"location":"agent_development/api/ethereum_common/#erc20_token","text":"ERC20 token to work with. Type is string , defaults to xrt.5.robonomics.eth","title":"~erc20_token"},{"location":"agent_development/api/ethereum_common/#factory_contract","text":"The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth","title":"~factory_contract"},{"location":"agent_development/api/ethereum_common/#ens_contract","text":"The checksumed address of ENS registry. The type is string , defaults to \"\"","title":"~ens_contract"},{"location":"agent_development/api/ethereum_common/#keyfile","text":"Path to keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile"},{"location":"agent_development/api/ethereum_common/#keyfile_password_file","text":"Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile_password_file"},{"location":"agent_development/api/ethereum_common/#published-topics","text":"","title":"Published topics"},{"location":"agent_development/api/ethereum_common/#etheventtransfer-ethereum_commontransferevent","text":"The event ethereum_common/TransferEvent is emitted after the transfer of tokens was made","title":"/eth/event/transfer (ethereum_common/TransferEvent)"},{"location":"agent_development/api/ethereum_common/#etheventapproval-ethereum_commonapprovalevent","text":"The event ethereum_common/ApprovalEvent is emitted after the approval of tokens was made","title":"/eth/event/approval (ethereum_common/ApprovalEvent)"},{"location":"agent_development/api/ethereum_common/#services","text":"","title":"Services"},{"location":"agent_development/api/ethereum_common/#ethaccounts-ethereum_commonaccounts","text":"List of available Ethereum accounts. See ethereum_common/Accounts","title":"/eth/accounts (ethereum_common/Accounts)"},{"location":"agent_development/api/ethereum_common/#ethaccount_eth_balance-ethereum_commonaccountbalance","text":"Returns the balance of the given address in Wei. See ethereum_common/AccountBalance","title":"/eth/account_eth_balance (ethereum_common/AccountBalance)"},{"location":"agent_development/api/ethereum_common/#etheth_balance-ethereum_commonbalance","text":"Returns the balance of the default address. See :ref: Ethereum-common-Balance.srv","title":"/eth/eth_balance (ethereum_common/Balance)"},{"location":"agent_development/api/ethereum_common/#ethcurrent_block-ethereum_commonblocknumber","text":"Returns current block number. See :ref: Ethereum-common-BlockNumber.srv","title":"/eth/current_block (ethereum_common/BlockNumber)"},{"location":"agent_development/api/ethereum_common/#ethtransfer-ethereum_commontransfer","text":"Transfers tokens from the default account to a given one. See :ref: Ethereum-common-Transfer.srv","title":"/eth/transfer (ethereum_common/Transfer)"},{"location":"agent_development/api/ethereum_common/#ethtransfer_from-ethereum_commontransferfrom","text":"Transfers tokens from a given account to another one. See :ref: Ethereum-common-TransferFrom.srv","title":"/eth/transfer_from (ethereum_common/TransferFrom)"},{"location":"agent_development/api/ethereum_common/#ethapprove-ethereum_commonapprove","text":"Approves tokens from the default account to a given one. See :ref: Ethereum-common-Approve.srv","title":"/eth/approve (ethereum_common/Approve)"},{"location":"agent_development/api/ethereum_common/#ethaccount_xrt_balance-ethereum_commonaccountbalance","text":"Returns the XRT balance of a given account. See :ref: Ethereum-common-AccountBalance.srv","title":"/eth/account_xrt_balance (ethereum_common/AccountBalance)"},{"location":"agent_development/api/ethereum_common/#ethxrt_balance-ethereum_commonbalance","text":"Return the XRT balance of the default account. See :ref: Ethereum-common-Balance.srv","title":"/eth/xrt_balance (ethereum_common/Balance)"},{"location":"agent_development/api/ethereum_common/#ethaccount_xrt_allowance-ethereum_commonaccounttoaddressallowance","text":"Returns how much one account is allowed to spend from another account. See :ref: Ethereum-common-AccountToAddressAllowance.srv","title":"/eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance)"},{"location":"agent_development/api/ethereum_common/#ethxrt_allowance-ethereum_commonallowance","text":"Returns how much the Factory is allowed to spend from the default account. See :ref: Ethereum-common-Allowance.srv","title":"/eth/xrt_allowance (ethereum_common/Allowance)"},{"location":"agent_development/api/ethereum_common_msgs/","text":"Ethereum Common Messages ethereum_common/Address.msg Field Type Description address std_msgs/String Address in Ethereum blockchain ethereum_common/UInt256.msg Field Type Description uint256 std_msgs/String A wrapper for big integers ethereum_common/TransferEvent.msg Field Type Description args_from ethereum_common/Address Sender address args_to ethereum_common/Address Receiver address args_value ethereum_common/UInt256 Amount of tokens ethereum_common/ApprovalEvent.msg Field Type Description args_owner ethereum_common/Address Owner address args_spender ethereum_common/Address Spender address args_value ethereum_common/UInt256 Amount of tokens ethereum_common/AccountBalance.srv Request Field Type Description account ethereum_common/Address Ethereum address Response Field Type Description balance ethereum_common/UInt256 Balance in Wei ethereum_common/AccountToAddressAllowance.srv Request Field Type Description account ethereum_common/Address Ethereum address to ethereum_common/Address Ethereum address Response Field Type Description amount ethereum_common/UInt256 Balance in Wn ethereum_common/Accounts.srv Request Request is empty Response Field Type Description accounts ethereum_common/Address[] List of available accounts ethereum_common/Allowance.srv Request Request is empty Response Field Type Description amount ethereum_common/UInt256 Amount of XRT the Factory is allowed to spend ethereum_common/Approve.srv Request Field Type Description spender ethereum_common/Address Who is allowed to spend value ethereum_common/UInt256 How much tokens are allowed Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash ethereum_common/Balance.srv Request Request is empty Response Field Type Description balance ethereum_common/UInt256 The balance of default account ethereum_common/BlockNumber.srv Request Request is empty Response Field Type Description number std_msgs/Uint64 Current block number ethereum_common/Transfer.srv Request Field Type Description to ethereum_common/Address Ethereum address value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash ethereum_common/TransferFrom.srv Request Field Type Description owner ethereum_common/Address Owner's address to ethereum_common/Address Another account value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"Ethereum Common Messages"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum-common-messages","text":"","title":"Ethereum Common Messages"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaddressmsg","text":"Field Type Description address std_msgs/String Address in Ethereum blockchain","title":"ethereum_common/Address.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonuint256msg","text":"Field Type Description uint256 std_msgs/String A wrapper for big integers","title":"ethereum_common/UInt256.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commontransfereventmsg","text":"Field Type Description args_from ethereum_common/Address Sender address args_to ethereum_common/Address Receiver address args_value ethereum_common/UInt256 Amount of tokens","title":"ethereum_common/TransferEvent.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonapprovaleventmsg","text":"Field Type Description args_owner ethereum_common/Address Owner address args_spender ethereum_common/Address Spender address args_value ethereum_common/UInt256 Amount of tokens","title":"ethereum_common/ApprovalEvent.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaccountbalancesrv","text":"Request Field Type Description account ethereum_common/Address Ethereum address Response Field Type Description balance ethereum_common/UInt256 Balance in Wei","title":"ethereum_common/AccountBalance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaccounttoaddressallowancesrv","text":"Request Field Type Description account ethereum_common/Address Ethereum address to ethereum_common/Address Ethereum address Response Field Type Description amount ethereum_common/UInt256 Balance in Wn","title":"ethereum_common/AccountToAddressAllowance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaccountssrv","text":"Request Request is empty Response Field Type Description accounts ethereum_common/Address[] List of available accounts","title":"ethereum_common/Accounts.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonallowancesrv","text":"Request Request is empty Response Field Type Description amount ethereum_common/UInt256 Amount of XRT the Factory is allowed to spend","title":"ethereum_common/Allowance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonapprovesrv","text":"Request Field Type Description spender ethereum_common/Address Who is allowed to spend value ethereum_common/UInt256 How much tokens are allowed Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"ethereum_common/Approve.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonbalancesrv","text":"Request Request is empty Response Field Type Description balance ethereum_common/UInt256 The balance of default account","title":"ethereum_common/Balance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonblocknumbersrv","text":"Request Request is empty Response Field Type Description number std_msgs/Uint64 Current block number","title":"ethereum_common/BlockNumber.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commontransfersrv","text":"Request Field Type Description to ethereum_common/Address Ethereum address value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"ethereum_common/Transfer.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commontransferfromsrv","text":"Request Field Type Description owner ethereum_common/Address Owner's address to ethereum_common/Address Another account value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"ethereum_common/TransferFrom.srv"},{"location":"agent_development/api/ipfs_common/","text":"IPFS Common The package handle IPFS connections, provides useful services for working with IPFS Network. It's included in robonomics_liability launch file ROS Parameters ~lighthouse_contract The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth ~ipfs_http_provider IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001 ~ipfs_public_providers A public IPFS node to pin result files. The type is string , defaults to \"\" ~ipfs_file_providers A list of public nodes to pin result files. The type is list of strings , defaults to [ipfs_public_providers] ~ipfs_swarm_connect_addresses IPFS nodes to connect to. The type is string , defaults to \"\" ~ipfs_swarm_connect_to A list of IPFS nodes to connect to. The type is list of strings , defaults to [ipfs_swarm_connect_addresses] Subscribed topics","title":"IPFS Common"},{"location":"agent_development/api/ipfs_common/#ipfs-common","text":"The package handle IPFS connections, provides useful services for working with IPFS Network. It's included in robonomics_liability launch file","title":"IPFS Common"},{"location":"agent_development/api/ipfs_common/#ros-parameters","text":"","title":"ROS Parameters"},{"location":"agent_development/api/ipfs_common/#lighthouse_contract","text":"The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth","title":"~lighthouse_contract"},{"location":"agent_development/api/ipfs_common/#ipfs_http_provider","text":"IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001","title":"~ipfs_http_provider"},{"location":"agent_development/api/ipfs_common/#ipfs_public_providers","text":"A public IPFS node to pin result files. The type is string , defaults to \"\"","title":"~ipfs_public_providers"},{"location":"agent_development/api/ipfs_common/#ipfs_file_providers","text":"A list of public nodes to pin result files. The type is list of strings , defaults to [ipfs_public_providers]","title":"~ipfs_file_providers"},{"location":"agent_development/api/ipfs_common/#ipfs_swarm_connect_addresses","text":"IPFS nodes to connect to. The type is string , defaults to \"\"","title":"~ipfs_swarm_connect_addresses"},{"location":"agent_development/api/ipfs_common/#ipfs_swarm_connect_to","text":"A list of IPFS nodes to connect to. The type is list of strings , defaults to [ipfs_swarm_connect_addresses]","title":"~ipfs_swarm_connect_to"},{"location":"agent_development/api/ipfs_common/#subscribed-topics","text":"","title":"Subscribed topics"},{"location":"agent_development/api/ipfs_common_msgs/","text":"IPFS Common Messages ipfs_common/Filepath.msg Field Type Description filepath std_msgs/String A path to a file ipfs_common/Multihash.msg Field Type Description multihash std_msgs/String A wrapper for model and objective fields ipfs_common/IpfsDownloadFile.srv Request Field Type Description ipfs_address ipfs_common/Multihash IPFS hash of a file file ipfs_common/Filepath Where to save the file Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message ipfs_common/IpfsUploadFile.srv Request Field Type Description file ipfs_common/Filepath Path to a file to be uploaded to IPFS Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message ipfs_address ipfs_common/Multihash IPFS hash of uploaded file","title":"IPFS Common Messages"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs-common-messages","text":"","title":"IPFS Common Messages"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonfilepathmsg","text":"Field Type Description filepath std_msgs/String A path to a file","title":"ipfs_common/Filepath.msg"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonmultihashmsg","text":"Field Type Description multihash std_msgs/String A wrapper for model and objective fields","title":"ipfs_common/Multihash.msg"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonipfsdownloadfilesrv","text":"Request Field Type Description ipfs_address ipfs_common/Multihash IPFS hash of a file file ipfs_common/Filepath Where to save the file Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message","title":"ipfs_common/IpfsDownloadFile.srv"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonipfsuploadfilesrv","text":"Request Field Type Description file ipfs_common/Filepath Path to a file to be uploaded to IPFS Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message ipfs_address ipfs_common/Multihash IPFS hash of uploaded file","title":"ipfs_common/IpfsUploadFile.srv"},{"location":"agent_development/api/robonomics_liability/","text":"Robonomics Liability The package is responsible for receiving New Liability events ( listener node) and playing topics from objective field ( executor node). The launch file also include ipfs_channel node and signer node. ROS Parameters ~web3_http_provider Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545 ~web3_ws_provider Web3 WebSocket provider address. The type is string , defaults to ws://127.0.0.1:8546 ~ipfs_http_provider IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001 ~ipfs_swarm_connect_addresses IPFS nodes to connect to. The type is string , defaults to \"\" ~ipfs_public_providers A public IPFS node to pin result files. The type is string , defaults to \"\" ~factory_contract The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth ~lighthouse_contract The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth ~enable_executor Enable or disable executor node. If it's false , no topics from objective would be published. The type is boolean , defaults to true ~master_check_interval Period (in seconds) to check master for new topic publications. It's necessary for the Recorder, which records all the topics a CPS publishes. The type is double , defaults to 0.1 ~recording_topics List of topics name separated by comma. It allows you to specify which topics would be recorded. The type is string , defaults to \"\" ~ens_contract The checksumed address of ENS registry. The type is string , defaults to \"\" ~keyfile Path to keyfile. The type is string , defaults to \"\" . Required parameter ~keyfile_password_file Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter Subscribed topics /liability/infochan/eth/signing/demand (robonomics_msgs/Demand) robonomics_msgs/Demand message to sign and send further to IPFS channel /liability/infochan/eth/signing/offer (robonomics_msgs/Offer) robonomics_msgs/Offer message to sign and send further to IPFS channel /liability/infochan/eth/signing/result (robonomics_msgs/Result) robonomics_msgs/Result message to sign and send further to IPFS channel Published topics /liability/infochan/incoming/demand (robonomics_msgs/Demand) Contains a robonomics_msgs/Demand message which was read from IPFS channel /liability/infochan/incoming/offer (robonomics_msgs/Offer) Contains a robonomics_msgs/Offer message which was read from IPFS channel /liability/infochan/incoming/result (robonomics_msgs/Result) Contains a robonomics_msgs/Result message which was read from IPFS channel /liability/incoming (robonomics_liability/Liability) Contains all the information about the last created robonomics_liability/Liability /liability/ready (robonomics_liability/Liability) Signals when a robonomics_liability/Liability is ready for execution /liability/complete (robonomics_liability/Liability) Signals when a robonomics_liability/Liability has done its job /liability/finalized (std_msgs/String) Signals when a liability has been finalized Services /liability/start (robonomics_liability/StartLiability) The service tells executor to play topics from the objective. It's required to pass a liability address ( robonomics_liability/StartLiability ), which you can get from /liability/ready topic /liability/finish (robonomics_liability/FinishLiability) CPS should call the service after performing the task. The input is robonomics_liability/FinishLiability /liability/restart (robonomics_liability/StartLiability) The service allows to restart a liability after the system shutdown. The input is robonomics_liability/StartLiability /liability/resume (robonomics_liability/StartLiability) The service allows to resume a liability from the last timestamp available in the persistence store. The input is robonomics_liability/StartLiability /liability/read (robonomics_liability/ReadLiability) The service returns all the data about a liability by its address. The input is robonomics_liability/ReadLiability","title":"Robonomics Liability"},{"location":"agent_development/api/robonomics_liability/#robonomics-liability","text":"The package is responsible for receiving New Liability events ( listener node) and playing topics from objective field ( executor node). The launch file also include ipfs_channel node and signer node.","title":"Robonomics Liability"},{"location":"agent_development/api/robonomics_liability/#ros-parameters","text":"","title":"ROS Parameters"},{"location":"agent_development/api/robonomics_liability/#web3_http_provider","text":"Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545","title":"~web3_http_provider"},{"location":"agent_development/api/robonomics_liability/#web3_ws_provider","text":"Web3 WebSocket provider address. The type is string , defaults to ws://127.0.0.1:8546","title":"~web3_ws_provider"},{"location":"agent_development/api/robonomics_liability/#ipfs_http_provider","text":"IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001","title":"~ipfs_http_provider"},{"location":"agent_development/api/robonomics_liability/#ipfs_swarm_connect_addresses","text":"IPFS nodes to connect to. The type is string , defaults to \"\"","title":"~ipfs_swarm_connect_addresses"},{"location":"agent_development/api/robonomics_liability/#ipfs_public_providers","text":"A public IPFS node to pin result files. The type is string , defaults to \"\"","title":"~ipfs_public_providers"},{"location":"agent_development/api/robonomics_liability/#factory_contract","text":"The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth","title":"~factory_contract"},{"location":"agent_development/api/robonomics_liability/#lighthouse_contract","text":"The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth","title":"~lighthouse_contract"},{"location":"agent_development/api/robonomics_liability/#enable_executor","text":"Enable or disable executor node. If it's false , no topics from objective would be published. The type is boolean , defaults to true","title":"~enable_executor"},{"location":"agent_development/api/robonomics_liability/#master_check_interval","text":"Period (in seconds) to check master for new topic publications. It's necessary for the Recorder, which records all the topics a CPS publishes. The type is double , defaults to 0.1","title":"~master_check_interval"},{"location":"agent_development/api/robonomics_liability/#recording_topics","text":"List of topics name separated by comma. It allows you to specify which topics would be recorded. The type is string , defaults to \"\"","title":"~recording_topics"},{"location":"agent_development/api/robonomics_liability/#ens_contract","text":"The checksumed address of ENS registry. The type is string , defaults to \"\"","title":"~ens_contract"},{"location":"agent_development/api/robonomics_liability/#keyfile","text":"Path to keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile"},{"location":"agent_development/api/robonomics_liability/#keyfile_password_file","text":"Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile_password_file"},{"location":"agent_development/api/robonomics_liability/#subscribed-topics","text":"","title":"Subscribed topics"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanethsigningdemand-robonomics_msgsdemand","text":"robonomics_msgs/Demand message to sign and send further to IPFS channel","title":"/liability/infochan/eth/signing/demand (robonomics_msgs/Demand)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanethsigningoffer-robonomics_msgsoffer","text":"robonomics_msgs/Offer message to sign and send further to IPFS channel","title":"/liability/infochan/eth/signing/offer (robonomics_msgs/Offer)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanethsigningresult-robonomics_msgsresult","text":"robonomics_msgs/Result message to sign and send further to IPFS channel","title":"/liability/infochan/eth/signing/result (robonomics_msgs/Result)"},{"location":"agent_development/api/robonomics_liability/#published-topics","text":"","title":"Published topics"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanincomingdemand-robonomics_msgsdemand","text":"Contains a robonomics_msgs/Demand message which was read from IPFS channel","title":"/liability/infochan/incoming/demand (robonomics_msgs/Demand)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanincomingoffer-robonomics_msgsoffer","text":"Contains a robonomics_msgs/Offer message which was read from IPFS channel","title":"/liability/infochan/incoming/offer (robonomics_msgs/Offer)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanincomingresult-robonomics_msgsresult","text":"Contains a robonomics_msgs/Result message which was read from IPFS channel","title":"/liability/infochan/incoming/result (robonomics_msgs/Result)"},{"location":"agent_development/api/robonomics_liability/#liabilityincoming-robonomics_liabilityliability","text":"Contains all the information about the last created robonomics_liability/Liability","title":"/liability/incoming (robonomics_liability/Liability)"},{"location":"agent_development/api/robonomics_liability/#liabilityready-robonomics_liabilityliability","text":"Signals when a robonomics_liability/Liability is ready for execution","title":"/liability/ready (robonomics_liability/Liability)"},{"location":"agent_development/api/robonomics_liability/#liabilitycomplete-robonomics_liabilityliability","text":"Signals when a robonomics_liability/Liability has done its job","title":"/liability/complete (robonomics_liability/Liability)"},{"location":"agent_development/api/robonomics_liability/#liabilityfinalized-std_msgsstring","text":"Signals when a liability has been finalized","title":"/liability/finalized (std_msgs/String)"},{"location":"agent_development/api/robonomics_liability/#services","text":"","title":"Services"},{"location":"agent_development/api/robonomics_liability/#liabilitystart-robonomics_liabilitystartliability","text":"The service tells executor to play topics from the objective. It's required to pass a liability address ( robonomics_liability/StartLiability ), which you can get from /liability/ready topic","title":"/liability/start (robonomics_liability/StartLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityfinish-robonomics_liabilityfinishliability","text":"CPS should call the service after performing the task. The input is robonomics_liability/FinishLiability","title":"/liability/finish (robonomics_liability/FinishLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityrestart-robonomics_liabilitystartliability","text":"The service allows to restart a liability after the system shutdown. The input is robonomics_liability/StartLiability","title":"/liability/restart (robonomics_liability/StartLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityresume-robonomics_liabilitystartliability","text":"The service allows to resume a liability from the last timestamp available in the persistence store. The input is robonomics_liability/StartLiability","title":"/liability/resume (robonomics_liability/StartLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityread-robonomics_liabilityreadliability","text":"The service returns all the data about a liability by its address. The input is robonomics_liability/ReadLiability","title":"/liability/read (robonomics_liability/ReadLiability)"},{"location":"agent_development/api/robonomics_liability_msgs/","text":"Robonomics Liability Messages robonomics_liability/Liability.msg Field Type Description address ethereum_commom/Address The Liability\u2019s address model ipfs_commom/Multihash CPS behavioral model Identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file result ipfs_commom/Multihash Liability result hash promisee ethereum_commom/Address The promisee address promisor ethereum_commom/Address The promisor address (usually CPS) lighthouse ethereum_commom/Address The address of lighthouse your CPS works on token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model implementation cost validator ethereum_commom/Address Observing network address validatorFee ethereum_commom/UInt256 Observing network commission robonomics_liability/StartLiability.srv Request Field Type Description address std_msgs/String The address of Liability you are willing to execute Response Field Type Description success std_msgs/Bool Weather or not the Liability was started msg std_msgs/String Status of launch robonomics_liability/FinishLiability.srv Request Field Type Description address std_msgs/String The address of Liability to finish success std_msgs/Bool The status of execution Response The response is empty robonomics_liability/ReadLiability.srv Request Field Type Description address ethereum_commom/Address The address of a liability Response Field Type Description read std_msgs/Bool Status of execution liability robonomics_liability/Liability Liability","title":"Robonomics Liability Messages"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics-liability-messages","text":"","title":"Robonomics Liability Messages"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilityliabilitymsg","text":"Field Type Description address ethereum_commom/Address The Liability\u2019s address model ipfs_commom/Multihash CPS behavioral model Identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file result ipfs_commom/Multihash Liability result hash promisee ethereum_commom/Address The promisee address promisor ethereum_commom/Address The promisor address (usually CPS) lighthouse ethereum_commom/Address The address of lighthouse your CPS works on token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model implementation cost validator ethereum_commom/Address Observing network address validatorFee ethereum_commom/UInt256 Observing network commission","title":"robonomics_liability/Liability.msg"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilitystartliabilitysrv","text":"Request Field Type Description address std_msgs/String The address of Liability you are willing to execute Response Field Type Description success std_msgs/Bool Weather or not the Liability was started msg std_msgs/String Status of launch","title":"robonomics_liability/StartLiability.srv"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilityfinishliabilitysrv","text":"Request Field Type Description address std_msgs/String The address of Liability to finish success std_msgs/Bool The status of execution Response The response is empty","title":"robonomics_liability/FinishLiability.srv"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilityreadliabilitysrv","text":"Request Field Type Description address ethereum_commom/Address The address of a liability Response Field Type Description read std_msgs/Bool Status of execution liability robonomics_liability/Liability Liability","title":"robonomics_liability/ReadLiability.srv"},{"location":"agent_development/hardware_examples/connect_sensor/","text":"Connect an Air Pollution Sensor In this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network! .. note:: Source code is located `here <https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city>`_ In this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message Arduino Let's begin with an Arduino circuit. You need the following components: Arduino Uno Optical Dust Sensor Sharp GP2Y1010AU0F Gas Sensor MQ-2 Gas Sensor MQ-7 Resistor 150 Ohm Capacitor 220 uF Wires Connect all parts as described below: .. image:: ../img/7.png :alt: Arduino schema :align: center A firmware for Arduino Uno is in sensor_city/scetches folder. In order to upload it to the board use Arduino IDE <https://www.arduino.cc/en/Main/Software> _. .. image:: ../img/8.png :alt: Arduino IDE :align: center Aira .. note:: The following steps are performed in Aira client. You can download the latest image from `this page <https://github.com/airalab/aira/releases>`_. It's convenient to `connect via SSH <../aira_in_depth/Connecting_via_SSH.html>`_ After you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check Enable Serial Port and assign /dev/ttyACM0 in Path/Address . Inside the virtual machine /dev/ttyS0 refers to your external Arduino. .. image:: ../img/9.png :alt: Set a port :align: center Finally launch the image and run these command:: $ roslaunch sensor_city publish_data.launch .. hint:: Check out the source code to learn how it works under the hood! Now Aira patiently waits for a signal to publish the measurements. Go to Dapp <https://dev.aira.life/smart-city/#/> _ and click on Broadcast signal . You should see the data!","title":"Connect an Air Pollution Sensor"},{"location":"agent_development/hardware_examples/connect_sensor/#connect-an-air-pollution-sensor","text":"In this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network! .. note:: Source code is located `here <https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city>`_ In this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message","title":"Connect an Air Pollution Sensor"},{"location":"agent_development/hardware_examples/connect_sensor/#arduino","text":"Let's begin with an Arduino circuit. You need the following components: Arduino Uno Optical Dust Sensor Sharp GP2Y1010AU0F Gas Sensor MQ-2 Gas Sensor MQ-7 Resistor 150 Ohm Capacitor 220 uF Wires Connect all parts as described below: .. image:: ../img/7.png :alt: Arduino schema :align: center A firmware for Arduino Uno is in sensor_city/scetches folder. In order to upload it to the board use Arduino IDE <https://www.arduino.cc/en/Main/Software> _. .. image:: ../img/8.png :alt: Arduino IDE :align: center","title":"Arduino"},{"location":"agent_development/hardware_examples/connect_sensor/#aira","text":".. note:: The following steps are performed in Aira client. You can download the latest image from `this page <https://github.com/airalab/aira/releases>`_. It's convenient to `connect via SSH <../aira_in_depth/Connecting_via_SSH.html>`_ After you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check Enable Serial Port and assign /dev/ttyACM0 in Path/Address . Inside the virtual machine /dev/ttyS0 refers to your external Arduino. .. image:: ../img/9.png :alt: Set a port :align: center Finally launch the image and run these command:: $ roslaunch sensor_city publish_data.launch .. hint:: Check out the source code to learn how it works under the hood! Now Aira patiently waits for a signal to publish the measurements. Go to Dapp <https://dev.aira.life/smart-city/#/> _ and click on Broadcast signal . You should see the data!","title":"Aira"},{"location":"agent_development/hardware_examples/connect_simple_cps/","text":"Connect the Simplest CPS In this section we will build the simplest real cyber-physical system! We will buy a \"wink\" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink> _. Arduino The firmware for the board is located in arduino_blink/misc/arduino/arduino.ino <https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino> . Use Arduino IDE <https://www.arduino.cc/en/Main/Software> to load the code to your Arduino board. In the code we subscribe for the /blink_led topic and set a callback. The type of the topic is Empty , so the board waits until someone publishes to the topic and performs the LED blinking. .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void messageCb( const std_msgs::Empty& toggle_msg){ blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); } ros::Subscriber sub(\"blink_led\", &messageCb ); void setup() { pinMode(LED_BUILTIN, OUTPUT); nh.initNode(); nh.subscribe(sub); } void loop() { nh.spinOnce(); delay(1); } AIRA client .. note:: You can download the latest release from here <https://github.com/airalab/aira/releases> _ Set up the COM port forwarding as described in this lesson <connect_sensor.html> _. You should forward your /dev/ttyUSB0 or /dev/ttyACM0 port (depending on the system) to COM1 . In the client /dev/ttyS0 will represent the board. After this launch the virtual machine. ROS When new liability is created it goes to /liability/ready topic. We have to remember the address and call /liability/start service to get the data from objective. .. code-block:: python def newliability(l): self.liability = l.address rospy.loginfo(\"Got new liability {}\".format(self.liability)) prefix = \"/liability/eth_\" + self.liability rospy.Subscriber(prefix + '/blink', Empty, self.blink) rospy.wait_for_service(\"/liability/start\") rospy.ServiceProxy('/liability/start', StartLiability)(StartLiabilityRequest(address=self.liability)) rospy.Subscriber(\"/liability/ready\", Liability, newliability) A message in the /blink topic come from the objective field. Have a look at Basic usage <../basic_usage.html> _ page. AIRA Connect to AIRA client via SSH as described here <Connecting_via_SSH.html> _. All tutorials are pre-installed. To launch the ros package run the following command:: $ rosrun arduino_blink blink.py Also we need to add a rosbag file to IPFS:: $ ipfs add rosbag/blink.bag .. note:: Before the next step you should approve XRT tokens on the Factory. On your host system build and launch an Dapp for the lesson:: $ git clone https://github.com/airalab/robonomics_tutorials/ $ cd robonomics_tutorials/arduino_blink_dapp $ npm i && npm run dev Open the link <http://localhost:8000/> _ and press Demand then Offer buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!","title":"Connect the Simplest CPS"},{"location":"agent_development/hardware_examples/connect_simple_cps/#connect-the-simplest-cps","text":"In this section we will build the simplest real cyber-physical system! We will buy a \"wink\" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink> _.","title":"Connect the Simplest CPS"},{"location":"agent_development/hardware_examples/connect_simple_cps/#arduino","text":"The firmware for the board is located in arduino_blink/misc/arduino/arduino.ino <https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino> . Use Arduino IDE <https://www.arduino.cc/en/Main/Software> to load the code to your Arduino board. In the code we subscribe for the /blink_led topic and set a callback. The type of the topic is Empty , so the board waits until someone publishes to the topic and performs the LED blinking. .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void messageCb( const std_msgs::Empty& toggle_msg){ blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); } ros::Subscriber sub(\"blink_led\", &messageCb ); void setup() { pinMode(LED_BUILTIN, OUTPUT); nh.initNode(); nh.subscribe(sub); } void loop() { nh.spinOnce(); delay(1); }","title":"Arduino"},{"location":"agent_development/hardware_examples/connect_simple_cps/#aira-client","text":".. note:: You can download the latest release from here <https://github.com/airalab/aira/releases> _ Set up the COM port forwarding as described in this lesson <connect_sensor.html> _. You should forward your /dev/ttyUSB0 or /dev/ttyACM0 port (depending on the system) to COM1 . In the client /dev/ttyS0 will represent the board. After this launch the virtual machine.","title":"AIRA client"},{"location":"agent_development/hardware_examples/connect_simple_cps/#ros","text":"When new liability is created it goes to /liability/ready topic. We have to remember the address and call /liability/start service to get the data from objective. .. code-block:: python def newliability(l): self.liability = l.address rospy.loginfo(\"Got new liability {}\".format(self.liability)) prefix = \"/liability/eth_\" + self.liability rospy.Subscriber(prefix + '/blink', Empty, self.blink) rospy.wait_for_service(\"/liability/start\") rospy.ServiceProxy('/liability/start', StartLiability)(StartLiabilityRequest(address=self.liability)) rospy.Subscriber(\"/liability/ready\", Liability, newliability) A message in the /blink topic come from the objective field. Have a look at Basic usage <../basic_usage.html> _ page.","title":"ROS"},{"location":"agent_development/hardware_examples/connect_simple_cps/#aira","text":"Connect to AIRA client via SSH as described here <Connecting_via_SSH.html> _. All tutorials are pre-installed. To launch the ros package run the following command:: $ rosrun arduino_blink blink.py Also we need to add a rosbag file to IPFS:: $ ipfs add rosbag/blink.bag .. note:: Before the next step you should approve XRT tokens on the Factory. On your host system build and launch an Dapp for the lesson:: $ git clone https://github.com/airalab/robonomics_tutorials/ $ cd robonomics_tutorials/arduino_blink_dapp $ npm i && npm run dev Open the link <http://localhost:8000/> _ and press Demand then Offer buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!","title":"AIRA"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/","text":"Passing Dynamic Parameters In previous <connect_simple_cps.html> _ example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let's expand the example and teach our board to blink blue or red led depending on objective parameter. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args> _. Arduino The only difference in Arduino source code is instead of subscribing to one topic now we subscribe to /blink_red and /blink_blue topics .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void blinkRedCb(const std_msgs::Empty& msg) { blink(13, 500); blink(13, 500); blink(13, 500); } void blinkBlueCb(const std_msgs::Empty& msg) { blink(12, 500); blink(12, 500); blink(12, 500); } ros::Subscriber subRed(\"blink_red\", &blinkRedCb); ros::Subscriber subBlue(\"blink_blue\", &blinkBlueCb); void setup() { pinMode(13, OUTPUT); pinMode(12, OUTPUT); nh.initNode(); nh.subscribe(subRed); nh.subscribe(subBlue); } void loop() { nh.spinOnce(); delay(1); } Here is the diagram of all connections: .. image:: ../img/6.png :alt: Arduino schema :align: center ROS We can pass arguments via objective which points to rosbag file. Have a look at blink.py script. The main difference is blink() method: .. code-block:: python ... def blink(self, data): if data.data == \"blue\": rospy.loginfo(\"Blinking blue...\") self.blink_blue.publish(Empty()) if data.data == \"red\": rospy.loginfo(\"Blinking red...\") self.blink_red.publish(Empty()) rospy.wait_for_service('/liability/finish') fin = rospy.ServiceProxy('/liability/finish', FinishLiability) fin(FinishLiabilityRequest(address=self.liability, success=True)) rospy.loginfo(\"Finished\") ... Now /blink topic has a String type. You can find prepared rosbags in rosbag folder. AIRA Connect to AIRA client via SSH as described here <Connecting_via_SSH.md> _. Do not forget to add COM1 port in settings. Run the following command:: $ rosrun arduino_with_args blink.py Also we need to add rosbag files to IPFS:: $ ipfs add rosbag/blink_blue.bag $ ipfs add rosbag/blink_red.bag .. note:: Before the next step you should approve XRT tokens on the Factory. The last step is to build Dapp and launch. Take a look at the previous lesson <connect_simple_cps.html> _. To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages. That's it! Now you are able to pass dynamic parameters to your cyber-physical system agent!","title":"Passing Dynamic Parameters"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#passing-dynamic-parameters","text":"In previous <connect_simple_cps.html> _ example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let's expand the example and teach our board to blink blue or red led depending on objective parameter. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args> _.","title":"Passing Dynamic Parameters"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#arduino","text":"The only difference in Arduino source code is instead of subscribing to one topic now we subscribe to /blink_red and /blink_blue topics .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void blinkRedCb(const std_msgs::Empty& msg) { blink(13, 500); blink(13, 500); blink(13, 500); } void blinkBlueCb(const std_msgs::Empty& msg) { blink(12, 500); blink(12, 500); blink(12, 500); } ros::Subscriber subRed(\"blink_red\", &blinkRedCb); ros::Subscriber subBlue(\"blink_blue\", &blinkBlueCb); void setup() { pinMode(13, OUTPUT); pinMode(12, OUTPUT); nh.initNode(); nh.subscribe(subRed); nh.subscribe(subBlue); } void loop() { nh.spinOnce(); delay(1); } Here is the diagram of all connections: .. image:: ../img/6.png :alt: Arduino schema :align: center","title":"Arduino"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#ros","text":"We can pass arguments via objective which points to rosbag file. Have a look at blink.py script. The main difference is blink() method: .. code-block:: python ... def blink(self, data): if data.data == \"blue\": rospy.loginfo(\"Blinking blue...\") self.blink_blue.publish(Empty()) if data.data == \"red\": rospy.loginfo(\"Blinking red...\") self.blink_red.publish(Empty()) rospy.wait_for_service('/liability/finish') fin = rospy.ServiceProxy('/liability/finish', FinishLiability) fin(FinishLiabilityRequest(address=self.liability, success=True)) rospy.loginfo(\"Finished\") ... Now /blink topic has a String type. You can find prepared rosbags in rosbag folder.","title":"ROS"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#aira","text":"Connect to AIRA client via SSH as described here <Connecting_via_SSH.md> _. Do not forget to add COM1 port in settings. Run the following command:: $ rosrun arduino_with_args blink.py Also we need to add rosbag files to IPFS:: $ ipfs add rosbag/blink_blue.bag $ ipfs add rosbag/blink_red.bag .. note:: Before the next step you should approve XRT tokens on the Factory. The last step is to build Dapp and launch. Take a look at the previous lesson <connect_simple_cps.html> _. To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages. That's it! Now you are able to pass dynamic parameters to your cyber-physical system agent!","title":"AIRA"},{"location":"agent_development/robonomics_network/become_a_provider/","text":"Become a Provider This page describes how to create a lighthouse and become a provider in the Robonomics network. Prepare an address First of all, an Ethereum address is required. You must have access to a private key of the address. In case you don't have one, below are steps to create an address via Parity . $ sudo snap install parity $ parity.ethkey generate random secret: 15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539 public: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff address: c531fa8f141493df3da264a864bdcbec19695b4c The secret field is a private key, you'll need it to run the provider client. Save it to a file: $ echo '0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539' > private.key The next step is to deposit some ethers and XRT tokens to the address which is held in the address field. Create a lighthouse Go to the lighthouse dapp and fill in a name in the right side: Click on the Create lighthouse and connect to the network button and sign a transaction. After a while you should see: Now it's time to put a stake. Select the new lighthouse and click Connect to the network : On this page in the Provider section click the Approve button, sign a transaction. When it's mined click the Refill button and do the same. Install the client You must install robonomics-tools at least 0.4.2 version. You can build from the source or do the following steps: Note Make sure you have Nix and Stack installed: $ curl -sSL https://get.haskellstack.org/ | sh $ curl https://nixos.org/nix/install | sh Setup Airalab binary cache at https://aira.cachix.org Import Airalab channel: $ nix-channel --add http://aira.life/channels/aira-unstable/ aira $ nix-channel --update Install from the binary cache: $ nix-env -iA aira.robonomics-tools Run the client: $ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key) Hint Get familiar with the xrtd options via xrtd --help Test the provider To test your provider go again to the lighthouse dapp and connect to the just created lighthouse. At the bottom you should see the TEST LIGHTHOUSE section. Click on the Demand button and then on the Offer one. You should see something similar to: Don't forget to sign every message with the MetaMask extension. Finally you should see a new liability contract created:","title":"Become a Provider"},{"location":"agent_development/robonomics_network/become_a_provider/#become-a-provider","text":"This page describes how to create a lighthouse and become a provider in the Robonomics network.","title":"Become a Provider"},{"location":"agent_development/robonomics_network/become_a_provider/#prepare-an-address","text":"First of all, an Ethereum address is required. You must have access to a private key of the address. In case you don't have one, below are steps to create an address via Parity . $ sudo snap install parity $ parity.ethkey generate random secret: 15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539 public: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff address: c531fa8f141493df3da264a864bdcbec19695b4c The secret field is a private key, you'll need it to run the provider client. Save it to a file: $ echo '0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539' > private.key The next step is to deposit some ethers and XRT tokens to the address which is held in the address field.","title":"Prepare an address"},{"location":"agent_development/robonomics_network/become_a_provider/#create-a-lighthouse","text":"Go to the lighthouse dapp and fill in a name in the right side: Click on the Create lighthouse and connect to the network button and sign a transaction. After a while you should see: Now it's time to put a stake. Select the new lighthouse and click Connect to the network : On this page in the Provider section click the Approve button, sign a transaction. When it's mined click the Refill button and do the same.","title":"Create a lighthouse"},{"location":"agent_development/robonomics_network/become_a_provider/#install-the-client","text":"You must install robonomics-tools at least 0.4.2 version. You can build from the source or do the following steps: Note Make sure you have Nix and Stack installed: $ curl -sSL https://get.haskellstack.org/ | sh $ curl https://nixos.org/nix/install | sh Setup Airalab binary cache at https://aira.cachix.org Import Airalab channel: $ nix-channel --add http://aira.life/channels/aira-unstable/ aira $ nix-channel --update Install from the binary cache: $ nix-env -iA aira.robonomics-tools Run the client: $ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key) Hint Get familiar with the xrtd options via xrtd --help","title":"Install the client"},{"location":"agent_development/robonomics_network/become_a_provider/#test-the-provider","text":"To test your provider go again to the lighthouse dapp and connect to the just created lighthouse. At the bottom you should see the TEST LIGHTHOUSE section. Click on the Demand button and then on the Offer one. You should see something similar to: Don't forget to sign every message with the MetaMask extension. Finally you should see a new liability contract created:","title":"Test the provider"},{"location":"agent_development/robonomics_network/contracts_deployment/","text":"Contracts Deployment Robonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on Github . Airalab team deploys new version of contracts and supports a current one. In this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. You need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this docker container $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest Next step is obtain a copy of robonomics contracts source code: $ git clone --recursive https://github.com/airalab/robonomics_contracts A file truffle.js contains available networks for migration. We will work with development network. When you are in robonomics_contracts directory install dependencies and run a migration: npm install // to install dependencies truffle migrate --network development It's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read white paper . Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. When XRT contracts was deployed some tokens were issued on our account. Let's check the balance: $ truffle --network development console > xrt = XRT.at(XRT.address) > xrt.balanceOf(web3.eth.accounts[0]) And that's how we create a lighthouse: > factory = LiabilityFactory.at(LiabilityFactory.address) > tx = factory.createLighthouse(1000, 10, \"test\") > tx.then(x => {laddress = x.logs[0].args.lighthouse}) > l = LighthouseLib.at(laddress) Instead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A l variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well: > xrt.approve(l.address,1000) > xrt.allowance(web3.eth.accounts[0],l.address) And a very important step is become a worker: > l.refill(1000) Each worker has to put a stake. In this case it's 1000 Wn. Below is a table of our addresses: Contract Address ENS name ENSRegistry 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49 XRT 0x673583a369eb3a830a5571208cf6eb7ce83987f8 xrt.3.robonomics.eth LiabilityFactory 0x1b3190e00c1903266862af1f31714d4b81ef59b2 factory.3.robonomics.eth Lighthouse 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e test.lighthouse.3.robonomics.eth","title":"Contracts Deployment"},{"location":"agent_development/robonomics_network/contracts_deployment/#contracts-deployment","text":"Robonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on Github . Airalab team deploys new version of contracts and supports a current one. In this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. You need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this docker container $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest Next step is obtain a copy of robonomics contracts source code: $ git clone --recursive https://github.com/airalab/robonomics_contracts A file truffle.js contains available networks for migration. We will work with development network. When you are in robonomics_contracts directory install dependencies and run a migration: npm install // to install dependencies truffle migrate --network development It's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read white paper . Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. When XRT contracts was deployed some tokens were issued on our account. Let's check the balance: $ truffle --network development console > xrt = XRT.at(XRT.address) > xrt.balanceOf(web3.eth.accounts[0]) And that's how we create a lighthouse: > factory = LiabilityFactory.at(LiabilityFactory.address) > tx = factory.createLighthouse(1000, 10, \"test\") > tx.then(x => {laddress = x.logs[0].args.lighthouse}) > l = LighthouseLib.at(laddress) Instead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A l variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well: > xrt.approve(l.address,1000) > xrt.allowance(web3.eth.accounts[0],l.address) And a very important step is become a worker: > l.refill(1000) Each worker has to put a stake. In this case it's 1000 Wn. Below is a table of our addresses: Contract Address ENS name ENSRegistry 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49 XRT 0x673583a369eb3a830a5571208cf6eb7ce83987f8 xrt.3.robonomics.eth LiabilityFactory 0x1b3190e00c1903266862af1f31714d4b81ef59b2 factory.3.robonomics.eth Lighthouse 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e test.lighthouse.3.robonomics.eth","title":"Contracts Deployment"},{"location":"agent_development/robonomics_network/how_it_works/","text":"How It Works In this section we will discuss the Robonomics Network scenario. There are few main parts in the Robonomics network: IPFS for the messages exchanging the Ethereum blockchain for storing new liability contracts a provider that is responsible for matching messages an agent Let's have a look at the following diagram that describes the scenario without any additional details: There are three types of messages in IPFS: Demand, Offer, Result. Below there is the specification for a Demand message: Field Type Description Example model ipfs_common/Multihash CPS behavioral model Identifier QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r token ethereum_common/Address Operational token address 0xbD949595eE52346c225a19724084cE517B2cB735 cost ethereum_common/UInt256 CPS behavioral model implementation cost 1 lighthouse ethereum_common/Address Lighthouse address 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1 validator ethereum_common/Address Observing network address 0x0000000000000000000000000000000000000000 validatorFee ethereum_common/UInt256 Observing network commission 0 deadline ethereum_common/UInt256 Deadline block number 6393332 sender ethereum_common/Address Message sender address 0x0000000000000000000000000000000000000000 signature std_msgs/UInt8[] Sender\u2019s digital signature 0x23bc\u2026c617 An Offer message has the same fields but instead of validatorFee there is a lighthouseFee field. This field determines the amount of fee for a lighthouse. Now let's have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization. A liability contract is created only if the following fields match: model , objective , token , cost . A provider of Robonomics Network watches every message and finds those ones that have a match. After the match is found the provider calls createLiability(demand, offer) method from the contract factory where demand and offer are serialized. Below is the package diagram for the Robonomics communication stack: The factory deserializes arguments and recovers promisee and promisor addresses from signatures. Next step is token transfer. The factory transfers cost tokens from the promisee address and validatorFee and lighthouseFee from the promisor address to the new liability address. Note You should approve sufficient amount of tokens for the factory. Note It's not required to approve tokens from the promisor address if fees are null. Now the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format. When the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the validator field is not null it means that only validator is able to finalize the liability. After the successful liability finalization the agent gets cost tokens. Otherwise, the promisee gets tokens back.","title":"How It Works"},{"location":"agent_development/robonomics_network/how_it_works/#how-it-works","text":"In this section we will discuss the Robonomics Network scenario. There are few main parts in the Robonomics network: IPFS for the messages exchanging the Ethereum blockchain for storing new liability contracts a provider that is responsible for matching messages an agent Let's have a look at the following diagram that describes the scenario without any additional details: There are three types of messages in IPFS: Demand, Offer, Result. Below there is the specification for a Demand message: Field Type Description Example model ipfs_common/Multihash CPS behavioral model Identifier QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r token ethereum_common/Address Operational token address 0xbD949595eE52346c225a19724084cE517B2cB735 cost ethereum_common/UInt256 CPS behavioral model implementation cost 1 lighthouse ethereum_common/Address Lighthouse address 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1 validator ethereum_common/Address Observing network address 0x0000000000000000000000000000000000000000 validatorFee ethereum_common/UInt256 Observing network commission 0 deadline ethereum_common/UInt256 Deadline block number 6393332 sender ethereum_common/Address Message sender address 0x0000000000000000000000000000000000000000 signature std_msgs/UInt8[] Sender\u2019s digital signature 0x23bc\u2026c617 An Offer message has the same fields but instead of validatorFee there is a lighthouseFee field. This field determines the amount of fee for a lighthouse. Now let's have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization. A liability contract is created only if the following fields match: model , objective , token , cost . A provider of Robonomics Network watches every message and finds those ones that have a match. After the match is found the provider calls createLiability(demand, offer) method from the contract factory where demand and offer are serialized. Below is the package diagram for the Robonomics communication stack: The factory deserializes arguments and recovers promisee and promisor addresses from signatures. Next step is token transfer. The factory transfers cost tokens from the promisee address and validatorFee and lighthouseFee from the promisor address to the new liability address. Note You should approve sufficient amount of tokens for the factory. Note It's not required to approve tokens from the promisor address if fees are null. Now the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format. When the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the validator field is not null it means that only validator is able to finalize the liability. After the successful liability finalization the agent gets cost tokens. Otherwise, the promisee gets tokens back.","title":"How It Works"},{"location":"aira/basic_usage/","text":"Basic Usage To get familiar with AIRA, let's see what is under the hood. Once you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes: $ rosnode list /eth/erc20_token /eth/eth_node /graph/aira_graph /liability/executor /liability/infochan/eth/signer /liability/infochan/ipfs_channel /liability/persistence /liability/listener /rosout /eth/erc20_token , /eth/eth_node - proved services for Ethereum blockchain and ERC20 tokens /graph/aira_graph - service node for exploring other AIRA instances /liability/executor - gets rosbag file from IPFS and plays it /liability/infochan/ipfs_channel - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back /liability/infochan/eth/signer - offers services for signing offer, demand and result messages /liability/listener - watches for a new liability contracts. When the event is received the node calls executor node /liability/persistence - helps to store incoming liabilities and restart them after shutdown And here's a list of robonomics stack topics. $ rostopic list /eth/event/approval /eth/event/transfer /graph/greetings /liability/complete /liability/finalized /liability/incoming /liability/infochan/eth/sending/demand /liability/infochan/eth/sending/offer /liability/infochan/eth/sending/result /liability/infochan/eth/signing/demand /liability/infochan/eth/signing/offer /liability/infochan/eth/signing/result /liability/infochan/incoming/demand /liability/infochan/incoming/offer /liability/infochan/incoming/result /liability/persistence/add /liability/persistence/del /liability/persistence/update_timestamp /liability/ready /liability/result /rosout /rosout_agg The most important topics for us are: /liability/incoming - when a new liability is created, this topic publishes Ethereum address of the contract /liability/result - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead /liability/infochan/incoming/* - a CPS gets information about offer, demand or result from corresponding topics /liability/infochan/eth/signing/* - a CPS sends offer, demand or result messages to corresponding topics For the details check out the API page . Let's start with greetings - say hello to AIRA! You should just launch a pre-installed package hello_aira : $ rosrun hello_aira hello_aira We've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to dapp and press Order. Now go back to the console and see the result!","title":"Basic Usage"},{"location":"aira/basic_usage/#basic-usage","text":"To get familiar with AIRA, let's see what is under the hood. Once you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes: $ rosnode list /eth/erc20_token /eth/eth_node /graph/aira_graph /liability/executor /liability/infochan/eth/signer /liability/infochan/ipfs_channel /liability/persistence /liability/listener /rosout /eth/erc20_token , /eth/eth_node - proved services for Ethereum blockchain and ERC20 tokens /graph/aira_graph - service node for exploring other AIRA instances /liability/executor - gets rosbag file from IPFS and plays it /liability/infochan/ipfs_channel - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back /liability/infochan/eth/signer - offers services for signing offer, demand and result messages /liability/listener - watches for a new liability contracts. When the event is received the node calls executor node /liability/persistence - helps to store incoming liabilities and restart them after shutdown And here's a list of robonomics stack topics. $ rostopic list /eth/event/approval /eth/event/transfer /graph/greetings /liability/complete /liability/finalized /liability/incoming /liability/infochan/eth/sending/demand /liability/infochan/eth/sending/offer /liability/infochan/eth/sending/result /liability/infochan/eth/signing/demand /liability/infochan/eth/signing/offer /liability/infochan/eth/signing/result /liability/infochan/incoming/demand /liability/infochan/incoming/offer /liability/infochan/incoming/result /liability/persistence/add /liability/persistence/del /liability/persistence/update_timestamp /liability/ready /liability/result /rosout /rosout_agg The most important topics for us are: /liability/incoming - when a new liability is created, this topic publishes Ethereum address of the contract /liability/result - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead /liability/infochan/incoming/* - a CPS gets information about offer, demand or result from corresponding topics /liability/infochan/eth/signing/* - a CPS sends offer, demand or result messages to corresponding topics For the details check out the API page . Let's start with greetings - say hello to AIRA! You should just launch a pre-installed package hello_aira : $ rosrun hello_aira hello_aira We've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to dapp and press Order. Now go back to the console and see the result!","title":"Basic Usage"},{"location":"aira/connecting_via_ssh/","text":"Connecting via SSH It is more convenient to work with virtual machine via ssh connection. In this section we will configure VM. Attention It's required to have your ssh public key on Github.com In case you don't have one, please follow the link First, launch AIRA client and run a command replacing with your own: $ mkdir .ssh $ chmod 700 .ssh $ curl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys Now go to machine settings, network, open Advanced and then Port Forwarding Add a new rule: Host IP Host Port Guest IP Guest Port 127.0.1.1 2202 10.0.2.15 22 Reboot the machine and you are able to connect to AIRA client via ssh:: $ ssh -p 2202 root@127.0.1.1","title":"Connecting via SSH"},{"location":"aira/connecting_via_ssh/#connecting-via-ssh","text":"It is more convenient to work with virtual machine via ssh connection. In this section we will configure VM. Attention It's required to have your ssh public key on Github.com In case you don't have one, please follow the link First, launch AIRA client and run a command replacing with your own: $ mkdir .ssh $ chmod 700 .ssh $ curl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys Now go to machine settings, network, open Advanced and then Port Forwarding Add a new rule: Host IP Host Port Guest IP Guest Port 127.0.1.1 2202 10.0.2.15 22 Reboot the machine and you are able to connect to AIRA client via ssh:: $ ssh -p 2202 root@127.0.1.1","title":"Connecting via SSH"},{"location":"aira/faq/","text":"Frequently Asked Questions How to see logs from main services? IPFS in real time: journalctl -u ipfs -f and Liability:: journalctl -u liability -f How to check the quantity of IPFS peers? ipfs pubsub peers IPFS can't connect to the daemon, what should I do? Try to specify --api option ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/ How to change ethereum address of AIRA? Delete keyfile and keyfile-psk in /var/lib/liability and restart the service systemctl restart liability","title":"FAQ"},{"location":"aira/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"aira/faq/#how-to-see-logs-from-main-services","text":"IPFS in real time: journalctl -u ipfs -f and Liability:: journalctl -u liability -f","title":"How to see logs from main services?"},{"location":"aira/faq/#how-to-check-the-quantity-of-ipfs-peers","text":"ipfs pubsub peers","title":"How to check the quantity of IPFS peers?"},{"location":"aira/faq/#ipfs-cant-connect-to-the-daemon-what-should-i-do","text":"Try to specify --api option ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/","title":"IPFS can't connect to the daemon, what should I do?"},{"location":"aira/faq/#how-to-change-ethereum-address-of-aira","text":"Delete keyfile and keyfile-psk in /var/lib/liability and restart the service systemctl restart liability","title":"How to change ethereum address of AIRA?"},{"location":"aira/installation/","text":"Installation In the other article it was shown how to launch AIRA in VirtualBox. The installation on Raspberry Pi is as simple as writing an image of AIRA on SD card using dd or Etcher , for example. This article includes two tutorials: Installation communication stack on your laptop for development purpose Switching a bare NixOS to AIRA","title":"Installation"},{"location":"aira/installation/#installation","text":"In the other article it was shown how to launch AIRA in VirtualBox. The installation on Raspberry Pi is as simple as writing an image of AIRA on SD card using dd or Etcher , for example. This article includes two tutorials: Installation communication stack on your laptop for development purpose Switching a bare NixOS to AIRA","title":"Installation"},{"location":"aira/overview/","text":"Overview Introduction Autonomous intelligent robot agent (AIRA) project which implements the standard of economic interaction between human-robot and robot-robot. Aira makes it possible to connect a variety of different robots to the market of robot's liabilities which existing in Ethereum. Basically it is the client for Robonomics Network supported by Airalab. AIRA is NixOS based operating system and officially supports the following architectures: x86, Raspberry Pi 3 B+ and Raspberry Pi 4. The most simple way to get familiar with AIRA is to try installing AIRA as a virtual machine . AIRA comes with a few preinstalled and configured services to help you focus on agent development. Meanwhile it's highly customizable, but it's recommended to understand NixOS and Nix language. What's included? The following services are included in the default distribution: Robonomics communication stack IPFS OpenSSH cjdns Yggdrasil-go Besides at the first launch AIRA generates for you new Ethereum address and IPNS identifier. It's possible to use AIRA as a virtual machine or install as a main operating system. Also you can install only the services you need","title":"Overview"},{"location":"aira/overview/#overview","text":"","title":"Overview"},{"location":"aira/overview/#introduction","text":"Autonomous intelligent robot agent (AIRA) project which implements the standard of economic interaction between human-robot and robot-robot. Aira makes it possible to connect a variety of different robots to the market of robot's liabilities which existing in Ethereum. Basically it is the client for Robonomics Network supported by Airalab. AIRA is NixOS based operating system and officially supports the following architectures: x86, Raspberry Pi 3 B+ and Raspberry Pi 4. The most simple way to get familiar with AIRA is to try installing AIRA as a virtual machine . AIRA comes with a few preinstalled and configured services to help you focus on agent development. Meanwhile it's highly customizable, but it's recommended to understand NixOS and Nix language.","title":"Introduction"},{"location":"aira/overview/#whats-included","text":"The following services are included in the default distribution: Robonomics communication stack IPFS OpenSSH cjdns Yggdrasil-go Besides at the first launch AIRA generates for you new Ethereum address and IPNS identifier. It's possible to use AIRA as a virtual machine or install as a main operating system. Also you can install only the services you need","title":"What's included?"},{"location":"cases/digital_identity/","text":"Create Digital Identity Run by Ethereum","title":"Create Digital Identity Run by Ethereum"},{"location":"cases/digital_identity/#create-digital-identity-run-by-ethereum","text":"","title":"Create Digital Identity Run by Ethereum"},{"location":"cases/offset_electricity_consumption_run_by_ethereum/","text":"Offset Electricity Consumption Rub by Ethereum \u0412\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0434\u0430\u0442\u0447\u0438\u043a \u0434\u043b\u044f \u043f\u043e\u0434\u0441\u0447\u0435\u0442\u0430 \u043f\u043e\u0442\u0440\u0435\u0431\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438, \u0441\u043a\u0430\u0436\u0435\u043c Voltaware. \u042d\u0442\u043e\u0442 \u0434\u0430\u0442\u0447\u0438\u043a \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043d\u0435\u0438\u043d\u0432\u0430\u0437\u0438\u0432\u043d\u044b\u043c \u0441\u043f\u043e\u0441\u043e\u0431\u043e\u043c \u0432 \u0432\u0430\u0448\u0443 \u0441\u0435\u0442\u044c \u0438 \u0441\u0447\u0438\u0442\u0430\u0435\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043f\u0440\u043e\u0448\u043b\u043e \u0447\u0435\u0440\u0435\u0437 \u0434\u0430\u043d\u043d\u0443\u044e \u0441\u0435\u0442\u044c. \u0417\u0430 \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u043e\u044f\u043c\u0438 \u043f\u043e \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0435 \u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044e \u0434\u0430\u0442\u0447\u0438\u043a\u0430 \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u0435\u0441\u044c \u043a \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 https://www.voltaware.com/support \u0417\u0434\u0435\u0441\u044c \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f, \u0447\u0442\u043e \u0432\u044b \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u043b\u0438 \u0438 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043d\u0430\u0441\u0442\u0440\u043e\u0438\u043b\u0438 \u0434\u0430\u0442\u0447\u0438\u043a, \u0430 \u0442\u0430\u043a \u0436\u0435 \u0437\u0430\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043b\u0438\u0441\u044c \u0438 \u043d\u0430\u0447\u0430\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u0435\u0436\u0435\u043c\u0435\u0441\u044f\u0447\u043d\u044b\u0435 \u043e\u0442\u0447\u0435\u0442\u044b \u043e \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u043d\u043e\u043c \u044d\u043b\u0435\u043a\u0442\u0440\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u0432 \u0432\u0438\u0434\u0435 \u041e\u0442\u0441\u044e\u0434\u0430 \u043d\u0430\u043c \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u043d\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438 \u0432 kWh. \u0427\u0442\u043e\u0431\u044b \u043f\u043e\u0433\u0430\u0441\u0438\u0442\u044c \u0443\u0433\u043b\u0435\u0440\u043e\u0434\u043d\u044b\u0439 \u0441\u043b\u0435\u0434, \u0432 Robonomics Network \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u0433\u0435\u043d\u0442. \u0418\u0434\u0435\u043c \u043d\u0430 \u0414\u0430\u043f\u043f https://new.dapp.ipci.io/#/offsetting \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u043f\u043e\u043b\u044f: \u0432\u0437\u044f\u0442\u043e \u0441 \u0441\u0430\u0439\u0442\u0430 voltaware (c) \u0412 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0441\u0442\u0440\u0430\u043d\u044b, \u0431\u0435\u0440\u0435\u0442\u0441\u044f renewable energy factor \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442, \u043a\u0430\u043a\u043e\u0439 \u043f\u0440\u043e\u0446\u0435\u043d\u0442 \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043e \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0432\u043e\u0437\u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c\u044b\u0445 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u043e\u0432. \u042d\u0442\u043e\u0442 \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c, \u0447\u0442\u043e\u0431\u044b \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c, \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0431\u044b\u043b\u043e \u0432\u044b\u0431\u0440\u043e\u0448\u0435\u043d\u043e CO2, \u0442\u043e \u0435\u0441\u0442\u044c \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043d\u0435 \u0437\u0435\u043b\u0435\u043d\u043e\u0439 \u044d\u043d\u0435\u0440\u0433\u0438\u0438 \u0431\u044b\u043b\u043e \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u043e. \u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0435 \u043f\u043e\u043b\u0435 \u043f\u0438\u0448\u0435\u043c \u0442\u043e, \u0447\u0442\u043e \u043f\u0440\u0438\u0448\u043b\u043e \u0432 \u0435\u0436\u0435\u043c\u0435\u0441\u044f\u0447\u043d\u043e\u043c \u043e\u0442\u0447\u0435\u0442\u0435 \u043e\u0442 \u0434\u0430\u0442\u0447\u0438\u043a\u0430 Voltaware \u0438 \u043d\u0430\u0436\u0438\u043c\u0430\u0435\u043c Request for cost. \u0410\u0433\u0435\u043d\u0442 \u0440\u0430\u0441\u0447\u0438\u0442\u0430\u0435\u0442 \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u043f\u043e\u0433\u0430\u0448\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u0435\u0440\u043e\u0434\u043d\u043e\u0433\u043e \u0441\u043b\u0435\u0434\u0430 \u0438 \u043f\u0440\u0438\u0448\u043b\u0435\u0442 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u0435.","title":"Offset Electricity Consumption Rub by Ethereum"},{"location":"cases/offset_electricity_consumption_run_by_ethereum/#offset-electricity-consumption-rub-by-ethereum","text":"\u0412\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0434\u0430\u0442\u0447\u0438\u043a \u0434\u043b\u044f \u043f\u043e\u0434\u0441\u0447\u0435\u0442\u0430 \u043f\u043e\u0442\u0440\u0435\u0431\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438, \u0441\u043a\u0430\u0436\u0435\u043c Voltaware. \u042d\u0442\u043e\u0442 \u0434\u0430\u0442\u0447\u0438\u043a \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043d\u0435\u0438\u043d\u0432\u0430\u0437\u0438\u0432\u043d\u044b\u043c \u0441\u043f\u043e\u0441\u043e\u0431\u043e\u043c \u0432 \u0432\u0430\u0448\u0443 \u0441\u0435\u0442\u044c \u0438 \u0441\u0447\u0438\u0442\u0430\u0435\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043f\u0440\u043e\u0448\u043b\u043e \u0447\u0435\u0440\u0435\u0437 \u0434\u0430\u043d\u043d\u0443\u044e \u0441\u0435\u0442\u044c. \u0417\u0430 \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u043e\u044f\u043c\u0438 \u043f\u043e \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0435 \u0438 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044e \u0434\u0430\u0442\u0447\u0438\u043a\u0430 \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u0435\u0441\u044c \u043a \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 https://www.voltaware.com/support \u0417\u0434\u0435\u0441\u044c \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f, \u0447\u0442\u043e \u0432\u044b \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u043b\u0438 \u0438 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043d\u0430\u0441\u0442\u0440\u043e\u0438\u043b\u0438 \u0434\u0430\u0442\u0447\u0438\u043a, \u0430 \u0442\u0430\u043a \u0436\u0435 \u0437\u0430\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043b\u0438\u0441\u044c \u0438 \u043d\u0430\u0447\u0430\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u0435\u0436\u0435\u043c\u0435\u0441\u044f\u0447\u043d\u044b\u0435 \u043e\u0442\u0447\u0435\u0442\u044b \u043e \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u043d\u043e\u043c \u044d\u043b\u0435\u043a\u0442\u0440\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u0432 \u0432\u0438\u0434\u0435 \u041e\u0442\u0441\u044e\u0434\u0430 \u043d\u0430\u043c \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u043d\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438 \u0432 kWh. \u0427\u0442\u043e\u0431\u044b \u043f\u043e\u0433\u0430\u0441\u0438\u0442\u044c \u0443\u0433\u043b\u0435\u0440\u043e\u0434\u043d\u044b\u0439 \u0441\u043b\u0435\u0434, \u0432 Robonomics Network \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u0433\u0435\u043d\u0442. \u0418\u0434\u0435\u043c \u043d\u0430 \u0414\u0430\u043f\u043f https://new.dapp.ipci.io/#/offsetting \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u043f\u043e\u043b\u044f: \u0432\u0437\u044f\u0442\u043e \u0441 \u0441\u0430\u0439\u0442\u0430 voltaware (c) \u0412 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0441\u0442\u0440\u0430\u043d\u044b, \u0431\u0435\u0440\u0435\u0442\u0441\u044f renewable energy factor \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442, \u043a\u0430\u043a\u043e\u0439 \u043f\u0440\u043e\u0446\u0435\u043d\u0442 \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u044d\u043d\u0435\u0440\u0433\u0438\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043e \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0432\u043e\u0437\u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c\u044b\u0445 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u043e\u0432. \u042d\u0442\u043e\u0442 \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c, \u0447\u0442\u043e\u0431\u044b \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c, \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0431\u044b\u043b\u043e \u0432\u044b\u0431\u0440\u043e\u0448\u0435\u043d\u043e CO2, \u0442\u043e \u0435\u0441\u0442\u044c \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043d\u0435 \u0437\u0435\u043b\u0435\u043d\u043e\u0439 \u044d\u043d\u0435\u0440\u0433\u0438\u0438 \u0431\u044b\u043b\u043e \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u043e. \u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0435 \u043f\u043e\u043b\u0435 \u043f\u0438\u0448\u0435\u043c \u0442\u043e, \u0447\u0442\u043e \u043f\u0440\u0438\u0448\u043b\u043e \u0432 \u0435\u0436\u0435\u043c\u0435\u0441\u044f\u0447\u043d\u043e\u043c \u043e\u0442\u0447\u0435\u0442\u0435 \u043e\u0442 \u0434\u0430\u0442\u0447\u0438\u043a\u0430 Voltaware \u0438 \u043d\u0430\u0436\u0438\u043c\u0430\u0435\u043c Request for cost. \u0410\u0433\u0435\u043d\u0442 \u0440\u0430\u0441\u0447\u0438\u0442\u0430\u0435\u0442 \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u043f\u043e\u0433\u0430\u0448\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u0435\u0440\u043e\u0434\u043d\u043e\u0433\u043e \u0441\u043b\u0435\u0434\u0430 \u0438 \u043f\u0440\u0438\u0448\u043b\u0435\u0442 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u0435.","title":"Offset Electricity Consumption Rub by Ethereum"},{"location":"cases/open_sensor_network_run_by_ipfs/","text":"Open Sensor Network Run by IPFS Robonomics allows you to build a peer-to-peer communication between you and a sensor. So it becomes possible to get data from your sensor all around the world. Those data is not stored in a blockchain but packed in rosbag format which is convenient to work with and transfered via IPFS network. At this page you'll find step-by-step instruction to connect SEN0233 sensor to Raspberry Pi 4 and make it publish data on demand. After reading this article you should get the main idea and be able to connect any desired sensor. Note All of the following steps are done on Linux Requirements SEN0233 PM2.5 Sensor Adapter Raspberry Pi 4 SD Card >=16Gb 1. Prepare Raspberry Pi 4 1.1 Get the image The latest AIRA image can be found here wget https://aira.life/channels/aira-unstable/aira-image-rpi4-20.03pre-git-aarch64-linux.img 1.2 Write the image on to a SD card sudo dd if=aira-image-rpi4-20.03pre-git-aarch64-linux.img of=/dev/sda bs=4M status=progress sync 1.3 Boot with the SD card Plug in the SD card and connect a power supply to the board. Wait a couple of minutes. By default OS has root user with empty password. There are a few ways to log in. First - using UART-USB cable. Connect the cable as shown below: Black to 6th pin White to 8th pin (TXD) Green to 10th pin (RXD) Check the official documentation out. The connection is the same for Raspberry Pi 3 and 4. Then on your laptop run: screen /dev/ttyUSB 115200 And you should see something similar to: <<< Welcome to NixOS 20.03pre-git (aarch64) - ttyS0 >>> aira-rpi4 login: root (automatic login) Starting... _ ___ ____ _ / \\ |_ _| _ \\ / \\ / _ \\ | || |_) | / _ \\ / ___ \\ | || _ < / ___ \\ /_/ \\_\\___|_| \\_\\/_/ \\_\\ My Ethereum address is \"38411681740ca6214b448d49549bb1dfd0a0cffa\" Look me at https://status.robonomics.network by \"Qmdiiux3uQS8JyuPNa7Vj3iNe7UZBrpMPB2dEqUeo4YRGH\" Note Save somewhere your ethereum address generated by the OS. You'll need it later. By default sshd service is up and running. All you need to do is to add your SSH key: mkdir .ssh/ curl -sSL https://github.com/<USERNAME>.keys >> .ssh/authorized_keys It's recommended to add your SSH key to Github account help If you don't have a key attached to your github account then simply put the content of your ~/.ssh/id_rsa.pub file to /root/.ssh/authorized_keys file on the SD card. Another way to put the key is to unplug the SD card, plug it in a laptop and do above steps manually. After that you should be able to connect to the board via SSH: ssh root@<RASPBERRY_PI_ADDRESS> 1.4. Remove blocking parameters You'll attach the sensor to GPIO pins which are currently are configured for UART connection. Open /boot/cmdline.txt and remove everything related to console . In the end it must look like: cma=256M loglevel=7 init=/nix/store/nlh5fcbb1cj36kn0m2pfvqs7w6dd127w-nixos-system-aira-rpi4-20.03pre197163.0c9d9518676/init Reboot reboot 2. Connect SEN0233 Connect the sensor as shown below: 3. Run the Agent The agent must be run under liability user su liability cd Now clone the repository and build the agent: git clone https://github.com/Vourhey/sen0233_sensor_agent/ cd sen0233_sensor_agent nix build -f release.nix Run the agent: source result/setup.bash roslaunch sensors_pack_agent agent.launch Note Don't hesitate to check the repository out. You'll see how easily the sensor can be replaced with any other 4. Test To test everything works as expected go to the Dapp: https://dapp.robonomics.network/#/sensors/airalab/QmWjvXGfVUDBNR15BBH5ERGP3SzEKbeLZWx7Fcp4kwwaw9/0x<YOUR_ETHEREUM_ADDRESS>/ where <YOUR_ETHEREUM_ADDRESS> is the address generated by OS on step 1.3. To find out the address again you can run: rosservice call /eth/accounts .row { display: flex; } .column { flex: 50%; padding: 5px; }","title":"Open Sensor Network Run by IPFS"},{"location":"cases/open_sensor_network_run_by_ipfs/#open-sensor-network-run-by-ipfs","text":"Robonomics allows you to build a peer-to-peer communication between you and a sensor. So it becomes possible to get data from your sensor all around the world. Those data is not stored in a blockchain but packed in rosbag format which is convenient to work with and transfered via IPFS network. At this page you'll find step-by-step instruction to connect SEN0233 sensor to Raspberry Pi 4 and make it publish data on demand. After reading this article you should get the main idea and be able to connect any desired sensor. Note All of the following steps are done on Linux","title":"Open Sensor Network Run by IPFS"},{"location":"cases/open_sensor_network_run_by_ipfs/#requirements","text":"SEN0233 PM2.5 Sensor Adapter Raspberry Pi 4 SD Card >=16Gb","title":"Requirements"},{"location":"cases/open_sensor_network_run_by_ipfs/#1-prepare-raspberry-pi-4","text":"","title":"1. Prepare Raspberry Pi 4"},{"location":"cases/open_sensor_network_run_by_ipfs/#11-get-the-image","text":"The latest AIRA image can be found here wget https://aira.life/channels/aira-unstable/aira-image-rpi4-20.03pre-git-aarch64-linux.img","title":"1.1 Get the image"},{"location":"cases/open_sensor_network_run_by_ipfs/#12-write-the-image-on-to-a-sd-card","text":"sudo dd if=aira-image-rpi4-20.03pre-git-aarch64-linux.img of=/dev/sda bs=4M status=progress sync","title":"1.2 Write the image on to a SD card"},{"location":"cases/open_sensor_network_run_by_ipfs/#13-boot-with-the-sd-card","text":"Plug in the SD card and connect a power supply to the board. Wait a couple of minutes. By default OS has root user with empty password. There are a few ways to log in. First - using UART-USB cable. Connect the cable as shown below: Black to 6th pin White to 8th pin (TXD) Green to 10th pin (RXD) Check the official documentation out. The connection is the same for Raspberry Pi 3 and 4. Then on your laptop run: screen /dev/ttyUSB 115200 And you should see something similar to: <<< Welcome to NixOS 20.03pre-git (aarch64) - ttyS0 >>> aira-rpi4 login: root (automatic login) Starting... _ ___ ____ _ / \\ |_ _| _ \\ / \\ / _ \\ | || |_) | / _ \\ / ___ \\ | || _ < / ___ \\ /_/ \\_\\___|_| \\_\\/_/ \\_\\ My Ethereum address is \"38411681740ca6214b448d49549bb1dfd0a0cffa\" Look me at https://status.robonomics.network by \"Qmdiiux3uQS8JyuPNa7Vj3iNe7UZBrpMPB2dEqUeo4YRGH\" Note Save somewhere your ethereum address generated by the OS. You'll need it later. By default sshd service is up and running. All you need to do is to add your SSH key: mkdir .ssh/ curl -sSL https://github.com/<USERNAME>.keys >> .ssh/authorized_keys It's recommended to add your SSH key to Github account help If you don't have a key attached to your github account then simply put the content of your ~/.ssh/id_rsa.pub file to /root/.ssh/authorized_keys file on the SD card. Another way to put the key is to unplug the SD card, plug it in a laptop and do above steps manually. After that you should be able to connect to the board via SSH: ssh root@<RASPBERRY_PI_ADDRESS>","title":"1.3 Boot with the SD card"},{"location":"cases/open_sensor_network_run_by_ipfs/#14-remove-blocking-parameters","text":"You'll attach the sensor to GPIO pins which are currently are configured for UART connection. Open /boot/cmdline.txt and remove everything related to console . In the end it must look like: cma=256M loglevel=7 init=/nix/store/nlh5fcbb1cj36kn0m2pfvqs7w6dd127w-nixos-system-aira-rpi4-20.03pre197163.0c9d9518676/init Reboot reboot","title":"1.4. Remove blocking parameters"},{"location":"cases/open_sensor_network_run_by_ipfs/#2-connect-sen0233","text":"Connect the sensor as shown below:","title":"2. Connect SEN0233"},{"location":"cases/open_sensor_network_run_by_ipfs/#3-run-the-agent","text":"The agent must be run under liability user su liability cd Now clone the repository and build the agent: git clone https://github.com/Vourhey/sen0233_sensor_agent/ cd sen0233_sensor_agent nix build -f release.nix Run the agent: source result/setup.bash roslaunch sensors_pack_agent agent.launch Note Don't hesitate to check the repository out. You'll see how easily the sensor can be replaced with any other","title":"3. Run the Agent"},{"location":"cases/open_sensor_network_run_by_ipfs/#4-test","text":"To test everything works as expected go to the Dapp: https://dapp.robonomics.network/#/sensors/airalab/QmWjvXGfVUDBNR15BBH5ERGP3SzEKbeLZWx7Fcp4kwwaw9/0x<YOUR_ETHEREUM_ADDRESS>/ where <YOUR_ETHEREUM_ADDRESS> is the address generated by OS on step 1.3. To find out the address again you can run: rosservice call /eth/accounts .row { display: flex; } .column { flex: 50%; padding: 5px; }","title":"4. Test"},{"location":"cases/substrate_demo/","text":"Run by Substrate","title":"Run by Substrate"},{"location":"cases/substrate_demo/#run-by-substrate","text":"","title":"Run by Substrate"},{"location":"try_it_out/aira_installation/","text":"AIRA Installation on VirtualBox AIRA is a client for Robonomics Network by Airalab. Basically it's a NixOS based operating system. It's possible to install AIRA on a x86_64 PC. Also there are images for Raspberry Pi 3 and 4 supported by the team. To get familiar with the OS it's better to start from installing it as a virtual machine in VirtualBox . Requirements: VirtualBox VirtualBox Extension Pack 2Gb of RAM for the machine 40Gb of free disk space Obtain the image There are channels stable and unstable To get stable image download the file with .ova extension. For example, the link for stable image is https://aira.life/channels/aira-stable/nixos-20.03pre-git-x86_64-linux.ova Note Don't forget to check checksum of an image. The last column on the download page is SHA-256 hash . It must be equal to the output of sha256sum nixos-20.03pre-git-x86_64-linux.ova There is a walkthrough video you may wish to check out Troubleshooting If you have a fresh installed VirtualBox you need to install the extension pack or disable USB 2.0 controller. Also VirtualBox may show a warning about Display settings . Consider switching Graphics Controller in settings of the VM to VMSVGA . Import to VirtualBox Open VirtualBox and press Ctrl+I or go to File > Import Applicance... At this moment the next step is not necessary but it will help you to connect to the VM via SSH easily. First add Host-Only adapter in VirtualBox menu File > Host Network Manager... or by pressing Ctrl+H Then go to the image's settings, Network and add the second network adapter Optionally you can increase the amount of video memory and switch Graphics Controller to VMSVGA . Launch the machine Finally press Start and you'll see AIRA welcoming you with generated Ethereum address and IPFS identifier At the very first initialization AIRA generates new Ethereum address and IPNS identifier for you.","title":"AIRA Installation on VirtualBox"},{"location":"try_it_out/aira_installation/#aira-installation-on-virtualbox","text":"AIRA is a client for Robonomics Network by Airalab. Basically it's a NixOS based operating system. It's possible to install AIRA on a x86_64 PC. Also there are images for Raspberry Pi 3 and 4 supported by the team. To get familiar with the OS it's better to start from installing it as a virtual machine in VirtualBox . Requirements: VirtualBox VirtualBox Extension Pack 2Gb of RAM for the machine 40Gb of free disk space","title":"AIRA Installation on VirtualBox"},{"location":"try_it_out/aira_installation/#obtain-the-image","text":"There are channels stable and unstable To get stable image download the file with .ova extension. For example, the link for stable image is https://aira.life/channels/aira-stable/nixos-20.03pre-git-x86_64-linux.ova Note Don't forget to check checksum of an image. The last column on the download page is SHA-256 hash . It must be equal to the output of sha256sum nixos-20.03pre-git-x86_64-linux.ova There is a walkthrough video you may wish to check out","title":"Obtain the image"},{"location":"try_it_out/aira_installation/#troubleshooting","text":"If you have a fresh installed VirtualBox you need to install the extension pack or disable USB 2.0 controller. Also VirtualBox may show a warning about Display settings . Consider switching Graphics Controller in settings of the VM to VMSVGA .","title":"Troubleshooting"},{"location":"try_it_out/aira_installation/#import-to-virtualbox","text":"Open VirtualBox and press Ctrl+I or go to File > Import Applicance... At this moment the next step is not necessary but it will help you to connect to the VM via SSH easily. First add Host-Only adapter in VirtualBox menu File > Host Network Manager... or by pressing Ctrl+H Then go to the image's settings, Network and add the second network adapter Optionally you can increase the amount of video memory and switch Graphics Controller to VMSVGA .","title":"Import to VirtualBox"},{"location":"try_it_out/aira_installation/#launch-the-machine","text":"Finally press Start and you'll see AIRA welcoming you with generated Ethereum address and IPFS identifier At the very first initialization AIRA generates new Ethereum address and IPNS identifier for you.","title":"Launch the machine"},{"location":"try_it_out/get_weather_on_fuji_mountain/","text":"Get Open Data from Sensor Let's start from a quick example of what Robonomics is able to do within 5 minutes. Requirements: Metamask extension Open sensor demo website and follow instructions below 1. Open the Dapp You see the next picture in case you don't have MetaMask extension. Go to the link provided above and install one 2. Allow connection to the extension 3. Press \"Request current values\" 4. Sign a message. No token or ether are needed 5. Wait until the agent collects the data and sends it back 6. Wait until the Dapp downloads the result file from IPFS 7. Look at the data Just now you have broadcasted a demand message and got a result from an autonomous agent! The result file is stored in IPFS, the result message is signed with the agent's private key. .center { display: block; margin-left: auto; margin-right: auto; } .half { transform: scale(0.5); }","title":"Get Weather on Fuji Mountain"},{"location":"try_it_out/get_weather_on_fuji_mountain/#get-open-data-from-sensor","text":"Let's start from a quick example of what Robonomics is able to do within 5 minutes. Requirements: Metamask extension Open sensor demo website and follow instructions below","title":"Get Open Data from Sensor"},{"location":"try_it_out/get_weather_on_fuji_mountain/#1-open-the-dapp","text":"You see the next picture in case you don't have MetaMask extension. Go to the link provided above and install one","title":"1. Open the Dapp"},{"location":"try_it_out/get_weather_on_fuji_mountain/#2-allow-connection-to-the-extension","text":"","title":"2. Allow connection to the extension"},{"location":"try_it_out/get_weather_on_fuji_mountain/#3-press-request-current-values","text":"","title":"3. Press \"Request current values\""},{"location":"try_it_out/get_weather_on_fuji_mountain/#4-sign-a-message-no-token-or-ether-are-needed","text":"","title":"4. Sign a message. No token or ether are needed"},{"location":"try_it_out/get_weather_on_fuji_mountain/#5-wait-until-the-agent-collects-the-data-and-sends-it-back","text":"","title":"5. Wait until the agent collects the data and sends it back"},{"location":"try_it_out/get_weather_on_fuji_mountain/#6-wait-until-the-dapp-downloads-the-result-file-from-ipfs","text":"","title":"6. Wait until the Dapp downloads the result file from IPFS"},{"location":"try_it_out/get_weather_on_fuji_mountain/#7-look-at-the-data","text":"Just now you have broadcasted a demand message and got a result from an autonomous agent! The result file is stored in IPFS, the result message is signed with the agent's private key. .center { display: block; margin-left: auto; margin-right: auto; } .half { transform: scale(0.5); }","title":"7. Look at the data"},{"location":"try_it_out/robonomics_dapp_overview/","text":"Robonomics DApp Overview There is The Dapp of Robonomics Network. The first page looks like shown below: Let's have a look at the bottom table \"Robonomics Telemetry\". Every time an instance of AIRA is launched it broadcasts a piece of information about itself. Usually it takes some time for the Dapp to receive data from an instance of AIRA. Have a brief look at the previous page to understand where IPNS and Address Eth came from. IPNS You can treat it as a unique identifier of your instance in IPFS network. Under that name AIRA publishes metadata about itself Address Eth By default AIRA generates a new Ethereum address for you (it's possible to generate new one) It's mainly used to sign all the outcoming messages Lighthouse In Robonomics Network an agent must choose a lighthouse to work on. By default it's airalab.lighthouse.5.robonomics.eth . You can choose existing one or create your own on Lighthouses page. Peers The amount of IPFS pubsub peers Date The date and time of last update Network Robonomics Network officially works in Ethereum Mainnet. There is also Sidechain which is mostly for testing purpose.","title":"Robonomics DApp Overview"},{"location":"try_it_out/robonomics_dapp_overview/#robonomics-dapp-overview","text":"There is The Dapp of Robonomics Network. The first page looks like shown below: Let's have a look at the bottom table \"Robonomics Telemetry\". Every time an instance of AIRA is launched it broadcasts a piece of information about itself. Usually it takes some time for the Dapp to receive data from an instance of AIRA. Have a brief look at the previous page to understand where IPNS and Address Eth came from.","title":"Robonomics DApp Overview"},{"location":"try_it_out/robonomics_dapp_overview/#ipns","text":"You can treat it as a unique identifier of your instance in IPFS network. Under that name AIRA publishes metadata about itself","title":"IPNS"},{"location":"try_it_out/robonomics_dapp_overview/#address-eth","text":"By default AIRA generates a new Ethereum address for you (it's possible to generate new one) It's mainly used to sign all the outcoming messages","title":"Address Eth"},{"location":"try_it_out/robonomics_dapp_overview/#lighthouse","text":"In Robonomics Network an agent must choose a lighthouse to work on. By default it's airalab.lighthouse.5.robonomics.eth . You can choose existing one or create your own on Lighthouses page.","title":"Lighthouse"},{"location":"try_it_out/robonomics_dapp_overview/#peers","text":"The amount of IPFS pubsub peers","title":"Peers"},{"location":"try_it_out/robonomics_dapp_overview/#date","text":"The date and time of last update","title":"Date"},{"location":"try_it_out/robonomics_dapp_overview/#network","text":"Robonomics Network officially works in Ethereum Mainnet. There is also Sidechain which is mostly for testing purpose.","title":"Network"}]}