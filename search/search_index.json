{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started Web3 Framework for smart cities and industry 4.0 app developers The idea of the network is to connect a particular service and a Dapp user interface. The following chart describes what place Robonmics takes in the scenario. Try it out yourself here ! What the documentation contains I'm interested in using Robonomics services Take a look at the Robonomics Dapp . Get familiar with the statistic, average miner reward etc. Try out existing services I'm a Dapp developer There are Robonomics-js library and dapp template I'm a robotics engineer Links: Install AIRA Messages FAQ etc...","title":"Getting Started"},{"location":"#getting-started","text":"Web3 Framework for smart cities and industry 4.0 app developers The idea of the network is to connect a particular service and a Dapp user interface. The following chart describes what place Robonmics takes in the scenario. Try it out yourself here !","title":"Getting Started"},{"location":"#what-the-documentation-contains","text":"","title":"What the documentation contains"},{"location":"#im-interested-in-using-robonomics-services","text":"Take a look at the Robonomics Dapp . Get familiar with the statistic, average miner reward etc. Try out existing services","title":"I'm interested in using Robonomics services"},{"location":"#im-a-dapp-developer","text":"There are Robonomics-js library and dapp template","title":"I'm a Dapp developer"},{"location":"#im-a-robotics-engineer","text":"Links: Install AIRA Messages FAQ etc...","title":"I'm a robotics engineer"},{"location":"agent_development/examples/","text":"Examples Useful pieces of code and a few scenarios All source code is here Broadcast Demand Broadcast Offer Trader Trader with ACL Open Sensor Data","title":"Examples"},{"location":"agent_development/examples/#examples","text":"Useful pieces of code and a few scenarios All source code is here Broadcast Demand Broadcast Offer Trader Trader with ACL Open Sensor Data","title":"Examples"},{"location":"agent_development/market_messages/","text":"Market Messages Market messages is used for exchange Demand and Offer information. It also used for delivery Result messages with liability execution reports. Note This is spec for Robonomics Generation 5 . Currently for message delivery is used IPFS PubSub broadcaster. IPFS PubSub topic is set according to Lighthouse ENS name. Messages content Robonomics market message use JSON data format. Demand Field ROS Type Description model ipfs_common/Multihash CPS behavioral model identifier objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file token ethereum_common/Address Operational token address cost ethereum_common/UInt256 CPS behavioral model execution cost lighthouse ethereum_common/Address Lighthouse contract address validator ethereum_common/Address Observing network address validatorFee ethereum_common/UInt256 Observing network fee deadline ethereum_common/UInt256 Deadline block number nonce ethereum_common/UInt256 Robonomics message counter sender ethereum_common/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature Offer Field ROS Type Description model ipfs_commom/Multihash CPS behavioral model identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model execution cost validator ethereum_commom/Address Observing network address lighthouse ethereum_commom/Address Lighthouse contract address lighthouseFee ethereum_commom/UInt256 Liability creation fee deadline ethereum_commom/UInt256 Deadline block number nonce ethereum_commom/UInt256 Robonomics message counter sender ethereum_commom/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature Result Field ROS Type Description liability ethereum_commom/Address Liability contract address result ipfs_commom/Multihash Liability result multihash success std_msgs/Bool Is liability executed successful signature std_msgs/UInt8[] Sender\u2019s Ethereum signature Messages signing Before signing the messages is packed using abi.encodePacked solidity finction and hashed by Keccak_256. demandHash = keccak256 ( abi . encodePacked ( _model , _objective , _token , _cost , _lighthouse , _validator , _validator_fee , _deadline , IFactory ( factory ). nonceOf ( _sender ) , _sender )); Note nonce parameter is counted by factory smart contract and incremented for each created liability smart contract. Message hash are signed using Ethereum secp256k1 signature .","title":"Market Messages"},{"location":"agent_development/market_messages/#market-messages","text":"Market messages is used for exchange Demand and Offer information. It also used for delivery Result messages with liability execution reports. Note This is spec for Robonomics Generation 5 . Currently for message delivery is used IPFS PubSub broadcaster. IPFS PubSub topic is set according to Lighthouse ENS name.","title":"Market Messages"},{"location":"agent_development/market_messages/#messages-content","text":"Robonomics market message use JSON data format.","title":"Messages content"},{"location":"agent_development/market_messages/#demand","text":"Field ROS Type Description model ipfs_common/Multihash CPS behavioral model identifier objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file token ethereum_common/Address Operational token address cost ethereum_common/UInt256 CPS behavioral model execution cost lighthouse ethereum_common/Address Lighthouse contract address validator ethereum_common/Address Observing network address validatorFee ethereum_common/UInt256 Observing network fee deadline ethereum_common/UInt256 Deadline block number nonce ethereum_common/UInt256 Robonomics message counter sender ethereum_common/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature","title":"Demand"},{"location":"agent_development/market_messages/#offer","text":"Field ROS Type Description model ipfs_commom/Multihash CPS behavioral model identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model execution cost validator ethereum_commom/Address Observing network address lighthouse ethereum_commom/Address Lighthouse contract address lighthouseFee ethereum_commom/UInt256 Liability creation fee deadline ethereum_commom/UInt256 Deadline block number nonce ethereum_commom/UInt256 Robonomics message counter sender ethereum_commom/Address Message sender address signature std_msgs/UInt8[] Sender\u2019s Ethereum signature","title":"Offer"},{"location":"agent_development/market_messages/#result","text":"Field ROS Type Description liability ethereum_commom/Address Liability contract address result ipfs_commom/Multihash Liability result multihash success std_msgs/Bool Is liability executed successful signature std_msgs/UInt8[] Sender\u2019s Ethereum signature","title":"Result"},{"location":"agent_development/market_messages/#messages-signing","text":"Before signing the messages is packed using abi.encodePacked solidity finction and hashed by Keccak_256. demandHash = keccak256 ( abi . encodePacked ( _model , _objective , _token , _cost , _lighthouse , _validator , _validator_fee , _deadline , IFactory ( factory ). nonceOf ( _sender ) , _sender )); Note nonce parameter is counted by factory smart contract and incremented for each created liability smart contract. Message hash are signed using Ethereum secp256k1 signature .","title":"Messages signing"},{"location":"agent_development/api/ethereum_common/","text":"Ethereum Common The packages contains two launch files: erc20.launch and signer.launch . The last one is included in Robonomics Liability . Below is the description for erc20 node which contains utils for convenient work with Ethereum accounts and XRT token. ROS Parameters ~web3_http_provider Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545 ~erc20_token ERC20 token to work with. Type is string , defaults to xrt.5.robonomics.eth ~factory_contract The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth ~ens_contract The checksumed address of ENS registry. The type is string , defaults to \"\" ~keyfile Path to keyfile. The type is string , defaults to \"\" . Required parameter ~keyfile_password_file Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter Published topics /eth/event/transfer (ethereum_common/TransferEvent) The event ethereum_common/TransferEvent is emitted after the transfer of tokens was made /eth/event/approval (ethereum_common/ApprovalEvent) The event ethereum_common/ApprovalEvent is emitted after the approval of tokens was made Services /eth/accounts (ethereum_common/Accounts) List of available Ethereum accounts. See ethereum_common/Accounts /eth/account_eth_balance (ethereum_common/AccountBalance) Returns the balance of the given address in Wei. See ethereum_common/AccountBalance /eth/eth_balance (ethereum_common/Balance) Returns the balance of the default address. See :ref: Ethereum-common-Balance.srv /eth/current_block (ethereum_common/BlockNumber) Returns current block number. See :ref: Ethereum-common-BlockNumber.srv /eth/transfer (ethereum_common/Transfer) Transfers tokens from the default account to a given one. See :ref: Ethereum-common-Transfer.srv /eth/transfer_from (ethereum_common/TransferFrom) Transfers tokens from a given account to another one. See :ref: Ethereum-common-TransferFrom.srv /eth/approve (ethereum_common/Approve) Approves tokens from the default account to a given one. See :ref: Ethereum-common-Approve.srv /eth/account_xrt_balance (ethereum_common/AccountBalance) Returns the XRT balance of a given account. See :ref: Ethereum-common-AccountBalance.srv /eth/xrt_balance (ethereum_common/Balance) Return the XRT balance of the default account. See :ref: Ethereum-common-Balance.srv /eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance) Returns how much one account is allowed to spend from another account. See :ref: Ethereum-common-AccountToAddressAllowance.srv /eth/xrt_allowance (ethereum_common/Allowance) Returns how much the Factory is allowed to spend from the default account. See :ref: Ethereum-common-Allowance.srv","title":"Ethereum Common"},{"location":"agent_development/api/ethereum_common/#ethereum-common","text":"The packages contains two launch files: erc20.launch and signer.launch . The last one is included in Robonomics Liability . Below is the description for erc20 node which contains utils for convenient work with Ethereum accounts and XRT token.","title":"Ethereum Common"},{"location":"agent_development/api/ethereum_common/#ros-parameters","text":"","title":"ROS Parameters"},{"location":"agent_development/api/ethereum_common/#web3_http_provider","text":"Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545","title":"~web3_http_provider"},{"location":"agent_development/api/ethereum_common/#erc20_token","text":"ERC20 token to work with. Type is string , defaults to xrt.5.robonomics.eth","title":"~erc20_token"},{"location":"agent_development/api/ethereum_common/#factory_contract","text":"The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth","title":"~factory_contract"},{"location":"agent_development/api/ethereum_common/#ens_contract","text":"The checksumed address of ENS registry. The type is string , defaults to \"\"","title":"~ens_contract"},{"location":"agent_development/api/ethereum_common/#keyfile","text":"Path to keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile"},{"location":"agent_development/api/ethereum_common/#keyfile_password_file","text":"Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile_password_file"},{"location":"agent_development/api/ethereum_common/#published-topics","text":"","title":"Published topics"},{"location":"agent_development/api/ethereum_common/#etheventtransfer-ethereum_commontransferevent","text":"The event ethereum_common/TransferEvent is emitted after the transfer of tokens was made","title":"/eth/event/transfer (ethereum_common/TransferEvent)"},{"location":"agent_development/api/ethereum_common/#etheventapproval-ethereum_commonapprovalevent","text":"The event ethereum_common/ApprovalEvent is emitted after the approval of tokens was made","title":"/eth/event/approval (ethereum_common/ApprovalEvent)"},{"location":"agent_development/api/ethereum_common/#services","text":"","title":"Services"},{"location":"agent_development/api/ethereum_common/#ethaccounts-ethereum_commonaccounts","text":"List of available Ethereum accounts. See ethereum_common/Accounts","title":"/eth/accounts (ethereum_common/Accounts)"},{"location":"agent_development/api/ethereum_common/#ethaccount_eth_balance-ethereum_commonaccountbalance","text":"Returns the balance of the given address in Wei. See ethereum_common/AccountBalance","title":"/eth/account_eth_balance (ethereum_common/AccountBalance)"},{"location":"agent_development/api/ethereum_common/#etheth_balance-ethereum_commonbalance","text":"Returns the balance of the default address. See :ref: Ethereum-common-Balance.srv","title":"/eth/eth_balance (ethereum_common/Balance)"},{"location":"agent_development/api/ethereum_common/#ethcurrent_block-ethereum_commonblocknumber","text":"Returns current block number. See :ref: Ethereum-common-BlockNumber.srv","title":"/eth/current_block (ethereum_common/BlockNumber)"},{"location":"agent_development/api/ethereum_common/#ethtransfer-ethereum_commontransfer","text":"Transfers tokens from the default account to a given one. See :ref: Ethereum-common-Transfer.srv","title":"/eth/transfer (ethereum_common/Transfer)"},{"location":"agent_development/api/ethereum_common/#ethtransfer_from-ethereum_commontransferfrom","text":"Transfers tokens from a given account to another one. See :ref: Ethereum-common-TransferFrom.srv","title":"/eth/transfer_from (ethereum_common/TransferFrom)"},{"location":"agent_development/api/ethereum_common/#ethapprove-ethereum_commonapprove","text":"Approves tokens from the default account to a given one. See :ref: Ethereum-common-Approve.srv","title":"/eth/approve (ethereum_common/Approve)"},{"location":"agent_development/api/ethereum_common/#ethaccount_xrt_balance-ethereum_commonaccountbalance","text":"Returns the XRT balance of a given account. See :ref: Ethereum-common-AccountBalance.srv","title":"/eth/account_xrt_balance (ethereum_common/AccountBalance)"},{"location":"agent_development/api/ethereum_common/#ethxrt_balance-ethereum_commonbalance","text":"Return the XRT balance of the default account. See :ref: Ethereum-common-Balance.srv","title":"/eth/xrt_balance (ethereum_common/Balance)"},{"location":"agent_development/api/ethereum_common/#ethaccount_xrt_allowance-ethereum_commonaccounttoaddressallowance","text":"Returns how much one account is allowed to spend from another account. See :ref: Ethereum-common-AccountToAddressAllowance.srv","title":"/eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance)"},{"location":"agent_development/api/ethereum_common/#ethxrt_allowance-ethereum_commonallowance","text":"Returns how much the Factory is allowed to spend from the default account. See :ref: Ethereum-common-Allowance.srv","title":"/eth/xrt_allowance (ethereum_common/Allowance)"},{"location":"agent_development/api/ethereum_common_msgs/","text":"Ethereum Common Messages ethereum_common/Address.msg Field Type Description address std_msgs/String Address in Ethereum blockchain ethereum_common/UInt256.msg Field Type Description uint256 std_msgs/String A wrapper for big integers ethereum_common/TransferEvent.msg Field Type Description args_from ethereum_common/Address Sender address args_to ethereum_common/Address Receiver address args_value ethereum_common/UInt256 Amount of tokens ethereum_common/ApprovalEvent.msg Field Type Description args_owner ethereum_common/Address Owner address args_spender ethereum_common/Address Spender address args_value ethereum_common/UInt256 Amount of tokens ethereum_common/AccountBalance.srv Request Field Type Description account ethereum_common/Address Ethereum address Response Field Type Description balance ethereum_common/UInt256 Balance in Wei ethereum_common/AccountToAddressAllowance.srv Request Field Type Description account ethereum_common/Address Ethereum address to ethereum_common/Address Ethereum address Response Field Type Description amount ethereum_common/UInt256 Balance in Wn ethereum_common/Accounts.srv Request Request is empty Response Field Type Description accounts ethereum_common/Address[] List of available accounts ethereum_common/Allowance.srv Request Request is empty Response Field Type Description amount ethereum_common/UInt256 Amount of XRT the Factory is allowed to spend ethereum_common/Approve.srv Request Field Type Description spender ethereum_common/Address Who is allowed to spend value ethereum_common/UInt256 How much tokens are allowed Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash ethereum_common/Balance.srv Request Request is empty Response Field Type Description balance ethereum_common/UInt256 The balance of default account ethereum_common/BlockNumber.srv Request Request is empty Response Field Type Description number std_msgs/Uint64 Current block number ethereum_common/Transfer.srv Request Field Type Description to ethereum_common/Address Ethereum address value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash ethereum_common/TransferFrom.srv Request Field Type Description owner ethereum_common/Address Owner's address to ethereum_common/Address Another account value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"Ethereum Common Messages"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum-common-messages","text":"","title":"Ethereum Common Messages"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaddressmsg","text":"Field Type Description address std_msgs/String Address in Ethereum blockchain","title":"ethereum_common/Address.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonuint256msg","text":"Field Type Description uint256 std_msgs/String A wrapper for big integers","title":"ethereum_common/UInt256.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commontransfereventmsg","text":"Field Type Description args_from ethereum_common/Address Sender address args_to ethereum_common/Address Receiver address args_value ethereum_common/UInt256 Amount of tokens","title":"ethereum_common/TransferEvent.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonapprovaleventmsg","text":"Field Type Description args_owner ethereum_common/Address Owner address args_spender ethereum_common/Address Spender address args_value ethereum_common/UInt256 Amount of tokens","title":"ethereum_common/ApprovalEvent.msg"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaccountbalancesrv","text":"Request Field Type Description account ethereum_common/Address Ethereum address Response Field Type Description balance ethereum_common/UInt256 Balance in Wei","title":"ethereum_common/AccountBalance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaccounttoaddressallowancesrv","text":"Request Field Type Description account ethereum_common/Address Ethereum address to ethereum_common/Address Ethereum address Response Field Type Description amount ethereum_common/UInt256 Balance in Wn","title":"ethereum_common/AccountToAddressAllowance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonaccountssrv","text":"Request Request is empty Response Field Type Description accounts ethereum_common/Address[] List of available accounts","title":"ethereum_common/Accounts.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonallowancesrv","text":"Request Request is empty Response Field Type Description amount ethereum_common/UInt256 Amount of XRT the Factory is allowed to spend","title":"ethereum_common/Allowance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonapprovesrv","text":"Request Field Type Description spender ethereum_common/Address Who is allowed to spend value ethereum_common/UInt256 How much tokens are allowed Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"ethereum_common/Approve.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonbalancesrv","text":"Request Request is empty Response Field Type Description balance ethereum_common/UInt256 The balance of default account","title":"ethereum_common/Balance.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commonblocknumbersrv","text":"Request Request is empty Response Field Type Description number std_msgs/Uint64 Current block number","title":"ethereum_common/BlockNumber.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commontransfersrv","text":"Request Field Type Description to ethereum_common/Address Ethereum address value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"ethereum_common/Transfer.srv"},{"location":"agent_development/api/ethereum_common_msgs/#ethereum_commontransferfromsrv","text":"Request Field Type Description owner ethereum_common/Address Owner's address to ethereum_common/Address Another account value ethereum_common/UInt256 The amount of tokens Response Field Type Description txhash std_msgs/Uint8[32] Transaction hash","title":"ethereum_common/TransferFrom.srv"},{"location":"agent_development/api/ipfs_common/","text":"IPFS Common The package handle IPFS connections, provides useful services for working with IPFS Network. It's included in robonomics_liability launch file ROS Parameters ~lighthouse_contract The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth ~ipfs_http_provider IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001 ~ipfs_public_providers A public IPFS node to pin result files. The type is string , defaults to \"\" ~ipfs_file_providers A list of public nodes to pin result files. The type is list of strings , defaults to [ipfs_public_providers] ~ipfs_swarm_connect_addresses IPFS nodes to connect to. The type is string , defaults to \"\" ~ipfs_swarm_connect_to A list of IPFS nodes to connect to. The type is list of strings , defaults to [ipfs_swarm_connect_addresses] Subscribed topics","title":"IPFS Common"},{"location":"agent_development/api/ipfs_common/#ipfs-common","text":"The package handle IPFS connections, provides useful services for working with IPFS Network. It's included in robonomics_liability launch file","title":"IPFS Common"},{"location":"agent_development/api/ipfs_common/#ros-parameters","text":"","title":"ROS Parameters"},{"location":"agent_development/api/ipfs_common/#lighthouse_contract","text":"The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth","title":"~lighthouse_contract"},{"location":"agent_development/api/ipfs_common/#ipfs_http_provider","text":"IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001","title":"~ipfs_http_provider"},{"location":"agent_development/api/ipfs_common/#ipfs_public_providers","text":"A public IPFS node to pin result files. The type is string , defaults to \"\"","title":"~ipfs_public_providers"},{"location":"agent_development/api/ipfs_common/#ipfs_file_providers","text":"A list of public nodes to pin result files. The type is list of strings , defaults to [ipfs_public_providers]","title":"~ipfs_file_providers"},{"location":"agent_development/api/ipfs_common/#ipfs_swarm_connect_addresses","text":"IPFS nodes to connect to. The type is string , defaults to \"\"","title":"~ipfs_swarm_connect_addresses"},{"location":"agent_development/api/ipfs_common/#ipfs_swarm_connect_to","text":"A list of IPFS nodes to connect to. The type is list of strings , defaults to [ipfs_swarm_connect_addresses]","title":"~ipfs_swarm_connect_to"},{"location":"agent_development/api/ipfs_common/#subscribed-topics","text":"","title":"Subscribed topics"},{"location":"agent_development/api/ipfs_common_msgs/","text":"IPFS Common Messages ipfs_common/Filepath.msg Field Type Description filepath std_msgs/String A path to a file ipfs_common/Multihash.msg Field Type Description multihash std_msgs/String A wrapper for model and objective fields ipfs_common/IpfsDownloadFile.srv Request Field Type Description ipfs_address ipfs_common/Multihash IPFS hash of a file file ipfs_common/Filepath Where to save the file Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message ipfs_common/IpfsUploadFile.srv Request Field Type Description file ipfs_common/Filepath Path to a file to be uploaded to IPFS Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message ipfs_address ipfs_common/Multihash IPFS hash of uploaded file","title":"IPFS Common Messages"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs-common-messages","text":"","title":"IPFS Common Messages"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonfilepathmsg","text":"Field Type Description filepath std_msgs/String A path to a file","title":"ipfs_common/Filepath.msg"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonmultihashmsg","text":"Field Type Description multihash std_msgs/String A wrapper for model and objective fields","title":"ipfs_common/Multihash.msg"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonipfsdownloadfilesrv","text":"Request Field Type Description ipfs_address ipfs_common/Multihash IPFS hash of a file file ipfs_common/Filepath Where to save the file Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message","title":"ipfs_common/IpfsDownloadFile.srv"},{"location":"agent_development/api/ipfs_common_msgs/#ipfs_commonipfsuploadfilesrv","text":"Request Field Type Description file ipfs_common/Filepath Path to a file to be uploaded to IPFS Response Field Type Description success std_msgs/Bool Status of execution error_msg std_msgs/String Error message ipfs_address ipfs_common/Multihash IPFS hash of uploaded file","title":"ipfs_common/IpfsUploadFile.srv"},{"location":"agent_development/api/robonomics_liability/","text":"Robonomics Liability The package is responsible for receiving New Liability events ( listener node) and playing topics from objective field ( executor node). The launch file also include ipfs_channel node and signer node. ROS Parameters ~web3_http_provider Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545 ~web3_ws_provider Web3 WebSocket provider address. The type is string , defaults to ws://127.0.0.1:8546 ~ipfs_http_provider IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001 ~ipfs_swarm_connect_addresses IPFS nodes to connect to. The type is string , defaults to \"\" ~ipfs_public_providers A public IPFS node to pin result files. The type is string , defaults to \"\" ~factory_contract The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth ~lighthouse_contract The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth ~enable_executor Enable or disable executor node. If it's false , no topics from objective would be published. The type is boolean , defaults to true ~master_check_interval Period (in seconds) to check master for new topic publications. It's necessary for the Recorder, which records all the topics a CPS publishes. The type is double , defaults to 0.1 ~recording_topics List of topics name separated by comma. It allows you to specify which topics would be recorded. The type is string , defaults to \"\" ~ens_contract The checksumed address of ENS registry. The type is string , defaults to \"\" ~keyfile Path to keyfile. The type is string , defaults to \"\" . Required parameter ~keyfile_password_file Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter Subscribed topics /liability/infochan/eth/signing/demand (robonomics_msgs/Demand) robonomics_msgs/Demand message to sign and send further to IPFS channel /liability/infochan/eth/signing/offer (robonomics_msgs/Offer) robonomics_msgs/Offer message to sign and send further to IPFS channel /liability/infochan/eth/signing/result (robonomics_msgs/Result) robonomics_msgs/Result message to sign and send further to IPFS channel Published topics /liability/infochan/incoming/demand (robonomics_msgs/Demand) Contains a robonomics_msgs/Demand message which was read from IPFS channel /liability/infochan/incoming/offer (robonomics_msgs/Offer) Contains a robonomics_msgs/Offer message which was read from IPFS channel /liability/infochan/incoming/result (robonomics_msgs/Result) Contains a robonomics_msgs/Result message which was read from IPFS channel /liability/incoming (robonomics_liability/Liability) Contains all the information about the last created robonomics_liability/Liability /liability/ready (robonomics_liability/Liability) Signals when a robonomics_liability/Liability is ready for execution /liability/complete (robonomics_liability/Liability) Signals when a robonomics_liability/Liability has done its job /liability/finalized (std_msgs/String) Signals when a liability has been finalized Services /liability/start (robonomics_liability/StartLiability) The service tells executor to play topics from the objective. It's required to pass a liability address ( robonomics_liability/StartLiability ), which you can get from /liability/ready topic /liability/finish (robonomics_liability/FinishLiability) CPS should call the service after performing the task. The input is robonomics_liability/FinishLiability /liability/restart (robonomics_liability/StartLiability) The service allows to restart a liability after the system shutdown. The input is robonomics_liability/StartLiability /liability/resume (robonomics_liability/StartLiability) The service allows to resume a liability from the last timestamp available in the persistence store. The input is robonomics_liability/StartLiability /liability/read (robonomics_liability/ReadLiability) The service returns all the data about a liability by its address. The input is robonomics_liability/ReadLiability","title":"Robonomics Liability"},{"location":"agent_development/api/robonomics_liability/#robonomics-liability","text":"The package is responsible for receiving New Liability events ( listener node) and playing topics from objective field ( executor node). The launch file also include ipfs_channel node and signer node.","title":"Robonomics Liability"},{"location":"agent_development/api/robonomics_liability/#ros-parameters","text":"","title":"ROS Parameters"},{"location":"agent_development/api/robonomics_liability/#web3_http_provider","text":"Web3 HTTP provider address. The type is string , defaults to http://127.0.0.1:8545","title":"~web3_http_provider"},{"location":"agent_development/api/robonomics_liability/#web3_ws_provider","text":"Web3 WebSocket provider address. The type is string , defaults to ws://127.0.0.1:8546","title":"~web3_ws_provider"},{"location":"agent_development/api/robonomics_liability/#ipfs_http_provider","text":"IPFS HTTP provider address. The type is string , defaults to http://127.0.0.1:5001","title":"~ipfs_http_provider"},{"location":"agent_development/api/robonomics_liability/#ipfs_swarm_connect_addresses","text":"IPFS nodes to connect to. The type is string , defaults to \"\"","title":"~ipfs_swarm_connect_addresses"},{"location":"agent_development/api/robonomics_liability/#ipfs_public_providers","text":"A public IPFS node to pin result files. The type is string , defaults to \"\"","title":"~ipfs_public_providers"},{"location":"agent_development/api/robonomics_liability/#factory_contract","text":"The name of the liability factory. The type is string , defaults to factory.5.robonomics.eth","title":"~factory_contract"},{"location":"agent_development/api/robonomics_liability/#lighthouse_contract","text":"The name of a lighthouse you are working on. The type is string , defaults to airalab.lighthouse.5.robonomics.eth","title":"~lighthouse_contract"},{"location":"agent_development/api/robonomics_liability/#enable_executor","text":"Enable or disable executor node. If it's false , no topics from objective would be published. The type is boolean , defaults to true","title":"~enable_executor"},{"location":"agent_development/api/robonomics_liability/#master_check_interval","text":"Period (in seconds) to check master for new topic publications. It's necessary for the Recorder, which records all the topics a CPS publishes. The type is double , defaults to 0.1","title":"~master_check_interval"},{"location":"agent_development/api/robonomics_liability/#recording_topics","text":"List of topics name separated by comma. It allows you to specify which topics would be recorded. The type is string , defaults to \"\"","title":"~recording_topics"},{"location":"agent_development/api/robonomics_liability/#ens_contract","text":"The checksumed address of ENS registry. The type is string , defaults to \"\"","title":"~ens_contract"},{"location":"agent_development/api/robonomics_liability/#keyfile","text":"Path to keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile"},{"location":"agent_development/api/robonomics_liability/#keyfile_password_file","text":"Path to a file with password for the keyfile. The type is string , defaults to \"\" . Required parameter","title":"~keyfile_password_file"},{"location":"agent_development/api/robonomics_liability/#subscribed-topics","text":"","title":"Subscribed topics"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanethsigningdemand-robonomics_msgsdemand","text":"robonomics_msgs/Demand message to sign and send further to IPFS channel","title":"/liability/infochan/eth/signing/demand (robonomics_msgs/Demand)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanethsigningoffer-robonomics_msgsoffer","text":"robonomics_msgs/Offer message to sign and send further to IPFS channel","title":"/liability/infochan/eth/signing/offer (robonomics_msgs/Offer)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanethsigningresult-robonomics_msgsresult","text":"robonomics_msgs/Result message to sign and send further to IPFS channel","title":"/liability/infochan/eth/signing/result (robonomics_msgs/Result)"},{"location":"agent_development/api/robonomics_liability/#published-topics","text":"","title":"Published topics"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanincomingdemand-robonomics_msgsdemand","text":"Contains a robonomics_msgs/Demand message which was read from IPFS channel","title":"/liability/infochan/incoming/demand (robonomics_msgs/Demand)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanincomingoffer-robonomics_msgsoffer","text":"Contains a robonomics_msgs/Offer message which was read from IPFS channel","title":"/liability/infochan/incoming/offer (robonomics_msgs/Offer)"},{"location":"agent_development/api/robonomics_liability/#liabilityinfochanincomingresult-robonomics_msgsresult","text":"Contains a robonomics_msgs/Result message which was read from IPFS channel","title":"/liability/infochan/incoming/result (robonomics_msgs/Result)"},{"location":"agent_development/api/robonomics_liability/#liabilityincoming-robonomics_liabilityliability","text":"Contains all the information about the last created robonomics_liability/Liability","title":"/liability/incoming (robonomics_liability/Liability)"},{"location":"agent_development/api/robonomics_liability/#liabilityready-robonomics_liabilityliability","text":"Signals when a robonomics_liability/Liability is ready for execution","title":"/liability/ready (robonomics_liability/Liability)"},{"location":"agent_development/api/robonomics_liability/#liabilitycomplete-robonomics_liabilityliability","text":"Signals when a robonomics_liability/Liability has done its job","title":"/liability/complete (robonomics_liability/Liability)"},{"location":"agent_development/api/robonomics_liability/#liabilityfinalized-std_msgsstring","text":"Signals when a liability has been finalized","title":"/liability/finalized (std_msgs/String)"},{"location":"agent_development/api/robonomics_liability/#services","text":"","title":"Services"},{"location":"agent_development/api/robonomics_liability/#liabilitystart-robonomics_liabilitystartliability","text":"The service tells executor to play topics from the objective. It's required to pass a liability address ( robonomics_liability/StartLiability ), which you can get from /liability/ready topic","title":"/liability/start (robonomics_liability/StartLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityfinish-robonomics_liabilityfinishliability","text":"CPS should call the service after performing the task. The input is robonomics_liability/FinishLiability","title":"/liability/finish (robonomics_liability/FinishLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityrestart-robonomics_liabilitystartliability","text":"The service allows to restart a liability after the system shutdown. The input is robonomics_liability/StartLiability","title":"/liability/restart (robonomics_liability/StartLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityresume-robonomics_liabilitystartliability","text":"The service allows to resume a liability from the last timestamp available in the persistence store. The input is robonomics_liability/StartLiability","title":"/liability/resume (robonomics_liability/StartLiability)"},{"location":"agent_development/api/robonomics_liability/#liabilityread-robonomics_liabilityreadliability","text":"The service returns all the data about a liability by its address. The input is robonomics_liability/ReadLiability","title":"/liability/read (robonomics_liability/ReadLiability)"},{"location":"agent_development/api/robonomics_liability_msgs/","text":"Robonomics Liability Messages robonomics_liability/Liability.msg Field Type Description address ethereum_commom/Address The Liability\u2019s address model ipfs_commom/Multihash CPS behavioral model Identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file result ipfs_commom/Multihash Liability result hash promisee ethereum_commom/Address The promisee address promisor ethereum_commom/Address The promisor address (usually CPS) lighthouse ethereum_commom/Address The address of lighthouse your CPS works on token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model implementation cost validator ethereum_commom/Address Observing network address validatorFee ethereum_commom/UInt256 Observing network commission robonomics_liability/StartLiability.srv Request Field Type Description address std_msgs/String The address of Liability you are willing to execute Response Field Type Description success std_msgs/Bool Weather or not the Liability was started msg std_msgs/String Status of launch robonomics_liability/FinishLiability.srv Request Field Type Description address std_msgs/String The address of Liability to finish success std_msgs/Bool The status of execution Response The response is empty robonomics_liability/ReadLiability.srv Request Field Type Description address ethereum_commom/Address The address of a liability Response Field Type Description read std_msgs/Bool Status of execution liability robonomics_liability/Liability Liability","title":"Robonomics Liability Messages"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics-liability-messages","text":"","title":"Robonomics Liability Messages"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilityliabilitymsg","text":"Field Type Description address ethereum_commom/Address The Liability\u2019s address model ipfs_commom/Multihash CPS behavioral model Identifier objective ipfs_commom/Multihash CPS behavioral model parameters in rosbag file result ipfs_commom/Multihash Liability result hash promisee ethereum_commom/Address The promisee address promisor ethereum_commom/Address The promisor address (usually CPS) lighthouse ethereum_commom/Address The address of lighthouse your CPS works on token ethereum_commom/Address Operational token address cost ethereum_commom/UInt256 CPS behavioral model implementation cost validator ethereum_commom/Address Observing network address validatorFee ethereum_commom/UInt256 Observing network commission","title":"robonomics_liability/Liability.msg"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilitystartliabilitysrv","text":"Request Field Type Description address std_msgs/String The address of Liability you are willing to execute Response Field Type Description success std_msgs/Bool Weather or not the Liability was started msg std_msgs/String Status of launch","title":"robonomics_liability/StartLiability.srv"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilityfinishliabilitysrv","text":"Request Field Type Description address std_msgs/String The address of Liability to finish success std_msgs/Bool The status of execution Response The response is empty","title":"robonomics_liability/FinishLiability.srv"},{"location":"agent_development/api/robonomics_liability_msgs/#robonomics_liabilityreadliabilitysrv","text":"Request Field Type Description address ethereum_commom/Address The address of a liability Response Field Type Description read std_msgs/Bool Status of execution liability robonomics_liability/Liability Liability","title":"robonomics_liability/ReadLiability.srv"},{"location":"agent_development/hardware_examples/connect_sensor/","text":"Connect an Air Pollution Sensor In this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network! .. note:: Source code is located `here <https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city>`_ In this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message Arduino Let's begin with an Arduino circuit. You need the following components: Arduino Uno Optical Dust Sensor Sharp GP2Y1010AU0F Gas Sensor MQ-2 Gas Sensor MQ-7 Resistor 150 Ohm Capacitor 220 uF Wires Connect all parts as described below: .. image:: ../img/7.png :alt: Arduino schema :align: center A firmware for Arduino Uno is in sensor_city/scetches folder. In order to upload it to the board use Arduino IDE <https://www.arduino.cc/en/Main/Software> _. .. image:: ../img/8.png :alt: Arduino IDE :align: center Aira .. note:: The following steps are performed in Aira client. You can download the latest image from `this page <https://github.com/airalab/aira/releases>`_. It's convenient to `connect via SSH <../aira_in_depth/Connecting_via_SSH.html>`_ After you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check Enable Serial Port and assign /dev/ttyACM0 in Path/Address . Inside the virtual machine /dev/ttyS0 refers to your external Arduino. .. image:: ../img/9.png :alt: Set a port :align: center Finally launch the image and run these command:: $ roslaunch sensor_city publish_data.launch .. hint:: Check out the source code to learn how it works under the hood! Now Aira patiently waits for a signal to publish the measurements. Go to Dapp <https://dev.aira.life/smart-city/#/> _ and click on Broadcast signal . You should see the data!","title":"Connect an Air Pollution Sensor"},{"location":"agent_development/hardware_examples/connect_sensor/#connect-an-air-pollution-sensor","text":"In this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network! .. note:: Source code is located `here <https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city>`_ In this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message","title":"Connect an Air Pollution Sensor"},{"location":"agent_development/hardware_examples/connect_sensor/#arduino","text":"Let's begin with an Arduino circuit. You need the following components: Arduino Uno Optical Dust Sensor Sharp GP2Y1010AU0F Gas Sensor MQ-2 Gas Sensor MQ-7 Resistor 150 Ohm Capacitor 220 uF Wires Connect all parts as described below: .. image:: ../img/7.png :alt: Arduino schema :align: center A firmware for Arduino Uno is in sensor_city/scetches folder. In order to upload it to the board use Arduino IDE <https://www.arduino.cc/en/Main/Software> _. .. image:: ../img/8.png :alt: Arduino IDE :align: center","title":"Arduino"},{"location":"agent_development/hardware_examples/connect_sensor/#aira","text":".. note:: The following steps are performed in Aira client. You can download the latest image from `this page <https://github.com/airalab/aira/releases>`_. It's convenient to `connect via SSH <../aira_in_depth/Connecting_via_SSH.html>`_ After you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check Enable Serial Port and assign /dev/ttyACM0 in Path/Address . Inside the virtual machine /dev/ttyS0 refers to your external Arduino. .. image:: ../img/9.png :alt: Set a port :align: center Finally launch the image and run these command:: $ roslaunch sensor_city publish_data.launch .. hint:: Check out the source code to learn how it works under the hood! Now Aira patiently waits for a signal to publish the measurements. Go to Dapp <https://dev.aira.life/smart-city/#/> _ and click on Broadcast signal . You should see the data!","title":"Aira"},{"location":"agent_development/hardware_examples/connect_simple_cps/","text":"Connect the Simplest CPS In this section we will build the simplest real cyber-physical system! We will buy a \"wink\" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink> _. Arduino The firmware for the board is located in arduino_blink/misc/arduino/arduino.ino <https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino> . Use Arduino IDE <https://www.arduino.cc/en/Main/Software> to load the code to your Arduino board. In the code we subscribe for the /blink_led topic and set a callback. The type of the topic is Empty , so the board waits until someone publishes to the topic and performs the LED blinking. .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void messageCb( const std_msgs::Empty& toggle_msg){ blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); } ros::Subscriber sub(\"blink_led\", &messageCb ); void setup() { pinMode(LED_BUILTIN, OUTPUT); nh.initNode(); nh.subscribe(sub); } void loop() { nh.spinOnce(); delay(1); } AIRA client .. note:: You can download the latest release from here <https://github.com/airalab/aira/releases> _ Set up the COM port forwarding as described in this lesson <connect_sensor.html> _. You should forward your /dev/ttyUSB0 or /dev/ttyACM0 port (depending on the system) to COM1 . In the client /dev/ttyS0 will represent the board. After this launch the virtual machine. ROS When new liability is created it goes to /liability/ready topic. We have to remember the address and call /liability/start service to get the data from objective. .. code-block:: python def newliability(l): self.liability = l.address rospy.loginfo(\"Got new liability {}\".format(self.liability)) prefix = \"/liability/eth_\" + self.liability rospy.Subscriber(prefix + '/blink', Empty, self.blink) rospy.wait_for_service(\"/liability/start\") rospy.ServiceProxy('/liability/start', StartLiability)(StartLiabilityRequest(address=self.liability)) rospy.Subscriber(\"/liability/ready\", Liability, newliability) A message in the /blink topic come from the objective field. Have a look at Basic usage <../basic_usage.html> _ page. AIRA Connect to AIRA client via SSH as described here <Connecting_via_SSH.html> _. All tutorials are pre-installed. To launch the ros package run the following command:: $ rosrun arduino_blink blink.py Also we need to add a rosbag file to IPFS:: $ ipfs add rosbag/blink.bag .. note:: Before the next step you should approve XRT tokens on the Factory. On your host system build and launch an Dapp for the lesson:: $ git clone https://github.com/airalab/robonomics_tutorials/ $ cd robonomics_tutorials/arduino_blink_dapp $ npm i && npm run dev Open the link <http://localhost:8000/> _ and press Demand then Offer buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!","title":"Connect the Simplest CPS"},{"location":"agent_development/hardware_examples/connect_simple_cps/#connect-the-simplest-cps","text":"In this section we will build the simplest real cyber-physical system! We will buy a \"wink\" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink> _.","title":"Connect the Simplest CPS"},{"location":"agent_development/hardware_examples/connect_simple_cps/#arduino","text":"The firmware for the board is located in arduino_blink/misc/arduino/arduino.ino <https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino> . Use Arduino IDE <https://www.arduino.cc/en/Main/Software> to load the code to your Arduino board. In the code we subscribe for the /blink_led topic and set a callback. The type of the topic is Empty , so the board waits until someone publishes to the topic and performs the LED blinking. .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void messageCb( const std_msgs::Empty& toggle_msg){ blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); blink(LED_BUILTIN, 500); } ros::Subscriber sub(\"blink_led\", &messageCb ); void setup() { pinMode(LED_BUILTIN, OUTPUT); nh.initNode(); nh.subscribe(sub); } void loop() { nh.spinOnce(); delay(1); }","title":"Arduino"},{"location":"agent_development/hardware_examples/connect_simple_cps/#aira-client","text":".. note:: You can download the latest release from here <https://github.com/airalab/aira/releases> _ Set up the COM port forwarding as described in this lesson <connect_sensor.html> _. You should forward your /dev/ttyUSB0 or /dev/ttyACM0 port (depending on the system) to COM1 . In the client /dev/ttyS0 will represent the board. After this launch the virtual machine.","title":"AIRA client"},{"location":"agent_development/hardware_examples/connect_simple_cps/#ros","text":"When new liability is created it goes to /liability/ready topic. We have to remember the address and call /liability/start service to get the data from objective. .. code-block:: python def newliability(l): self.liability = l.address rospy.loginfo(\"Got new liability {}\".format(self.liability)) prefix = \"/liability/eth_\" + self.liability rospy.Subscriber(prefix + '/blink', Empty, self.blink) rospy.wait_for_service(\"/liability/start\") rospy.ServiceProxy('/liability/start', StartLiability)(StartLiabilityRequest(address=self.liability)) rospy.Subscriber(\"/liability/ready\", Liability, newliability) A message in the /blink topic come from the objective field. Have a look at Basic usage <../basic_usage.html> _ page.","title":"ROS"},{"location":"agent_development/hardware_examples/connect_simple_cps/#aira","text":"Connect to AIRA client via SSH as described here <Connecting_via_SSH.html> _. All tutorials are pre-installed. To launch the ros package run the following command:: $ rosrun arduino_blink blink.py Also we need to add a rosbag file to IPFS:: $ ipfs add rosbag/blink.bag .. note:: Before the next step you should approve XRT tokens on the Factory. On your host system build and launch an Dapp for the lesson:: $ git clone https://github.com/airalab/robonomics_tutorials/ $ cd robonomics_tutorials/arduino_blink_dapp $ npm i && npm run dev Open the link <http://localhost:8000/> _ and press Demand then Offer buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!","title":"AIRA"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/","text":"Passing Dynamic Parameters In previous <connect_simple_cps.html> _ example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let's expand the example and teach our board to blink blue or red led depending on objective parameter. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args> _. Arduino The only difference in Arduino source code is instead of subscribing to one topic now we subscribe to /blink_red and /blink_blue topics .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void blinkRedCb(const std_msgs::Empty& msg) { blink(13, 500); blink(13, 500); blink(13, 500); } void blinkBlueCb(const std_msgs::Empty& msg) { blink(12, 500); blink(12, 500); blink(12, 500); } ros::Subscriber subRed(\"blink_red\", &blinkRedCb); ros::Subscriber subBlue(\"blink_blue\", &blinkBlueCb); void setup() { pinMode(13, OUTPUT); pinMode(12, OUTPUT); nh.initNode(); nh.subscribe(subRed); nh.subscribe(subBlue); } void loop() { nh.spinOnce(); delay(1); } Here is the diagram of all connections: .. image:: ../img/6.png :alt: Arduino schema :align: center ROS We can pass arguments via objective which points to rosbag file. Have a look at blink.py script. The main difference is blink() method: .. code-block:: python ... def blink(self, data): if data.data == \"blue\": rospy.loginfo(\"Blinking blue...\") self.blink_blue.publish(Empty()) if data.data == \"red\": rospy.loginfo(\"Blinking red...\") self.blink_red.publish(Empty()) rospy.wait_for_service('/liability/finish') fin = rospy.ServiceProxy('/liability/finish', FinishLiability) fin(FinishLiabilityRequest(address=self.liability, success=True)) rospy.loginfo(\"Finished\") ... Now /blink topic has a String type. You can find prepared rosbags in rosbag folder. AIRA Connect to AIRA client via SSH as described here <Connecting_via_SSH.md> _. Do not forget to add COM1 port in settings. Run the following command:: $ rosrun arduino_with_args blink.py Also we need to add rosbag files to IPFS:: $ ipfs add rosbag/blink_blue.bag $ ipfs add rosbag/blink_red.bag .. note:: Before the next step you should approve XRT tokens on the Factory. The last step is to build Dapp and launch. Take a look at the previous lesson <connect_simple_cps.html> _. To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages. That's it! Now you are able to pass dynamic parameters to your cyber-physical system agent!","title":"Passing Dynamic Parameters"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#passing-dynamic-parameters","text":"In previous <connect_simple_cps.html> _ example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let's expand the example and teach our board to blink blue or red led depending on objective parameter. .. note:: The source code of this lesson is here <https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args> _.","title":"Passing Dynamic Parameters"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#arduino","text":"The only difference in Arduino source code is instead of subscribing to one topic now we subscribe to /blink_red and /blink_blue topics .. code-block:: c #include #include ros::NodeHandle nh; void blink(int led, int mil) { digitalWrite(led, HIGH); delay(mil); digitalWrite(led, LOW); delay(mil); } void blinkRedCb(const std_msgs::Empty& msg) { blink(13, 500); blink(13, 500); blink(13, 500); } void blinkBlueCb(const std_msgs::Empty& msg) { blink(12, 500); blink(12, 500); blink(12, 500); } ros::Subscriber subRed(\"blink_red\", &blinkRedCb); ros::Subscriber subBlue(\"blink_blue\", &blinkBlueCb); void setup() { pinMode(13, OUTPUT); pinMode(12, OUTPUT); nh.initNode(); nh.subscribe(subRed); nh.subscribe(subBlue); } void loop() { nh.spinOnce(); delay(1); } Here is the diagram of all connections: .. image:: ../img/6.png :alt: Arduino schema :align: center","title":"Arduino"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#ros","text":"We can pass arguments via objective which points to rosbag file. Have a look at blink.py script. The main difference is blink() method: .. code-block:: python ... def blink(self, data): if data.data == \"blue\": rospy.loginfo(\"Blinking blue...\") self.blink_blue.publish(Empty()) if data.data == \"red\": rospy.loginfo(\"Blinking red...\") self.blink_red.publish(Empty()) rospy.wait_for_service('/liability/finish') fin = rospy.ServiceProxy('/liability/finish', FinishLiability) fin(FinishLiabilityRequest(address=self.liability, success=True)) rospy.loginfo(\"Finished\") ... Now /blink topic has a String type. You can find prepared rosbags in rosbag folder.","title":"ROS"},{"location":"agent_development/hardware_examples/passing_dynamic_parameters/#aira","text":"Connect to AIRA client via SSH as described here <Connecting_via_SSH.md> _. Do not forget to add COM1 port in settings. Run the following command:: $ rosrun arduino_with_args blink.py Also we need to add rosbag files to IPFS:: $ ipfs add rosbag/blink_blue.bag $ ipfs add rosbag/blink_red.bag .. note:: Before the next step you should approve XRT tokens on the Factory. The last step is to build Dapp and launch. Take a look at the previous lesson <connect_simple_cps.html> _. To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages. That's it! Now you are able to pass dynamic parameters to your cyber-physical system agent!","title":"AIRA"},{"location":"agent_development/robonomics_network/become_a_provider/","text":"Become a Provider This page describes how to create a lighthouse and become a provider in the Robonomics network. Prepare an address First of all, an Ethereum address is required. You must have access to a private key of the address. In case you don't have one, below are steps to create an address via Parity . $ sudo snap install parity $ parity.ethkey generate random secret: 15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539 public: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff address: c531fa8f141493df3da264a864bdcbec19695b4c The secret field is a private key, you'll need it to run the provider client. Save it to a file: $ echo '0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539' > private.key The next step is to deposit some ethers and XRT tokens to the address which is held in the address field. Create a lighthouse Go to the lighthouse dapp and fill in a name in the right side: Click on the Create lighthouse and connect to the network button and sign a transaction. After a while you should see: Now it's time to put a stake. Select the new lighthouse and click Connect to the network : On this page in the Provider section click the Approve button, sign a transaction. When it's mined click the Refill button and do the same. Install the client You must install robonomics-tools at least 0.4.2 version. You can build from the source or do the following steps: Note Make sure you have Nix and Stack installed: $ curl -sSL https://get.haskellstack.org/ | sh $ curl https://nixos.org/nix/install | sh Setup Airalab binary cache at https://aira.cachix.org Import Airalab channel: $ nix-channel --add http://aira.life/channels/aira-unstable/ aira $ nix-channel --update Install from the binary cache: $ nix-env -iA aira.robonomics-tools Run the client: $ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key) Hint Get familiar with the xrtd options via xrtd --help Test the provider To test your provider go again to the lighthouse dapp and connect to the just created lighthouse. At the bottom you should see the TEST LIGHTHOUSE section. Click on the Demand button and then on the Offer one. You should see something similar to: Don't forget to sign every message with the MetaMask extension. Finally you should see a new liability contract created:","title":"Become a Provider"},{"location":"agent_development/robonomics_network/become_a_provider/#become-a-provider","text":"This page describes how to create a lighthouse and become a provider in the Robonomics network.","title":"Become a Provider"},{"location":"agent_development/robonomics_network/become_a_provider/#prepare-an-address","text":"First of all, an Ethereum address is required. You must have access to a private key of the address. In case you don't have one, below are steps to create an address via Parity . $ sudo snap install parity $ parity.ethkey generate random secret: 15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539 public: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff address: c531fa8f141493df3da264a864bdcbec19695b4c The secret field is a private key, you'll need it to run the provider client. Save it to a file: $ echo '0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539' > private.key The next step is to deposit some ethers and XRT tokens to the address which is held in the address field.","title":"Prepare an address"},{"location":"agent_development/robonomics_network/become_a_provider/#create-a-lighthouse","text":"Go to the lighthouse dapp and fill in a name in the right side: Click on the Create lighthouse and connect to the network button and sign a transaction. After a while you should see: Now it's time to put a stake. Select the new lighthouse and click Connect to the network : On this page in the Provider section click the Approve button, sign a transaction. When it's mined click the Refill button and do the same.","title":"Create a lighthouse"},{"location":"agent_development/robonomics_network/become_a_provider/#install-the-client","text":"You must install robonomics-tools at least 0.4.2 version. You can build from the source or do the following steps: Note Make sure you have Nix and Stack installed: $ curl -sSL https://get.haskellstack.org/ | sh $ curl https://nixos.org/nix/install | sh Setup Airalab binary cache at https://aira.cachix.org Import Airalab channel: $ nix-channel --add http://aira.life/channels/aira-unstable/ aira $ nix-channel --update Install from the binary cache: $ nix-env -iA aira.robonomics-tools Run the client: $ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key) Hint Get familiar with the xrtd options via xrtd --help","title":"Install the client"},{"location":"agent_development/robonomics_network/become_a_provider/#test-the-provider","text":"To test your provider go again to the lighthouse dapp and connect to the just created lighthouse. At the bottom you should see the TEST LIGHTHOUSE section. Click on the Demand button and then on the Offer one. You should see something similar to: Don't forget to sign every message with the MetaMask extension. Finally you should see a new liability contract created:","title":"Test the provider"},{"location":"agent_development/robonomics_network/contracts_deployment/","text":"Contracts Deployment Robonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on Github . Airalab team deploys new version of contracts and supports a current one. In this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. You need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this docker container $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest Next step is obtain a copy of robonomics contracts source code: $ git clone --recursive https://github.com/airalab/robonomics_contracts A file truffle.js contains available networks for migration. We will work with development network. When you are in robonomics_contracts directory install dependencies and run a migration: npm install // to install dependencies truffle migrate --network development It's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read white paper . Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. When XRT contracts was deployed some tokens were issued on our account. Let's check the balance: $ truffle --network development console > xrt = XRT.at(XRT.address) > xrt.balanceOf(web3.eth.accounts[0]) And that's how we create a lighthouse: > factory = LiabilityFactory.at(LiabilityFactory.address) > tx = factory.createLighthouse(1000, 10, \"test\") > tx.then(x => {laddress = x.logs[0].args.lighthouse}) > l = LighthouseLib.at(laddress) Instead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A l variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well: > xrt.approve(l.address,1000) > xrt.allowance(web3.eth.accounts[0],l.address) And a very important step is become a worker: > l.refill(1000) Each worker has to put a stake. In this case it's 1000 Wn. Below is a table of our addresses: Contract Address ENS name ENSRegistry 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49 XRT 0x673583a369eb3a830a5571208cf6eb7ce83987f8 xrt.3.robonomics.eth LiabilityFactory 0x1b3190e00c1903266862af1f31714d4b81ef59b2 factory.3.robonomics.eth Lighthouse 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e test.lighthouse.3.robonomics.eth","title":"Contracts Deployment"},{"location":"agent_development/robonomics_network/contracts_deployment/#contracts-deployment","text":"Robonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on Github . Airalab team deploys new version of contracts and supports a current one. In this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. You need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this docker container $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest Next step is obtain a copy of robonomics contracts source code: $ git clone --recursive https://github.com/airalab/robonomics_contracts A file truffle.js contains available networks for migration. We will work with development network. When you are in robonomics_contracts directory install dependencies and run a migration: npm install // to install dependencies truffle migrate --network development It's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read white paper . Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. When XRT contracts was deployed some tokens were issued on our account. Let's check the balance: $ truffle --network development console > xrt = XRT.at(XRT.address) > xrt.balanceOf(web3.eth.accounts[0]) And that's how we create a lighthouse: > factory = LiabilityFactory.at(LiabilityFactory.address) > tx = factory.createLighthouse(1000, 10, \"test\") > tx.then(x => {laddress = x.logs[0].args.lighthouse}) > l = LighthouseLib.at(laddress) Instead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A l variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well: > xrt.approve(l.address,1000) > xrt.allowance(web3.eth.accounts[0],l.address) And a very important step is become a worker: > l.refill(1000) Each worker has to put a stake. In this case it's 1000 Wn. Below is a table of our addresses: Contract Address ENS name ENSRegistry 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49 XRT 0x673583a369eb3a830a5571208cf6eb7ce83987f8 xrt.3.robonomics.eth LiabilityFactory 0x1b3190e00c1903266862af1f31714d4b81ef59b2 factory.3.robonomics.eth Lighthouse 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e test.lighthouse.3.robonomics.eth","title":"Contracts Deployment"},{"location":"agent_development/robonomics_network/how_it_works/","text":"How It Works In this section we will discuss the Robonomics Network scenario. There are few main parts in the Robonomics network: IPFS for the messages exchanging the Ethereum blockchain for storing new liability contracts a provider that is responsible for matching messages an agent Let's have a look at the following diagram that describes the scenario without any additional details: There are three types of messages in IPFS: Demand, Offer, Result. Below there is the specification for a Demand message: Field Type Description Example model ipfs_common/Multihash CPS behavioral model Identifier QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r token ethereum_common/Address Operational token address 0xbD949595eE52346c225a19724084cE517B2cB735 cost ethereum_common/UInt256 CPS behavioral model implementation cost 1 lighthouse ethereum_common/Address Lighthouse address 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1 validator ethereum_common/Address Observing network address 0x0000000000000000000000000000000000000000 validatorFee ethereum_common/UInt256 Observing network commission 0 deadline ethereum_common/UInt256 Deadline block number 6393332 sender ethereum_common/Address Message sender address 0x0000000000000000000000000000000000000000 signature std_msgs/UInt8[] Sender\u2019s digital signature 0x23bc\u2026c617 An Offer message has the same fields but instead of validatorFee there is a lighthouseFee field. This field determines the amount of fee for a lighthouse. Now let's have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization. A liability contract is created only if the following fields match: model , objective , token , cost . A provider of Robonomics Network watches every message and finds those ones that have a match. After the match is found the provider calls createLiability(demand, offer) method from the contract factory where demand and offer are serialized. Below is the package diagram for the Robonomics communication stack: The factory deserializes arguments and recovers promisee and promisor addresses from signatures. Next step is token transfer. The factory transfers cost tokens from the promisee address and validatorFee and lighthouseFee from the promisor address to the new liability address. Note You should approve sufficient amount of tokens for the factory. Note It's not required to approve tokens from the promisor address if fees are null. Now the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format. When the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the validator field is not null it means that only validator is able to finalize the liability. After the successful liability finalization the agent gets cost tokens. Otherwise, the promisee gets tokens back.","title":"How It Works"},{"location":"agent_development/robonomics_network/how_it_works/#how-it-works","text":"In this section we will discuss the Robonomics Network scenario. There are few main parts in the Robonomics network: IPFS for the messages exchanging the Ethereum blockchain for storing new liability contracts a provider that is responsible for matching messages an agent Let's have a look at the following diagram that describes the scenario without any additional details: There are three types of messages in IPFS: Demand, Offer, Result. Below there is the specification for a Demand message: Field Type Description Example model ipfs_common/Multihash CPS behavioral model Identifier QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC objective ipfs_common/Multihash CPS behavioral model parameters in rosbag file QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r token ethereum_common/Address Operational token address 0xbD949595eE52346c225a19724084cE517B2cB735 cost ethereum_common/UInt256 CPS behavioral model implementation cost 1 lighthouse ethereum_common/Address Lighthouse address 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1 validator ethereum_common/Address Observing network address 0x0000000000000000000000000000000000000000 validatorFee ethereum_common/UInt256 Observing network commission 0 deadline ethereum_common/UInt256 Deadline block number 6393332 sender ethereum_common/Address Message sender address 0x0000000000000000000000000000000000000000 signature std_msgs/UInt8[] Sender\u2019s digital signature 0x23bc\u2026c617 An Offer message has the same fields but instead of validatorFee there is a lighthouseFee field. This field determines the amount of fee for a lighthouse. Now let's have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization. A liability contract is created only if the following fields match: model , objective , token , cost . A provider of Robonomics Network watches every message and finds those ones that have a match. After the match is found the provider calls createLiability(demand, offer) method from the contract factory where demand and offer are serialized. Below is the package diagram for the Robonomics communication stack: The factory deserializes arguments and recovers promisee and promisor addresses from signatures. Next step is token transfer. The factory transfers cost tokens from the promisee address and validatorFee and lighthouseFee from the promisor address to the new liability address. Note You should approve sufficient amount of tokens for the factory. Note It's not required to approve tokens from the promisor address if fees are null. Now the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format. When the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the validator field is not null it means that only validator is able to finalize the liability. After the successful liability finalization the agent gets cost tokens. Otherwise, the promisee gets tokens back.","title":"How It Works"},{"location":"aira/basic_usage/","text":"Basic Usage To get familiar with AIRA, let's see what is under the hood. Once you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes: $ rosnode list /eth/erc20_token /eth/eth_node /graph/aira_graph /liability/executor /liability/infochan/eth/signer /liability/infochan/ipfs_channel /liability/persistence /liability/listener /rosout /eth/erc20_token , /eth/eth_node - proved services for Ethereum blockchain and ERC20 tokens /graph/aira_graph - service node for exploring other AIRA instances /liability/executor - gets rosbag file from IPFS and plays it /liability/infochan/ipfs_channel - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back /liability/infochan/eth/signer - offers services for signing offer, demand and result messages /liability/listener - watches for a new liability contracts. When the event is received the node calls executor node /liability/persistence - helps to store incoming liabilities and restart them after shutdown And here's a list of robonomics stack topics. $ rostopic list /eth/event/approval /eth/event/transfer /graph/greetings /liability/complete /liability/finalized /liability/incoming /liability/infochan/eth/sending/demand /liability/infochan/eth/sending/offer /liability/infochan/eth/sending/result /liability/infochan/eth/signing/demand /liability/infochan/eth/signing/offer /liability/infochan/eth/signing/result /liability/infochan/incoming/demand /liability/infochan/incoming/offer /liability/infochan/incoming/result /liability/persistence/add /liability/persistence/del /liability/persistence/update_timestamp /liability/ready /liability/result /rosout /rosout_agg The most important topics for us are: /liability/incoming - when a new liability is created, this topic publishes Ethereum address of the contract /liability/result - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead /liability/infochan/incoming/* - a CPS gets information about offer, demand or result from corresponding topics /liability/infochan/eth/signing/* - a CPS sends offer, demand or result messages to corresponding topics For the details check out the API page . Let's start with greetings - say hello to AIRA! You should just launch a pre-installed package hello_aira : $ rosrun hello_aira hello_aira We've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to dapp and press Order. Now go back to the console and see the result!","title":"Basic Usage"},{"location":"aira/basic_usage/#basic-usage","text":"To get familiar with AIRA, let's see what is under the hood. Once you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes: $ rosnode list /eth/erc20_token /eth/eth_node /graph/aira_graph /liability/executor /liability/infochan/eth/signer /liability/infochan/ipfs_channel /liability/persistence /liability/listener /rosout /eth/erc20_token , /eth/eth_node - proved services for Ethereum blockchain and ERC20 tokens /graph/aira_graph - service node for exploring other AIRA instances /liability/executor - gets rosbag file from IPFS and plays it /liability/infochan/ipfs_channel - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back /liability/infochan/eth/signer - offers services for signing offer, demand and result messages /liability/listener - watches for a new liability contracts. When the event is received the node calls executor node /liability/persistence - helps to store incoming liabilities and restart them after shutdown And here's a list of robonomics stack topics. $ rostopic list /eth/event/approval /eth/event/transfer /graph/greetings /liability/complete /liability/finalized /liability/incoming /liability/infochan/eth/sending/demand /liability/infochan/eth/sending/offer /liability/infochan/eth/sending/result /liability/infochan/eth/signing/demand /liability/infochan/eth/signing/offer /liability/infochan/eth/signing/result /liability/infochan/incoming/demand /liability/infochan/incoming/offer /liability/infochan/incoming/result /liability/persistence/add /liability/persistence/del /liability/persistence/update_timestamp /liability/ready /liability/result /rosout /rosout_agg The most important topics for us are: /liability/incoming - when a new liability is created, this topic publishes Ethereum address of the contract /liability/result - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead /liability/infochan/incoming/* - a CPS gets information about offer, demand or result from corresponding topics /liability/infochan/eth/signing/* - a CPS sends offer, demand or result messages to corresponding topics For the details check out the API page . Let's start with greetings - say hello to AIRA! You should just launch a pre-installed package hello_aira : $ rosrun hello_aira hello_aira We've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to dapp and press Order. Now go back to the console and see the result!","title":"Basic Usage"},{"location":"aira/connecting_via_ssh/","text":"Connecting via SSH It is more convenient to work with virtual machine via ssh connection. In this section we will configure VM. Attention It's required to have your ssh public key on Github.com In case you don't have one, please follow the link First, launch AIRA client and run a command replacing with your own: $ mkdir .ssh $ chmod 700 .ssh $ curl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys Now go to machine settings, network, open Advanced and then Port Forwarding Add a new rule: Host IP Host Port Guest IP Guest Port 127.0.1.1 2202 10.0.2.15 22 Reboot the machine and you are able to connect to AIRA client via ssh:: $ ssh -p 2202 root@127.0.1.1","title":"Connecting via SSH"},{"location":"aira/connecting_via_ssh/#connecting-via-ssh","text":"It is more convenient to work with virtual machine via ssh connection. In this section we will configure VM. Attention It's required to have your ssh public key on Github.com In case you don't have one, please follow the link First, launch AIRA client and run a command replacing with your own: $ mkdir .ssh $ chmod 700 .ssh $ curl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys Now go to machine settings, network, open Advanced and then Port Forwarding Add a new rule: Host IP Host Port Guest IP Guest Port 127.0.1.1 2202 10.0.2.15 22 Reboot the machine and you are able to connect to AIRA client via ssh:: $ ssh -p 2202 root@127.0.1.1","title":"Connecting via SSH"},{"location":"aira/contributing/","text":"Contributing Main Airalab repositories aira - AIRA client. robonomics_comm - Robonomics communication stack robonomics_contracts - smart contracts of Robonomics network Please choose a corresponding repository for reporting an issue! Found a bug? Make sure the bug was not already reported - check GitHub Issues . If there is no open issue addressing the problem, open a new one . Be sure to include a title and clear description , as much relevant information as possible. Also, you can open an issue if you have a proposal for improvements. Wrote a patch that fixes a bug? Open a new GitHub pull request with the patch. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable. Please don't fix whitespace, format code, or make a purely cosmetic patch Thanks!","title":"Contributing"},{"location":"aira/contributing/#contributing","text":"","title":"Contributing"},{"location":"aira/contributing/#main-airalab-repositories","text":"aira - AIRA client. robonomics_comm - Robonomics communication stack robonomics_contracts - smart contracts of Robonomics network Please choose a corresponding repository for reporting an issue!","title":"Main Airalab repositories"},{"location":"aira/contributing/#found-a-bug","text":"Make sure the bug was not already reported - check GitHub Issues . If there is no open issue addressing the problem, open a new one . Be sure to include a title and clear description , as much relevant information as possible. Also, you can open an issue if you have a proposal for improvements.","title":"Found a bug?"},{"location":"aira/contributing/#wrote-a-patch-that-fixes-a-bug","text":"Open a new GitHub pull request with the patch. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable. Please don't fix whitespace, format code, or make a purely cosmetic patch Thanks!","title":"Wrote a patch that fixes a bug?"},{"location":"aira/faq/","text":"Frequently Asked Questions How to see logs from main services? IPFS in real time: journalctl -u ipfs -f and Liability:: journalctl -u liability -f $$ How to check the quantity of IPFS peers? ipfs pubsub peers airalab.lighthouse.5.robonomics.eth IPFS can't connect to the daemon, what should I do? Try to specify --api option ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/","title":"FAQ"},{"location":"aira/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"aira/faq/#how-to-see-logs-from-main-services","text":"IPFS in real time: journalctl -u ipfs -f and Liability:: journalctl -u liability -f $$ How to check the quantity of IPFS peers? ipfs pubsub peers airalab.lighthouse.5.robonomics.eth","title":"How to see logs from main services?"},{"location":"aira/faq/#ipfs-cant-connect-to-the-daemon-what-should-i-do","text":"Try to specify --api option ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/","title":"IPFS can't connect to the daemon, what should I do?"},{"location":"aira/installation/","text":"Installation","title":"Installation"},{"location":"aira/installation/#installation","text":"","title":"Installation"},{"location":"aira/overview/","text":"Overview","title":"Overview"},{"location":"aira/overview/#overview","text":"","title":"Overview"},{"location":"cases/connect_sen0233_to_robonomics/","text":"Connect SEN0233 Sensor to Robonomics Network Robonomics allows you to build a peer-to-peer communication between you and a sensor. So it becomes possible to get data from your sensor all around the world. Those data is not stored in a blockchain but packed in rosbag format which is convenient to work with and transfered via IPFS network. At this page you'll find step-by-step instruction to connect SEN0233 sensor to Raspberry Pi 4 and make it publish data on demand. Requirements SEN0233 PM2.5 Sensor Adapter Raspberry Pi 4 SD Card >=16Gb 1. Prepare Raspberry Pi 4 1.1 Get the image The latest AIRA image can be found here wget https://aira.life/channels/aira-unstable/aira-image-rpi4-20.03pre-git-aarch64-linux.img 1.2 Write the image on to a SD card sudo dd if=aira-image-rpi4-20.03pre-git-aarch64-linux.img of=/dev/sda bs=4M status=progress sync 1.3 Boot with the SD card Plug in the SD card and connect a power supply to the board. Wait a couple of minutes. By default OS has root user with empty password. There are a few ways to log in. First - using UART-USB cable. Connect the cable as shown below: Black to 6th pin White to 8th pin (TXD) Green to 10th pin (RXD) Check the official documentation out. The connection is the same for Raspberry Pi 3 and 4. Then on your laptop run: screen /dev/ttyUSB 115200 And you should see something similar to: <<< Welcome to NixOS 20.03pre-git (aarch64) - ttyS0 >>> aira-rpi4 login: root (automatic login) Starting... _ ___ ____ _ / \\ |_ _| _ \\ / \\ / _ \\ | || |_) | / _ \\ / ___ \\ | || _ < / ___ \\ /_/ \\_\\___|_| \\_\\/_/ \\_\\ My Ethereum address is \"38411681740ca6214b448d49549bb1dfd0a0cffa\" Look me at https://status.robonomics.network by \"Qmdiiux3uQS8JyuPNa7Vj3iNe7UZBrpMPB2dEqUeo4YRGH\" Note Save somewhere your ethereum address generated by the OS. You'll need it later. By default sshd service is up and running. All you need to do is to add your SSH key: mkdir .ssh/ curl -sSL https://github.com/<USERNAME>.keys >> .ssh/authorized_keys It's recommended to add your SSH key to Github account help If you don't have a key attached to your github account then simply put the content of your ~/.ssh/id_rsa.pub file to /root/.ssh/authorized_keys file on the SD card. Another way to put the key is to unplug the SD card, plug it in a laptop and do above steps manually. After that you should be able to connect to the board via SSH: ssh root@<RASPBERRY_PI_ADDRESS> 1.4. Remove blocking parameters You'll attach the sensor to GPIO pins which are currently are configured for UART connection. Open /boot/cmdline.txt and remove everything related to console . In the end it must look like: cma=256M loglevel=7 init=/nix/store/nlh5fcbb1cj36kn0m2pfvqs7w6dd127w-nixos-system-aira-rpi4-20.03pre197163.0c9d9518676/init Reboot reboot 2. Connect SEN0233 Connect the sensor as shown below: 3. Run the Agent The agent must be run under liability user su liability cd Now clone the repository and build the agent: git clone https://github.com/Vourhey/sen0233_sensor_agent/ cd sen0233_sensor_agent nix build -f release.nix Run the agent: source result/setup.bash roslaunch sensors_pack_agent agent.launch 4. Test To test everything works as expected go to the Dapp: https://dapp.robonomics.network/#/sensors/airalab/QmWjvXGfVUDBNR15BBH5ERGP3SzEKbeLZWx7Fcp4kwwaw9/0x<YOUR_ETHEREUM_ADDRESS>/ where <YOUR_ETHEREUM_ADDRESS> is the address generated by OS on step 1.3. To find out the address again you can run: rosservice call /eth/accounts .row { display: flex; } .column { flex: 50%; padding: 5px; }","title":"Connect SEN0233 Sensor to Robonomics"},{"location":"cases/connect_sen0233_to_robonomics/#connect-sen0233-sensor-to-robonomics-network","text":"Robonomics allows you to build a peer-to-peer communication between you and a sensor. So it becomes possible to get data from your sensor all around the world. Those data is not stored in a blockchain but packed in rosbag format which is convenient to work with and transfered via IPFS network. At this page you'll find step-by-step instruction to connect SEN0233 sensor to Raspberry Pi 4 and make it publish data on demand.","title":"Connect SEN0233 Sensor to Robonomics Network"},{"location":"cases/connect_sen0233_to_robonomics/#requirements","text":"SEN0233 PM2.5 Sensor Adapter Raspberry Pi 4 SD Card >=16Gb","title":"Requirements"},{"location":"cases/connect_sen0233_to_robonomics/#1-prepare-raspberry-pi-4","text":"","title":"1. Prepare Raspberry Pi 4"},{"location":"cases/connect_sen0233_to_robonomics/#11-get-the-image","text":"The latest AIRA image can be found here wget https://aira.life/channels/aira-unstable/aira-image-rpi4-20.03pre-git-aarch64-linux.img","title":"1.1 Get the image"},{"location":"cases/connect_sen0233_to_robonomics/#12-write-the-image-on-to-a-sd-card","text":"sudo dd if=aira-image-rpi4-20.03pre-git-aarch64-linux.img of=/dev/sda bs=4M status=progress sync","title":"1.2 Write the image on to a SD card"},{"location":"cases/connect_sen0233_to_robonomics/#13-boot-with-the-sd-card","text":"Plug in the SD card and connect a power supply to the board. Wait a couple of minutes. By default OS has root user with empty password. There are a few ways to log in. First - using UART-USB cable. Connect the cable as shown below: Black to 6th pin White to 8th pin (TXD) Green to 10th pin (RXD) Check the official documentation out. The connection is the same for Raspberry Pi 3 and 4. Then on your laptop run: screen /dev/ttyUSB 115200 And you should see something similar to: <<< Welcome to NixOS 20.03pre-git (aarch64) - ttyS0 >>> aira-rpi4 login: root (automatic login) Starting... _ ___ ____ _ / \\ |_ _| _ \\ / \\ / _ \\ | || |_) | / _ \\ / ___ \\ | || _ < / ___ \\ /_/ \\_\\___|_| \\_\\/_/ \\_\\ My Ethereum address is \"38411681740ca6214b448d49549bb1dfd0a0cffa\" Look me at https://status.robonomics.network by \"Qmdiiux3uQS8JyuPNa7Vj3iNe7UZBrpMPB2dEqUeo4YRGH\" Note Save somewhere your ethereum address generated by the OS. You'll need it later. By default sshd service is up and running. All you need to do is to add your SSH key: mkdir .ssh/ curl -sSL https://github.com/<USERNAME>.keys >> .ssh/authorized_keys It's recommended to add your SSH key to Github account help If you don't have a key attached to your github account then simply put the content of your ~/.ssh/id_rsa.pub file to /root/.ssh/authorized_keys file on the SD card. Another way to put the key is to unplug the SD card, plug it in a laptop and do above steps manually. After that you should be able to connect to the board via SSH: ssh root@<RASPBERRY_PI_ADDRESS>","title":"1.3 Boot with the SD card"},{"location":"cases/connect_sen0233_to_robonomics/#14-remove-blocking-parameters","text":"You'll attach the sensor to GPIO pins which are currently are configured for UART connection. Open /boot/cmdline.txt and remove everything related to console . In the end it must look like: cma=256M loglevel=7 init=/nix/store/nlh5fcbb1cj36kn0m2pfvqs7w6dd127w-nixos-system-aira-rpi4-20.03pre197163.0c9d9518676/init Reboot reboot","title":"1.4. Remove blocking parameters"},{"location":"cases/connect_sen0233_to_robonomics/#2-connect-sen0233","text":"Connect the sensor as shown below:","title":"2. Connect SEN0233"},{"location":"cases/connect_sen0233_to_robonomics/#3-run-the-agent","text":"The agent must be run under liability user su liability cd Now clone the repository and build the agent: git clone https://github.com/Vourhey/sen0233_sensor_agent/ cd sen0233_sensor_agent nix build -f release.nix Run the agent: source result/setup.bash roslaunch sensors_pack_agent agent.launch","title":"3. Run the Agent"},{"location":"cases/connect_sen0233_to_robonomics/#4-test","text":"To test everything works as expected go to the Dapp: https://dapp.robonomics.network/#/sensors/airalab/QmWjvXGfVUDBNR15BBH5ERGP3SzEKbeLZWx7Fcp4kwwaw9/0x<YOUR_ETHEREUM_ADDRESS>/ where <YOUR_ETHEREUM_ADDRESS> is the address generated by OS on step 1.3. To find out the address again you can run: rosservice call /eth/accounts .row { display: flex; } .column { flex: 50%; padding: 5px; }","title":"4. Test"},{"location":"robonomics-js/beginning/","text":"Introduction Robonomics-js is a simple Javascript library for working with Robonomics network Installation npm install robonomics-js --save or yarn add robonomics-js CDN <script src=\"https://cdn.jsdelivr.net/npm/robonomics-js/dist/robonomics.min.js\"></script> Dependencies Web3 Ipfs Initialization import Robonomics, { MessageProviderIpfsApi } from 'robonomics-js' import IPFS from 'ipfs-api' const robonomics = new Robonomics({ provider: new MessageProviderIpfsApi(new IPFS('http://localhost:5001')) }) robonomics.ready().then(() => { console.log('robonomics js ready') console.log('xrt', robonomics.xrt.address) console.log('factory', robonomics.factory.address) console.log('lighthouse default', robonomics.lighthouse.address) }) Available arguments web3 - isn't necessary if Metamask is available account - isn't necessary if Metamask is available privateKey - optional provider - IPFS HTTP API version - the latest by default ens - ENS address, 0x314159265dD8dbb310642f98f50C066173C1259b by default lighthouse - a lighthouse name in ENS, airalab.lighthouse.5.robonomics.eth by default","title":"Introduction"},{"location":"robonomics-js/beginning/#introduction","text":"Robonomics-js is a simple Javascript library for working with Robonomics network","title":"Introduction"},{"location":"robonomics-js/beginning/#installation","text":"npm install robonomics-js --save or yarn add robonomics-js CDN <script src=\"https://cdn.jsdelivr.net/npm/robonomics-js/dist/robonomics.min.js\"></script>","title":"Installation"},{"location":"robonomics-js/beginning/#dependencies","text":"Web3 Ipfs","title":"Dependencies"},{"location":"robonomics-js/beginning/#initialization","text":"import Robonomics, { MessageProviderIpfsApi } from 'robonomics-js' import IPFS from 'ipfs-api' const robonomics = new Robonomics({ provider: new MessageProviderIpfsApi(new IPFS('http://localhost:5001')) }) robonomics.ready().then(() => { console.log('robonomics js ready') console.log('xrt', robonomics.xrt.address) console.log('factory', robonomics.factory.address) console.log('lighthouse default', robonomics.lighthouse.address) })","title":"Initialization"},{"location":"robonomics-js/beginning/#available-arguments","text":"web3 - isn't necessary if Metamask is available account - isn't necessary if Metamask is available privateKey - optional provider - IPFS HTTP API version - the latest by default ens - ENS address, 0x314159265dD8dbb310642f98f50C066173C1259b by default lighthouse - a lighthouse name in ENS, airalab.lighthouse.5.robonomics.eth by default","title":"Available arguments"},{"location":"robonomics-js/creating_dapp/","text":"Creating Dapp Almost every project needs a user interface to interact with. A user should not type in a Demand message. In Airalab repository there's a convenient template for a Dapp. In this section you are going to learn how to get a new Dapp for your CPS. Note The source code is here To get a template you don't even have to clone the repo. Instead do these steps: $ npm install -g vue-cli $ vue init airalab/vue-dapp-robonomics-template my-project $ cd my-project $ npm install $ npm run dev After the last step a webserver has started on http://localhost:8000/ . But before you open this link in a browser you should configure the Dapp. Note MetaMask is required for the Dapp Here is a configuration file below. You have to specify a LIGHTHOUSE you work on, your CPS MODEL and OBJECTIVE . Also the Dapp uses IPFS message broker. You can either set up your own broker or use existing one, for example https://wss.pool.aira.life . export const NETWORK = 1 export const LIGHTHOUSE = 'airalab.lighthouse.3.robonomics.eth' export const MODEL = 'QmdFh1HPVe7H4LrDio899mxA7NindgxqiNUM9BNnBD7ryS' export const OBJECTIVE = 'QmbSW1E73DKUvGDrgx8GirEVfHJLvj8RBijtH9iEZ7UecU' export const IPFS_PUBSUB = 'http://127.0.0.1:9999' export const ENS = '' export const VERSION = 1 After editing the file, launch the Dapp $ npm run dev Check the source code out to get familiar with the structure of the template. Good luck!","title":"Creating Dapp"},{"location":"robonomics-js/creating_dapp/#creating-dapp","text":"Almost every project needs a user interface to interact with. A user should not type in a Demand message. In Airalab repository there's a convenient template for a Dapp. In this section you are going to learn how to get a new Dapp for your CPS. Note The source code is here To get a template you don't even have to clone the repo. Instead do these steps: $ npm install -g vue-cli $ vue init airalab/vue-dapp-robonomics-template my-project $ cd my-project $ npm install $ npm run dev After the last step a webserver has started on http://localhost:8000/ . But before you open this link in a browser you should configure the Dapp. Note MetaMask is required for the Dapp Here is a configuration file below. You have to specify a LIGHTHOUSE you work on, your CPS MODEL and OBJECTIVE . Also the Dapp uses IPFS message broker. You can either set up your own broker or use existing one, for example https://wss.pool.aira.life . export const NETWORK = 1 export const LIGHTHOUSE = 'airalab.lighthouse.3.robonomics.eth' export const MODEL = 'QmdFh1HPVe7H4LrDio899mxA7NindgxqiNUM9BNnBD7ryS' export const OBJECTIVE = 'QmbSW1E73DKUvGDrgx8GirEVfHJLvj8RBijtH9iEZ7UecU' export const IPFS_PUBSUB = 'http://127.0.0.1:9999' export const ENS = '' export const VERSION = 1 After editing the file, launch the Dapp $ npm run dev Check the source code out to get familiar with the structure of the template. Good luck!","title":"Creating Dapp"},{"location":"robonomics-js/howto/","text":"How to How to create a demand? Listen to a demand with a specific model: const model = 'QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg' robonomics.getAsk(model, (msg) => { console.log(msg) }) const ask = { objective: 'QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M', token: robonomics.xrt.address, cost: 1, deadline: 9999999 } Fields: objective - IPFS hash to a rosbag file with a task token - token address cost - cost validator - validator address validatorFee - validator fee deadline - block number It's necessary to make an approve: robonomics.xrt.send('approve', [robonomics.factory.address, ask.cost], { from: robonomics.account }).then((tx) => console.log(tx)) In case of other token: import { Token } from 'robonomics-js' const token = new Token(robonomics.web3, '0x1231321321321321321321321') token.send('approve', [robonomics.factory.address, ask.cost], { from: robonomics.account }) .then((tx) => console.log(tx)) And send a demand message: robonomics.postAsk(market, ask) .then((liability) => { console.log('liability', liability.address) liability.watchResult((result) => { console.log('liability result', result) }) return liability.getInfo() }) .then((info) => { console.log('liability info', info) }) How to get an offer? Obtain all the messages by a given model: const model = 'QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg' robonomics.getBid(model, (msg) => { console.log(msg) }) Fields: objective - IPFS hash to a rosbag file with a task token - token address cost - cost lighthouseFee - lighthouse fee deadline - block number How to listen to a result? Obtain all the messages by a given model: robonomics.getResult((msg) => { console.log(msg) }) Note It's not a verified result. A verified result could be obtained from a liability contract. How to create a lighthouse? const minimalFreeze = 1000 // Wn const timeout = 25 // blocks const name = 'mylighthouse' // \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0430\u044f\u043a\u0430 robonomics.factory.send('createLighthouse', [minimalFreeze, timeout, name], { from: robonomics.account }) .then((tx) => console.log(tx)) robonomics.factory.watchLighthouse((lighthouse) => { console.log(lighthouse.name) }) How to become a provider? const name = 'mylighthouse' // \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0430\u044f\u043a\u0430 const stake = 1000 // Wn robonomics.setLighthouse(name) robonomics.xrt.send('approve', [robonomics.lighthouse.address, stake], { from: robonomics.account }) .then((tx) => console.log(tx)) robonomics.lighthouse.send('refill', [stake], { from: robonomics.account }) .then((tx) => console.log(tx)) How to change a lighthouse? robonomics.setLighthouse(name) How to check the balance? robonomics.xrt.call('balanceOf', [robonomics.account]) .then((balance) => console.log('balance', balance)) How to check the allowance? robonomics.xrt.call('allowance', [robonomics.account, robonomics.factory.address]) .then((allowance) => console.log('allowance', allowance))","title":"How to"},{"location":"robonomics-js/howto/#how-to","text":"","title":"How to"},{"location":"robonomics-js/howto/#how-to-create-a-demand","text":"Listen to a demand with a specific model: const model = 'QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg' robonomics.getAsk(model, (msg) => { console.log(msg) }) const ask = { objective: 'QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M', token: robonomics.xrt.address, cost: 1, deadline: 9999999 } Fields: objective - IPFS hash to a rosbag file with a task token - token address cost - cost validator - validator address validatorFee - validator fee deadline - block number It's necessary to make an approve: robonomics.xrt.send('approve', [robonomics.factory.address, ask.cost], { from: robonomics.account }).then((tx) => console.log(tx)) In case of other token: import { Token } from 'robonomics-js' const token = new Token(robonomics.web3, '0x1231321321321321321321321') token.send('approve', [robonomics.factory.address, ask.cost], { from: robonomics.account }) .then((tx) => console.log(tx)) And send a demand message: robonomics.postAsk(market, ask) .then((liability) => { console.log('liability', liability.address) liability.watchResult((result) => { console.log('liability result', result) }) return liability.getInfo() }) .then((info) => { console.log('liability info', info) })","title":"How to create a demand?"},{"location":"robonomics-js/howto/#how-to-get-an-offer","text":"Obtain all the messages by a given model: const model = 'QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg' robonomics.getBid(model, (msg) => { console.log(msg) }) Fields: objective - IPFS hash to a rosbag file with a task token - token address cost - cost lighthouseFee - lighthouse fee deadline - block number","title":"How to get an offer?"},{"location":"robonomics-js/howto/#how-to-listen-to-a-result","text":"Obtain all the messages by a given model: robonomics.getResult((msg) => { console.log(msg) }) Note It's not a verified result. A verified result could be obtained from a liability contract.","title":"How to listen to a result?"},{"location":"robonomics-js/howto/#how-to-create-a-lighthouse","text":"const minimalFreeze = 1000 // Wn const timeout = 25 // blocks const name = 'mylighthouse' // \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0430\u044f\u043a\u0430 robonomics.factory.send('createLighthouse', [minimalFreeze, timeout, name], { from: robonomics.account }) .then((tx) => console.log(tx)) robonomics.factory.watchLighthouse((lighthouse) => { console.log(lighthouse.name) })","title":"How to create a lighthouse?"},{"location":"robonomics-js/howto/#how-to-become-a-provider","text":"const name = 'mylighthouse' // \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0430\u044f\u043a\u0430 const stake = 1000 // Wn robonomics.setLighthouse(name) robonomics.xrt.send('approve', [robonomics.lighthouse.address, stake], { from: robonomics.account }) .then((tx) => console.log(tx)) robonomics.lighthouse.send('refill', [stake], { from: robonomics.account }) .then((tx) => console.log(tx))","title":"How to become a provider?"},{"location":"robonomics-js/howto/#how-to-change-a-lighthouse","text":"robonomics.setLighthouse(name)","title":"How to change a lighthouse?"},{"location":"robonomics-js/howto/#how-to-check-the-balance","text":"robonomics.xrt.call('balanceOf', [robonomics.account]) .then((balance) => console.log('balance', balance))","title":"How to check the balance?"},{"location":"robonomics-js/howto/#how-to-check-the-allowance","text":"robonomics.xrt.call('allowance', [robonomics.account, robonomics.factory.address]) .then((allowance) => console.log('allowance', allowance))","title":"How to check the allowance?"},{"location":"try_it_out/get_open_data_from_sensor/","text":"Get Open Data from Sensor Let's start from a quick example of what Robonomics is able to do within 5 minutes. Requirements: Metamask extension Open sensor demo website and follow instructions below 1. Open the Dapp You see the next picture in case you don't have MetaMask extension. Go to the link provided above and install one 2. Allow connection to the extension 3. Press \"Request current values\" 4. Sign a message. No token or ether are needed 5. Wait until the agent collects the data and sends it back 6. Wait until the Dapp downloads the result file from IPFS 7. Look at the data Just now you have broadcasted a demand message and got a result from an autonomous agent! The result file is stored in IPFS, the result message is signed with the agent's private key. .center { display: block; margin-left: auto; margin-right: auto; } .half { transform: scale(0.5); }","title":"Get Open Data from Sensor"},{"location":"try_it_out/get_open_data_from_sensor/#get-open-data-from-sensor","text":"Let's start from a quick example of what Robonomics is able to do within 5 minutes. Requirements: Metamask extension Open sensor demo website and follow instructions below","title":"Get Open Data from Sensor"},{"location":"try_it_out/get_open_data_from_sensor/#1-open-the-dapp","text":"You see the next picture in case you don't have MetaMask extension. Go to the link provided above and install one","title":"1. Open the Dapp"},{"location":"try_it_out/get_open_data_from_sensor/#2-allow-connection-to-the-extension","text":"","title":"2. Allow connection to the extension"},{"location":"try_it_out/get_open_data_from_sensor/#3-press-request-current-values","text":"","title":"3. Press \"Request current values\""},{"location":"try_it_out/get_open_data_from_sensor/#4-sign-a-message-no-token-or-ether-are-needed","text":"","title":"4. Sign a message. No token or ether are needed"},{"location":"try_it_out/get_open_data_from_sensor/#5-wait-until-the-agent-collects-the-data-and-sends-it-back","text":"","title":"5. Wait until the agent collects the data and sends it back"},{"location":"try_it_out/get_open_data_from_sensor/#6-wait-until-the-dapp-downloads-the-result-file-from-ipfs","text":"","title":"6. Wait until the Dapp downloads the result file from IPFS"},{"location":"try_it_out/get_open_data_from_sensor/#7-look-at-the-data","text":"Just now you have broadcasted a demand message and got a result from an autonomous agent! The result file is stored in IPFS, the result message is signed with the agent's private key. .center { display: block; margin-left: auto; margin-right: auto; } .half { transform: scale(0.5); }","title":"7. Look at the data"}]}