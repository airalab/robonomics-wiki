{"hash":"6aecd251eafd09e46c3628f8c5f662af95c38fd7","data":{"doc":{"id":"ecd3bb67f6bd0a89db828bb9c97e87be","title":"Lesson 6.1, Build IoT Dapps For End Users","description":"","contributors":["vol4tim"],"translated":false,"headings":[],"subtitles":[{"depth":2,"value":"Getting ready","anchor":"#getting-ready"},{"depth":3,"value":"Robonomics node launch","anchor":"#robonomics-node-launch"},{"depth":3,"value":"Browser extension","anchor":"#browser-extension"},{"depth":2,"value":"DApp development","anchor":"#dapp-development"},{"depth":3,"value":"Step 1","anchor":"#step-1"},{"depth":3,"value":"Step 2. Getting started with polkadot.js","anchor":"#step-2-getting-started-with-polkadotjs"},{"depth":4,"value":"Installing dependencies","anchor":"#installing-dependencies"},{"depth":4,"value":"Connecting to Robonomics","anchor":"#connecting-to-robonomics"},{"depth":3,"value":"Step 3. Vue connecting component","anchor":"#step-3-vue-connecting-component"},{"depth":4,"value":"Connecting","anchor":"#connecting"},{"depth":4,"value":"Account with balance","anchor":"#account-with-balance"},{"depth":3,"value":"Step 4. Datalog","anchor":"#step-4-datalog"},{"depth":3,"value":"Step 5. Launch","anchor":"#step-5-launch"},{"depth":3,"value":"Step 6. Demo","anchor":"#step-6-demo"}],"content":"\n## Getting ready\n\n### Robonomics node launch\n\nFor dApp development and testing, we will use a local Robonomics node. To do this, you need to download the compiled binary file v0.24 from https://github.com/airalab/robonomics/releases. I will be using Ubuntu, so I download the appropriate version.\n\nUnpack the archive\n```sh\nwget https://github.com/airalab/robonomics/releases/download/v0.24.0/robonomics-ubuntu-0.24.0-x86_64.tar.xz\ntar -xvf robonomics-ubuntu-0.24.0-x86_64.tar.xz\nchmod +x robonomics\n```\n\nNow we can start the node in development mode. To do this, use the --dev flag\n```sh\n./robonomics --dev --tmp\n```\n\n> Troubleshooting\n```sh\n./robonomics purge-chain --dev\n```\n\n### Browser extension\n\nTo store keys in a browser, there is a `polkadot{.js} extension`. In dApp we will use it to sign transactions.\n\nThe extension is currently available for `Google chrome` and `Firefox` https://polkadot.js.org/extension/\n\nAfter installing the extension, create a new account.\n![screen1](../images/build-iot-dapps/screen1.png)\n\n> The first step is completed.\n\n## DApp development\n\n### Step 1\n\n> We will write the dApp using the vue.js framework, although you can use whatever you like/can.\n\nLet's start developing the dApp by creating a startup application with vue.js And here you can do it in two ways.\n\nWay 1:\n\nUsing the `Vue cli` console utility.\nTo do this, you need to install [it](https://cli.vuejs.org/guide/installation.html\nAlso we will need `yarn`. Install it from [here](https://yarnpkg.com)\n\nAfter installation, you can run the command in the terminal\n\n```sh\nvue create mydapp\n```\n\nAnswer a few questions of the setup wizard. We will be using version Vue 2, so we keep the default version `Default ([Vue 2] babel, eslint)`.\n\nWay 2:\n\nClone the prepared git repository with the example and switch to step 1\n\n```sh\ngit clone https://github.com/airalab/example-robonomics-dapp.git mydapp\ncd mydapp\ngit checkout step-1\n```\n\nAs a result, we will get a directory with the installed startup application, which can already be launched and opened in the browser.\n\n```sh\nyarn\nyarn serve\n```\n\n### Step 2. Getting started with polkadot.js\n\n#### Installing dependencies\n\nTo connect the dApp to the Robonomics chain, there is the `@polkadot/api` library. And for interaction of dApp with an extension with keys, we have the `@polkadot/extension-dapp` library. We need to install them into our application.\nMore details on using this library can be found in the documentation https://polkadot.js.org/docs/.\n\nWay 1:\n\n```sh\nyarn add @polkadot/api @polkadot/extension-dapp\n```\n\nYou also need to add the `vue.config.js` file to support `mjs` extension.\n\n`vue.config.js`\n```js\nmodule.exports = {\n  publicPath: \"\",\n  configureWebpack: {\n    resolve: {\n      extensions: [\"*\", \".mjs\", \".js\", \".vue\", \".json\", \".gql\", \".graphql\"]\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.mjs$/,\n          include: /node_modules/,\n          type: \"javascript/auto\"\n        }\n      ]\n    }\n  }\n};\n```\n\n#### Connecting to Robonomics\n\nFirst, let's create a configuration file with the parameters for connecting to the Robonomics node. In the demo repository, there is an example of this file `config.template.json`.\n\n`src/config.json`\n```json\n{\n  \"endpoint\": \"ws://localhost:9944\",\n  \"types\": {\n    \"Record\": \"Vec<u8>\",\n    \"Parameter\": \"Bool\",\n    \"Address\": \"AccountId\",\n    \"LookupSource\": \"AccountId\"\n  }\n}\n```\n\nIn this file, we indicate the node, which we are going to connect to, and custom types.\n\nNow we need to write a script to connect to our running node.\n\n`src/utils/api.js`\n```js\nimport { ApiPromise, WsProvider } from \"@polkadot/api\";\nimport config from \"../config.json\";\n\nlet api;\nexport async function initApi() {\n  const provider = new WsProvider(config.endpoint);\n  api = await ApiPromise.create({\n    provider,\n    types: config.types\n  });\n  return api;\n}\n\nexport function getApi() {\n  return api;\n}\n```\n\nSo that we can sign transactions with the key from the extension, let’s add two functions for connecting to the extension and the function for initializing the account.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport {\n  web3Accounts,\n  web3Enable,\n  web3FromAddress\n} from \"@polkadot/extension-dapp\";\n\nasync function getExtension() {\n  const extensions = await web3Enable(\"demo\");\n  if (extensions.length === 0) throw new Error(\"no extension\");\n  return extensions[0];\n}\n\nexport async function initAccount(index = 0) {\n  const timeout = new Promise(resolve => {\n    setTimeout(resolve, 300);\n  });\n  await timeout;\n  await getExtension();\n  const accounts = await web3Accounts();\n  if (accounts.length > 0) {\n    const injector = await web3FromAddress(accounts[index].address);\n    api.setSigner(injector.signer);\n    return accounts[index].address;\n  }\n  throw new Error(\"no accounts\");\n}\n\n...OTHER_CODE...\n```\n\nOur account will have a zero balance, while we need a little funds. So we need to create another faucet function. As we launched Robonomics with the `--dev` flag, we have `Alice` account with a large balance, so we will request funds from there.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport { Keyring } from \"@polkadot/keyring\";\n\nexport function getBalance(account, cb) {\n  api.query.system.account(account, ({ data: { free: currentFree } }) => {\n    cb(currentFree);\n  });\n}\n\nexport const keyring = new Keyring({ type: \"sr25519\" });\n\nexport async function faucet(address) {\n  keyring.setSS58Format(api.registry.chainSS58);\n  const account = keyring.addFromUri(\"//Alice\");\n  const tx = api.tx.balances.transfer(address, 1000000000000000);\n  await tx.signAndSend(account);\n}\n\n...OTHER_CODE...\n```\n\nThe full version of script https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/api.js\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then in order to complete these steps, it will be enough to switch to step 2 and install the rest of the dependencies.\n\n```sh\ngit checkout step-2\ncp src/config.template.json src/config.json\nyarn\nyarn serve\n```\n\n### Step 3. Vue connecting component\n\n#### Connecting\n\nWe have already written a script for connecting. Now we can use it on our interface. It is enough to call the written `initApi` function in  the root component `App.vue`. And while the user is waiting for a connection, we will show him a small loader, for now in the form of an ellipsis.\n\nWay 1:\n\nComponent template and base styles.\n\n`src/App.vue`\n```js\n<template>\n  <div id=\"app\">\n    <h1>Robonomics dApp</h1>\n    <div v-if=\"load\">...</div>\n    <template v-else>\n      <div v-if=\"error\" class=\"error\">{{ error }}</div>\n      <template v-else-if=\"api\">\n        connected\n      </template>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\nbutton {\n  font-size: 14px;\n  padding: 5px 12px;\n}\nbutton:hover {\n  cursor: pointer;\n}\ninput {\n  font-size: 14px;\n  padding: 5px;\n}\nselect {\n  font-size: 14px;\n  padding: 5px;\n}\nbutton:focus,\ninput:focus {\n  outline: none;\n}\n.error {\n  color: rgb(151, 31, 31);\n  font-weight: bold;\n  text-align: center;\n  margin: 10px 0;\n}\n</style>\n```\n\nThere is the component code where the  `initApi` function will be called\n\n`src/App.vue`\n```js\n<script>\nimport { initApi } from \"./utils/api\";\n\nexport default {\n  name: \"App\",\n  data() {\n    return {\n      load: false,\n      api: null,\n      error: null\n    };\n  },\n  created() {\n    this.init();\n  },\n  methods: {\n    async init() {\n      try {\n        this.load = true;\n        this.api = await initApi();\n        this.load = false;\n      } catch (error) {\n        this.error = error.message;\n        this.load = false;\n      }\n    }\n  }\n};\n</script>\n```\n\n#### Account with balance\n\nNow we can use our account, top up its balance and show it on the interface.\n\nLet’s add the appropriate markup to the template\n\n`src/App.vue`\n```js\n<template>\n\n  ...OTHER_CODE...\n\n    <template v-else>\n      <div v-if=\"error\" class=\"error\">{{ error }}</div>\n      <template v-else-if=\"api && account\">\n        <p>\n          Account: <b>{{ account }}</b> {{ balance }} |\n          <button @click=\"faucet\">\n            faucet\n          </button>\n        </p>\n      </template>\n    </template>\n\n  ...OTHER_CODE...\n\n</template>\n```\n\nLet’s add new fields for account address and balance\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\ndata() {\n  return {\n\n    ...OTHER_CODE...\n\n    account: null,\n    balance: 0,\n\n    ...OTHER_CODE...\n\n  };\n}\n\n...OTHER_CODE...\n```\n\nWe need to add the account initialization to the `init` function and get its balance\n\n`src/App.vue`\n```js\n<script>\nimport { initApi, initAccount, getBalance, faucet } from \"./utils/api\";\nimport { formatBalance } from \"@polkadot/util\";\n\n...OTHER_CODE...\n\nasync init() {\n\n  ...OTHER_CODE...\n\n  this.api = await initApi();\n  this.account = await initAccount();\n  getBalance(this.account, balance => {\n    this.balance = formatBalance(balance);\n  });\n\n  ...OTHER_CODE...\n\n}\n\n...OTHER_CODE...\n</script>\n```\n\nIt remains to add the function of replenishing the balance, when clicking on the button\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\n  methods: {\n    faucet() {\n      faucet(this.account);\n    },\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/step-3/src/App.vue\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 3.\n\n```sh\ngit checkout step-3\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen2](../images/build-iot-dapps/screen2.png)\n\n### Step 4. Datalog\n\nTo save and read any data in the chain, we use the `datalog` module.\n\nFor an example of how to use this module, let's make a `Datalog.vue` component.\n\nWay 1:\n\nIn the markup, we will have a button for reading data `read` with a block, where we will display a list in the form of a date and the data itself. And there will be a form with a text input, into which you can enter any data in the form of a string, and a `write` button.\n\n`src/components/Datalog.vue`\n```js\n<template>\n  <div>\n    <h2>Datalog</h2>\n    <button @click=\"read\">read</button> |\n    <input v-model=\"data\" :disabled=\"isWrite\" />\n    <button @click=\"write\" :disabled=\"isWrite\">write</button>\n    <div v-if=\"error\" class=\"error\">{{ error }}</div>\n    <div v-if=\"log\" class=\"log\">\n      <p v-if=\"log.length === 0\" class=\"error\">Not found</p>\n      <div v-for=\"(item, k) in log\" :key=\"k\" class=\"row\">\n        date: <b>{{ item[0] | dateFormat }}</b>\n        <br />\n        data: <b>{{ item[1] | dataFormat }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nComponent code. Here the main point in sending a transaction is to call the function, into which we transfer data and which we sign with our account, via api `this.api.tx.datalog.record(stringToHex(this.data)).signAsync(this.account);`\n\n`src/components/Datalog.vue`\n```js\n<script>\nimport { stringToHex, u8aToString } from \"@polkadot/util\";\n\nexport default {\n  props: [\"api\", \"account\"],\n  data() {\n    return {\n      data: \"data string\",\n      log: null,\n      isWrite: false,\n      error: \"\"\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return u8aToString(v);\n    }\n  },\n  methods: {\n    async read() {\n      this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n    },\n    async write() {\n      try {\n        this.error = \"\";\n        this.isWrite = true;\n        const tx = await this.api.tx.datalog\n          .record(stringToHex(this.data))\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.read();\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n</script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Datalog.vue\n\nTo switch between components, added to `App.vue` the output of our component\n\n`src/App.vue`\n```js\n...OTHER_CODE...\n\n<template v-else-if=\"api && account\">\n  <p>\n    Account: <b>{{ account }}</b> {{ balance }} |\n    <button @click=\"faucet\">faucet</button>\n  </p>\n\n  <div>\n    <div class=\"tabs\">\n      <button\n        @click=\"tab = 'datalog'\"\n        :class=\"{ active: tab === 'datalog' }\"\n      >\n        datalog\n      </button>\n    </div>\n    <Datalog v-if=\"tab === 'datalog'\" :api=\"api\" :account=\"account\" />\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from \"./components/Datalog\";\n\n...OTHER_CODE...\n\nexport default {\n  name: \"App\",\n  components: {\n    Datalog\n  },\n  data() {\n    return {\n      tab: \"datalog\"\n\n...OTHER_CODE...\n</script>\n\n<style>\n...OTHER_CODE...\n\n.tabs button {\n  font-size: 14px;\n  padding: 10px 20px;\n  font-weight: bold;\n  background: #ececec;\n  border: 1px solid #aaa;\n}\n.tabs button:hover {\n  background: #bfbfbf;\n}\n.tabs button:last-child {\n  border-left: none;\n}\n.tabs button.active {\n  background: #ced5e2;\n}\n</style>\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 4.\n\n```sh\ngit checkout step-4\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen3](../images/build-iot-dapps/screen3.png)\n\n### Step 5. Launch\n\nThis function is used to start and stop the robot. To demonstrate how to use this module, let's write the `Launch.vue` component.\n\nWay 1:\n\nIn the component template, we will have a form where you can specify the address of the robot, the ON/OFF clicker and the button for sending.\n\n`src/components/Launch.vue`\n```js\n<template>\n  <div>\n    <h2>Launch</h2>\n    <input v-model=\"robot\" :disabled=\"isWrite\" placeholder=\"Robot address\" />\n    <select v-model=\"parameter\" :disabled=\"isWrite\">\n      <option value=\"ON\">ON</option>\n      <option value=\"OFF\">OFF</option>\n    </select>\n    <button @click=\"launch\" :disabled=\"isWrite\">launch</button>\n    <div v-if=\"error\" class=\"error\">{{ error }}</div>\n    <div v-if=\"log.length > 0\" class=\"log\">\n      <div v-for=\"(item, k) in log\" :key=\"k\" class=\"row\">\n        sender: <b>{{ item.sender }}</b>\n        <br />\n        robot: <b>{{ item.robot }}</b>\n        <br />\n        parameter: <b>{{ item.parameter ? \"ON\" : \"OFF\" }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nThe code looks like the `Datalog.vue` component. The difference is just in reading. The robot will receive the command through events.\n\n`src/components/Launch.vue`\n```js\n<script>\nexport default {\n  props: [\"api\", \"account\"],\n  data() {\n    return {\n      robot: this.account,\n      parameter: \"ON\",\n      log: [],\n      isWrite: false,\n      error: \"\",\n      unsubscribe: null\n    };\n  },\n  async created() {\n    this.unsubscribe = await this.api.query.system.events(events => {\n      events.forEach(record => {\n        const { event } = record;\n        if (event.section === \"launch\" && event.method === \"NewLaunch\") {\n          const sender = event.data[0].toString();\n          const robot = event.data[1].toString();\n          const parameter = event.data[2].toHuman();\n          this.log.push({\n            sender,\n            robot,\n            parameter\n          });\n        }\n      });\n    });\n  },\n  destroyed() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  },\n  methods: {\n    async launch() {\n      try {\n        this.error = \"\";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === \"ON\")\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n</script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Launch.vue\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n...OTHER_CODE...\n\n  <div>\n    <div class=\"tabs\">\n      <button\n        @click=\"tab = 'datalog'\"\n        :class=\"{ active: tab === 'datalog' }\"\n      >\n        datalog\n      </button>\n      <button\n        @click=\"tab = 'launch'\"\n        :class=\"{ active: tab === 'launch' }\"\n      >\n        launch\n      </button>\n    </div>\n    <Datalog v-if=\"tab === 'datalog'\" :api=\"api\" :account=\"account\" />\n    <Launch v-if=\"tab === 'launch'\" :api=\"api\" :account=\"account\" />\n  </div>\n\n...OTHER_CODE...\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from \"./components/Datalog\";\nimport Launch from \"./components/Launch\";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 5.\n\n```sh\ngit checkout step-5\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen4](../images/build-iot-dapps/screen4.png)\n\n### Step 6. Demo\n\nIn this demo, we will have a car that can be started and stopped through the dApp. The car collects a log during the trip, and after stopping, saves it to the chain. Here we will use both modules, which we tried separately, in conjunction.\n\nTo emulate the behavior of a robot (car), we will write a Robot class. We will use the `Alice` key as an account for this robot. The `Robot` class will watch for `NewLaunch` events to turn itself on and off. After turning on, it starts collecting data into the log, in terms of data it will be just a timestamp. And after shutdown, it saves this log to the `datalog` module.\n\nWay 1:\n\nCreate file `src/utils/robot.js`. The full code of the file https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/robot.js\n\nFor visualization, we will create a `Demo.vue` component, where we will have a start button, car animation and log output.\n\n`src/components/Demo.vue`\n```js\n<template>\n  <div>\n    <h2>Demo</h2>\n    <template v-if=\"robot\">\n      <h3>Robot: {{ robot.address }}</h3>\n      <p v-if=\"robot.state\">Driver: {{ robot.driver }}</p>\n      <button @click=\"run\" :disabled=\"isWrite\">\n        <template v-if=\"!robot.state\">run</template>\n        <template v-else>stop</template>\n      </button>\n      <div class=\"road\">\n        <div\n          class=\"robot\"\n          :class=\"[robot.state ? 'robot-play' : 'robot-stop']\"\n        ></div>\n      </div>\n      <div v-if=\"error\" class=\"error\">{{ error }}</div>\n      <div v-if=\"log\" class=\"log\">\n        <p v-if=\"log.length === 0\" class=\"error\">Not found</p>\n        <div v-for=\"(item, k) in log\" :key=\"k\" class=\"row\">\n          <b>{{ item[0] | dateFormat }}</b>\n          <pre>{{ item[1] | dataFormat }}</pre>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n  height: 500px;\n  overflow-y: auto;\n}\n.log .row {\n  margin: 10px;\n  border-bottom: 1px solid #eee;\n}\n.road {\n  width: 1000px;\n  margin: 20px auto;\n  background-color: #eee;\n  padding: 20px 0;\n  border: 5px solid #a5a5a5;\n  border-left: 0;\n  border-right: 0;\n  position: relative;\n}\n.road::before {\n  content: \" \";\n  width: 1000px;\n  border-top: 5px dashed #a5a5a5;\n  position: absolute;\n  top: 50%;\n  left: 0;\n}\n@keyframes move {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n.robot {\n  height: 100px;\n  width: 100px;\n  color: #fff;\n  font-weight: bold;\n  font-style: 14px;\n  animation: move 30s linear infinite;\n  border-radius: 0 10px 10px 0;\n  background: url(\"../images/build-iot-dapps/car.png\") no-repeat 0 0;\n  background-size: cover;\n}\n.robot-play {\n  animation-play-state: running;\n}\n.robot-stop {\n  animation-play-state: paused;\n}\n</style>\n```\n\nComponent code. Here we need to create an instance of the `Robot` class and a launch/stop function.\n\n`src/components/Demo.vue`\n```js\n...OTHER_CODE...\n\n<script>\nimport { u8aToString } from \"@polkadot/util\";\nimport Robot from \"../utils/robot\";\n\nexport default {\n  props: [\"api\", \"account\"],\n  data() {\n    return {\n      isWrite: false,\n      error: \"\",\n      robot: null,\n      log: []\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return JSON.parse(u8aToString(v));\n    }\n  },\n  async created() {\n    this.robot = new Robot(\"//Alice\", this.api);\n    await this.robot.subscribeLog(r => {\n      this.log = r.reverse().map(item => {\n        return [item[0], item[1]];\n      });\n    });\n  },\n  destroyed() {\n    this.robot.destroy();\n  },\n  methods: {\n    async run() {\n      try {\n        this.error = \"\";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot.account.address, !this.robot.state)\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n</script>\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Demo.vue\n\n    Let's add another picture of our car to `src/images/build-iot-dapps/car.png` and to `src/assets/car.png`. Example https://github.com/airalab/example-robonomics-dapp/blob/master/src/assets/car.png\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n\n...OTHER_CODE...\n\n  <div>\n    <div class=\"tabs\">\n      <button\n        @click=\"tab = 'datalog'\"\n        :class=\"{ active: tab === 'datalog' }\"\n      >\n        datalog\n      </button>\n      <button\n        @click=\"tab = 'launch'\"\n        :class=\"{ active: tab === 'launch' }\"\n      >\n        launch\n      </button>\n      <button @click=\"tab = 'demo'\" :class=\"{ active: tab === 'demo' }\">\n        demo\n      </button>\n    </div>\n    <Datalog v-if=\"tab === 'datalog'\" :api=\"api\" :account=\"account\" />\n    <Launch v-if=\"tab === 'launch'\" :api=\"api\" :account=\"account\" />\n    <Demo v-if=\"tab === 'demo'\" :api=\"api\" :account=\"account\" />\n  </div>\n\n...OTHER_CODE...\n\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from \"./components/Datalog\";\nimport Launch from \"./components/Launch\";\nimport Demo from \"./components/Demo\";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch,\n  Demo\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 6.\n\n```sh\ngit checkout step-6\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen5](../images/build-iot-dapps/screen5.png)\n\nThis concludes our lesson.\n\nThanks!\n","tools":[],"fileInfo":{"path":"ru/wschool2021-build-dapp-for-end-users.md","name":"wschool2021-build-dapp-for-end-users"}}},"context":{}}