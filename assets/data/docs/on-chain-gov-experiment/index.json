{"hash":"b019132cdf18eb9f78219b0565b919b16f679c3f","data":{"doc":{"id":"7482385b6654c2669c7747d0d9afc95f","title":"Ðžn-chain Government Experiment","description":"","contributors":[],"headings":[],"subtitles":[{"depth":2,"value":"Requirements","anchor":"#requirements"},{"depth":2,"value":"Creating a Polkadot Listener","anchor":"#creating-a-polkadot-listener"},{"depth":3,"value":"Testing","anchor":"#testing"},{"depth":2,"value":"Connecting to the Smart Home","anchor":"#connecting-to-the-smart-home"}],"content":"\nAt present, Polkadot is one of the largest DAOs in the world! There are many interesting events \ntaking place in the ecosystem as part of the on-chain governance experiment. \nRobonomics developers suggest that hackathon participants increase the level of Polkadot community \nimmersion by integrating events related to voting, new treasury requests, epoch \nchanges, and much more, into a typical smart home system.\n\n\n---\n\nThis article discusses smart home management through the Robonomics Cloud as a result of any event in the Polkadot ecosystem. Here is an example of how a lamp can be turned on when a new referendum is being submitted in the Polkadot network.\n\n<robo-wiki-video autoplay loop controls :videos=\"[{src: 'QmWARwfH8WSEjnWUEFSDn28ya8Xp93qyjmSdGkdkwFntWe', type:'mp4'}]\" />\n\n## Requirements\n\n - Installed Home Assistant instance with Robonomics integration. Installation methods can be found [here](/docs/install-smart-home).\n - Polkadot node or gateway for interaction. For example - `wss://polkadot.api.onfinality.io`\n - Robonomics node or gateway for interaction.\n - Created account in ED25519 format. Information can be found [here](/docs/sub-activate).\n - Having created account in a device list of the Robonomics subscription. Learn more [here](/docs/add-user).\n - Subscription owner and controller addresses.\n\nPython libraries:\n- [substrate-interface](https://pypi.org/project/substrate-interface/)\n- [IPFS-Toolkit](https://pypi.org/project/IPFS-Toolkit/)\n- [robonomics-interface](https://pypi.org/project/robonomics-interface/)\n\n## Creating a Polkadot Listener\n\nFirst, you need to create a script that will listen for new events in the Polkadot network. In the example, we will track the creation of new Referenda.\n\nFor testing convenience, a local Polkadot node in dev mode was used.You may find deployment [manual here](https://github.com/paritytech/polkadot-sdk/tree/master/polkadot#hacking-on-polkadot).\n\nTo connect to a public node, change the \"POLKADOT_GATEWAY\" variable.\n\nExample code:\n\n<code-helper copy>\n\n```python\nfrom substrateinterface import SubstrateInterface\n\nPOLKADOT_GATEWAY = \"ws://127.0.0.1:9944\"\n\nsubstrate = SubstrateInterface(\n    url=POLKADOT_GATEWAY\n)\n\ndef subscription_handler(data, update_nr, subscription_id):\n    if update_nr == 0:\n        print('Referenda count start:', data.value)\n    if update_nr > 0:\n        print('Referenda count increased:', data.value)\n\nsubstrate.query(\"Referenda\", \"ReferendumCount\", subscription_handler=subscription_handler)\n```\n\n</code-helper>\nThis script will listen for changes in the current referendum number and display the number of the latest referendum.\n\n### Testing\n\nRun the program and open [polkadot.js](https://polkadot.js.org/apps/#/explorer). \nTo switch to the local dev node, click on the icon in the upper left corner, and a sidebar menu will appear. Select \"Development\" and \"Local Node\" at the bottom, then click \"Switch\".\n\n<robo-wiki-picture src=\"gov-exp/polka_sidemenu.png\" />\n\nYou will switch to the local node. Go to the \"Governance\" -> \"Preimages\" tab.\n\n<robo-wiki-picture src=\"gov-exp/preimage.png\" />\n\nCreate a new preimage. Let's leave a remark in the network. Sign and send it to the network.\n\n<robo-wiki-picture src=\"gov-exp/remark.png\" />\n\nYou will receive its hash. Copy it and go to the \"Governance\" -> \"Referenda\" tab. Do \"Submit Proposal\". Since this is a test network, most of the configurable fields can be left as default. Paste the preimage hash and sign the proposal.\n\n<robo-wiki-picture src=\"gov-exp/proposal.png\" />\n\nAfter sending it to the network, the program will detect the new proposal and output the following logs:\n\n```\nReferenda count start: 0\nReferenda count increased: 1\n```\n\n## Connecting to the Smart Home\n\nNow we need to add an interaction with the smart home after creating a new proposal.\n\nFor this, we need to know the following:\n- Service domain\n- Service name\n- Target entity\n- Data  - should be type \"dict\"\n\nLet's see where to find them. Open the installed Home Assistant instance. Go to \"Developer Tools -> Services\", select any service and switch to YAML mode. Let's consider the example of a switch.\n\n<robo-wiki-picture src=\"gov-exp/service.png\" />\n\nThe \"service\" key contains the service domain and name. Everything before the dot is the domain, and everything after the dot is the service name. The data field is also needed.\n\nTo find the target entity, go to \"Settings -> Devices & Services -> Entities\". There will be a column with \"entity ID\" - this is the required target entity parameter.\n\nNow that we know all the parameters, let's go through what will happen in the script.\n\nThe script will connect to the local IPFS daemon. (If you followed the smart home setup instructions, you already have the IPFS daemon running.)\n\nFirst, we will form a command in JSON format. Next, the message is encrypted with the user's and controller's keys. \nThen the encrypted command is saved to a file and added to IPFS. After that, the resulting IPFS hash is sent to the Robonomics parachain through an extrinsic `Launch` to the controller's address.\nWhen the controller receives the launch, it will download the file from IPFS, decrypt it, and call the service specified inside.\n\nThe full code is as follows:\n\n<code-helper copy>\n\n```python\nimport os\nimport json\nimport ipfshttpclient2\nfrom substrateinterface import SubstrateInterface\nfrom robonomicsinterface import Account, Launch\nfrom substrateinterface import Keypair, KeypairType\nfrom robonomicsinterface.utils import ipfs_qm_hash_to_32_bytes, web_3_auth\n\n# polkadot part\nPOLKADOT_GATEWAY = \"<POLKADOT_GATEWAY>\" # ws://127.0.0.1:9944\nsubstrate = SubstrateInterface(url=POLKADOT_GATEWAY)\n\n# Robonomics part\n\n# Robonomics credentials\n# User address must be in RWS devices\n# User address must be ED25519\nuser_seed = \"<SEED_PHRASE>\"\ncontroller_address = \"<CONTROLLER_ADDRESS>\"\nsub_owner_address = \"<OWNER_ADDRESS>\"\n\n# Command\nservice_domain = \"<DOMAIN>\"  # domain is what is before the dot in the name of the service. For example \"switch\"\nservice_name = \"<NAME>\"  # name - what comes after the dot in the name of the service. For example \"turn_on\"\ntarget_entity = \"<ENTITY_ID>\"  #  entity_id. For example \"switch.boiler\"\ndata = {}  # Must be dict\n\n\ndef subscription_handler(data, update_nr, subscription_id):\n    if update_nr == 0:\n        print('Referenda count start:', data.value)\n\n    if update_nr > 0:\n        print('Referenda count increased:', data.value)\n        # Send launch to controller address with ipfs hash\n        launch = Launch(sender, rws_sub_owner=sub_owner_address)\n        res = launch.launch(controller_address, result_ipfs)\n        print(f\"Transaction result: {res}\")\n\ndef encrypt_message(\n        message, sender_keypair: Keypair, recipient_public_key: bytes\n) -> str:\n    \"\"\"\n    Encrypt message with sender private key and recepient public key\n    :param message: Message to encrypt\n    :param sender_keypair: Sender account Keypair\n    :param recipient_public_key: Recepient public key\n    :return: encrypted message\n    \"\"\"\n    encrypted = sender_keypair.encrypt_message(message, recipient_public_key)\n    return f\"0x{encrypted.hex()}\"\n\n\n# Format message to launch\ndata['entity_id'] = target_entity\ncommand = {'platform': service_domain, 'name': service_name, 'params': data}\n\nmessage = json.dumps(command)\nprint(f\"Message: {message}\")\nsender = Account(user_seed, crypto_type=KeypairType.ED25519)\n\n# Encrypt command\nrecipient = Keypair(\n    ss58_address=controller_address, crypto_type=KeypairType.ED25519\n)\nmessage = encrypt_message(message, sender.keypair, recipient.public_key)\nprint(f\"Ecrypted message: {message}\")\nfilename = \"temporal_file\"\nwith open(filename, \"w\") as f:\n    f.write(message)\nwith ipfshttpclient2.connect() as client:\n    result = client.add(filename, pin=False)\n    result_ipfs  = result[\"Hash\"]\n    print(f\"IPFS hash: {result_ipfs}\")\n    print(f\"IPFS hash for launch {ipfs_qm_hash_to_32_bytes(result_ipfs)}\")\n\nos.remove(filename)\n\nsubstrate.query(\"Referenda\", \"ReferendumCount\", subscription_handler=subscription_handler)\n```\n\n</code-helper>\n\nif you did everything correctly, you will see the following logs:\n```\nMessage: {\"platform\": \"switch\", \"name\": \"turn_on\", \"params\": {\"entity_id\": \"switch.boiler\"}}\nEcrypted message: 0x33356b915e51e4c050180db0c3e39de86e946b6807ea83114978c848d016ab34a812e271dd1e5b40aa8632edd5acf4254090d2c2849daafcc46d2d4a4406a169a04edb4a668a268b3265e96ded0411398e3520fd5b676109752d24f12a7ece976bdc58da6a5b95d3c9e77aa59270bbc86c66c2ffe69ef7b10fae20\nIPFS hash: QmcrqSD3bBYmm4rpaDMUVNQwF8CSi5WWVnwPtuGJdzgWpK\nIPFS hash for launch 0xd7bf2b46baebf5556ac30fda97d7bf34a71558acdafde694c849521d01ccd8b4\nReferenda count start: 0\nReferenda count increased: 1\nTransaction result: 0xe07d43462d540a7312763349b362318c427ca9a61e7d5bfa3c890e8b1c0294c1\n```","tools":[],"fileInfo":{"path":"on-chain-gov-experiment.md","name":"on-chain-gov-experiment"}}},"context":{}}