{"hash":"0fc731af9b90653b97e5d5b575cb73fa2319c9c4","data":{"doc":{"id":"6c0beab06ba44299a4c8edf3837e11a7","title":"Gaka-Chu Einrichtung und Softwareinstallation","description":"","contributors":["PaTara43"],"headings":[],"subtitles":[{"depth":2,"value":"Softwareinstallation auf KRC4","anchor":"#softwareinstallation-auf-krc4"},{"depth":2,"value":"Softwareinstallation auf NUC","anchor":"#softwareinstallation-auf-nuc"},{"depth":2,"value":"Ausfüllen von Konstanten","anchor":"#ausfüllen-von-konstanten"},{"depth":2,"value":"Kalibrierung von Gaka-Chu","anchor":"#kalibrierung-von-gaka-chu"},{"depth":2,"value":"Testen der Gaka-Chu-Kalibrierung","anchor":"#testen-der-gaka-chu-kalibrierung"},{"depth":2,"value":"Kunst machen","anchor":"#kunst-machen"},{"depth":3,"value":"Eki-Schnittstelle","anchor":"#eki-schnittstelle"},{"depth":3,"value":"RViz und MOVEit","anchor":"#rviz-und-moveit"},{"depth":3,"value":"Umgebung","anchor":"#umgebung"},{"depth":3,"value":"Bilderprozessor","anchor":"#bilderprozessor"},{"depth":3,"value":"Trajektorien-Zeichner","anchor":"#trajektorien-zeichner"},{"depth":2,"value":"Schicken Sie dem Roboter ein Bild zum Zeichnen","anchor":"#schicken-sie-dem-roboter-ein-bild-zum-zeichnen"}],"content":"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**In diesem Artikel werden wir einige Installierenierenations- und Startschritte durchgehen, um einen Roboter-Maler einzurichten. Anforderungen:**\n- KUKA KR6 R900 sixx mit KRC4 und einem SmartPad;\n- Intel NUC mit [ROS melodic](http://wiki.ros.org/melodic/Installation/Ubuntu) installiert;\n- Tisch, Farbe, Pinsel, Wasser.\n\n## Softwareinstallation auf KRC4\nEKI-Schnittstelle ist sowohl auf KRC4 als auch auf NUC erforderlich. Detaillierte Informationen zur Einrichtung auf KRC4 finden Sie [hier](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Starten Sie es auf dem Controller des Roboters.\n\n## Softwareinstallation auf NUC\nErstellen Sie einen Catkin-Arbeitsbereich:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nLaden Sie ROS-Pakete herunter. Alle Skripte sind [hier](https://github.com/airalab/robot_painter/tree/test_branch) gespeichert. Klonen Sie das Repository:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nSie benötigen möglicherweise einige Header-Dateien und Bibliotheken, um alles korrekt funktionieren zu lassen. Laden Sie sie herunter:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nFügen Sie den Quellbefehl zur Datei `.bashrc` hinzu:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nBis jetzt sollten Sie in der Lage sein, die Skripte zu starten. Wenn etwas schief geht, versuchen Sie einige [Fehlerbehebung](https://github.com/airalab/robot_painter/issues)\n\n## Ausfüllen von Konstanten\nZunächst muss der Roboter den Standort und die Ausrichtung der Leinwand sowie die Position der Farbdose kennen. All dies wird in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp` angegeben. Schauen wir uns das an.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nDies sind die Konstanten der Ebenengleichung, die die Position der Leinwand im 3D-Raum angeben. Sie werden während eines Kalibrierungsprozesses ermittelt, der unten beschrieben wird. Als nächstes kommt die Farbe.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nDies sind die Koordinaten der Farbdose. Sie können auch während der Kalibrierung angegeben werden. Die Größe der Leinwand ist angegeben in\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nEinige weitere wichtige Konstanten sind in `local_task_planner/src/Drawing.cpp` gespeichert:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nIhre Namen sagen alles, füllen Sie sie entsprechend der Situation aus.\n\n## Kalibrierung von Gaka-Chu\nDer Kalibrierungsprozess selbst ist ziemlich einfach.\n\n1) Starten Sie die EKI-Schnittstelle auf dem KRC4:\n\nMelden Sie sich im 'AUT'-Modus an, schalten Sie die Treiber ein und starten Sie das Skript `eki_hw_interface`\n\n2) Starten Sie die EKI-Schnittstelle auf dem NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nEs sollte endlose Protokolle ausgeben.\n\n3) Starten Sie RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nSie sollten Folgendes sehen:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nVersuchen Sie, den Endeffektor zu bewegen und auf 'Planen und Ausführen' zu klicken. Der Roboter sollte sich bewegen. Gehen Sie auf dem SmartPad zu **Display -> Actual position** und beobachten Sie die Koordinaten des Endeffektors. Platzieren Sie eine Leinwand horizontal zur Roboterbasis. Stecken Sie einen Pinsel in den Pinselhalter und bewegen Sie ihn vorsichtig, bis er die Leinwand kaum berührt. Speichern Sie in dieser Position die Koordinaten des Endeffektors. Wiederholen Sie dies 12-15 Mal. Speichern Sie auch die Koordinaten des Leinwandzentrums und der Farbdose.\nWenn Sie eine Reihe von Koordinaten haben, verwenden Sie [diese](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab-Skripte, um die fehlenden Konstanten und Quaternionen zu berechnen. Fügen Sie sie ein. Erstellen Sie Ihren Arbeitsbereich neu mit\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Testen der Gaka-Chu-Kalibrierung\nWenn kalibriert, muss Gaka-Chu durch das Zeichnen der Grenzen der Leinwand getestet werden. Um dies zu tun, führen Sie jeweils in einem neuen Terminal aus:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nDanach sollten Sie eine Leinwandkontur in RViz sehen:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nDrücken Sie in der Konsole \"S\", um den Test durchzuführen. Der Endeffektor des Roboters sollte sich direkt über den Grenzen der Leinwand bewegen und der Pinsel sollte die Leinwand während der gesamten Bewegung sanft berühren. Wenn dies nicht der Fall ist, versuchen Sie eine erneute Kalibrierung. Wenn das Leinwandmodell falsch gedreht ist, können Sie es durch Ändern des Quaternions in Matlab drehen.\n\n## Kunst machen\nSie benötigen 6 grundlegende Module, um alles zum Laufen zu bringen:\n- EKI-Schnittstelle;\n- MOVEit + RViz;\n- Umgebungsfelderübertragung;\n- Bildkonverterdienst;\n- Trajektorienzeichnungsmodul;\n- Startauslöser.\n\nLassen Sie uns sie nacheinander starten.\n\n### Eki-Schnittstelle\nStarten Sie auf KRC4 `eki_hw_interface`, auf NUC in einem neuen Terminal:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz und MOVEit\nSie benötigen einen Planer und eine Simulation. Starten Sie sie mit\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Umgebung\nSagen Sie dem Roboter, wo sich die Farbdose und die Leinwand befinden. Beachten Sie, dass es nicht notwendig ist, den Knoten `draw workspace` zu starten, der `tf_broadcaster` teilt die Größe der Leinwand mit. Es zeigt es nur nicht in RViz an.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Bilderprozessor\nAlle eingehenden Bilder müssen verarbeitet werden. Starten Sie den Dienst.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nWenn es den Anruf erhält, verarbeitet es ein Bild mit einem HP-Filter und erstellt eine rosbag-Datei mit Trajektorien.\n\n### Trajektorien-Zeichner\nDas Hauptskript hier ist der Trajektorien-Zeichner selbst. Es wartet auf das Bild, ruft den TextConverter-Service auf und zeichnet das Gemälde.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Schicken Sie dem Roboter ein Bild zum Zeichnen\nDer Roboter hört auf ein bestimmtes ROS-Thema, in dem Sie den Pfad zu einem gewünschten Bild übergeben müssen. Das Bild sollte quadratisch sein (Breite entspricht Höhe) und aus Linien bestehen. Senden Sie den Pfad:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nDanach öffnen sich zwei Fenster, die die Konturen und die Spuren zeigen. Schließen Sie sie und sehen Sie Gaka-Chu beim Zeichnen zu. Achten Sie auf Sicherheit und seien Sie immer bereit, den Not-Aus-Knopf zu drücken.\nWenn Gaka-Chu seine Kunst beendet hat, können Sie einen anderen Pfad zum Bild senden und der Maler wiederholt den gesamten Prozess.\n","tools":[],"fileInfo":{"path":"de/gaka-chu.md","name":"gaka-chu"}}},"context":{}}