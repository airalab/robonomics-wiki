{"hash":"0196e6eaf77d64aeb5e8bcaa4d983797efef2fe5","data":{"doc":{"id":"5a103d47585e2af130441295953000d1","title":"Substrate Cumulus Parachain Testsuite für Cross-Chain-Messaging","description":"","contributors":["ddulesov","boogerwooger","tubleronchik"],"headings":[],"subtitles":[{"depth":2,"value":"Upstream","anchor":"#upstream"},{"depth":2,"value":"Build & Run","anchor":"#build--run"},{"depth":2,"value":"Überprüfen, ob die anfängliche Einrichtung funktioniert","anchor":"#überprüfen-ob-die-anfängliche-einrichtung-funktioniert"},{"depth":3,"value":"Beispiel:","anchor":"#beispiel"},{"depth":3,"value":"UMP-Nachrichtenübermittlungstest","anchor":"#ump-nachrichtenübermittlungstest"},{"depth":3,"value":"HRMP-Nachrichtenübermittlungstest","anchor":"#hrmp-nachrichtenübermittlungstest"},{"depth":3,"value":"Weitere Optionen","anchor":"#weitere-optionen"},{"depth":2,"value":"Lokales Testnetz","anchor":"#lokales-testnetz"},{"depth":3,"value":"Erstellen einer benutzerdefinierten Ketten-Spezifikation","anchor":"#erstellen-einer-benutzerdefinierten-ketten-spezifikation"},{"depth":2,"value":"Parachain hacken","anchor":"#parachain-hacken"},{"depth":2,"value":"Learn More","anchor":"#learn-more"}],"content":"\n\nDas Hauptziel dieses Projekts ist die Vereinfachung der Entwicklung von Parachain-Laufzeitumgebungen bei Verwendung von Cross-Chain-Nachrichten. \nEs ermöglicht die Entwicklung von Laufzeitcode mit Integrationstests mit hoher Wiederholbarkeit und einfacher Verwendung.\nEs automatisiert den Aufbau, die Konstruktion einer voreingestellten Netzwerkkonfiguration (d. h. 1 Relay-Chain + 2 Parachains), die Einrichtung von Nachrichtenkanälen zwischen Parachains und die Durchführung von Messaging-Tests, das Senden von Nachrichten unter Verwendung eines Aufrufs an die Laufzeitumgebung, alles in Python konstruiert und zusammengesetzt.\n\nDie XCM-Testsuite wird zur Prüfung des Produktionszyklus von Robobank verwendet - der Satz von Substrate-Paletten, die es Robotern ermöglichen, sich auf externen Parachains zu registrieren, vorab bezahlte Bestellungen zu erhalten, diese auszuführen und Zahlungen unter Verwendung externer Token zu erhalten. Dies ermöglicht es Robotern, innerhalb des Robonomics-Netzwerks mit der gesamten erforderlichen Infrastruktur zu arbeiten, gleichzeitig aber ihre Dienste auf jedem anderen Parachain anzubieten.\n\nEin Beispielvideo ist auf [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM) verfügbar.\n\nDie wichtigsten Schritte im Demo-Szenario sind:\n- Starten Sie Relay-Chain und zwei Parachains in einem Paket von 6 Prozessen.\n- Richten Sie XCM-Nachrichtenkanäle zwischen Parachains ein.\n- Registrieren Sie einen Roboter in beiden Parachains.\n- Erstellen Sie eine Bestellung für diesen Roboter im Client-Parachain (Reservierung der Zahlung für die Fertigstellung der Bestellung).\n- Senden Sie eine XCM-Nachricht an das Robonomics-Parachain.\n- Erstellen des \"gespiegelten\" Bestellungsdatensatzes auf dem Robonomics-Parachain.\n- Der Roboter akzeptiert die Bestellung auf dem Robonomics-Parachain.\n- Senden Sie eine XCM-Nachricht über die Bestellannahme zurück an das Client-Parachain.\n- Akzeptieren Sie die Bestellung auf dem Client-Parachain (Reservierung einer Strafgebühr für die Nichterfüllung der Bestellung bis zum Bestellungsdeadline).\n- Der Roboter erfüllt die Bestellung auf dem Robonomics-Parachain.\n- Senden Sie eine XCM-Nachricht über die Bestellfertigstellung an das Client-Parachain.\n- Abwicklung aller Zahlungen (Kundenzahlung wird an den Roboter übertragen sowie die ungenutzte Strafgebühr).\n- Schließen Sie die Bestellung1 ab.\n\n\n## Upstream\nDieses Projekt ist ein Fork des\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\nEs enthält den Code der getesteten Laufzeitpaletten.\nWie im Originalknotencode befinden sich die Parachain-Codes in den Verzeichnissen \"./pallets\", \"./runtime\", \"./node\".\n\nUnterschiede zum Original \"substrate-node-template\":\n- Diese Collator-Laufzeitumgebung verfügt über ein HRMP-Handlermodul und kann Nachrichten von benachbarten Parachains verarbeiten.\n- Mock-Test-Laufzeitumgebung, die für interne XCM-Tests bereit ist.\n\n## Build & Run\nEmpfohlene (sehr) Einrichtung: \n```\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\n```\n[HINWEIS] Der erste Build kann viel Zeit in Anspruch nehmen, bis zu mehreren Stunden auf suboptimalen Maschinen.\n\n[HINWEIS] Das Skript funktioniert mit den festen Versionen (Commit-Hashes) von Polkadot(Rococo) in der Relay-Chain und den Parachains.\n\n[HINWEIS] Standardmäßig erstellt das Skript bei jedem Start die gleiche Umgebung, indem es alle vorherigen Zustände entfernt. Dieses Verhalten kann in \"config.sh\" mit dem Parameter \"PERSISTENT\" geändert werden.\n\n\nFühren Sie das Build- und Setup-Skript aus.  \n```bash\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\ncd xcm-robobank-prototype\n./scripts/init.sh\n```\n\nGrundlegende Aktionen des Skripts \"init.sh\":\n - Konfiguration lesen (Datei \"config.sh\" mit Revisionsnummer, initialen Knotenschlüsseln und -identifikatoren, Chaindata-Persistenzparameter usw.)\n - Setup von OS-Paketen, Rust und Python\n - Erstellen separater Binärdateien für die Relay-Chain sowie für beide Parachains\n    - Die Binärdateien werden im Unterverzeichnis ./bin generiert. \n - (optional) Entfernen aller vorherigen Chain-Daten für alle Chains\n    - Deaktiviert, wenn \"PERSISTENT=1\" in \"config.sh\" festgelegt ist\n - Als separate Prozesse ausführen (mit separaten PIDs und I/O-Pipes):\n    - Validatoren der Relay-Chain (d. h. 4 Validatoren, die eine stabile Rococo-Revision ausführen)\n    - Collatoren für Parachain-100 (d. h. ein einzelner Collator für den ersten Parachain, den Sie entwickeln)\n    - Collatoren für Parachain-200 (d. h. ein einzelner Collator für den zweiten Parachain, den Sie entwickeln)\n - Alle Endpunkte und Ports werden in der Konsole gedruckt, sodass Sie jede Chain mit Frontend-Apps (Explorer, DApp) untersuchen können.\n - Alle Ausgabedaten aller Chains werden weiterhin in der Konsole gedruckt.\n\n[WARNUNG] Warten Sie nach dem Starten, bis das Netzwerk hochgefahren ist, stellen Sie sicher, dass die Blockfinalisierung begonnen hat und die Parachains registriert sind. Diese Prozesse sollten etwa 5 Minuten dauern (50 Blöcke x 6 Sekunden).\n\n## Überprüfen, ob die anfängliche Einrichtung funktioniert \n\nVerwenden Sie das Standard-Polkadot-Frontend und die generierten \"--ws-port\"-Endpunkte, um eine Verbindung zu jedem Knoten herzustellen.\nÖffnen Sie [Polkadot-Anwendung](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/), um die Chains zu überwachen. \n\n### Beispiel:\nLocalhost, 4 Relay-Chain-Validatoren, ein Parachain-100-Collator, ein Parachain-200-Collator:\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\n\n\nWenn alles funktioniert und der Konsens gestartet ist, können wir mit dem Ausführen unserer Testfälle fortfahren (in einem neuen Terminal).\n\n### UMP-Nachrichtenübermittlungstest\n```bash\n./scripts/init.sh ump\n```\nEs erstellt eine `Balance.transfer`-Nachricht in `Parachain-100` und leitet sie an die Relay-Kette weiter.\nWenn die Relay-Kette die Nachricht empfängt, werden 15 Token vom Konto `Para 100` auf das Konto von Charlie übertragen.\n\n\n### HRMP-Nachrichtenübermittlungstest\n```bash\n./scripts/init.sh ump\n```\n\nEs erstellt eine `Balance.transfer`-Nachricht in `Parachain-100` und leitet sie an die `Sibling 200` weiter.\nDavor stattet es das Konto `Subl 100` mit 1000 Token aus und richtet eine Kommunikationsverbindung zwischen den Parachains ein.\n```bash\n./scripts/init.sh hrmp\n```\nWeitere Nachrichten können gesendet werden, indem der Befehl `hrmpm` ausgeführt wird. Es erstellt keinen Kanal und läuft daher schneller.\n```bash\n./scripts/init.sh hrmpm\n```\n\n### Weitere Optionen\n```bash\n./scripts/init.sh help\n```\n\n## Lokales Testnetz\n\n### Erstellen einer benutzerdefinierten Ketten-Spezifikation\n```\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\n```\n\nBearbeiten Sie die Datei rococo_local.json und ersetzen Sie die Parameter für Guthaben und Behörden durch Ihre eigenen.\n```json\n  \"keys\": [\n    [\n      \"\",\n      \"\",\n      {\n        \"grandpa\": \"\",\n        \"babe\": \"\",\n        \"im_online\": \"\",\n        \"para_validator\": \"\",\n        \"para_assignment\": \"\",\n        \"authority_discovery\": \"\"\n      }\n    ]\n```\n\nPolkadot-Adresse für //Alice//Stash (sr25519-Kryptographie).\n```bash\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\n```\n\n```text\nSecret Key URI `//Alice//stash` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nPolkadot-Grandpa-Sitzungsschlüssel für //Alice (ed25519-Kryptographie).\n```bash\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nPolkadot-Adresse für //Alice (sr25519-Kryptographie).\n```\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nKonvertieren Sie rococo_local.json in das Rohformat.\n```\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\n```\nUm die neue Ketten-Spezifikation zu verwenden, ersetzen Sie die Datei rococo.json im Verzeichnis ./config/ durch diese neue und führen Sie die Kette erneut aus.\n```bash\n./scripts/init.sh run\n```\nSie können den Code frei bearbeiten. Der obige Befehl erstellt das Projekt neu und aktualisiert den Collator-Knoten vor dem Start.\nCumulus ist eine Vorabversion der Software, die sich noch in der intensiven Entwicklung befindet.\nWir verwenden einen bestimmten Commit von Polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18. März 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\n\nSie können neuere Versionen der Software verwenden. Ändern Sie dazu POLKADOT_COMMIT in ./scipt/config.sh\nauf den neuesten Commit des `rococo-v1`-Zweigs, löschen Sie ./bin/polkadot und führen Sie aus \n```bash\n./scripts/init.sh run\n```\n\nAktualisieren Sie die Abhängigkeiten des Collator-Projekts \n```bash\ncargo update\n./scripts/init.sh build\n```\nEinige Abhängigkeiten erfordern wahrscheinlich neue Funktionen der Rust-Toolchain. Dieses Projekt basiert auf Rust `nightly-2021-01-26`\nAktualisieren Sie die Version der Rust-Toolchain in ./scripts/config.sh vor dem Build.\n\n## Parachain hacken\n[Externe Palette hinzufügen](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - sollte es wahrscheinlich in \"Weitere Informationen\" sein?\n## Learn More\n\nWeitere Informationen zur Struktur dieses Projekts, den darin enthaltenen Fähigkeiten und der Art und Weise, wie diese Fähigkeiten implementiert sind, finden Sie im Upstream [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template). Weitere Informationen zum [Pfad eines Parachain-Blocks](https://polkadot.network/the-path-of-a-parachain-block/) finden Sie im offiziellen Polkadot-Blog. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\n","tools":[],"fileInfo":{"path":"de/xcm-robobank.md","name":"xcm-robobank"}}},"context":{}}