{"hash":"1ca1c2e9eb79a0e8c67655508915b5798519f749","data":{"doc":{"id":"83b5ce1b04353c26a9ac22798ceb6d76","title":"Gaka-Chu setup and software 설치","description":"","contributors":["PaTara43"],"headings":[],"subtitles":[{"depth":2,"value":"KRC4에 소프트웨어 설치","anchor":"#krc4에-소프트웨어-설치"},{"depth":2,"value":"NUC에 소프트웨어 설치","anchor":"#nuc에-소프트웨어-설치"},{"depth":2,"value":"상수 채우기","anchor":"#상수-채우기"},{"depth":2,"value":"Gaka-Chu 보정","anchor":"#gaka-chu-보정"},{"depth":2,"value":"작업 공간을 다시 빌드하세요.","anchor":"#작업-공간을-다시-빌드하세요"},{"depth":2,"value":"아트 만들기","anchor":"#아트-만들기"},{"depth":3,"value":"Eki 인터페이스","anchor":"#eki-인터페이스"},{"depth":3,"value":"RViz와 MOVEit","anchor":"#rviz와-moveit"},{"depth":3,"value":"환경","anchor":"#환경"},{"depth":3,"value":"사진 처리기","anchor":"#사진-처리기"},{"depth":3,"value":"트라젝토리 그리기","anchor":"#트라젝토리-그리기"},{"depth":2,"value":"로봇에게 그릴 그림을 보내세요","anchor":"#로봇에게-그릴-그림을-보내세요"}],"content":"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**이 기사에서는 로봇 페인터를 설정하기 위한 몇 가지 설치 및 실행 단계를 살펴보겠습니다. 요구 사항:**\n- KUKA KR6 R900 sixx 및 KRC4와 SmartPad;\n- [ROS melodic](http://wiki.ros.org/melodic/설치/Ubuntu)이 설치된 Intel NUC;\n- 테이블, 페인트, 브러시, 물.\n\n## KRC4에 소프트웨어 설치\nKRC4와 NUC 모두에 EKI 인터페이스가 필요합니다. KRC4에서 설정하는 방법에 대한 자세한 정보는 [여기](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl)에서 제공됩니다. 로봇 컨트롤러에서 실행하세요.\n\n## NUC에 소프트웨어 설치\ncatkin 작업 공간을 생성하세요.\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nROS 패키지를 다운로드하세요. 모든 스크립트는 [여기](https://github.com/airalab/robot_painter/tree/test_branch)에 저장되어 있습니다. 리포지토리를 복제하세요.\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\n모두가 올바르게 작동하려면 일부 헤더 파일과 라이브러리가 필요할 수 있습니다. 다운로드하세요.\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\n`.bashrc` 파일에 소스 명령을 추가하세요.\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\n지금까지 스크립트를 실행할 수 있어야 합니다. 문제가 발생하면 [문제 해결](https://github.com/airalab/robot_painter/issues)을 시도하세요.\n\n## 상수 채우기\n먼저, 로봇은 캔버스 위치와 방향, 그리고 페인트 통 위치를 알아야 합니다. 이 모든 것은 `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`에서 지정됩니다. 살펴보겠습니다.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\n이것들은 3D 공간에서 캔버스 위치를 지정하는 평면 방정식 상수입니다. 아래에서 설명하는 보정 과정 중에 얻어야 합니다. 다음은 페인트입니다.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\n이것들은 페인트 통 좌표입니다. 보정하는 동안 지정할 수도 있습니다. 캔버스 크기는\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\n`local_task_planner/src/Drawing.cpp`에 저장된 몇 가지 더 중요한 상수가 있습니.\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\n상수의 이름이 그 자체로 말해주기 때문에 상황에 맞게 채우세요.\n\n## Gaka-Chu 보정\n보정 과정 자체는 매우 간단합니다.\n\n1) KRC4에서 EKI 인터페이스 시작:\n\n'AUT' 모드로 로그인하고 드라이버를 켜고 `eki_hw_interface` 스크립트를 실행하세요.\n\n2) NUC에서 EKI 인터페이스 시작\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n무한한 로그가 출력되어야 합니다.\n\n3) RViz 시작\n```\nroslaunch kuka_moveit_config demo.launch\n```\n다음을 볼 수 있어야 합니다.\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\n끝 지점을 이동하고 '계획 및 실행'을 클릭해 보세요. 로봇이 움직여야 합니다. SmartPad에서 **Display -> Actual position**으로 이동하여 끝 지점의 좌표를 확인하세요. 캔버스를 로봇 베이스에 수평으로 배치하세요. 브러시를 브러시 홀더에 연결하고 조심스럽게 캔버스에 거의 닿을 때까지 이동하세요. 이 위치에서 끝 지점의 좌표를 저장하세요. 12-15번 반복하세요. 또한 캔버스 중심과 페인트 통의 좌표를 저장하세요.\n좌표 세트가 있으면 [이](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab 스크립트를 사용하여 누락된 상수와 쿼터니온을 해결하세요. 붙여넣으세요. 다음으로\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## 작업 공간을 다시 빌드하세요.\nGaka-Chu 보정 테스트\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\n보정된 후에는 Gaka-Chu를 사용하여 캔버스의 테두리를 그리는 테스트를 수행해야 합니다. 각각을 새로운 터미널에서 실행하세요.\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\n터미널에서 테스트를 수행하려면 \"S\"를 누르세요. 로봇의 엔드 이펙터는 캔버스의 테두리 바로 위로 이동해야 하며 브러시는 이동 동안 캔버스에 부드럽게 닿아야 합니다. 그렇지 않으면 재보정을 시도해보세요. 캔버스 모델이 잘못 회전된 경우, Matlab에서 쿼터니언을 변경하여 회전시킬 수 있습니다.\n\n## 아트 만들기\n모두 작동하려면 6개의 기본 모듈이 필요합니다:\n- EKI 인터페이스;\n- MOVEit + RViz;\n- 환경 프레임 브로드캐스팅;\n- 사진 변환 서비스;\n- 트라젝토리 그리기 모듈;\n- 시작 트리거.\n\n하나씩 실행해 보겠습니다.\n\n### Eki 인터페이스\nKRC4에서 `eki_hw_interface`를 실행하고, 새 터미널에서 NUC에서 다음을 수행하세요:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz와 MOVEit\n플래너와 시뮬레이션이 필요합니다. 다음과 같이 실행하세요.\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### 환경\n로봇에게 페인트 통과 캔버스의 위치를 알려주세요. `draw workspace` 노드를 실행할 필요는 없으며, `tf_broadcaster`가 캔버스 크기를 공유합니다. 그저 RViz에 표시되지 않을 뿐입니다.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### 사진 처리기\n들어오는 모든 사진은 처리되어야 합니다. 서비스를 실행하세요.\n```\nrosrun picture_preprocessing TextConverter.py\n```\n호출을 받으면 HP 필터로 사진을 처리하고 트라젝토리가 포함된 rosbag 파일을 생성합니다.\n\n### 트라젝토리 그리기\n가장 중요한 스크립트는 트라젝토리 그리기 자체입니다. 그림을 기다리고 TextConverter 서비스를 호출하여 그림을 그립니다.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## 로봇에게 그릴 그림을 보내세요\n로봇은 특정 ROS 픽을 청취하여 원하는 그림의 경로를 전달해야 합니다. 그림은 정사각형이어야 하며 (너비와 높이가 같아야 함) 선으로 이루어져 있어야 합니다. 경로를 전송하세요:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\n이후에 두 개의 창이 나타나고 윤곽과 트랙이 표시됩니다. 이를 닫고 Gaka-Chu의 그림을 확인하세요. 안전에 주의하고 언제든지 비상 정지 버튼을 누를 준비를 해야 합니다.\nGaka-Chu가 그림을 완성하면 다른 경로를 그림에 전송할 수 있으며, 화가는 전체 과정을 반복합니다.\n","tools":[],"fileInfo":{"path":"ko/gaka-chu.md","name":"gaka-chu"}}},"context":{}}