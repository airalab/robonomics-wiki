{"hash":"6049b68e007bd8fa4054505bb4c1089344ab6865","data":{"doc":{"id":"7f0d3c60431f5fb4be95ecb697c467d7","title":"Substrat Cumulus Parachain Testsuite pour la messagerie inter-chaînes","description":"","contributors":["ddulesov","boogerwooger","tubleronchik"],"headings":[],"subtitles":[{"depth":2,"value":"Amont","anchor":"#amont"},{"depth":2,"value":"Build & Run","anchor":"#build--run"},{"depth":2,"value":"Vérification du bon fonctionnement de la configuration initiale","anchor":"#vérification-du-bon-fonctionnement-de-la-configuration-initiale"},{"depth":3,"value":"Exemple:","anchor":"#exemple"},{"depth":3,"value":"Test de passage de message UMP","anchor":"#test-de-passage-de-message-ump"},{"depth":3,"value":"Test de passage de message HRMP","anchor":"#test-de-passage-de-message-hrmp"},{"depth":3,"value":"Plus d'options","anchor":"#plus-doptions"},{"depth":2,"value":"Testnet local","anchor":"#testnet-local"},{"depth":3,"value":"Créer une spécification de chaîne personnalisée","anchor":"#créer-une-spécification-de-chaîne-personnalisée"},{"depth":2,"value":"Pirater la parachaine","anchor":"#pirater-la-parachaine"},{"depth":2,"value":"Learn More","anchor":"#learn-more"}],"content":"\n\nL'objectif principal de ce projet est la simplification du développement de l'exécution de parachain, lorsque des messages inter-chaînes sont utilisés. \nIl permet le développement de code d'exécution avec des tests d'intégration avec un degré élevé de répétabilité et une utilisation simple.\nIl automatise la construction, la construction d'une configuration de réseau prédéfinie (c'est-à-dire 1 chaîne de relais + 2 parachains), la configuration de canaux de transmission de messages entre les parachains et l'exécution de tests de messagerie, l'envoi de messages, en utilisant l'appel à l'exécution, le tout construit et composé en Python.\n\nXCM Testsuite est utilisé pour tester le cycle de production de Robobank - l'ensemble de palettes Substrate, qui permettent aux robots de s'enregistrer sur des parachains externes, de recevoir des commandes prépayées, de les exécuter et de recevoir des paiements en utilisant des jetons externes. Cela permet aux robots de fonctionner à l'intérieur du réseau Robonomics avec toute l'infrastructure requise, mais en même temps, d'offrir leurs services sur n'importe quel autre parachain.\n\nUne vidéo d'exemple est disponible sur [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\n\nLes principales étapes du scénario de démonstration sont:\n- lancer une chaîne de relais et deux parachains dans un pack de 6 processus\n- configurer les canaux de messages XCM entre les parachains\n- enregistrer un robot dans les deux parachains\n- créer une commande pour ce robot dans le parachain client (réservation du paiement pour l'achvement de la commande)\n- envoyer un message XCM au parachain Robonomics\n- créer l'enregistrement de commande \"mirrored\" sur le parachain Robonomics\n- le robot accepte la commande sur le parachain Robonomics\n- envoyer un message XCM sur l'acceptation de la commande au parachain client\n- accepter la commande sur le parachain client (réservation d'une pénalité en cas de non-achèvement de la commande jusqu'à la date limite de la commande)\n- le robot achève la commande sur le parachain Robonomics\n- envoyer un message XCM sur l'achèvement de la commande au parachain client\n- régler tous les paiements (le paiement du client est transféré au robot, ainsi que la pénalité non utilisée)\n- fermer la commande1\n\n\n## Amont\nCe projet est un fork du\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\nIl contient le code des palettes d'exécution en cours de test.\nComme dans le code d'origine du nœud, les parachains se trouvent dans les catalogues \"./pallets\", \"./runtime\", \"./node\".\n\nDifférences avec le modèle de nœud \"substrate-node-template\" d'origine:\n- cette exécution de collecteur a un module de gestionnaire HRMP et peut gérer les messages des parachains frères\n- exécution de test fictive prête pour les tests internes XCM\n\n## Build & Run\nConfiguration recommandée (fortement recommandée): \n```\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\n```\n[NOTE] La première construction peut prendre beaucoup de temps, jusqu'à plusieurs heures sur des machines suboptimales.\n\n[NOTE] Le script fonctionne avec les versions FIXÉES (hachages de validation) de Polkadot(Rococo) dans la chaîne de relais et les parachains.\n\n[NOTE] Par défaut, le script recrée le même environnement à chaque lancement, en supprimant tous les états précédents. Ce comportement peut être modifié dans \"config.sh\" en utilisant le paramètre \"PERSISTENT\".\n\n\nExécutez le script de construction et de configuration.  \n```bash\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\ncd xcm-robobank-prototype\n./scripts/init.sh\n```\n\nActions de base du script \"init.sh\":\n - lire la configuration (fichier \"config.sh\" avec le numéro de révision, les clés et identifiants de nœud initiaux, le paramètre de persistance des données de chaîne, etc.)\n - configuration des paquets OS, Rust et Python\n - génère des binaires séparés pour la chaîne de relais et également pour les deux parachains\n    - les binaires seront générés dans le sous-répertoire ./bin. \n - (facultatif) supprime toutes les données de chaîne précédentes pour toutes les chaînes\n    - désactivé si \"PERSISTENT=1\" est défini dans \"config.sh\"\n - s'exécute en tant que processus séparés (avec des PID et des tuyaux d'E/S séparés):\n    - validateurs de la chaîne de relais (c'est-à-dire 4 validateurs d'une révision Rococo stable en cours d'exécution)\n    - collecteurs pour le parachain-100 (c'est-à-dire un seul collecteur pour le premier parachain que vous développez)\n    - collecteurs pour le parachain-200 (c'est-à-dire un seul collecteur pour le deuxième parachain que vous développez)\n - imprime tous les points de terminaison, les ports sur la console, vous permettant d'étudier n'importe quelle chaîne à l'aide d'applications frontales (explorateur, DApp)\n - continue d'imprimer toutes les données de sortie de toutes les chaînes sur la console\n\n[WARNING] Après le lancement, attendez que le réseau soit opérationnel, assurez-vous que la finalisation des blocs a commencé et que les parachains sont enregistrés. Ces processus devraient prendre environ 5 minutes (50 blocs x 6 secondes).\n\n## Vérification du bon fonctionnement de la configuration initiale \n\nUtilisez l'interface Polkdot standard et les points de terminaison \"--ws-port\" générés pour vous connecter à chaque nœud.\nOuvrez [l'application Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) pour surveiller les chaînes. \n\n### Exemple:\nLocalhost, 4 validateurs de chaîne de relais, un collecteur de parachain-100, un collecteur de parachain-200:\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\n\n\nSi tout fonctionne et que le consensus a commencé, nous pouvons procéder à l'exécution de nos cas de test (dans un nouveau terminal).\n\n### Test de passage de message UMP\n```bash\n./scripts/init.sh ump\n```\nIl crée un message `Balance.transfer` dans `parachain-100` et le transmet à la chaîne de relais.\nLorsque la chaîne de relais reçoit le message, elle transfère 15 jetons du compte `para 100` vers le compte Charlie.\n\n\n### Test de passage de message HRMP\n```bash\n./scripts/init.sh ump\n```\n\nIl crée un message `Balance.transfer` dans `parachain-100` et le transmet à la chaîne `sibling 200`.\nAvant cela, il dote le compte `subl 100` de 1000 jetons et établit un canal de communication entre les parachaines.\n```bash\n./scripts/init.sh hrmp\n```\nLes messages suivants peuvent être envoyés en exécutant la sous-commande `hrmpm`. Cela ne crée pas de canal et permet donc une exécution plus rapide.\n```bash\n./scripts/init.sh hrmpm\n```\n\n### Plus d'options\n```bash\n./scripts/init.sh help\n```\n\n## Testnet local\n\n### Créer une spécification de chaîne personnalisée\n```\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\n```\n\nModifier rococo_local.json, remplacer les paramètres de solde et d'autorités par les vôtres.\n```json\n  \"keys\": [\n    [\n      \"\",\n      \"\",\n      {\n        \"grandpa\": \"\",\n        \"babe\": \"\",\n        \"im_online\": \"\",\n        \"para_validator\": \"\",\n        \"para_assignment\": \"\",\n        \"authority_discovery\": \"\"\n      }\n    ]\n```\n\nAdresse Polkadot pour le compte //Alice//stash (cryptographie sr25519).\n```bash\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\n```\n\n```text\nSecret Key URI `//Alice//stash` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nClé de session grandpa Polkadot pour //Alice (cryptographie ed25519).\n```bash\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nAdresse Polkadot pour le compte //Alice (cryptographie sr25519).\n```\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nConvertir rococo_local.json au format brut.\n```\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\n```\nPour utiliser une nouvelle spécification de chaîne, remplacez le fichier rococo.json dans le répertoire ./config/ par celui-ci et relancez la chaîne.\n```bash\n./scripts/init.sh run\n```\nVous pouvez librement modifier le code. La commande ci-dessus reconstruira le projet et mettra à jour le nœud collecteur avant de démarrer.\nCumulus est un logiciel préliminaire encore en cours de développement intensif.\nNous utilisons un commit spécifique de polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\n\nVous pouvez utiliser des versions plus récentes du logiciel. Pour ce faire, modifiez POLKADOT_COMMIT dans ./scipt/config.sh\npar le dernier commit de la branche `rococo-v1`, supprimez ./bin/polkadot et exécutez \n```bash\n./scripts/init.sh run\n```\n\nMettre à jour les dépendances du projet collecteur \n```bash\ncargo update\n./scripts/init.sh build\n```\nCertaines dépendances nécessitent probablement de nouvelles fonctionnalités de la chaîne d'outils Rust. Ce projet est basé sur Rust `nightly-2021-01-26`\nMettez à jour la version de la chaîne d'outils Rust dans ./scripts/config.sh avant de construire.\n\n## Pirater la parachaine\n[Ajouter une palette externe](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - devrait probablement être dans \"en savoir plus\"?\n## Learn More\n\nConsultez le [Modèle de nœud du hub de développeurs Substrate](https://github.com/substrate-developer-hub/substrate-node-template) en amont pour en savoir plus sur la structure de ce projet, les capacités qu'il encapsule et la manière dont ces capacités sont mises en œuvre. Vous pouvez en savoir plus sur [Le chemin d'un bloc de parachaine](https://polkadot.network/the-path-of-a-parachain-block/) sur le blog officiel de Polkadot. [Atelier Parity Cumulus](https://substrate.dev/cumulus-workshop/#/)\n","tools":[],"fileInfo":{"path":"fr/xcm-robobank.md","name":"xcm-robobank"}}},"context":{}}