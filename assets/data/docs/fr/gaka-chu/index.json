{"hash":"4837eab19522bd51a4e900b04399f243c7412046","data":{"doc":{"id":"abc700fc65e6c02ff3b06d820f08dfdd","title":"Configuration et installation du logiciel Gaka-Chu","description":"","contributors":["PaTara43"],"headings":[],"subtitles":[{"depth":2,"value":"Installation du logiciel sur KRC4","anchor":"#installation-du-logiciel-sur-krc4"},{"depth":2,"value":"Installation du logiciel sur NUC","anchor":"#installation-du-logiciel-sur-nuc"},{"depth":2,"value":"Remplissage des constantes","anchor":"#remplissage-des-constantes"},{"depth":2,"value":"Calibration de Gaka-Chu","anchor":"#calibration-de-gaka-chu"},{"depth":2,"value":"Calibration de Gaka-Chu","anchor":"#calibration-de-gaka-chu-1"},{"depth":2,"value":"Création d'art","anchor":"#création-dart"},{"depth":3,"value":"Interface Eki","anchor":"#interface-eki"},{"depth":3,"value":"RViz et MOVEit","anchor":"#rviz-et-moveit"},{"depth":3,"value":"Environnement","anchor":"#environnement"},{"depth":3,"value":"Traitement des images","anchor":"#traitement-des-images"},{"depth":3,"value":"Tiroir de trajectoires","anchor":"#tiroir-de-trajectoires"},{"depth":2,"value":"Envoyez au robot une image à dessiner","anchor":"#envoyez-au-robot-une-image-à-dessiner"}],"content":"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**Dans cet article, nous passerons en revue quelques étapes d'installation et de lancement pour configurer un robot-peintre. Exigences :**\n- KUKA KR6 R900 sixx avec KRC4 et un SmartPad ;\n- Intel NUC avec [ROS melodic](http://wiki.ros.org/melodic/Installeration/Ubuntu) installé ;\n- Table, peinture, pinceau, eau.\n\n## Installation du logiciel sur KRC4\nL'interface EKI est requise à la fois sur KRC4 et NUC. Des informations détaillées sur la façon de la configurer sur KRC4 sont présentées [ici](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Lancez-la sur le contrôleur du robot.\n\n## Installation du logiciel sur NUC\nCréez un espace de travail catkin :\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nTéléchargez les packages ROS. Tous les scripts sont stockés [ici](https://github.com/airalab/robot_painter/tree/test_branch). Clonez le référentiel :\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nVous devrez peut-être télécharger certains fichiers d'en-tête et bibliothèques pour que tout fonctionne correctement. Téléchargez-les :\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAjoutez la commande source au fichier `.bashrc` :\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nJusqu'à présent, vous devriez pouvoir lancer les scripts. Si quelque chose ne va pas, essayez quelques [solutions de dépannage](https://github.com/airalab/robot_painter/issues)\n\n## Remplissage des constantes\nTout d'abord, le robot doit connaître l'emplacement et l'orientation de la toile ainsi que la position de la boîte de peinture. Tout cela est spécifié dans `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Jetons-y un coup d'œil.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nCe sont les constantes de l'équation du plan qui spécifient la position de la toile dans l'espace en 3D. Elles doivent être obtenues lors d'un processus de calibration décrit ci-dessous. Ensuite vient la peinture.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nCe sont les coordonnées de la boîte de peinture. Elles peuvent également être spécifiées lors de la calibration. La taille de la toile est spécifiée dans\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nPlusieurs autres constantes importantes sont stockées dans `local_task_planner/src/Drawing.cpp` :\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nLeurs noms en disent long, alors remplissez-les en fonction de la situation.\n\n## Calibration de Gaka-Chu\nLe processus de calibration lui-même est assez simple.\n\n1) Démarrez l'interface EKI sur le KRC4 :\n\nConnexionez-vous en mode 'AUT', activez les pilotes et lancez le script `eki_hw_interface`\n\n2) Démarrez l'interface EKI sur le NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nIl devrait afficher des journaux sans fin.\n\n3) Démarrez RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nVous devriez voir ce qui suit :\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nEssayez de déplacer l'effecteur final et cliquez sur 'Plan and Execute'. Le robot devrait bouger. Sur le SmartPad, allez dans **Display -> Actual position** et observez les coordonnées de l'effecteur final. Placez une toile horizontalement sur la base du robot. Branchez un pinceau dans le support de pinceau et déplacez-le soigneusement jusqu'à ce qu'il touche à peine la toile. À cette position, enregistrez les coordonnées de l'effecteur final. Répétez 12 à 15 fois. Enregistrez également les coordonnées du centre de la toile et de la boîte de peinture.\nLorsque vous avez un ensemble de coordonnées, utilisez [ces](https://github.com/nakata5321/Matlab_scripts_gaka-chu) scripts Matlab pour résoudre les constantes et le quaternion manquants. Collez-les. Reconstruisez votre espace de travail avec\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Calibration de Gaka-Chu\nLorsque Gaka-Chu est calibré, il doit être testé en dessinant les contours de la toile. Pour le faire, exécutez chacun dans un nouveau terminal :\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nAprès cela, vous devriez voir un contour de toile dans RViz :\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nAppuyez sur \"S\" dans le terminal pour effectuer le test. L'effecteur final du robot devrait se déplacer juste au-dessus des contours de la toile et le pinceau devrait effleurer délicatement la toile pendant tout le mouvement. Si ce n'est pas le cas, essayez de recalibrer. Si le modèle de la toile est mal orienté, vous pouvez le faire pivoter en changeant le quaternion dans Matlab.\n\n## Création d'art\nVous avez besoin de 6 modules de base pour que tout fonctionne :\n- Interface EKI ;\n- MOVEit + RViz;\n- Diffusion des cadres de l'environnement ;\n- Service de conversion d'images ;\n- Module de dessin de trajectoires ;\n- Déclencheur de démarrage.\n\nLançons-les un par un.\n\n### Interface Eki\nSur KRC4, lancez `eki_hw_interface`, sur NUC dans un nouveau terminal, faites :\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz et MOVEit\nVous avez besoin d'un planificateur et d'une simulation. Lancez-les avec\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Environnement\nIndiquez au robot où se trouvent la boîte de peinture et la toile. Notez qu'il n'est pas nécessaire de lancer le nœud `draw workspace`, le `tf_broadcaster` partage la taille de la toile. Il ne l'affiche simplement pas dans RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Traitement des images\nToutes les images entrantes doivent être traitées. Lancez le service.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nLorsqu'il reçoit l'appel, il traite une image avec un filtre HP et crée un fichier rosbag avec des trajectoires.\n\n### Tiroir de trajectoires\nLe script principal ici est le tiroir de trajectoires lui-même. Il attend l'image, appelle le service TextConverter et dessine la peinture.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Envoyez au robot une image à dessiner\nLe robot écoute un topic ROS spécifique où vous devez transmettre le chemin vers une image souhaitée. L'image doit être carrée (largeur égale à la hauteur) et composée de lignes. Envoyez le chemin:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nAprès cela. Deux fenêtres apparaissent montrant les contours et les pistes. Fermez-les et observez Gaka-Chu dessiner. Faites attention à la sécurité et soyez toujours prêt à appuyer sur le bouton d'arrêt d'urgence.\nLorsque Gaka-Chu termine son art, vous pouvez envoyer un autre chemin vers une image et le peintre répète tout le processus.\n","tools":[],"fileInfo":{"path":"fr/gaka-chu.md","name":"gaka-chu"}}},"context":{}}