{"hash":"17cc78d0b06fdca2940be0bd65777dc98e2b7d1b","data":{"doc":{"id":"5cb539cb43ea399e5b249905f21c5787","title":"Substrate Cumulus Parachain Testsuite para mensagens entre cadeias cruzadas","description":"","contributors":["ddulesov","boogerwooger","tubleronchik"],"headings":[],"subtitles":[{"depth":2,"value":"Upstream","anchor":"#upstream"},{"depth":2,"value":"Construir & Executar","anchor":"#construir--executar"},{"depth":2,"value":"Verificando se a configuração inicial funciona","anchor":"#verificando-se-a-configuração-inicial-funciona"},{"depth":3,"value":"Exemplo:","anchor":"#exemplo"},{"depth":3,"value":"Teste de passagem de mensagem UMP","anchor":"#teste-de-passagem-de-mensagem-ump"},{"depth":3,"value":"Teste de passagem de mensagem HRMP","anchor":"#teste-de-passagem-de-mensagem-hrmp"},{"depth":3,"value":"Mais opções","anchor":"#mais-opções"},{"depth":2,"value":"Testnet Local","anchor":"#testnet-local"},{"depth":3,"value":"Criar especificação de cadeia personalizada","anchor":"#criar-especificação-de-cadeia-personalizada"},{"depth":2,"value":"Hackeie a parachain","anchor":"#hackeie-a-parachain"},{"depth":2,"value":"Learn More","anchor":"#learn-more"}],"content":"\n\nO objetivo principal deste projeto é a simplificação do desenvolvimento de tempo de execução de parachain, quando mensagens entre cadeias cruzadas são usadas. \nEle permite o desenvolvimento de código de tempo de execução com testes de integração com alto grau de repetibilidade e uso simples.\nAutomatiza a construção, construção de configuração de rede pré-definida (ou seja, 1 cadeia de retransmissão + 2 parachains), configuração de canais de passagem de mensagens entre parachains e execução de testes de mensagens, envio de mensagens, usando chamada para tempo de execução, tudo construído e composto em Python.\n\nXCM Testsuite é usado para testar o ciclo de produção da Robobank - o conjunto de paletes Substrate, que permitem que robôs se registrem em parachains externos, recebam pedidos pré-pagos, executem-nos e recebam pagamentos usando tokens externos. Isso permite que os robôs operem dentro da rede Robonomics com toda a infraestrutura necessária, mas ao mesmo tempo, ofereçam seus serviços em qualquer outro parachain.\n\nUm exemplo de vídeo está disponível no [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\n\nAs principais etapas no cenário de demonstração são:\n- lançar cadeia de retransmissão e dois parachains em um pacote de 6 processos\n- configurar canais de mensagens XCM entre parachains\n- registrar um robô em ambos os parachains\n- criar um pedido para este robô no parachain do cliente (reservando pagamento para a conclusão do pedido)\n- enviar mensagem XCM para o parachain Robonomics\n- criar o registro de pedido \"espelhado\" no parachain Robonomics\n- robô aceita o pedido no parachain Robonomics\n- enviar mensagem XCM sobre a aceitação do pedido de volta ao parachain do cliente\n- aceitar o pedido no parachain do cliente (reservando uma taxa de penalidade por falta de conclusão do pedido até o prazo do pedido)\n- robô conclui o pedido no parachain Robonomics\n- enviar mensagem XCM sobre a conclusão do pedido para o parachain do cliente\n- resolver todos os pagamentos (o pagamento do cliente é transferido para o robô, assim como a taxa de penalidade não utilizada)\n- fechar o pedido1\n\n\n## Upstream\nEste projeto é um fork do\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\nEle contém o código dos paletes de tempo de execução sendo testados.\nComo no código original do nó, os parachains estão nos catálogos \"./pallets\", \"./runtime\", \"./node\".\n\nDiferenças com o \"substrate-node-template\" original:\n- este tempo de execução do coletor tem o módulo do manipulador HRMP e pode lidar com mensagens de parachains irmãos\n- tempo de execução de teste simulado pronto para testes internos de XCM\n\n## Construir & Executar\nConfiguração recomendada (altamente): \n```\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\n```\n[NOTA] A primeira compilação pode levar muito tempo, até várias horas em máquinas subótimas.\n\n[NOTA] O script funciona com as versões FIXAS (hashes de commit) do Polkadot (Rococo) na cadeia de retransmissão e nos parachains.\n\n[NOTA] Por padrão, o script recria o mesmo ambiente a cada inicialização, removendo todos os estados anteriores. Esse comportamento pode ser alterado em \"config.sh\" usando o parâmetro \"PERSISTENT\".\n\n\nExecute o script de compilação e configuração.  \n```bash\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\ncd xcm-robobank-prototype\n./scripts/init.sh\n```\n\nAções básicas do script \"init.sh\":\n - ler configuração (arquivo \"config.sh\" com número de revisão, chaves e identificadores iniciais do nó, parâmetro de persistência de dados da cadeia, etc.)\n - configurar pacotes do sistema operacional, Rust e Python\n - gerar binários separados para a cadeia de retransmissão e também para ambos os parachains\n    - os binários serão gerados no subdiretório ./bin. \n - (opcional) remover todos os dados anteriores da cadeia para todas as cadeias\n    - desativado se \"PERSISTENT=1\" estiver definido em \"config.sh\"\n - executar como processos separados (com PIDs e pipes de E/S separados):\n    - validadores da cadeia de retransmissão (ou seja, 4 validadores de execução de uma revisão estável do Rococo)\n    - coletor para parachain-100 (ou seja, único coletor para o primeiro parachain que você está desenvolvendo)\n    - coletor para parachain-200 (ou seja, único coletor para o segundo parachain que você está desenvolvendo)\n - imprimir todos os endpoints, portas no console, permitindo que você estude qualquer cadeia usando aplicativos front-end (explorador, DApp)\n - continuar imprimindo todos os dados de saída de todas as cadeias no console\n\n[AVISO] Após o lançamento, aguarde até que a rede esteja ativa, verifique se a finalização do bloco foi iniciada e se os parachains estão registrados. Esses processos devem levar aproximadamente 5 minutos (50 blocos x 6 segundos).\n\n## Verificando se a configuração inicial funciona \n\nUse a interface padrão do Polkdot e os endpoints gerados \"--ws-port\" para se conectar a cada nó.\nAbra o [aplicativo Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) para monitorar as cadeias. \n\n### Exemplo:\nLocalhost, 4 validadores de cadeia de retransmissão, um coletor parachain-100, um coletor parachain-200:\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\n\n\nSe tudo funcionar e o consenso começar, podemos prosseguir para executar nossos casos de teste (em um novo terminal).\n\n### Teste de passagem de mensagem UMP\n```bash\n./scripts/init.sh ump\n```\nEle cria uma mensagem `Balance.transfer` em `parachain-100` e a passa para a cadeia de relé.\nQuando a cadeia de relé recebe a mensagem, ela transferirá 15 tokens da conta `para 100` para a conta Charlie.\n\n\n### Teste de passagem de mensagem HRMP\n```bash\n./scripts/init.sh ump\n```\n\nEle cria uma mensagem `Balance.transfer` em `parachain-100` e a passa para o `sibling 200`.\nAntes disso, ele endossa a conta `subl 100` com 1000 tokens e estabelece um canal de comunicação entre as parachains.\n```bash\n./scripts/init.sh hrmp\n```\nAs próximas mensagens podem ser enviadas executando o subcomando `hrmpm`. Isso não cria um canal e, portanto, é executado mais rápido.\n```bash\n./scripts/init.sh hrmpm\n```\n\n### Mais opções\n```bash\n./scripts/init.sh help\n```\n\n## Testnet Local\n\n### Criar especificação de cadeia personalizada\n```\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\n```\n\nEdite o arquivo rococo_local.json, substitua os parâmetros de saldos e autoridades pelos seus.\n```json\n  \"keys\": [\n    [\n      \"\",\n      \"\",\n      {\n        \"grandpa\": \"\",\n        \"babe\": \"\",\n        \"im_online\": \"\",\n        \"para_validator\": \"\",\n        \"para_assignment\": \"\",\n        \"authority_discovery\": \"\"\n      }\n    ]\n```\n\nEndereço Polkadot para //Alice//stash (criptografia sr25519).\n```bash\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\n```\n\n```text\nSecret Key URI `//Alice//stash` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nChave de sessão Polkadot grandpa para //Alice (criptografia ed25519).\n```bash\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nEndereço Polkadot para //Alice (criptografia sr25519).\n```\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nConverter rococo_local.json para o formato bruto.\n```\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\n```\nPara usar a nova especificação de cadeia, substitua o arquivo rococo.json no diretório ./config/ por este novo e execute novamente a cadeia.\n```bash\n./scripts/init.sh run\n```\nVocê pode editar o código livremente. O comando acima reconstruirá o projeto e atualizará o nó do colator antes de iniciar.\nCumulus é um software pré-lançamento que ainda está em desenvolvimento intenso.\nEstamos usando um commit específico do polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15 18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\n\nVocê pode usar versões mais recentes do software. Para fazer isso, altere POLKADOT_COMMIT em ./scipt/config.sh\npara o commit mais recente do branch `rococo-v1`, exclua ./bin/polkadot e execute \n```bash\n./scripts/init.sh run\n```\n\nAtualize as dependências do projeto do colator \n```bash\ncargo update\n./scripts/init.sh build\n```\nAlgumas dependências provavelmente requerem novos recursos da ferramenta rust. Este projeto é baseado no rust `nightly-2021-01-26`\nAtualize a versão da ferramenta rust em ./scripts/config.sh antes de compilar.\n\n## Hackeie a parachain\n[Adicione um pallet externo](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - deve estar provavelmente em \"saiba mais\"?\n## Learn More\n\nConsulte o [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template) upstream para saber mais sobre a estrutura deste projeto, as capacidades que ele encapsula e a maneira como essas capacidades são implementadas. Você pode saber mais sobre [O Caminho de um Bloco de Parachain](https://polkadot.network/the-path-of-a-parachain-block/) no blog oficial do Polkadot. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\n","tools":[],"fileInfo":{"path":"pt/xcm-robobank.md","name":"xcm-robobank"}}},"context":{}}