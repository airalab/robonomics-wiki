{"hash":"7aa239c3bcfadce6a760f54beda5c30e0b86854b","data":{"doc":{"id":"d93f469113b6a9969411bc8aab48e001","title":"Configuração e Instalação de Software Gaka-Chu","description":"","contributors":["PaTara43"],"headings":[],"subtitles":[{"depth":2,"value":"Instalação de software no KRC4","anchor":"#instalação-de-software-no-krc4"},{"depth":2,"value":"Instalação de software no NUC","anchor":"#instalação-de-software-no-nuc"},{"depth":2,"value":"Preenchendo constantes","anchor":"#preenchendo-constantes"},{"depth":2,"value":"Calibrando Gaka-Chu","anchor":"#calibrando-gaka-chu"},{"depth":2,"value":"Testando a calibração do Gaka-Chu","anchor":"#testando-a-calibração-do-gaka-chu"},{"depth":2,"value":"Fazendo arte","anchor":"#fazendo-arte"},{"depth":3,"value":"Interface Eki","anchor":"#interface-eki"},{"depth":3,"value":"RViz e MOVEit","anchor":"#rviz-e-moveit"},{"depth":3,"value":"Ambiente","anchor":"#ambiente"},{"depth":3,"value":"Processador de imagens","anchor":"#processador-de-imagens"},{"depth":3,"value":"Trajetórias desenhadas","anchor":"#trajetórias-desenhadas"},{"depth":2,"value":"Envie ao robô uma imagem para desenhar","anchor":"#envie-ao-robô-uma-imagem-para-desenhar"}],"content":"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**Neste artigo, passaremos por algumas etapas de instalação e lançamento para configurar um robô pintor. Requisitos:**\n- KUKA KR6 R900 sixx com KRC4 e um SmartPad;\n- Intel NUC com [ROS melodic](http://wiki.ros.org/melodic/Instalaration/Ubuntu) instalado;\n- Mesa, tinta, pincel, água.\n\n## Instalação de software no KRC4\nA interface EKI é necessária tanto no KRC4 quanto no NUC. Informações detalhadas sobre como configurá-lo no KRC4 são apresentadas [aqui](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Inicie no controlador do robô.\n\n## Instalação de software no NUC\nCrie um espaço de trabalho catkin:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nBaixe os pacotes ROS. Todos os scripts estão armazenados [aqui](https://github.com/airalab/robot_painter/tree/test_branch). Clone o repositório:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nVocê pode precisar de alguns arquivos de cabeçalho e bibliotecas para que tudo funcione corretamente. Baixe-os:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAdicione o comando de origem ao arquivo `.bashrc`:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nAté agora. você deve ser capaz de lançar os scripts. Se algo der errado, tente algumas [soluções de problemas](https://github.com/airalab/robot_painter/issues)\n\n## Preenchendo constantes\nEm primeiro lugar, o robô precisa saber a localização e orientação da tela, bem como a posição da lata de tinta. Tudo isso é especificado em `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Vamos dar uma olhada nisso.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nEssas são as constantes da equação do plano que especificam a posição da tela no espaço 3D. Elas devem ser obtidas durante um processo de calibração descrito abaixo. Em seguida, vem a tinta.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nEssas são as coordenadas da lata de tinta. Elas também podem ser especificadas durante a calibração. O tamanho da tela é especificado em\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nVárias outras constantes importantes são armazenadas em `local_task_planner/src/Drawing.cpp`:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nSeus nomes dizem tudo, então preencha-os de acordo com a situação.\n\n## Calibrando Gaka-Chu\nO próprio processo de calibração é bastante simples.\n\n1) Inicie a interface EKI no KRC4:\n\nFaça login no modo 'AUT', ligue os drivers e inicie o script `eki_hw_interface`\n\n2) Inicie a interface EKI no NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nDeve exibir logs infinitos.\n\n3) Inicie o RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nVocê deve ver o seguinte:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nTente mover o efetuador final e clicar em 'Planejar e Executar'. O robô deve se mover. No SmartPad, vá para **Display -> Actual position** e observe as coordenadas do efetuador final. Coloque uma tela horizontalmente na base do robô. Conecte um pincel no suporte do pincel e mova-o cuidadosamente até que ele toque levemente a tela. Nessa posição, salve as coordenadas do efetuador final. Repita 12-15 vezes. Além disso, salve as coordenadas do centro da tela e da lata de tinta.\nQuando você tiver um conjunto de coordenadas, use [esses](https://github.com/nakata5321/Matlab_scripts_gaka-chu) scripts do Matlab para resolver as constantes e quaterniões ausentes. Cole-os. Reconstrua seu espaço de trabalho com\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Testando a calibração do Gaka-Chu\nQuando calibrado, o Gaka-Chu precisa ser testado desenhando as bordas da tela. Para fazer isso, execute cada um em um novo terminal:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nDepois disso, você deve ver um contorno da tela no RViz:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nNo terminal, pressione \"S\" para realizar o teste. O efetuador final do robô deve se mover acima das bordas da tela e o pincel deve tocar suavemente a tela durante todo o movimento. Se não for assim, tente recalibrar. Se o modelo da tela estiver girado incorretamente, você pode girá-lo alterando o quaternião no Matlab.\n\n## Fazendo arte\nVocê precisa de 6 módulos básicos para fazer tudo funcionar:\n- Interface EKI;\n- MOVEit + RViz;\n- Transmissão de quadros de ambiente;\n- Serviço de conversão de imagens;\n- Módulo de desenho de trajetórias;\n- Gatilho de início.\n\nVamos lançá-los um por um.\n\n### Interface Eki\nNo KRC4, inicie `eki_hw_interface`, no NUC em um novo terminal faça:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz e MOVEit\nVocê precisa de um planejador e uma simulação. Inicie-os com\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Ambiente\nInforme ao robô onde está a lata de tinta e a tela. Observe que não é necessário iniciar o nó `draw workspace`, o `tf_broadcaster` compartilha o tamanho da tela. Ele apenas não o mostra no RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Processador de imagens\nTodas as imagens recebidas precisam ser processadas. Inicie o serviço.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nQuando recebe a chamada, ele processa uma imagem com um filtro HP e cria um arquivo rosbag com trajetórias.\n\n### Trajetórias desenhadas\nO script principal aqui é o próprio desenhador de trajetórias. Ele espera pela imagem, chama o serviço TextConverter e desenha a pintura.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Envie ao robô uma imagem para desenhar\nO robô escuta um tópico específico do ROS onde você precisa passar o caminho para uma imagem desejada. A imagem deve ser quadrada (largura igual à altura) e feita de linhas. Envie o caminho:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nDepois disso, duas janelas aparecem mostrando os contornos e as trilhas. Feche-as e veja Gaka-Chu desenhando. Tome cuidado com a segurança e esteja sempre pronto para pressionar o botão de parada de emergência.\nQuando Gaka-Chu termina sua arte, você pode enviar outro caminho para a imagem e o pintor repete todo o processo.\n","tools":[],"fileInfo":{"path":"pt/gaka-chu.md","name":"gaka-chu"}}},"context":{}}