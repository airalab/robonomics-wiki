{"hash":"53abe0fd1aeba0a6e1f75f3e7657baa86d8f7363","data":{"doc":{"id":"07c305e94622361cb1089f05f1c216a3","title":"Substrate Cumulus Parachain Testsuite para mensajería entre cadenas","description":"","contributors":["ddulesov","boogerwooger","tubleronchik"],"headings":[],"subtitles":[{"depth":2,"value":"Corriente ascendente","anchor":"#corriente-ascendente"},{"depth":2,"value":"Construir y ejecutar","anchor":"#construir-y-ejecutar"},{"depth":2,"value":"Comprobando que la configuración inicial funciona","anchor":"#comprobando-que-la-configuración-inicial-funciona"},{"depth":3,"value":"Ejemplo:","anchor":"#ejemplo"},{"depth":3,"value":"Prueba de paso de mensajes UMP","anchor":"#prueba-de-paso-de-mensajes-ump"},{"depth":3,"value":"Prueba de paso de mensajes HRMP","anchor":"#prueba-de-paso-de-mensajes-hrmp"},{"depth":3,"value":"Más opciones","anchor":"#más-opciones"},{"depth":2,"value":"Testnet local","anchor":"#testnet-local"},{"depth":3,"value":"Crear especificación de cadena personalizada","anchor":"#crear-especificación-de-cadena-personalizada"},{"depth":2,"value":"Hackear parachain","anchor":"#hackear-parachain"},{"depth":2,"value":"Learn More","anchor":"#learn-more"}],"content":"\n\nEl objetivo principal de este proyecto es simplificar el desarrollo de tiempo de ejecución de parachain cuando se utilizan mensajes entre cadenas. \nPermite el desarrollo de código de tiempo de ejecución con pruebas de integración con un alto grado de repetibilidad y uso sencillo.\nAutomatiza la construcción, la construcción de una configuración de red predefinida (es decir, 1 cadena de relé + 2 parachains), la configuración de canales de envío de mensajes entre parachains y la ejecución de pruebas de mensajería, el envío de mensajes, utilizando llamadas al tiempo de ejecución, todo construido y compuesto en Python.\n\nXCM Testsuite se utiliza para probar el ciclo de producción de Robobank, el conjunto de paletas de Substrate que permiten a los robots registrarse en parachains externos, recibir pedidos prepagos, ejecutarlos y recibir pagos utilizando tokens externos. Esto permite que los robots operen dentro de la red Robonomics con toda la infraestructura requerida, pero al mismo tiempo, ofrezcan sus servicios en cualquier otra parachain.\n\nUn ejemplo de video está disponible en [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\n\nLos principales pasos en el escenario de demostración son:\n- lanzar la cadena de relé y dos parachains en un paquete de 6 procesos\n- configurar canales de mensajes XCM entre parachains\n- registrar un robot en ambos parachains\n- crear un pedido para este robot en el parachain del cliente (reservando el pago para la finalización del pedido)\n- enviar un mensaje XCM al parachain de Robonomics\n- crear el registro de pedido \"reflejado\" en el parachain de Robonomics\n- el robot acepta el pedido en el parachain de Robonomics\n- enviar un mensaje XCM sobre la aceptación del pedido de vuelta al parachain del cliente\n- aceptar el pedido en el parachain del cliente (reservando una tarifa de penalización por falta de finalización del pedido hasta la fecha límite del pedido)\n- el robot completa el pedido en el parachain de Robonomics\n- enviar un mensaje XCM sobre la finalización del pedido al parachain del cliente\n- liquidar todos los pagos (el pago del cliente se transfiere al robot, así como la tarifa de penalización no utilizada)\n- cerrar el pedido1\n\n\n## Corriente ascendente\nEste proyecto es un fork de\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\nContiene el código de las paletas de tiempo de ejecución que se están probando.\nAl igual que en el código de nodo original, los parachains se encuentran en los catálogos \"./pallets\", \"./runtime\", \"./node\".\n\nDiferencias con el \"substrate-node-template\" original:\n- este tiempo de ejecución del recolector tiene un módulo de controlador HRMP y puede manejar mensajes de parachains hermanos\n- tiempo de ejecución de prueba simulado listo para pruebas internas de XCM\n\n## Construir y ejecutar\nConfiguración recomendada (altamente): \n```\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\n```\n[NOTA] La primera compilación puede llevar mucho tiempo, hasta varias horas en máquinas subóptimas.\n\n[NOTA] El script funciona con las versiones FIJAS (hashes de confirmación) de Polkadot (Rococo) en la cadena de relé y parachains.\n\n[NOTA] Por defecto, el script recrea el mismo entorno en cada lanzamiento, eliminando todos los estados anteriores. Este comportamiento se puede cambiar en \"config.sh\" utilizando el parámetro \"PERSISTENT\".\n\n\nEjecutar script de compilación y configuración.  \n```bash\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\ncd xcm-robobank-prototype\n./scripts/init.sh\n```\n\nAcciones básicas del script \"init.sh\":\n - leer la configuración (archivo \"config.sh\" con número de revisión, claves e identificadores de nodo iniciales, parámetro de persistencia de datos de cadena, etc.)\n - configurar paquetes del sistema operativo, Rust y Python\n - generar binarios separados para la cadena de relé y también para ambos parachains\n    - los binarios se generarán en el subdirectorio ./bin. \n - (opcional) eliminar todos los datos de cadena anteriores para todas las cadenas\n    - desactivado si \"PERSISTENT=1\" está configurado en \"config.sh\"\n - se ejecuta como procesos separados (con PID y tuberías de E/S separadas):\n    - validadores de la cadena de relé (es decir, 4 validadores de una revisión estable de Rococo en ejecución)\n    - recolectores para parachain-100 (es decir, un solo recolector para el primer parachain que estás desarrollando)\n    - recolectores para parachain-200 (es decir, un solo recolector para el segundo parachain que estás desarrollando)\n - imprime todos los puntos finales, puertos en la consola, lo que te permite estudiar cualquier cadena utilizando aplicaciones frontend (explorador, DApp)\n - sigue imprimiendo todos los datos de salida de todas las cadenas en la consola\n\n[ADVERTENCIA] Después de iniciar, espera hasta que la red esté activa, asegúrate de que la finalización del bloque haya comenzado y de que los parachains estén registrados. Estos procesos deberían tardar aproximadamente 5 minutos (50 bloques x 6 segundos).\n\n## Comprobando que la configuración inicial funciona \n\nUtiliza el frontend estándar de Polkdot y los puntos finales generados \"--ws-port\" para conectarte con cada nodo.\nAbre [Polkadot application](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) para monitorear las cadenas. \n\n### Ejemplo:\nLocalhost, 4 validadores de cadena de relé, un recolector de parachain-100, un recolector de parachain-200:\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\n\n\nSi todo funciona y el consenso comienza, podemos proceder a ejecutar nuestros casos de prueba (en una nueva terminal).\n\n### Prueba de paso de mensajes UMP\n```bash\n./scripts/init.sh ump\n```\nCrea un mensaje `Balance.transfer` en `parachain-100` y lo pasa a la cadena de relé.\nCuando la cadena de relé recibe el mensaje, transferirá 15 tokens de la cuenta `para 100` a la cuenta de Charlie.\n\n\n### Prueba de paso de mensajes HRMP\n```bash\n./scripts/init.sh ump\n```\n\nCrea un mensaje `Balance.transfer` en `parachain-100` y lo pasa al `sibling 200`.\nAntes de eso, dota a la cuenta `subl 100` con 1000 tokens y establece un canal de comunicación entre las parachains.\n```bash\n./scripts/init.sh hrmp\n```\nLos mensajes siguientes se pueden enviar ejecutando el subcomando `hrmpm`. No crea un canal y, por lo tanto, se ejecuta más rápido.\n```bash\n./scripts/init.sh hrmpm\n```\n\n### Más opciones\n```bash\n./scripts/init.sh help\n```\n\n## Testnet local\n\n### Crear especificación de cadena personalizada\n```\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\n```\n\nEditar rococo_local.json, reemplazar los parámetros de saldos y autoridades con los tuyos.\n```json\n  \"keys\": [\n    [\n      \"\",\n      \"\",\n      {\n        \"grandpa\": \"\",\n        \"babe\": \"\",\n        \"im_online\": \"\",\n        \"para_validator\": \"\",\n        \"para_assignment\": \"\",\n        \"authority_discovery\": \"\"\n      }\n    ]\n```\n\nDirección de Polkadot para //Alice//stash (criptografía sr25519).\n```bash\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\n```\n\n```text\nSecret Key URI `//Alice//stash` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nClave de sesión de Polkadot grandpa para //Alice (criptografía ed25519).\n```bash\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nDirección de Polkadot para //Alice (criptografía sr25519).\n```\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\n```\n```text\nSecret Key URI `//Alice` is account:\nSecret seed:      \n\nPublic key (hex): \n\nAccount ID:       \n\nSS58 Address:     \n```\n\nConvertir rococo_local.json al formato sin procesar.\n```\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\n```\nPara usar una nueva especificación de cadena, reemplaza el archivo rococo.json en el directorio ./config/ con este nuevo y vuelve a ejecutar la cadena.\n```bash\n./scripts/init.sh run\n```\nPuedes editar libremente el código. El comando anterior reconstruirá el proyecto y actualizará el nodo del colador antes de comenzar.\nCumulus es un software de prelanzamiento que aún está en desarrollo intenso.\nEstamos utilizando un compromiso específico de polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15 18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\n\nPuedes usar versiones más recientes del software. Para hacer esto, cambia POLKADOT_COMMIT en ./scipt/config.sh\nal último compromiso de la rama `rococo-v1`, elimina ./bin/polkadot y ejecuta \n```bash\n./scripts/init.sh run\n```\n\nActualizar dependencias del proyecto del colador \n```bash\ncargo update\n./scripts/init.sh build\n```\nEs probable que algunas dependencias requieran nuevas características de la cadena de herramientas de Rust. Este proyecto se basa en Rust `nightly-2021-01-26`\nActualiza la versión de la cadena de herramientas de Rust en ./scripts/config.sh antes de compilar.\n\n## Hackear parachain\n[Agregar paleta externa](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - ¿debería estar probablemente en \"más información\"?\n## Learn More\n\nConsulta la [Plantilla de Nodo del Hub de Desarrolladores de Substrate](https://github.com/substrate-developer-hub/substrate-node-template) para obtener más información sobre la estructura de este proyecto, las capacidades que encapsula y la forma en que se implementan esas capacidades. Puedes obtener más información sobre [El camino de un bloque de parachain](https://polkadot.network/the-path-of-a-parachain-block/) en el blog oficial de Polkadot. [Taller de Paridad Cumulus](https://substrate.dev/cumulus-workshop/#/)\n","tools":[],"fileInfo":{"path":"es/xcm-robobank.md","name":"xcm-robobank"}}},"context":{}}