{"hash":"2310785970cc94a8f6e745a2fc6ad60f7447cafd","data":{"doc":{"id":"be4c0d5977a0e3ed65555c7edea3087c","title":"Configuración e instalación de software de Gaka-Chu","description":"","contributors":["PaTara43"],"headings":[],"subtitles":[{"depth":2,"value":"Instalación de software en KRC4","anchor":"#instalación-de-software-en-krc4"},{"depth":2,"value":"Instalación de software en NUC","anchor":"#instalación-de-software-en-nuc"},{"depth":2,"value":"Rellenando constantes","anchor":"#rellenando-constantes"},{"depth":2,"value":"Calibrando Gaka-Chu","anchor":"#calibrando-gaka-chu"},{"depth":2,"value":"Probando la calibración de Gaka-Chu","anchor":"#probando-la-calibración-de-gaka-chu"},{"depth":2,"value":"Haciendo arte","anchor":"#haciendo-arte"},{"depth":3,"value":"Interfaz Eki","anchor":"#interfaz-eki"},{"depth":3,"value":"RViz y MOVEit","anchor":"#rviz-y-moveit"},{"depth":3,"value":"Entorno","anchor":"#entorno"},{"depth":3,"value":"Procesador de imágenes","anchor":"#procesador-de-imágenes"},{"depth":3,"value":"Dibujante de trayectorias","anchor":"#dibujante-de-trayectorias"},{"depth":2,"value":"Envía al robot una imagen para dibujar","anchor":"#envía-al-robot-una-imagen-para-dibujar"}],"content":"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**En este artículo repasaremos algunos pasos de instalación y lanzamiento para configurar un robot pintor. Requisitos:**\n- KUKA KR6 R900 sixx con KRC4 y un SmartPad;\n- Intel NUC con [ROS melodic](http://wiki.ros.org/melodic/Instalaration/Ubuntu) instalado;\n- Mesa, pintura, pincel, agua.\n\n## Instalación de software en KRC4\nSe requiere la interfaz EKI tanto en KRC4 como en NUC. Se presenta información detallada sobre cómo configurarlo en KRC4 [aquí](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Lanzarlo en el controlador del robot.\n\n## Instalación de software en NUC\nCrear un espacio de trabajo de catkin:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nDescargar paquetes de ROS. Todos los scripts se almacenan [aquí](https://github.com/airalab/robot_painter/tree/test_branch). Clonar el repositorio:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nEs posible que necesite algunos archivos de encabezado y bibliotecas para que todo funcione correctamente. Descárguelos:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAgregar el comando de origen al archivo `.bashrc`:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nHasta ahora, debería poder lanzar los scripts. Si algo sale mal, intente algunas [soluciones](https://github.com/airalab/robot_painter/issues)\n\n## Rellenando constantes\nEn primer lugar, el robot necesita conocer la ubicación y orientación del lienzo, así como la posición del bote de pintura. Todo esto se especifica en `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Echemos un vistazo.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nEstas son las constantes de la ecuación del plano que especifican la posición del lienzo en el espacio tridimensional. Se deben obtener durante un proceso de calibración que se describe a continuación. A continuación, viene la pintura.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nEstas son las coordenadas del bote de pintura. También se pueden especificar durante la calibración. El tamaño del lienzo se especifica en\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nVarias constantes importantes más se almacenan en `local_task_planner/src/Drawing.cpp`:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nSus nombres lo dicen todo, así que complételos según la situación.\n\n## Calibrando Gaka-Chu\nEl proceso de calibración en sí es bastante simple.\n\n1) Inicie la interfaz EKI en el KRC4:\n\nInicie sesión en el modo 'AUT', encienda los controladores y ejecute el script `eki_hw_interface`\n\n2) Inicie la interfaz EKI en el NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nDebería mostrar registros infinitos.\n\n3) Inicie RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nDebería ver lo siguiente:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nIntente mover el efector final y hacer clic en 'Planificar y ejecutar'. El robot debería moverse. En SmartPad, vaya a **Mostrar -> Posición actual** y observe las coordenadas del efector final. Coloque un lienzo horizontalmente en la base del robot. Conecte un pincel al soporte del pincel y muévalo cuidadosamente hasta que apenas toque el lienzo. En esta posición, guarde las coordenadas del efector final. Repita 12-15 veces. Además, guarde las coordenadas del centro del lienzo y del bote de pintura.\nCuando tenga un conjunto de coordenadas, use [estos](https://github.com/nakata5321/Matlab_scripts_gaka-chu) scripts de Matlab para resolver las constantes y cuaternión faltantes. Péguelos. Reconstruya su espacio de trabajo con\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Probando la calibración de Gaka-Chu\nUna vez calibrado, Gaka-Chu debe ser probado dibujando los bordes del lienzo. Para hacerlo, ejecute cada uno en una nueva terminal:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nDespués de esto, debería ver un contorno del lienzo en RViz:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nEn la terminal, presione \"S\" para realizar la prueba. El efector final del robot debería moverse justo encima de los bordes del lienzo y el pincel debería tocar suavemente el lienzo durante todo el movimiento. Si no es así, intente recalibrar. Si el modelo del lienzo está girado incorrectamente, puede girarlo cambiando el cuaternión en Matlab.\n\n## Haciendo arte\nNecesitas 6 módulos básicos para que todo funcione:\n- Interfaz EKI;\n- MOVEit + RViz;\n- Transmisión de marcos de entorno;\n- Servicio de conversión de imágenes;\n- Módulo de dibujo de trayectorias;\n- Disparador de inicio.\n\nVamos a lanzarlos uno por uno.\n\n### Interfaz Eki\nEn KRC4, inicie `eki_hw_interface`, en NUC en una nueva terminal haga:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz y MOVEit\nNecesitas un planificador y una simulación. Lánzalos con\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Entorno\nIndique al robot dónde se encuentra el bote de pintura y el lienzo. Tenga en cuenta que no es necesario lanzar el nodo `draw workspace`, el `tf_broadcaster` comparte el tamaño del lienzo. Simplemente no lo muestra en RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Procesador de imágenes\nTodas las imágenes entrantes deben ser procesadas. Lanza el servicio.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nCuando recibe la llamada, procesa una imagen con un filtro HP y crea un archivo rosbag con trayectorias.\n\n### Dibujante de trayectorias\nEl script principal aquí es el propio dibujante de trayectorias. Espera la imagen, llama al servicio TextConverter y dibuja la pintura.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Envía al robot una imagen para dibujar\nEl robot escucha un tópico específico de ROS donde debes pasar la ruta a una imagen deseada. La imagen debe ser cuadrada (ancho igual a alto) y estar compuesta por líneas. Envía la ruta:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nDespués de eso, aparecen dos ventanas mostrando los contornos y las pistas. Ciérralas y observa a Gaka-Chu dibujando. Ten cuidado con la seguridad y siempre esté listo para presionar el botón de parada de emergencia.\nCuando Gaka-Chu termina su arte, puedes enviar otra ruta de imagen y el pintor repite todo el proceso.\n","tools":[],"fileInfo":{"path":"es/gaka-chu.md","name":"gaka-chu"}}},"context":{}}