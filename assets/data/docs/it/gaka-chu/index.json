{"hash":"374e5e6bd3c921ba1dd42a764de57557a5b04902","data":{"doc":{"id":"cff303df9c292ca567842cc9c1eaa4b0","title":"Configurazione e installazione del software Gaka-Chu","description":"","contributors":["PaTara43"],"headings":[],"subtitles":[{"depth":2,"value":"Installazione del software su KRC4","anchor":"#installazione-del-software-su-krc4"},{"depth":2,"value":"Installazione del software su NUC","anchor":"#installazione-del-software-su-nuc"},{"depth":2,"value":"Compilazione delle costanti","anchor":"#compilazione-delle-costanti"},{"depth":2,"value":"Calibrazione di Gaka-Chu","anchor":"#calibrazione-di-gaka-chu"},{"depth":2,"value":"Test della calibrazione di Gaka-Chu","anchor":"#test-della-calibrazione-di-gaka-chu"},{"depth":2,"value":"Creazione di arte","anchor":"#creazione-di-arte"},{"depth":3,"value":"Interfaccia Eki","anchor":"#interfaccia-eki"},{"depth":3,"value":"RViz e MOVEit","anchor":"#rviz-e-moveit"},{"depth":3,"value":"Ambiente","anchor":"#ambiente"},{"depth":3,"value":"Processore di immagini","anchor":"#processore-di-immagini"},{"depth":3,"value":"Disegnatore di traiettorie","anchor":"#disegnatore-di-traiettorie"},{"depth":2,"value":"Invia al robot un'immagine da disegnare","anchor":"#invia-al-robot-unimmagine-da-disegnare"}],"content":"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**In questo articolo passeremo attraverso alcuni passaggi di installazione e avvio per configurare un robot pittore. Requisiti:**\n- KUKA KR6 R900 sixx con KRC4 e SmartPad;\n- Intel NUC con [ROS melodic](http://wiki.ros.org/melodic/Installaation/Ubuntu) installato;\n- Tavolo, vernice, pennello, acqua.\n\n## Installazione del software su KRC4\nÈ necessaria l'interfaccia EKI sia su KRC4 che su NUC. Le informazioni dettagliate su come configurarla su KRC4 sono presentate [qui](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Avviala sul controller del robot.\n\n## Installazione del software su NUC\nCrea uno spazio di lavoro catkin:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nScarica i pacchetti ROS. Tutti gli script sono archiviati [qui](https://github.com/airalab/robot_painter/tree/test_branch). Clona il repository:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nPotrebbe essere necessario scaricare alcuni file di intestazione e librerie per far funzionare tutto correttamente. Scaricali:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAggiungi il comando di origine al file `.bashrc`:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nFinora dovresti essere in grado di avviare gli script. Se qualcosa va storto, prova a risolvere alcuni [problemi](https://github.com/airalab/robot_painter/issues)\n\n## Compilazione delle costanti\nInnanzitutto, il robot deve conoscere la posizione e l'orientamento della tela e la posizione del barattolo di vernice. Tutto ciò è specificato in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Diamo un'occhiata.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nQueste sono le costanti dell'equazione del piano che specificano la posizione della tela nello spazio tridimensionale. Devono essere ottenute durante un processo di calibrazione descritto di seguito. Successivamente viene la vernice.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nQueste sono le coordinate del barattolo di vernice. Possono anche essere specificate durante la calibrazione. Le dimensioni della tela sono specificate in\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nAltre costanti importanti sono archiviate in `local_task_planner/src/Drawing.cpp`:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nI loro nomi dicono tutto, quindi compilali in base alla situazione.\n\n## Calibrazione di Gaka-Chu\nIl processo di calibrazione stesso è piuttosto semplice.\n\n1) Avvia l'interfaccia EKI su KRC4:\n\nAccedi in modalità 'AUT', accendi i driver e avvia lo script `eki_hw_interface`\n\n2) Avvia l'interfaccia EKI su NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nDovrebbe produrre log infiniti.\n\n3) Avvia RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nDovresti vedere quanto segue:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nProva a muovere l'effettore terminale e fare clic su 'Pianifica ed esegui'. Il robot dovrebbe muoversi. Sul SmartPad vai su **Visualizza -> Posizione effettiva** e osserva le coordinate dell'effettore terminale. Posiziona una tela in posizione orizzontale rispetto alla base del robot. Inserisci un pennello nel supporto del pennello e spostalo delicatamente fino a quando tocca appena la tela. In questa posizione, salva le coordinate dell'effettore terminale. Ripeti 12-15 volte. Salva anche le coordinate del centro della tela e del barattolo di vernice.\nQuando hai un insieme di coordinate, utilizza [questi](https://github.com/nakata5321/Matlab_scripts_gaka-chu) script Matlab per risolvere le costanti e il quaternione mancanti. Incollali. Ricostruisci il tuo spazio di lavoro con\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Test della calibrazione di Gaka-Chu\nQuando è calibrato, Gaka-Chu deve essere testato disegnando i bordi della tela. Per farlo, esegui ognuno in un nuovo terminale:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nDopo questo, dovresti vedere un contorno della tela in RViz:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nNel terminale premi \"S\" per eseguire il test. L'effettore terminale del robot dovrebbe muoversi proprio sopra i bordi della tela e il pennello dovrebbe toccare delicatamente la tela durante tutto il movimento. Se non è così, prova a ricalibrare. Se il modello della tela è ruotato in modo errato, puoi ruotarlo cambiando il quaternione in Matlab.\n\n## Creazione di arte\nHai bisogno di 6 moduli di base per far funzionare tutto:\n- Interfaccia EKI;\n- MOVEit + RViz;\n- Trasmissione dei frame dell'ambiente;\n- Servizio di conversione delle immagini;\n- Modulo di disegno delle traiettorie;\n- Trigger di avvio.\n\nLanciamoli uno per uno.\n\n### Interfaccia Eki\nSu KRC4 avvia `eki_hw_interface`, su NUC in un nuovo terminale fai:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz e MOVEit\nHai bisogno di un pianificatore e di una simulazione. Avviali con\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Ambiente\nIndica al robot dove si trovano il barattolo di vernice e la tela. Nota che non è necessario avviare il nodo `draw workspace`, il `tf_broadcaster` condivide le dimensioni della tela. Non le mostra solo in RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Processore di immagini\nTutte le immagini in ingresso devono essere elaborate. Avvia il servizio.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nQuando riceve la chiamata, elabora un'immagine con un filtro HP e crea un file rosbag con le traiettorie.\n\n### Disegnatore di traiettorie\nLo script principale qui è il disegnatore di traiettorie stesso. Aspetta l'immagine, chiama il servizio TextConverter e disegna il dipinto.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Invia al robot un'immagine da disegnare\nIl robot ascolta un ROS-topic specifico dove devi passare il percorso di un'immagine desiderata. L'immagine dovrebbe essere quadrata (larghezza uguale altezza) e composta da linee. Invia il percorso:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nDopo di che, due finestre si aprono mostrando i contorni e le tracce. Chiudile e guarda Gaka-Chu disegnare. Stai attento alla sicurezza e sii sempre pronto a premere il pulsante di arresto di emergenza.\nQuando Gaka-Chu finisce la sua arte, puoi inviare un altro percorso per l'immagine e il pittore ripete l'intero processo.\n","tools":[],"fileInfo":{"path":"it/gaka-chu.md","name":"gaka-chu"}}},"context":{}}