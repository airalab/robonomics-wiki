(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[12],{

/***/ "A2fM":
/*!**********************************************************************************!*\
  !*** ./src/components/Search.vue?vue&type=custom&index=0&blockType=static-query ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_14_0_node_modules_gridsome_lib_plugins_vue_components_lib_loaders_static_query_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_custom_index_0_blockType_static_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib??ref--14-0!../../node_modules/gridsome/lib/plugins/vue-components/lib/loaders/static-query.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib??vue-loader-options!./Search.vue?vue&type=custom&index=0&blockType=static-query */ \"r2nM\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_14_0_node_modules_gridsome_lib_plugins_vue_components_lib_loaders_static_query_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_custom_index_0_blockType_static_query__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/components/Search.vue?");

/***/ }),

/***/ "AmrW":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??ref--2-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--2-oneOf-1-2!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Search.vue?vue&type=style&index=0&id=667ceb10&prod&scoped=true&lang=css ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/components/Search.vue?./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??ref--2-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--2-oneOf-1-2!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "Umzq":
/*!*****************************************************************************!*\
  !*** ./src/components/Search.vue?vue&type=template&id=667ceb10&scoped=true ***!
  \*****************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_gridsome_cacheIdentifier_524ceff2_vue_loader_template_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_babel_loader_lib_index_js_ref_1_1_node_modules_vue_loader_lib_loaders_templateLoader_js_ref_6_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_template_id_667ceb10_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/gridsome\",\"cacheIdentifier\":\"524ceff2-vue-loader-template\"}!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/babel-loader/lib??ref--1-1!../../node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib??vue-loader-options!./Search.vue?vue&type=template&id=667ceb10&scoped=true */ \"aB1D\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_gridsome_cacheIdentifier_524ceff2_vue_loader_template_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_babel_loader_lib_index_js_ref_1_1_node_modules_vue_loader_lib_loaders_templateLoader_js_ref_6_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_template_id_667ceb10_scoped_true__WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_gridsome_cacheIdentifier_524ceff2_vue_loader_template_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_babel_loader_lib_index_js_ref_1_1_node_modules_vue_loader_lib_loaders_templateLoader_js_ref_6_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_template_id_667ceb10_scoped_true__WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/components/Search.vue?");

/***/ }),

/***/ "YlIy":
/*!***********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/babel-loader/lib??ref--1-1!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Search.vue?vue&type=script&lang=js ***!
  \***********************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data() {\n    return {\n      isActive: false,\n      isFocused: false,\n      search: ''\n    };\n  },\n  computed: {\n    toggleClasses() {\n      return {\n        'active': this.isActive\n      };\n    },\n    searchResults() {\n      if (this.search.length > 2) {\n        return this.$static.allDocPage.edges.filter(post => {\n          return (post.node.title.toLowerCase().includes(this.search.toLowerCase().trim()) || post.node.content.toLowerCase().includes(this.search.toLowerCase().trim())) & post.node.path != this.$route.matched[0].path + '/';\n        });\n      } else return '';\n    }\n  },\n  methods: {\n    focusIn() {\n      this.isActive = true;\n    },\n    focusOut() {\n      this.isActive = false;\n    }\n\n    // SearchLinksFocus() {\n    //   document.querySelector('.search-container nav a:first-child').focus()\n    // }\n  },\n\n  watch: {\n    \"$route.path\": function () {\n      this.isActive = false;\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/components/Search.vue?./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/babel-loader/lib??ref--1-1!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "aB1D":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/gridsome","cacheIdentifier":"524ceff2-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/babel-loader/lib??ref--1-1!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Search.vue?vue&type=template&id=667ceb10&scoped=true ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function render() {\n  var _vm = this,\n    _c = _vm._self._c;\n  return _c('div', {\n    staticClass: \"search-container\",\n    class: _vm.toggleClasses,\n    attrs: {\n      \"tabindex\": \"0\"\n    },\n    on: {\n      \"focusin\": _vm.focusIn,\n      \"focusout\": _vm.focusOut\n    }\n  }, [_c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: _vm.search,\n      expression: \"search\"\n    }],\n    attrs: {\n      \"type\": \"search\",\n      \"aria-label\": \"Search\",\n      \"placeholder\": _vm.$t('Search')\n    },\n    domProps: {\n      \"value\": _vm.search\n    },\n    on: {\n      \"input\": function ($event) {\n        if ($event.target.composing) return;\n        _vm.search = $event.target.value;\n      }\n    }\n  }), _vm.searchResults.length > 0 ? _c('div', {\n    staticClass: \"searchresults\",\n    attrs: {\n      \"role\": \"listbox\"\n    }\n  }, [_c('div', {\n    staticClass: \"layout__content\"\n  }, [_c('div', {\n    staticClass: \"search-msg-count\",\n    attrs: {\n      \"aria-hidden\": \"true\"\n    }\n  }, [_vm._v(_vm._s(_vm.$t('Found results:')) + \" \" + _vm._s(_vm.searchResults.length))]), _c('nav', _vm._l(_vm.searchResults, function (post) {\n    return _c('g-link', {\n      key: post.node.id,\n      attrs: {\n        \"to\": post.node.path\n      },\n      on: {\n        \"focusout\": _vm.SearchLinksNextFocus\n      }\n    }, [_vm._v(_vm._s(post.node.title))]);\n  }), 1)])]) : _vm._e()]);\n};\nvar staticRenderFns = [];\n\n\n//# sourceURL=webpack:///./src/components/Search.vue?./node_modules/cache-loader/dist/cjs.js?%7B%22cacheDirectory%22:%22node_modules/.cache/gridsome%22,%22cacheIdentifier%22:%22524ceff2-vue-loader-template%22%7D!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/babel-loader/lib??ref--1-1!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "abJ6":
/*!***********************************************************!*\
  !*** ./src/components/Search.vue?vue&type=script&lang=js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_babel_loader_lib_index_js_ref_1_1_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/babel-loader/lib??ref--1-1!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib??vue-loader-options!./Search.vue?vue&type=script&lang=js */ \"YlIy\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_babel_loader_lib_index_js_ref_1_1_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/components/Search.vue?");

/***/ }),

/***/ "r2nM":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--14-0!./node_modules/gridsome/lib/plugins/vue-components/lib/loaders/static-query.js!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Search.vue?vue&type=custom&index=0&blockType=static-query ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"Kw5r\");\nconst{computed}=vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].config.optionMergeStrategies;const data={\"allDocPage\":{\"edges\":[{\"node\":{\"id\":\"d88dfcda9729b980d6ff9ed1b5dda545\",\"title\":\"Глобальное управление\",\"path\":\"/docs/ru/global-administration/\",\"content\":\"\\n**Эта статья покажет вам, как настроить нового пользователя в Home Assistant.**\\n\\n## Добавление пользователей в подписку\\n\\nВы не можете использовать ранее созданные учетные записи, потому что `SUB_OWNER` и `SUB_CONTROLLER` обеспечивают безопасность, и первый пользователь, которого вы создали при первом запуске Home Assistant, не имеет учетной записи Robonomics Parachain.\\n\\n1. Создайте учетную запись на Robonomics parachain, как вы делали в [предыдущей статье](/docs/sub-activate/).\\n\\n2. Используя учетную запись `SUB_OWNER`, добавьте новую учетную запись пользователя в подписку в [dapp](https://dapp.robonomics.network/#/subscription/devices). Теперь в списке доступа должно быть три адреса: `SUB_OWNER`, `SUB_CONTROLLER` и `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Предоставление доступа пользователю\\n\\n1. Перейдите на службу dapp с названием [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Выберите учетную запись, которую вы только что создали, в правой боковой панели (убедитесь, что вы выбрали нужную учетную запись, нажав на значок профиля).\\n\\n2. Введите `USER` seed в соответствующее поле. Добавьте адреса `SUB_OWNER` и `SUB_CONTROLLER` в поля администраторских кредитов. Если все верно, вы увидите статус проверки `VERIFIED`.\\n\\n3. Создайте пароль для нового пользователя, которого вы только что зарегистрировали, а затем подтвердите транзакцию, которая теперь будет без комиссии из-за подписки. Позже вы сможете восстановить пароль во вкладке Восстановление.\\n\\n4. После процесса регистрации войдите в Home Assistant с помощью вашего адреса пользователя в качестве логина и только что созданного пароля.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nТеперь вы можете использовать dapp для управления своим домом через Robonomics, ознакомьтесь с статьей [**\\\"Получение телеметрии умного дома\\\"**](/docs/smart-home-telemetry/).\\n\\n## Устранение неполадок\\n\\n1. Если вы забыли пароль к Home Assistant от своей учетной записи Робономики, [проверьте Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nПерейдите в раздел \\\"Your Home Assistant password\\\" и выберите вкладку \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"2281fdb745d7e29a8823156c6dfaff33\",\"title\":\"Cómo enviar un lanzamiento con suscripción\",\"path\":\"/docs/es/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Preste atención que este tutorial demuestra cómo usar una suscripción en la parachain de Robonomics Kusama. También puede realizar todos los mismos pasos en su [nodo local](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nSi su dirección tiene una suscripción activa, entonces cualquier dispositivo configurado con la cuenta secreta de esa cuenta puede enviar extrínsecos sin cargo. \\nIntentemos enviar el comando `launch`.\\n\\nVaya a la página `Developer/Extrinsics`, luego elija su cuenta (la de la lista de dispositivos) y seleccione `rws -> call(subscriptionId, call)`. Luego, en el campo `subscriptionId`, pegue la dirección del propietario de la suscripción (quien realizó la oferta en la subasta) y en el siguiente campo elija `launch -> launch(robot, param)`. En el campo `robot`, escriba la dirección a la que desea enviar la transacción `launch` e inserte el comando (para obtener una descripción del comando de lanzamiento, consulte [aquí](/docs/launch)). Luego, envíe la transacción: \\n\\n![launch](../images/rws/launch.png)\\n\\n\\nAhora ve a la página `Network/Explorer` y en el área de `Recent Events` verás dos eventos que creaste: `rws.NewCall` y `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"0e7d03ccecae7f856d4b3d0b6ecb9d1d\",\"title\":\"Substrate Cumulus Parachain Testsuite for cross-chain messaging\",\"path\":\"/docs/zh/xcm-robobank/\",\"content\":\"\\n\\n该项目的主要目标是简化平行链运行时开发，当使用跨链消息时。 \\n它允许使用高度可重复性和简单使用的集成测试开发运行时代码。\\n它自动构建、构建预设网络配置（即1个中继链+2个平行链）、设置平行链之间的消息传递通道并运行消息测试、发送消息、使用对运行时的调用，所有这些都是在Python中构建和组合的。\\n\\nXCM测试套件用于测试Robobank的生产周期-一组Substrate托盘，允许机器人在外部平行链上注册、接收预付订单、执行订单并使用外部代币收款。这使得机器人可以在Robonomics网络内运行，并提供其服务于任何其他平行链。\\n\\n示例视频可在[YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)上找到。\\n\\n演示场景中的主要步骤是：\\n- 启动一个包含6个进程的中继链和两个平行链的组合\\n- 在平行链之间设置XCM消息通道\\n- 在两个平行链中注册一个机器人\\n- 在客户端平行链中为该机器人创建一个订单（为订单完成保留付款）\\n- 向Robonomics平行链发送XCM消息\\n- 在Robonomics平行链上创建\\\"镜像\\\"订单记录\\n- 机器人在Robonomics平行链上接受订单\\n- 将有关订单接受的XCM消息发送回客户端平行链\\n- 在客户端平行链上接受订单（为订单未完成保留罚款费用，直到订单截止日期）\\n- 机器人在Robonomics平行链上完成订单\\n- 将有关订单完成的XCM消息发送到客户端平行链\\n- 结算所有付款（客户付款转给机器人，未使用罚款费用也转给机器人）\\n- 关闭订单1\\n\\n\\n## 上游\\n该项目是\\\"substrate-node-template\\\"的一个分支\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\n它包含正在测试的运行时托盘的代码。\\n与原始节点代码的区别在于，平行链的代码位于\\\"./pallets\\\"、\\\"./runtime\\\"、\\\"./node\\\"目录中。\\n\\n与原始的\\\"substrate-node-template\\\"的区别：\\n- 此收集器运行时具有HRMP处理程序模块，并且可以处理来自兄弟平行链的消息\\n- 为内部XCM测试准备的模拟测试运行时\\n\\n## 构建和运行\\n推荐（强烈）设置： \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[注意]第一次构建可能需要很长时间，最多几个小时在非最佳的机器上。\\n\\n[注意]脚本使用Polkadot（Rococo）的固定版本（提交哈希）在中继链和平行链中。\\n\\n[注意]默认情况下，脚本在每次启动时都会重新创建相同的环境，删除所有先前的状态。可以在\\\"config.sh\\\"中使用\\\"PERSISTENT\\\"参数更改此行为。\\n\\n\\n运行构建和设置脚本。  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\n\\\"init.sh\\\"脚本的基本操作：\\n - 读取配置（文件\\\"config.sh\\\"，包括修订号、初始节点密钥和标识符、链数据持久性参数等）\\n - 设置操作系统包、Rust和Python\\n - 为中继链和两个平行链构建单独的二进制文件\\n    - 二进制文件将生成在./bin子目中。 \\n - （可选）删除所有链的先前链数据\\n    - 如果在\\\"config.sh\\\"中设置了\\\"PERSISTENT=1\\\"，则禁用\\n - 作为单独的进程运行（具有单独的PID和I/O管道）：\\n    - 中继链的验证者（即运行稳定的Rococo修订版的4个验证者）\\n    - 用于平行链-100的收集器（即第一个正在开发的平行链的单个收集器）\\n    - 用于平行链-200的收集器（即第二个正在开发的平行链的单个收集器）\\n - 将所有链的所有端点、端口打印到控制台，允许您使用前端应用程序（浏览器、DApp）研究任何链\\n - 将所有链的所有输出数据持续打印到控制台\\n\\n[警告]启动后，请等待网络启动，确保块最终化已开始，并且平行链已注册。这些过程应该需要大约5分钟（50个块x 6秒）。\\n\\n## 检查初始设置是否正常工作 \\n\\n使用标准的Polkdot前端和生成的\\\"--ws-port\\\"端点连接到每个节点。\\n打开[Polkadot应用程序](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)以监视链。 \\n\\n### 示例：\\n本地主机，4个中继链验证者，一个平行链-100收集器，一个平行链-200收集器：\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\n如果一切正常，并且共识已经开始，我们可以继续运行我们的测试用例（在新的终端中）。\\n\\n### UMP消息传递测试\\n```bash\\n./scripts/init.sh ump\\n```\\n它在`parachain-100`中创建一个`Balance.transfer`消息，并将其传递给中继链。\\n当中继链接收到消息时，它将从`para 100`账户向Charlie账户转15个代币。\\n\\n\\n### HRMP消息传递测试\\n```bash\\n./scripts/init.sh ump\\n```\\n\\n它在`parachain-100`中创建一个`Balance.transfer`消息，并将其传递给`sibling 200`。\\n在此之前，它将`subl 100`账户赋予1000个代币，并在平行链之间建立通信通道。\\n```bash\\n./scripts/init.sh hrmp\\n```\\n下一条消息可以通过运行`hrmpm`子命令发送。它不会创建通道，因此运行速度更快。\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### 更多选项\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## 本地测试网络\\n\\n### 创建自定义链规范\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\n编辑rococo_local.json，用您自己的余额和权限参数替换它们。\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\n用于//Alice//stash的Polkadot地址（sr25519密码学）。\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\n用于//Alice的Polkadot grandpa会话密钥（ed25519密码学）。\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\n用于//Alice的Polkadot地址（sr25519密码学）。\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\n将rococo_local.json转换为原始格式。\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\n要使用新的链规范，将rococo.json文件替换为./config/目录中的此新文件，并重新运行链。\\n```bash\\n./scripts/init.sh run\\n```\\n您可以自由编辑代码。上述命令将在启动之前重新构建项目并更新整理者节点。\\nCumulus是预发布软件，仍在积极开发中。\\n我们正在使用特定的polkadot提交[46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\n您可以使用更新版本的软件。要做到这一点，请在./scipt/config.sh中更POLKADOT_COMMIT为`rococo-v1`分支的最新提交，删除./bin/polkadot，并运行\\n`rococo-v1`分支的最新提交，删除./bin/polkadot，并运行 \\n```bash\\n./scripts/init.sh run\\n```\\n\\n更新整理者项目依赖项 \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\n某些依赖项可能需要新的rust工具链功能。该项目基于rust `nightly-2021-01-26`\\n在构建之前，请在./scripts/config.sh中更新rust工具链版本。\\n\\n##  黑客平行链\\n[添加外部托盘](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - 可能应该在\\\"了解更多\\\"中？\\n## Learn More\\n\\n有关此项目的结构、封装的功能以及这些功能的实现方式，请参考上游[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template)。您可以在官方Polkadot博客上了解有关[Parachain块的路径](https://polkadot.network/the-path-of-a-parachain-block/)的更多信息。[Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"a02e9448005381afb83f3d3692592785\",\"title\":\"Zigbee适配器与预安装图像的Zigbee2MQTT\",\"path\":\"/docs/zh/zigbee-to-mqtt-image/\",\"content\":\"\\n**在本文中，您将配对智能设备。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\n打开一个网页浏览器，转到`http://%RASPBERRY_IP_ADDRESS%:8099`。您可以使用[Fing移动应用程序](https://www.fing.com/products)或[nmap CLI工具](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)找到树莓派的IP地址。\\n\\n您将看到Zigbee2MQTT的Web界面：\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\n是时候连接您的智能设备了。 \\n首先，在Zigbee2MQTT的Web界面顶部按下`Permit join (All)`按钮。 \\n\\n然后，开始配对设备。将设备切换到连接模式的最常见方法是按住其电源按钮或将其开/关5次。确保Zigbee2MQTT正在运行。\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n设备连接后，您将在Web界面中看到它们：\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\n现在您应该在Home Assistant WebUI中看到此传感器。转到`Settings` -> `Devices & Services` -> `Devices`：\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\n添加完所有传感器后，您可以关闭Zigbee2MQTT的Web界面。\\n\"}},{\"node\":{\"id\":\"2b6f393fa8df2e9e5373274766160936\",\"title\":\"如何使用蓝图\",\"path\":\"/docs/zh/use-blueprints/\",\"content\":\"\\n在本文中，您将了解如何将自动化蓝图添加到您的Home Assistant并进行配置。\\n\\n## 蓝图自动化\\n\\n某些蓝图已经安装。基于这些蓝图的自动化只需要进行配置。在Web界面中，您可以在`Settings/Automations & Scenes`中找到预安装的蓝图。打开`Blueprints`并找到您想要使用的蓝图。在本示例中，将使用`Motion-activated Light`。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\n单击`Create Automation`以打开自动化编辑器。给它命名，选择要使用的蓝图（在我们的例子中是`Motion-activated Light`）。之后，您需要选择运动传感器和灯。配置完成后，单击`Save`。\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation 配置\\\" />\\n\\n如果您想进行更改，可以通过转到`Settings/Automations & Scenes`，然后选择`Automations`来找到它。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## 导入蓝图\\n\\nHome Assistant可以从Home Assistant论坛、GitHub和GitHub gists导入蓝图。所有蓝图的列表位于[蓝图交流](https://community.home-assistant.io/c/blueprints-exchange/53)上。选择后，转到`Settings/Automations & Scenes`，然后打开`Blueprints`。单击`Import Blueprint`，并插入所选蓝图的URL。然后单击`PREVIEW BLUEPRINT`。在这种情况下，我们将使用[所有电池传感器的低电量检测和通知](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664)。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\n这将加载蓝图并在导入对话框中显示预览。您可以更改名称并完成导入。单击`Create Automation`以打开自动化编辑器。在这里，您可以配置自动化的参数并添加操作以获取通知。\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"41e2c92fa3f9bff63f5f1ff316af105f\",\"title\":\"如何通过订阅发送启动命令\",\"path\":\"/docs/zh/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  请注意，本教程演示了在Robonomics Kusama平行链上使用订阅。您也可以在您的[本地节点](/docs/run-dev-node)上执行相同的步骤。\\n\\n</robo-wiki-note>\\n\\n如果您的地址有一个活跃的订阅，那么使用该账户的密钥设置的任何设备都可以免费发送外部交易。 \\n让我们尝试发送`launch`命令。\\n\\n转到`Developer/Extrinsics`页面，然后选择您的账户（设备列表中的账户）并选择`rws -> call(subscriptionId, call)`。 \\n然后在`subscriptionId`字段中粘贴订阅的所有者地址（竞拍者的地址），在下一个字段中选择`launch -> launch(robot, param)`。在`robot`字段中输入您想要发送`launch`交易的地址，并插入命令（有关启动命令的描述，请参阅[此处](/docs/launch)）。然后提交交易：\\n\\n![launch](../images/rws/launch.png)\\n\\n\\n现在转到`Network/Explorer`页面，在`Recent Events`区域中，您将看到您创建的两个事件：`rws.NewCall`和`launch.NewLaunch`：\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"e8ba879561a0c5c1fac9c26ae894b35e\",\"title\":\"订阅激活\",\"path\":\"/docs/zh/sub-activate/\",\"content\":\"\\n在本文中，您将创建Robonomics空投账户并购买物联网订阅。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\n要使用Robonomics控制Home Assistant，您需要在Robonomics空投上拥有2个账户。其中一个账户（`sub_owner`）将购买Robonomics订阅。第二个账户（`sub_controller`）将控制所有Home Assistant进程（如测）并提供其他用户访问权限。这些账户将为您的Home Assistant提供安全保障。 \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\n这两个帐户都必须使用 **ed25519** 加密创建。 因此，您需要使用 Polkadot-JS UI 创建一个帐户并选择所需的加密。\\n\\n此功能在Polkadot-JS UI上默认禁用。要启用它，请导航到`Settings` -> `General` -> `account options`，并在下拉菜单`Allow local in-browser account storage`中选择`in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## 创建所有者和控制者帐户\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. 打开[Robonomics空投应用](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/)，进入Polkadot / Substrate Portal。**检查左上角以确保您已连接到Robonomics空投。**\\n\\n2. 进入`Accounts` -> `Accounts`，点击`Add account`按钮。您将看到带有账户种子的弹出菜单。它有两种形式：*助记词*（可读）和*原始*（一串数字和字母）。 \\n\\n3. 打开`Advanced creation options`，将创建账户的加密类型更改为“Edwards - ed25519”，然后点击`Next`。\\n\\n\\n4. 安全保存助记词种子短语，然后点击`Next`。\\n\\n5. 在下一个菜单中，您需要设置账户名称和密码。为方便起见，给它取名为`sub_owner`。点击`Next`.\\n\\n6. 在最后一个窗口中，点击`Save`以完成账户创建。它还将生成一个备份JSON文件，您应该安全地存储。如果您记得密码，以后可以使用此文件恢复您的账户。\\n\\n7. 为名称为`sub_controller`的户重复这些步骤。\\n\\n\\n## 将账户添加到Polkadot.js\\n\\n为了方便起见，您应该使用[Polkadot.js扩展](https://polkadot.js.org/extension/)并将这些新创建的账户添加到其中。对于ed25519账户，您只能使用备份的JSON文件来完成。您可以使用创建账户时保存的文件。\\n\\n您可以通过创建账户的备份文件再次获取这些文件。点击您的账户上的三个点，选择`Create a backup file for this account` ，然后输入密码。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. 打开扩展，点击右上角的“+”按钮，然后选择Restore account from backup JSON file`。\\n\\n2. 在打开的窗口中上传JSON文件，输入密码，然后点击`Restore`.\\n\\n3. 确保在Polkadot.js扩展中为账户选择了Robonomics网络。在Polkadot / Substrate Portal上，转到`Setting` -> `Metadata` ，然后点击`Update metadata`按钮。 \\n\\n4. 在弹出窗口中确认元数据更新。现在扩展将显示用于该地址的网络标签。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## 激活Robonomics订阅 \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\n在此步骤中，您必须在`sub_owner`账户中拥有足够数量的XRT代币（最少2-3个XRT）。\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. 前往Robonomics dapp的[订阅页面](https://dapp.robonomics.network/#/subscription)，然后在右侧边栏点击“连接账户”。\\n\\n2. 在接下来的弹出菜单中连接Polkadot.js扩展。您将看到带有余额的账户地址。\\n\\n3. 在购买之前，请检查您选择了`sub_owner`账户。点击地址配置文件图标，您应该在`Check owner account`字段下看到`sub_owner`账户。\\n\\n4. 最后，点击`SUBMIT`按钮并输入您的账户密码。然后等待激活过程完成。过一段时间后，您将看到订阅的状态。\\n\\n\\n## 将账户添加到订阅\\n\\n现在您需要将“sub_controller”帐户添加到**访问列表**。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. 打开扩展，并点击账户名称旁边的图标。它将复制账户地址。\\n\\n\\n2. 将此地址粘贴到**管理访问**部分的“Robonomics空投地址`Robonomics parachain address` +”按钮。 \\n\\n3. 重复步骤1和2，为`sub_owner`账户执行。\\n\\n4. 点击`Save`。在弹出窗口中输入您的`sub_owner`密码，然后等待激活过程完成。\\n\"}},{\"node\":{\"id\":\"f2e8d594bf3a499246f26413533cb31c\",\"title\":\"获取智能家居遥测数据\",\"path\":\"/docs/zh/smart-home-telemetry/\",\"content\":\"\\n**在本文中，您将使用Robonomics服务查询智能家居设备的遥测数据。**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. 进入dapp并选择[智能家居遥测](https://dapp.robonomics.network/#/smarthome-telemetry)服务。\\n\\n2. 在控制器字段中输入`SUB_CONTROLLER`地址。插入种子短语以加密数据。\\n\\n3. 在`Get telemetry`区块中选择一个时间戳并点击`DOWNLOAD TELEMETRY`按钮。\\n\\n4. 遥测数据下载可能需要一些时间。下载完成后，您将看到来自设备和传感器的信息。\\n\\n\\n<!---\\n## 启动 devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"启动\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"fa389498cd3d116fb03cbabe6ea98f7b\",\"title\":\"Robonomics SLS 网关\",\"path\":\"/docs/zh/sls-gateway/\",\"content\":\"\\n**在本文中，您将设置 Robonomics SLS 网关。您将安装网关所需的软件，配置它并将其连接到 Home Assistant。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## 固件\\n\\n首先，您需要安装网关的微控制器固件。通过将 SLS 网关底部的开关 `1` 和 `3` 设置为 `ON`，其他开关必须设置为 `OFF` 来准备网关。\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\n通过网关上的 USB Type-C 端口将网关连接到您的 Raspberry Pi。\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\n将固件的存储库克隆到您的 Raspberry Pi 上：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\n转到 `robonomics-hass-utils/esp_firmware/linux`。要刷新 SLS 网关，您需要运行 `Clear` 和 `Flash_16mb` 脚本。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### 故障排除\\n\\n如果您在更新网关固件时遇到问题，您需要采取其他步骤：\\n\\n1. 确保您已安装 pySerial 模块：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. 为您的用户授予对 USB 端口的访问权限并重新启动计算机：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. 在某些情况下，需要更改脚本中的带宽设置以更新固件。使用 `nano` 编辑器打开 `Flash_16mb.sh` 脚本，并将波特率参数从 `921600` 更改为较小的值（例如 `115200`）。\\n\\n## 配置\\n\\n1. 从计算机断开 SLS 网关。将网关背面的开关设置为正确的位置。开关 `5`（RX Zigbee 到 ESP）和 `6`（TX Zigbee 到 ESP）必须处于 `ON` 位置，其他开关必须设置为 `OFF`。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. 连接 Type-C 电源电缆。中心的指示灯应变为绿色。\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. 在首次启动时，网关将开始共享 Wi-Fi，SSID 为 `zgw****`。连接到此网络。请注意，信号可能相当弱，因此最好将 SLS 网关靠近您的计算机。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. 如果连接成功，将打开 Web 界面（或您可以在 192.168.1.1 地址上找到它）。 \\n\\n5. 您将看到 `Wi-Fi Settings` 页。选择您的 Wi-Fi 并输入密码。按下 `Apply` 按钮。网关将重新启动并连接到您的 Wi-Fi 网络。 \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. 找到 SLS 网关的本地 IP 以访问 Web 界面。您可以使用 [Fing 移动应用](https://www.fing.com/products) 或 [nmap CLI 工具](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) 来查找它。网关名称应该类似于 `zgw****`。通过将网关 IP 粘贴到浏览器中，打开网关的 Web 界面。\\n\\n7. 转到 `Setting` -> `Hardware`，确保设置与图像上的设置相同。如有必要，请更正设置并单击 `Save` 按钮：\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\n所需值的表格：\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. 然后重新启动网关。在右上角选择 `Actions` -> `Reboot system`。\\n\\n9. 确保网关在 Zigbee 信息窗口中正常工作。DeviceState 应为 `OK`。\\n\\n10. 自动配置将设备添加到 Home Assistant。转到 `Zigbee` -> `Config`，然后选择 `Home Assistant MQTT Discovery` 和 `Clear States`。保存更改，然后再次 **重新启动** SLS 网关。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n如果您家中已经有一个活动的 SLS 网关，并且您现在正在配置另一个网关，则它们将互相冲突。要解决此问题，您需要更改新设备上的信道。为此，请转到 `Zigbee` -> `Config` 并将信道更改为其他信道（例如信道 15）。\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## 将 SLS 配对到 MQTT\\n\\n在配置 SLS 网关之后，您需要将 SLS 网关连接到 Home Assistant。打开 SLS 网关的 Web 界面，然后转到 `Settings/Link` -> `MQTT Setup`：\\n\\n\\n添加您的代理地址（本地网络中具有 Home Assistant 的 Raspberry Pi 的地址，您可以使用 [Fing 移动应用](https://www.fing.com/products) 或 [nmap CLI 工具](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) 找到它），端口（默认为 `1883`），代理用户名和密码（您之前创建的）以及主题名称（您可以选择任何）。此外，树莓派的 IP 地址必须是静态的。单击 `Enable` 和 `Retain states`。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\n保存更改。现在设备将自动显示在 Home Assistant 中。\\n\\n## 连接设备\\n\\n通过转到`Zigbee` -> `Join`来连接您的设备。将您的传感器置于配对模式下，将设备切换到连接模式的最常见方法是按住其电源按钮或将其开/关5次。按下`Enable Join`按钮开始搜索Zigbee设备。您将看到活动传感器。\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\n现在您可以转到[**IoT订阅**](/docs/sub-activate)部分并开始激活Robonomics订阅。\\n\"}},{\"node\":{\"id\":\"4df365d333939e328e78062810341e43\",\"title\":\"去中心化传感器网络\",\"path\":\"/docs/zh/sensors-network-introduction/\",\"content\":\"\\n有关去中心化传感器网络的文章已转移到Robonomics学院：https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"61ca6cef49b5a4a3debe7c2e0cdb2059\",\"title\":\"将云AI安全连接到工厂车间\",\"path\":\"/docs/zh/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nRobonomics技术已经能够解决工业4.0面临的挑战，并已经应用于工业环境中的实际场景。\\n\\n大量的AI公司正在构建解决方案，以优化工厂车间的流程，使工厂能够以更低的成本生产更多产品。然而，大多数工厂不愿直接将基础施连接到云端，因为这会导致潜在的网络安全风险，可能导致数百万美元的损失甚至人员伤亡。\\n\\n[MerkleBot](https://merklebot.com)已经使用[Robonomics Network](https://robonomics.network)构建了一个安全连接工厂与基于云端AI的解决方案，用于工业客户。\\n\\n本文是在我们与[Veracity Protocol](https://www.veracityprotocol.org/)进行的一项实验之后撰写的，该实验使用算法基于移动设备的照片创建任何物理物品的非侵入性保护。\\n\\n这个用例展示了使用机器人手臂扫描工业零部件的过程。\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## 逐步过程\\n\\n### DApp作为用户界面\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp作为操作员的用户界面。它用于请求启动机器人以收集照片，其目的是允许工厂环境与基于云端AI之间进行安全通信。\\n\\n### 启动机器人\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\n操作员通过在DApp中签署交易来启动机器人扫描。这一步确保了工厂车间的流程只能基于公共区块链中的交易开始。\\n\\n机器人通过Robonomics Network从区块链接收命令并开始扫描。Robonomics Network技术使我们能够弥合业务目标和机器人操作之间的差距。\\n\\n### 数据收集并发送到基于云端AI\\n\\n在DApp中，操作员可以看到确认信息，机器人开始扫描放置在桌子上的物品，例如在这个用例中，或者根据需要直接工厂生产线上进行扫描。\\n\\n<!-- ![](../images/Veracity_Protocol_启动.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\n当机器人收集数据时，它会将数据存储在本地，并通过IPFS协议将其提供给基于云端AI。通过对数据进行加密，并通过区块链交易组织数据交换，我们可以授权访问基于云端AI，同时确保数据的安全性和完整性。\\n\\n基于公共区块链的共享安全性构建的Robonomics安全机制，使得大多数工厂自行组织这种安全级别变得代价高昂。\\n\\n### 数字护照创建\\n\\n当基于云端AI分析数据时，日志文件和建议会自动记录为[数字护照](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/)。由于区块链记录通过IPFS协议与所有这些文件的哈希相关联，因此可以追溯每个操作和扫描。\\n\\n## 关于用例的评论\\n\\n在这个用例中，使用了Universal Robot UR3工业机械臂。但由于Robonomics对ROS的支持，大多数主要的工业操纵器都可以安全地连接到基于云端AI，包括KUKA、Fanuc和Yaskawa。\\n\\n如果您对安全部署和集成基于云端AI工具感兴趣，请[联系我们](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"0f3000085799adc97729301614d05082\",\"title\":\"如何将SDS011传感器添加到Home Assistant\",\"path\":\"/docs/zh/sds-sensor-hass/\",\"content\":\"\\n本文介绍了如何将SDS空气质量传感器与[Luftdaten](https://github.com/opendata-stuttgart/sensors-software)和[Robonomics](https://github.com/airalab/sensors-software)固件连接到Home Assistant。\\n\\n## 安装 \\n有两种安装选项可用：\\n\\n### 选项1：HACS\\n\\n通过HACS加本地Luftdaten传感器是最简单的方法。[这里](https://hacs.xyz/docs/setup/download/)可以找到有关如何设置HACS的简要说明。\\n\\n安装HACS后，导航到HACS->集成并搜索“Local Luftdaten Sensor”集成。单击下载按钮，下载完成后重新启动Home Assistant。\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### 选项2：手动安装\\n\\n在homeassistant用户下，克隆项目存储库：\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\n如果您已经有任何自定义集成，请将`custom_components/local_luftdaten/`复制到您的`custom_components`目录中，例如：\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\n如果您没有任何自定义集成，请将整个`custom_components`目录复制到您的Home Assistant配置目录中，例如：\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## 配置\\n\\n在您的`configuration.yaml`中创建一个新的传感器条目，并调整主机名或IP地址。要找到传感器的本地IP地址，您可以使用[Fing移动应用程序](https://www.fing.com/products)或[nmap CLI工具](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)。名称可以是任何名称。\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> 所有支持的传感器列表可以在[存储库](https://github.com/lichtteil/local_luftdaten)中找到。\\n\\n重新启动您的Home Assistant。\\n之后，您可以将传感器添加到您的仪表板。实体的名称将是您添加到`configuration.yaml`中的名称。\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"b8f45a22e94b034f7936510c9428f0b4\",\"title\":\"Robonomics视频服务\",\"path\":\"/docs/zh/robonomics-video/\",\"content\":\"\\n本文介绍如何将IP摄像机添加到Home Assistant并将视频发送到Robonomics Web服务。\\n\\n要将摄像机连接到Home Assistant，您需要知道其IP地址并创建一个本地摄像机帐户以连接到RTSP流。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n由于每个摄像机的操作方式不同，本文不涉及此过程。\\n</robo-wiki-note>\\n\\n要求:\\n- IP摄像机\\n- 配置的本地摄像机帐户\\n- 摄像机的IP地址\\n- 配置的Home Assistant\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\n本文假设您拥有一台没有RTZ（旋转、倾斜、缩放）选项的通用IP摄像机。 \\n如果您有一台RTZ摄像机，请查看[\\\"RTZ摄像机\\\"文章](/docs/ptz-camera)。然后回到这里的第二步。\\n\\n</robo-wiki-note>\\n\\n## 连接摄像机\\n\\n首先，您需要找到摄像机的 RTSP 流的 URL。\\n为此，请尝试在互联网上输入以下查询：“<摄像机名称> RTSP流”。\\n流URL必须以`rtsp://<IP地址>...`开头。 \\n\\n本文使用的是“Tapo”摄像机，流路径为`rtsp://<IP地址>/stream1`。\\n\\n打开Home Assistant并转到\\\"Settings\\\"-> \\\"Devices & Services\\\"。按下\\\"ADD INTEGRATION\\\"按钮并\\n开始输入\\\"Generic Camera\\\"集成。选择它。\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\n在配置窗口中提供以下信息：\\n- Stream Source URL - 摄像机的RTSP流URL\\n- Username - 编写本地摄像机帐户的用户名\\n- Password - 编写本地摄像机帐户的密码\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\n向下滚动设置并按下\\\"Submit\\\"按钮。\\n\\n在预览窗口中激活复选框\\\"This image looks good.\\\"并按下\\\"Submit\\\"按钮。然后 - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### 添加到仪表板\\n\\n此外，您还可以将流添加到仪表板。要执行此操作，请导航到仪表板并创建一个新卡片 \\n\\\"Picture Glance\\\"。进一步的步骤：\\n- 输入您想要的\\\"Title\\\"\\n- 从“Image Path\\\"中删除数据\\n- 在Camera Entity\\\"中选择摄像机\\n- 在\\\"Camera View\\\"中，选择\\\"live\\\"以减少延迟\\n\\n然后保存。\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## 检查媒体文件夹\\n\\nBefore being sent to the Robonomics Video Service, the video must be saved in a folder, and Home Assistant must have access to this folder. \\n在这种情况下，最简单的选择是使用媒体包，其中Home Assistant存储所有媒体。\\n\\n- 如果您使用HAOS或预安装的映像，您的Home Assistant **已经有媒体文件夹**。\\n- 如果您使用Home Assistant Core，您应该转到`.homeassistant`文件夹并在其中创建`media`文件夹。\\n- 如果您使用Home Assistant Docker，请将` -v /PATH_TO_YOUR_MEDIA:/media \\\\`行添加到Docker命令中。\\n\\n要检查是否正确设置了所有内容，请转到Home Assistant中的“Media” -> “local media”选项卡。 \\n您应该看到一个空文件夹（没有错误）：\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## 服务调用\\n\\n要将视频发送到Robonomics，您应该在Home Assistant中调用一个专用服务。 \\n在本文中，这是手动完成的，但您可以为其创建一个自动化。\\n\\n要执行此操作，请转到\\\"Developer tools\\\" -> \\\"Services\\\"，然后找到\\\"Robonomics: Save recording to Robonomics\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\n在\\\"Targets\\\"中选择您的摄像机实体。\\n在\\\"Path to save the recording\\\"中，您应该提供一个绝对路径到文件夹，\\nHome Assistant可以在其中保存视频：\\n- 对于预安装的映像 - `/home/homeassistant/.homeassistant/media`;\\n- 对于HA OS或Home Assistant Docker- `/media`;\\n- 对于Home Assistant Core-先前创建的媒体文件夹的路径。\\n\\n此外，您还可以选择录制持续时间。 \\n\\n填写数据并使用\\\"CALL SERVICE\\\"按钮调用服务。\\n\\n## DAPP\\n\\n要查看生成的视频，请转到[Robonomics DAPP](https://vol4tim.github.io/videostream/)。\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\n粘贴您的控制器帐户地址并单击下面的按钮。等待\\\"Search for Twins\\\"过程。 \\n结果，您将获得一个带有所有录制视频的IPFS CID。\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\n接下来，从下拉列表中选择控制器帐户（或其他任何帐户），并签署一条用于在\\nWeb3 IPFS网关中进行授权以下载所有视频的消息。结果，您将获得由您的智能家居录制的所有视频。\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\n由于文件夹中的所有视频都使用控制器密钥进行加密，因此您需要插入它以解密视频。\\n之后，视频播放按钮将被激活。单击它以下载视频。\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"fb4209869be829ad25181b70502509dc\",\"title\":\"如何运行Robonomics Dev节点\",\"path\":\"/docs/zh/run-dev-node/\",\"content\":\"\\n**为了在Robonomics上测试您的应用程序，您可能希望以开发模式运行它。本文介绍了逐步说明\\n如何获得您自己的本地测试实例的Robonomics。**\\n\\n\\n## 获取节点二进制文件\\n\\n1. 首先，您需要一个二进制文件，从最新的[发布](https://github.com/airalab/robonomics/releases)中下载它的存档。\\n\\n2. 导航到存档文件夹，解压缩二进制文件并更改权限：\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## 运行\\n\\n使用以下命令运行节点：\\n\\n```bash\\n./robonomics --dev\\n```\\n您将看到以下输出：\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  如果您想清除现有的区块，可以通过删除`/tmp/substrate******/chains/dev/db/full`中的RocksDB来执行此操作。\\n  将`******`替换为启动日志中显示的相应标识符。\\n\\n  如果您想每次从头开始启动节点，请使用`--tmp`标志。\\n\\n</robo-wiki-note>\\n\\n## 连接\\n\\n现在您可以通过[Polkadot Portal](https://polkadot.js.org/apps/#/explorer)连接到本地节点。\\n\\n在左上角将网络更改为“Local Node”，然后点击“Switch”。\\n\\n![switch](../images/dev-node/portal.png)\\n\\n欢迎来到Robonomics的本地实例！\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"844b242f6da2cff5e761671adbb74872\",\"title\":\"如何连接SDS011传感器\",\"path\":\"/docs/zh/sds-sensor-connect/\",\"content\":\"\\n** 这是一个逐步指南，介绍如何将您的传感器连接到Robonomics传感器网络。我们的传感器使用Robonomics固件，这是传感器.community固件的增强版本。它包括额外的传感器并具有修改后的数据发送机制。 **\\n\\n1. 将传感器插入插座以供。\\n2. 该板将创建一个名为`RobonomicsSensor-xxxxxxxxx`的Wi-Fi网络。从您的手机或计算机连接到它：您将看到授权窗口（如果没有，请打开浏览器并转到`192.168.4.1`）。\\n3. 从列表中选择您的Wi-Fi网络（如果不在列表中，请自行填写）并填写密码字段。\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\n传感器只能连接到 2.4GHz Wi-Fi 网络。\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. 编写传感器将安装的位置的坐标。您可以从任何地图获取它们，或者使用[此链接](https://www.latlong.net/convert-address-to-lat-long.html)从地址获取它们。\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n传感器坐标将显示在公开可用的地图上。如果您不想显示您的私人信息，请写入接近但不精确的坐标。\\n</robo-wiki-note> \\n5. 点击`Save configuration and restart`。板将重新启动并连接到指定的Wi-Fi网络。\\n6. 打开[Robonomics传感器地图](https://sensors.robonomics.network/#/)，找到您安装传感器的位置。几分钟后，您将能够在地图上看到带有数据的传感器。\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"e4dbc2f5485977a79d0aea44e63a0717\",\"title\":\"Robonomics智能家居 Overview\",\"path\":\"/docs/zh/robonomics-smart-home-overview/\",\"content\":\"\\n## 使用区块链保护物联网安全 \\n\\n对于您的智能家居，现代物联网市场提供了各种解决方案。但通常您会受限于集中式云供应商或昂贵的专有网关。因此，作为用户，您始终依赖于硬件和基础设施供应商来运行您的智能系统。与此时，如果没有云统计和分析，您的智能家居将无法真正智能。\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**我们认为当前智能家居存在两个主要问题：**\\n\\n1. 您无法控制与供应商或第三方共享的数据。\\n2. 您的智能家居容易受到集中式云服务器关闭的影响。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\n为了解决这两个问题，我们建议您尝试Robonomics，我们的**安全**、**无服务器**和**未来主义**的分散式云。\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## 无需依赖企业的云的步骤\\n\\n以下是使用Home Assistant作为设备通信应用程序和Robonomics作为无需依赖企业的分散式云平台创建经济实惠智能家居的简单步骤。Robonomics利用现代安全的Web3技术，确保整个过程的增强安全性。.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## 从这里开始您的智能家居\\n\\n我们已经准备了关于在Robonomics上设置智能家居的详细指南。具体步骤可能因您的具体情况而异：无论您是否已经拥有配对设备的运行中的Home Assistant，还是从头开始建立您的智能家居。\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/zh/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/zh/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"e8c99651ac4fbfe11402cda4edac19a2\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/zh/robonomics-prometheus-grafana/\",\"content\":\"\\n**以下指令由[Hubo Bubo](https://github.com/hubobubo)提供**\\n\\n**原始文章位于[此处](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## 介绍\\n为了更好地监控和维护Robonomics节点，建议使用基于Prometheus Server和Grafana的监控系统。本文将展示如何配置这两个工具以完全监控您的节点。\\n\\n##  先决条件\\n* [使用Ubuntu 18.04进行服务器设置](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [已安装Robonomics parachain collator](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* 确保您的机器上已经运行了robonomics.service，并且端口9615是可访问的 \\n\\n## 第一步 - 创建服务用户\\n\\n出于安全考虑，我们将首先创建两个新的用户账户，即prometheus和node_exporter。创建这两个用户，并使用“--no-create-home”和“--shell /bin/false”选项，以防止这些用户登录到服务器。\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\n在下载Prometheus二进制文件之前，创建用于存储Prometheus文件和数据的必要目录。按照标准的Linux约定，我们将在/etc目录中创建一个目录用于存储Prometheus的配置文件，并在/var/lib目录中创建一个目录用于存储其数据。\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\n现在，将新目录上的用户和组所有权设置为prometheus用户。\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## 第二步 - 下载Prometheus\\n\\n首先，下载并解压缩当前稳定版本的Prometheus到您的主目录。您可以在[Prometheus下载页面](https://prometheus.io/download/)上找到最新的二进制文件。\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\n现在，解压缩下的存档。\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\n这将创建一个名为prometheus-2.21.0.linux-amd64的目录，其中包含两个二进制文件（prometheus和promtool），包含Web界面文件的consoles和console_libraries目录，以及许可证、通知和几个示例文件。\\n\\n将这两个二进制文件复制到/usr/local/bin目录。\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\n将二进制文件上的用户和组所有权设置为第1步中创建的prometheus用户。\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\n将consoles和console_libraries目录复制到/etc/prometheus目录。\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\n将目录上的用户和组所有权设置为prometheus用户。使用-R标志将确保在目录内部的文件上设置所有权。\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\n现在，Prometheus已安装，我们将创建其配置和服务文件，以准备进行首次运行。\\n\\n## 第三步 - 配置Prometheus\\n\\n在/etc/prometheus目录中，使用nano或您喜欢的文本编辑器创建一个名为prometheus.yml的配置文件。\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\n在全局设置中，定义抓取指标的默认间隔。请注意，Prometheus将将这些设置应用于每个导出器，除非单个导出器的自身设置覆盖全局设置。\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\n这个scrape_interval值告诉Prometheus每15秒从其导出器收集指标，这对于大多数导出器来说足够长。\\n现在，使用以下scrape_configs指令将Prometheus本身添加到要从中抓取的导出器列表中：\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus使用job_name在查询和图形上标记导出器，因此在此处选择一些描述性的内容。\\n\\n由于Prometheus导出有关自身的重要数据，您可以用于性能监控和调试，因此我们将全局scrape_interval指令从15秒覆盖为5秒，以获得更频繁的更新。\\n\\n最后，Prometheus使用static_configs和targets指令来确定导出器的运行位置。由于此特定导出器在与Prometheus本身相同的服务器上运行，因此我们可以使用localhost而不是IP地址以及默认端口9090。\\n\\n您的配置文件现在应该如下所示：\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\n保存文件并退出文本编辑器。\\n\\n现在，将配置文件上的用户和组所有权设置为第1步中创建的prometheus用户。\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\n配置完成后，我们准备通过首次运行来测试Prometheus。\\n\\n## 第四步 - 运行Prometheus\\n\\n以prometheus用户身份启动Prometheus，提供配置文件和数据目录的路径。\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n输出包含有关Prometheus的加载进度、配置文件和相关服务的信息。它还确认Prometheus正在监听端口9090。\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\n如果您收到错误消息，请仔细检查您的配置文件中是否使用了YAML语法，然后按照屏幕上的说明解决问题。\\n\\n现在，按下_CTRL+C_ 停止Prometheus，然后打开一个新的_systemd_服务文件。\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\n服务文件告诉_systemd_以prometheus用户身份运行Prometheus，配置文件位于_/etc/prometheus/prometheus.yml_目录中，并将其数据存储在_/var/lib/prometheus_目录中。将以下内容复制到文件中：\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\n最后，保存文件并关闭文本编辑器。要使用新创建的服务，重新加载systemd。\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\n现在，您可以使用以下命令启动Prometheus：\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\n为确保Prometheus正在运行，请检查服务的状态。\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n输出会告诉您Prometheus的状态、主进程标识符（PID）、内存使用情况等。\\n\\n如果服务的状态不是活动状态，请按照屏幕上的说明重新跟踪前面的步骤以解决问题，然后继续教程。\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n当您准备好继续时，按下_Q_退出状态命令。最后，启用服务以在启动时启动。\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\n现在，Prometheus已经启动并运行，我们可以安装一个额外的导出器来生成有关服务器资源的指标。\\n\\n## 第5步 - 下载Node Exporter\\n\\n为了将Prometheus扩展到仅有关自身的指标之外，我们将安装一个名为Node Exporter的额外导出器。Node Exporter提供有关系统的详细信息，包括CPU、磁盘和内存使用情况。将当前稳定版本的Node Exporter下载到您的主目录中。您可以在[Prometheus下载页面](https://prometheus.io/download/)上找到最新的二进制文件。\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\n现在，解压缩下的存档。\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\n这将创建一个名为_node_exporter-1.0.1.linux-amd64_的目录，其包含一个名为_node_exporter_的二进制文件、一个许可证和一个通知。\\n\\n将二进制文件复制到_/usr/local/bin_目录，并将用户和组所有权设置为在第1步中创建的node_exporter用户。\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\n现在，您已经安装了Node Exporter，让我们在创建一个服务文件之前先运行它，以便它在启动时启动。\\n\\n## 第6步 - 运行Node Exporter\\n\\n运行Node Exporter的步骤与运行Prometheus本身的步骤类似。首先，为Node Exporter创建Systemd服务文件。\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\n将以下内容复制到服务文件中：\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\n保存文件并关闭文本编辑器。最后，重新加载systemd以使用新创建的服务。\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\n现在，您可以使用以下命令运行Node Exporter：\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\n验证 that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\n与之前一样，此输出会告诉您Node Exporter的状态、主进程标识符（PID）、内存使用情况等。如果服务的状态不是活动状态，请按照屏幕上的消息重新跟踪前面的步骤以解决问题，然后继续。\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\n最后，启用Node Exporter以在启动时启动。\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\n配置和运行Node Exporter如预期后，我们将告诉Prometheus开始抓取新的指标。\\n\\n## 第7步 - 配置Prometheus以抓取Node Exporter\\n\\n因为Prometheus仅抓取在其配置文件的scrape_configs部分中定义的导出器，所以我们需要为Node Exporter添加一个条目，就像我们为Prometheus本身做的那样。打开配置文件。\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\n在scrape_configs块的末尾，添加一个名为node_exporter的新条目。\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\n因为该导出器也在与Prometheus本身相同的服务器上运行，所以我们可以再次使用localhost，以及Node Exporter的默认端口9100。您的整个配置文件应如下所示：\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\n当您准备继续时，保存文件并退出文本编辑器。最后，重新启动Prometheus以使更改生效。\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\n再次使用状态命令验证一切是否正常运行。\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n如果服务的状态未设置为活动状态，请按照屏幕上的说明重新跟踪之前的步骤。\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n现在，我们已经安装、配置和运行了Prometheus和Node Exporter。\\n\\n## 第8步 - 添加Robonomic内置的node_exporter\\n\\n在成功安装Prometheus和node_exporter之后，我们将不得不在每个substrate项目中使用内置的prometheus导出器。为此，我们必须向_/etc/prometheus/prometheus.yml_添加附加条目。. \\n打开配置文件。\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\n在scrape_configs块的末尾，添加一个名为robonomic_exporter的新条目。\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n保存文件并退出文本编辑器。您的整个配置文件应该如下所示：\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\n最后，重新启动Prometheus以使更改生效。\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\n再次使用状态命令验证一切是否正常运行。\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n我们现在已经安装、配置和运行了_Prometheus_、_Node Exporter_以及_Robonomic Exporter_。现在继续进行Grafana的设置。\\n\\n## 第9步-设置Grafana\\n\\n最后一步是在Grafana中将Prometheus连接为数据源。为了本教程的目的，我们将使用免费的基于云的Grafana，它允许最多拥有5个仪表板以及专用的[Robonomics仪表板](https://grafana.com/grafana/dashboards/13015)。只需转到[grafana.com](https://grafana.com/)创建新帐户并登录到您新创建的Grafana实例。\\n\\n首先，我们必须向Grafana添加新的_**数据源**_，在我们的情况下将是Prometheus服务器。\\n转到数据源：\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\n然后点击**_添加数据源_**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\n接下来选择_**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\n在新的屏幕上输入您的**_带有9090端口的Prometheus服务器IP地址_**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\n之后，_**保存并测试**_，如果您完成了所有步骤，您应该会看到绿色并准备好导入仪表板。在主站点上点击**+**，然后如下图所示点击**导入**：\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\n然后您应该看到导入页面：\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\n在_Grafana.com仪表板URL或ID_中写入_**13015**_（因为这是Robonomic仪表板的ID）\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\n加载外部仪表板后，您将看到此屏幕：\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\n最后一步是选择先前创建的**_数据源_**并点击_**导入**_\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\n完成！此时您应该可以看到导入的仪表板。 \\n\\n\\n## 参考资料\\n\\n* [如何在Ubuntu 16.04上安装Prometheus](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [通过Prometheus + Grafana构建监控仪表板](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Prometheus的Grafana支持](https://prometheus.io/docs/visualization/grafana/)\\n* [使用节点导出器监控Linux主机指标](https://prometheus.io/docs/guides/node-exporter/)\\n* [查询Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [可视化节点指标](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Polkadot节点指标](https://grafana.com/grafana/dashboards/12425)\\n* [用于Prometheus的节点导出器仪表板](https://grafana.com/grafana/dashboards/11074)\\n* [Grafana ROBONOMICS（XRT）指标](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"d35c4b8b3a3ba2329cc542581055871c\",\"title\":\"Robonomics开放式治理\",\"path\":\"/docs/zh/robonomics-opengov/\",\"content\":\"\\n## 介绍\\n\\nRobonomics已将平行链的治理模式转移到Polkadot的复杂OpenGov机制上，该机制允许链随时间演变，最终由代币持有人决定。\\nRobonomics过渡到OpenGov确保代币持有人DAO始终能够控制大部分股份，始终能够指挥Robonomics平行链的方向，对网络进行任何他们认为合适的更改。\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov仅适用于基于Substrate的Robonomics平行链，该链连接到Kusama中继链。OpenGov不适用于Robonomics以太坊实现，因为以太坊主网目前不支持OpenGov等复杂的治理系统。\\n</robo-wiki-note>\\n\\nOpenGov改变了平行链的日常运营和决策方式。它提供了更清晰的公投范围，并有可能大幅增加在平行链上做出的决策的吞吐量。\\n\\n在撰写本文时，OpenGov已在Kusama中继链上运行了几个月，并证明它大大增加了代币持有人DAO可以提议、投票并通过投票最终控制协议方向的决策数量（个体和离散公投）。\\n\\n**本维基部分的内容将介绍Robonomics平行链上OpenGov的核心原则，并旨在帮助您更好地理解OpenGov背后的概念。**\\n\\n*需要注意的是，在协议的早期阶段，治理是一个不断发展的机制。*\\n\\n对于那些只对Robonomics OpenGov跟踪参数感兴趣的人，请参见[此处](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)。\\n\\n## 关于公投\\n\\n公投是简单、包容和基于股份的投票方案。每个公投都与特定提案相关联，该提案采用链运行时的特权函数调用形式。这也可以包括最强大的调用 `set_code`，它能够切换链运行时的整个代码 - 这是基于 Substrate 的链所独有的，并且在更新链的业务逻辑（运行时）时消除了对链的“硬分叉”的要求 ）。\\n\\n公投是离散事件，其具有固定的投票期限（有关公投生命周期中不同期间的更多信息稍后介绍）。个体代币持有人可以以三种方式之一对公投进行投票-赞成（同意/是），反对（不同意/否），或完全弃权。\\n\\n所有公投都与其相关的生效延迟相关联。这是公投结束后到公投被批准的更改在网络上生效之间的时间段。 \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  每种不同类型的Origin都有一个特定的**最小生效**期，但特定公投的发起者可以将该公投的任务设置为在未来的多个区块中执行\\n\\n</robo-wiki-note>\\n\\n如果公投已关闭并计算了投票结果，则公投被视为“烘焙”。假设公投被批准，它将被安排在网络中生效（在链的调度器中）。如果结果尚未确定，公投被视为“未烘焙”-例如，如果公投仍在进行投票。\\n\\n通过引入OpenGov，任何人都可以随时发起公投，并且可以无限次数地这样做。OpenGov消除了一次只能处理1个公投的限制（请注意，在Gov v1中，一次只能对一个公投进行投票。唯一的例外是由快速跟踪技术委员会提出的额外紧急公投，社区也可以同时对其进行投票）。\\n\\nOpenGov引入了几个新功能/概念，称为Origin和Track，这些功能/概念旨在帮助协议中的公投流程和处理。\\n\\n每个Origin与单个公投类相关联，每个类与一个Track相联。Track概述了公投的生命周期，并且对于特定的Origin，该Track是特定的。具有自己特定参数的Track允许网络根据其特权级别动态修改公投的生命周期（您可以将特权级别视为公投的强大程度/它可以对协议进行哪些类型的更改）。\\n\\n*将Origin视为公投的权力，将Track视为公投的投票参数，例如其期间的长度以及批准和支持标准。*\\n\\n例如，对协议的运行时升级对协议的影响与小额财政小费不同，因此需要不同的Origin，其中将预先确定链的批准、支持、存款和生效期（Track）。\\n\\n## 提议公投和公投生命周期 \\n\\n### 准备期\\n\\n在OpenGov中，当公投刚刚创建时，代币持有者社区可以立即对其进行投票。然而，它并不立即处于可以结束或计算其投票、获得批准并立即生效的状态。相反，公投必须满足一些条件，然后才能进入决策期。在公投入决策期之前，它们将保持未决状态，并最终在个别轨道中指定的整体生命周期期限后超时。\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\n公投进入决策期的条件如下：\\n1. 准备期，概述了决策期开始之前必须经过的时间。这个准备期有助于减轻“决策抢夺”的可能性，即攻击者控制大量投票权可能试图利用他们的大股份使公投立即通过，绕过代币持有者DAO的其他成员有足够的时间考虑公投并参与投票的可能性。这就是为什么具有更高特权级别的起源具有显着较长的准备期的原因。\\n\\n2. 必须有决策的空间。每个轨道对可以同时决定的公投数量都有自己的限制（max_deciding）。特权级别更高的轨道将有较低的限制。例如，根级别的起源在与小费较低的特权级别起源相比可以同时决定的公投数量要少得多。\\n\\n3. 必须提交决策押金。最初创建公投相当便宜，提交押金的价值（在公投最初创建时保留）相当低，主要由与公投相关的链上存储的价值组成。决策押金要高得多，这是为了对抗垃圾邮件，并参与OpenGov带来的经济游戏，我们稍后将详细介绍。\\n\\n一旦满足了上述这三个条件，公投将进入决策期。然后，对公投的投票将计入结果。\\n\\n### 决策期\\n\\n*有关决策期的快视频演示，请参见[此视频](https://www.youtube.com/watch?v=wk58C-2CqPI)*。\\n\\n一旦公投满足了上面部分详细描述的所有条件，它将进入决策期。\\n\\n决策期围绕两个主要概念展开，即批准和支持标准。 \\n\\n批准是指批准投票权重（赞成票与反对票）与总投票权重（所有赞成票和反对票的总和）的比较。每个投票的信念都计入赞成票/反对票的总权重（有关信念投票/自愿锁定的更多信息将在后面的部分介绍）。\\n\\n支持是参与公投的总票数（代币数）（不考虑信念）与系统中可能进行的总票数的比较（将其视为空投链上的总发行量 - 值得注意的是，XRT的总流通供应量在这里不是主要因素，因为该数字的一部分存在于以太坊上作为ERC-20代币）。\\n\\n**弃权方向的投票不会对批准标准产生影响，但会包括/计入支持标准**\\n\\n在决策期内，公投必须同时满足支持和批准标准，才能进入确认期。\\n\\n有关每个轨道的支持和批准标准的详细信息，请参见此[电子表格](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)。\\n\\n### 确认期\\n\\n每个轨道都有自己特定的确认期限。特权级别较高的轨道（如根轨道）的确认期限要长得多，而特权级别较低的轨道（如小费较低的轨道）的确认期限要短得多。\\n\\n公投必须在整个确认期内继续满足批准和支持标准，否则它们将再次返回决策期（注意：决策期在确认期间不会暂停，因此完全有可能在确认期间决策期到期，这意味着如果公投因不再满足批准和支持标准而被推出确认期，它将被视为失败的公投，不会生效）。\\n\\n**通过具有根源特权的公投，可以调整各个轨道的批准和支持标准。**\\n\\n具有较低特权级别的起源具有比具有较高特权级别的起源更容易满足的批准和支持标准（由轨道设置）。同样，具有较高特权级别的起源比具有较低特权级别的起源具有更平缓的曲（如轨道中定义的），以确保代币持有人DAO确实批准公投，并避免对高特权起源公投的公投抢夺。\\n\\n在OpenGov中，决策期结束后未经批准的公投将被默认视为被拒绝，并将提交和决策保证金退还给其发起者（注意：决策保证金可以由非公投发起者发布）。\\n\\n如果一个公投在整个确认期间持续满足批准和支持标准，则被视为已批准，并将安排从提议的起源执行，但公投只有在最低实施期过去后才会执行。\\n\\n### 实施期\\n\\n实施期由公投发起者在提议公投时指定，但它受到每个轨道中指定的最低实施期的限制。更强大的起源具有比较低特权起源更高的最低实施期。这确保网络有足够的时间为强大的公投做好准备可能带来的任何变化。\\n\\n## 自愿锁定/信念\\n\\nRobonomics使用一种被称为自愿锁定或信念投票的概念。这使得代币持有者可以通过决定锁定代币的时间来增加他们的投票权力。这个机制只影响每个公投的批准标准，信念投票不影响支持标准。\\n\\n可以使用以下公式计算信念投票:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\n这个表格显示了每个不同的锁定期限如何将您的投票乘以批准标准:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\n代币持有者可以使用的最大信念是6倍信念。您只能按照上表设置信念，例如不能使用5.5倍信念。\\n\\n当代币由于投票而被锁定时，它们仍然可以用于投票其他公投，但它们不会成为您可转让的余额（您不能将其发送到另一个账户）-只有整个锁定期限过期后，余额才会变得可转让。\\n\\n## 投票委托\\n\\n在OpenGov中，添加了一种机制，允许没有足够时间审查每个公投的代币持有者的代币作为治理系统的一部分使用，这被称为投票委托。\\n\\n代币持有者可以选择将他们的投票权委托给系统中的另一个投票人（另一个账户）。投票人可以灵活地指定将他们的投票权分配给每个单独的发起者的不同账户。投票人还可以设置为为每个发起者分配不同数量的投票权（代币数量和信念水平）。\\n\\n这个委托功能有一个目标，就是增加投票率，并帮助确保满足批准和支持标准所需的投票率。\\n\\n要委托您的投票权，您可以使用\\\"Delegate\\\"功能，您可以在[Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer)的治理->公投部分找到。或者，用户可以使用Robonomics Portal的开发者->外部部分提交convictionVoting(Delegate)外部，但是使用门户的公投部分的\\\"Delegate\\\"功能要简单得多。\\n\\n## 取消/终止公投和治理经济游戏\\n\\n在OpenGov中，有一些发起者专门用于拒绝正在进行的公投，无论其状态如何。这些被称为治理取消者和治理终结者。\\n\\n这些发起者介入已经被投票的公投。如果来自这些发起者的公投被批准，它们将立即拒绝正在进行的公投，无论其状态如何。 \\n\\n取消本身是一种必须由代币持有者投票才能执行的公投。取消具有自己的发起者和轨道，其引导时间（决策期等）较短，并且具有比其他发起者更陡峭的批准和支持曲线（这意味着它们的标准随时间变得更容易满足）。这是因为取消公投通常会带来紧迫感。\\n\\n治理取消者旨在立即拒绝正在进行的公投。当公投被此发起者取消时，提交和决策存款将退还给其发起者。公投可能被视为取消的一个例子是如果发起者在公投内容上犯了一些人为错误，并且并没有试图做任何恶意行为。\\n\\n治理终结者旨在立即拒绝正在进行的公投。这就是治理经济游戏的作用。具有高特权级别（例如Root）的发起者需要投入大量资本（XRT代币）作为决策存款，以便公投进入决策期。 \\n\\n如果恶意行为者提交了一个公投，例如一个具有Root来源的公投，旨在将链的运行时`set_code`为会停止链产生区块的内容，那么代币持有者DAO可以提出一个反对此行为的治理终结者公投。如果通过治理终结者发起者拒绝了恶意公投，那么提交和决策存款都将被削减，这意味着发起者（这些存款的账户）将失去这些资金。 \\n\\n这意味着对于试图提出对链产生严重负面影响的公投的恶意行为者来说，存在严重的经济后果，这理论上将阻止任何恶意行为者尝试这样做。\\n\\n治理杀手轨道的决策存款本身相当高，这是为了阻止同样恶意的参与者试图削减本来良好的公投的存款。**现有的治理杀手公投可以被随后的治理杀手公投终结。**\\n\\n## Robonomics技术委员会和白名单来源\\n\\n这个团体是一个自治的专家机构，其主要目标是代具有Robonomics网络协议技术知识的人类。 \\n\\n这个团体（仅限这个团体）能够从白名单调色板发起公投。这个调色板只做一件事，它允许一个发起者提升另一个发起者的特权级别进行某个操作。 \\n\\n这个团体可以授权一个名为白名单根的发起者发起公投，这些公投可以以根级特权执行，但这些公投只能成功执行已被团体授权的特定指令。白名单调色板验证两件事：\\n1. 发起者确实是白名单根（即公投通过了这个发起者的轨道）。\\n2. 提案确实已被团体列入白名单。\\n\\n如果两个条件都为真，则操作将以根级特权执行。\\n\\n该系统使得能够拥有一个新的并行轨道（白名单根发起者），其参数允许更短的投票周转时间（批准和支持标准比根级稍微容易满足）。这个开放透明的过程允许Robonomics网络协议的专家团体提出他们认为安全且时间紧迫的公投。\\n\\n值得注意的是，使用白名单根发起的公投的支持标准不会像其他发起者/轨道那样趋近于0。这确保了该团体不会对整个Robonomics网络协议拥有实际控制权，并要求整体代币持有人的最低支持（投票人数）。\\n\\n\\n## 公投持续时间 \\n\\n重要的是要理解，每个单独公投的持续时间不是一个确定的事情，它不是一成不变的。公投生命周期中的某些时期，如最小生效期，确实有确定的持续时间，然而其他时期，包括决策期，没有。例如，将准备期、决策期、确认期和最小生效期的最大持续时间相加，并声明“每个公投将需要X天”，这种说法并不准确，它比这更加灵活。\\n\\n让我们通过几个单独的公投来看待这个问题，所有这些公投都来自同一个发起者，即根发起者。 \\n\\n根发起者有自己的轨道，其中每个时期的持续时间以及批准和支持曲线都被设定。\\n\\n重要的是记住，只有在满足某些条件的情况下，公投才会进入其生命周期的下一个阶段。 \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\n在下面的图像中，您应该假设为了使公投进入其生命周期的下一个阶段，必须满足上述图像中描述的条件（除非另有说明）。\\n\\n\\n### 在很少的选民投票的情况下的最长持续时间\\n\\n下面的图像是一个公投的最长可能时间线的表示，可以将其视为一个公投：\\n1. 已经发布了决策存款，因此进入了决策期。\\n2. 有一个单一的投票，例如1个XRT，朝着赞成方向 - 这意味着它只会在决策期结束时（由于整体支持非常低）满足所需的支持（投票人数），但有100%的批准，因此最终将满足进入确认期的要求。\\n3. 在确认期间继续满足上述条件。\\n4. 公投提出的提案将在最小生效期结束时恰好生效 - 从技术上讲，公投的发起者可以将网络更改设置为在未来的许多区块中执行，因此实际上一个单独公投的生命周期可能跨越多天、周、月或年。\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\n我们可以看到，在这个例子中，公投的生命周期将是（大约）17天。\\n\\n\\n### 在有很多选民投票（有大量赞成票）的情况下的持续时间\\n\\n现在让我们来看一下一个公投，XRT代币持有者DAO对此表达了很大的兴趣。在这个例子中，我们假设总共有约248,771个XRT的选民投票，所有选民都投票支持（注意：从技术上讲，在Root公投的这个阶段，根据轨道，只有60%的选票必须支持才能满足批准标准）\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n 始终请参考最新的轨道信息以获取关于每个轨道的准确信息，更多信息可以在此[电子表格](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)上找到。\\n\\n</robo-wiki-note>\\n\\n在这个例子中：\\n1. 决策存款在准备期间发布，因此在准备期结束时能够过渡到决策期。\\n2. 许多选民在这个公投上投票 - 在相对较短的时间内获得了约248,771个XRT的选民投票。\\n3. 投票结果以支持方向为多数（超过60%的支持票）。\\n4. 公投在整个确认期间始终满足确认期标准（注意：如果公投不再满足确认期标准，则会被推回到决策期）。\\n5. 公投提出的提案将在最低生效期结束的同一区块上实施。\\n\\n由于有约248,771个XRT的投票，公投将在约168小时（7天）后满足进入确认期的标准。\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\n我们可以看到，在这个第二个例子中，由于有相当多的选民投票，决策期实际上在其最大允许时间的一半结束。这导致公投可以在约10天内生效。\\n\\n\\n### 决策存款从未发布的持续时间\\n\\n现在，让我们来看一个公投的例子，该公投已经发起，但决策存款从未发布。这样的公投处于一种“悬而未决”的状态，其准备期已经结束，但由于决策存款未发布，公投仍处于“准备状态”。\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\n我们可以看到，在这个第三个例子中，由于决策存款从未发布，公投实际上永远不会进入决策期，而是保持在“准备状态”。这意味着，如果永远没有决策存款发布，公投将在调色板的timeOut常量指定的持续时间后超时。\\n\\n这在Kusama之前发生过，其中一个公投是由Root发起的，但由于发布决策存款的高资本要求，该公投从未进入其生命周期的后期阶段。这样的公投以“超时”标志结束。\\n\\n\\n### 决策存款发布较晚的持续时间\\n\\n最后，让我们来看一个例子，其中决策存款在公投发起后相当长的时间内未发布。这在Kusama之前发生过，其中一个公投是由Root发起的，但发起者花费时间找到一个资本较高的人代表他们发布决策存款。\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\n在这个最后的例子中，由于决策存款是在准备期结束后发布的，但在公投超时之前 - 公投的生命周期实际上比正常情况下要长，因为它在较长的时间后进入决策期。\\n\\n重要的是要注意，代币持有者DAO能够在准备期或处于“准备状态”的公投上投票支持/反对。\\n\"}},{\"node\":{\"id\":\"54f7c78a20dd7f8e61e30db6e682f45a\",\"title\":\"Robonomics集成设置\",\"path\":\"/docs/zh/robonomics-hass-integration/\",\"content\":\"\\n**在本文中，您将向Home Assistant添加Robonomics。这使得Home Assistant能够将加密数据的数据日志记录到Robonomics Parachain，并侦听来自Parachain的启动命令以控制智能设备。集成使用IPFS存储数据并将IPFS哈希发送到数据日志或启动函数。**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Home Assistant的Web界面中，转到`Settings` -> `Device & Services`，然后点击`ADD INTEGRATION`。搜索`Robonomics`。\\n\\n2. 点击Robonomics并填写配置: \\n\\n- 将`SUB_CONTROLLER`账户的种子添加到控制器账户种子中。\\n- 将`SUB_OWNER`账户的公共地址添加到订阅所有者地址中。\\n- 设置数据发送的间隔（默认为10分钟）。\\n- （可选）您可以为固定服务Pinata或其他自定义网关添加凭据，以在IPFS网络上更广泛地传播您的数据。\\n\\n3. 完成配置后，点击`SUBMIT`。如果您填写的内容都正确，您将看到成功窗口。\\n\\n就是这样！您已经完全设置了Robonomics集成到Home Assistant。现在您可以使用所有的 \\nRobonomics Web服务。要了解更多信息，请转到[\\\"使用\\\"部分](/docs/global-administration)。\\n\"}},{\"node\":{\"id\":\"fe8789791e55eae058d830a6a7f3ae48\",\"title\":\"Robonomics在以太坊上\",\"path\":\"/docs/zh/robonomics-ethereum/\",\"content\":\"\\n有关Robonomics在以太坊上的所有信息已转移到GitHub存储库。所有必要的信息可以在[此处找到。](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"432fc40b0e9912468f41dbee5c48147c\",\"title\":\"Python接口和Robonomics IO\",\"path\":\"/docs/zh/rinterface/\",\"content\":\"\\n**一些在Robonomics调色板中实现的外部功能很难从Polkadot应用程序中提交。此外，有 \\n需要使用编程语言与此功能进行交互。为此，开发了一个简单的Python工具\\n称为 [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface)。 它是 polkascan 维护的包装\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface)。下面对此软件包的简要描述\\n和一些有用的链接和示例。还讨论了CLI工具**\\n\\n## robonomics-interface\\n\\n可在[PyPi](https://pypi.org/project/robonomics-interface/)上下载和设置软件包。\\n还提供了详细的基于docstring生成的[文档](https://multi-agent-io.github.io/robonomics-interface/)。\\n\\n总的来说，这是一个供开发人员使用编程工具与Robonomics区块链进行交互的工具。几乎 \\nRobonomics团队的所有Python项目都使用这个接口与平行链进行交互。\\n\\n### 安装\\n\\n安装过程要求用户至少安装Python 3.8。既不是`x86`，也不是`arm7`，也不是`arm8`\\n架构。所有的轮子都是由依赖维护者构建和发布的。\\n\\n`pip`被用作安装工具:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### 示例用法\\n\\n主要思想是创建一个`Account`实例，然后使用它来创建专用于调色板的实例。\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  还可以使用自定义的端点（例如，用于测试的本地节点）:\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\n也可以提交外部功能:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  正如前面所说，更多示例可在[文档](https://multi-agent-io.github.io/robonomics-interface/)页面上找到。\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface`还包含一个Python `click` CLI工具，用于原型设计和快速测试。它已安装\\n与软件包一起，并在终端中可用:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\n您可以尝试在本地节点上使用它。采用了流水线哲学:\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"30e56d9eb207abdfea41f942aa7432ce\",\"title\":\"在Home Assistant中进行PTZ摄像机控制\",\"path\":\"/docs/zh/ptz-camera/\",\"content\":\"\\n本文介绍了在Home Assistant中设置PTZ摄像头的过程。\\n将使用ONVIF协议。这需要一个本地摄像机账户。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n本文不涵盖设置本地摄像机账户的过程。\\n</robo-wiki-note>\\n\\n要求:\\n- PTZ camera\\n- 本地摄像机账户\\n- 摄像机IP地址\\n- 配置的Home Assistant\\n\\n## ONVIF集成\\n\\n让我们从**ONVIF集成**的安装开始。\\n\\n转到\\\"设置\\\"Settings\\\"\\\"Devices & Services\\\"，然后点击\\\"ADD INTEGRATION\\\"按钮。\\n输入\\\"ONVIF\\\"并选择集成。您将看到下一个窗口。\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\n点击\\\"Submit\\\"按钮。它将尝试自动搜索您的摄像机。如果成功， \\n从列表中选择您的摄像机并填写空白字段。 \\n否则，您必须手动填写所有字段。您将看到以下窗口。\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\n填写空白处:\\n- Name - 为您的摄像机命名\\n- Host - 提供您的摄像机IP地址\\n- Port - 通常是2020年最常见的，但您的摄像机供应商可能会更改它\\n- Username - 为您的摄像机本地账户编写用户名\\n  - Password - 为您的摄像机本地账户编写密码\\n\\n然后点击\\\"Submit\\\"。为您的摄像机选择一个区域，然后点击\\\"Finish\\\"。\\n\\n## 将摄像机控制添加到仪表板\\n\\n现在您已经完全设置好摄像机，可以将其流和控制按钮添加到仪表板。\\n\\n转到仪表板并开始创建一个新卡片。选择\\\"Picture Glance\\\"。\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\n填写数据:\\n- Title - 选择摄像机图像标题\\n- Camera Entity - 从下拉列表中选择一个摄像机实体\\n- Camera View - 选择\\\"live\\\"以减少延迟\\n\\n接下来，通过按下左下角的按钮切换到\\\"Code Editor\\\"模式。您将看到以下代码:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\n根据下面的示例替换`entities: []`的内容（`<YOUR_CAMERA_ENTITY>`与`camera_image`参数相同）:\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\n就这样。现在您应该在仪表板上看到PTZ摄机卡片以及控制按钮.\\n\\n## 故障排除\\n如果您正在使用Home Assistant Core，但是您没有看到来自摄像头的流，请安装\\\"stream\\\"和\\\"FFMPEG\\\"集成。 \\n要做到这一点，您应该在configuration.yaml的末尾添加`stream: `和`ffmpeg: `字符串。\"}},{\"node\":{\"id\":\"31de3096c04e3ffb334c54991310a8ce\",\"title\":\"Robonomics智能家居\",\"path\":\"/docs/zh/notifications/\",\"content\":\"\\n您可以通过[notify](https://notify.events/)在智能手机上接收通知。首先在那里注册并在`Control Panel`上创建新通道：\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\n添加标题并按`Save`：\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\n然后按`Add Source`并在`IoT and Smart Home`选项卡中选择`Home Assistant`：\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\n编写标题并按`Next`：\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\n在那里您将看到您需要添加到Home Assistant配置文件中的令牌。将其保存在某个地方并按`Done`：\\n\\n![token](../images/home-assistant/not_token.png)\\n\\n然后按`Subscribe`以添加订阅者：\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\n选择您想要的任何订阅者并按照说明操作。\\n\\n现在您需要在计算机上使用Home Assistant编辑配置。在`homeassistant`用户下打开`configuration.yaml`文件：\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\n并添加以下行：\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\n在`automation:`行之后还要添加新的自动化：\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\n此自动化将在传感器实体ID`binary_sensor.contact_sensor_contact`状态从`off`更改为`on`时发送消息`Door was changed to on/off`。\\n\\n然后重新启动Home Assistant：\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"c57194f869f274dbf9c8aad19a86af84\",\"title\":\"责任\",\"path\":\"/docs/zh/liability/\",\"content\":\"\\n**要将机器人变成经济主体，需要一种合同工具。认识一下责任 - 实现了跨链账户之间的合同的Robonomics托盘！**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  请注意，本教程是在Robonomics节点的本地实例上演示的。按照[这些说明](/docs/run-dev-node)设置您自己的节点。\\n\\n</robo-wiki-note>\\n\\n## 理论概述\\n\\n在以太坊上，责任交互有一个相当复杂的结构。您可以在[这里](/docs/robonomics-how-it-works)了解它。如今，在Kusama上的事情要简单一些！\\n\\n### 谈判\\n\\n要签订合同，双方首先需要进行谈判。 这可以通过多种方式完成，包括 [IPFS PubSub ](https://blog.ipfs.tech/25-pubsub/) 或 Robonomics PubSub。 [此处](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub) 提供了使用 Robonomics PubSub 的 Python 代码示例。 \\n\\n供求是包含合同的两个主要特征的消息：**工作描述**和**价格**。每个特定应用程序的消息格式由用户设计。在谈判过程中，遵循严格的格式规则并不重要。可能的流程如下图所示。\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  请注意，PubSub是一种开放协议，因此不应传输任何敏感数据。为此，您应该使用其他协议。\\n\\n</robo-wiki-note>\\n\\n\\n### 签名\\n\\n当谈判成功结束后，双方都需要签署所谓的协议，即签名。 这是一条包含职位描述和价格的消息**以特定格式**，并使用帐户的私钥签名。 \\n还有一个[Python工具](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability)。\\n - 工作描述称为**技术**。这是一个类似启动的32字节长的字符串，可以是编码的IPFS CID。\\n - 价格称为**经济学**。这是一个XRT小数 - 维纳。1维纳= 10**-9 XRT。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  您可以使用[Python库](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes)以正确的方式格式化IPFS CID。\\n  使用`sign_liability`函数时，无需转换哈希，它将自动完。\\n\\n</robo-wiki-note>\\n\\n以下是咖啡的例子：\\n\\n1. 任务是一个JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. 其IPFS CID为`QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. 因此，**技术**（转换后的CID）为`0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **经济学**为`1.5 XRT`。\\n\\n签署后，就可以创建责任了！这可以由其中一方（承诺方或承诺方）或所谓的提供者的第三方账户完成。\\n\\n## 创建责任\\n\\n### 准备工作\\n\\n如前所述，该过程涉及至少两方。在这个例子中，我们使用三方，并为此创建一个独立的提供者。假设谈判已经以某种方式进行。\\n\\n### 1. 创建三个账户并向它们添加资金\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\n在这里，我们为提供者提供了100 XRT来签署责任外部交易，承诺方获得了2 XRT来支付工作费用。\\n承诺方没有获得任何资金（除了至少1 mXRT的存在性存款）。\\n\\n### 1. 导航到 Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. 从可能的外部因素的下拉列表中选择 liability -> createte\\n\\n还要选择要提交外部交易的账户。填写所有参数。\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  由于这里使用了提供者，无需知道参与者的种子。只需要他们的签名。\\n\\n</robo-wiki-note>\\n\\n### 3. 提交交易\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. 在事件中查看您的责任\\n\\n为此，请导航到`Network -> Explorer`并在右侧找到事件列表。单击三角形图标展开。\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  可以使用相同的 [Python 工具](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash) 将哈希值转换为 IPFS CID。\\n\\n</robo-wiki-note>\\n\\n### 5. 存储探索\\n\\n您还可以在存储模块`liability`中探索一责任的特征。\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  `Next Index`存储函数显示最新的责任索引+1，因此即使是`1`，也可以探索到责任`0`。\\n\\n</robo-wiki-note>\\n\\n## 报告\\n\\n假设咖啡已经做好了，现在咖啡机需要以某种方式报告。这就是责任报告的作用。作为劳动的证明，账户在完成现有责任时添加另一个IPFS CID作为报告内容。这再次需要承诺方的签名。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  签名的消息包含现有责任指数和以32字节表示的报告IPFS CID。再次，[Python工具](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report)可以帮助签署报告。\\n\\n</robo-wiki-note>\\n\\n继续使用咖啡机的例子：\\n\\n1. 报告是一个JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. 它的IPFS CID`QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. 所以**有效负载**（转换后的CID）是“0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2”\\n4. **索引**是`0`，它是现有责任指数。\\n\\n### 1. 导航到extrinsics，liability -> finalize(report)\\n\\n填写参数并提交外部。 同样，这可以通过第三方帐户来完成。\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  请注意，承诺人账户不应该是\\\"dead\\\" - 它应该至少有1 mXRT的存在性存款。\\n\\n</robo-wiki-note>\\n\\n签署并提交报告。完成后，您可以在事件中探索它。\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. 探索报告\\n\\n您还可以在存储中观察报告。转到`Developer -> Storage`并从下拉列表中选择`liability`。\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. 检查余额\\n\\n图片显示现在承诺人已经得到了\\\"工资\\\"。经济关系发生了！\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  目前还没有办法验证工作是否完成，因此一旦承诺人报告，代币将转移到其账户。 \\n  验证功能将在将来添加。\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"6405c3bcc8f693c37324f23b11e18896\",\"title\":\"启动\",\"path\":\"/docs/zh/launch/\",\"content\":\"\\n**Another basic feature of Robonomics parachain is the 启动 pallet. It allows you to send commands to the accounts/any entities behind them. These commands include parameter to specify the task to be executed.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  请注意，此教程及其后续教程是在Robonomics节点的本地实例上演示的。请按照[这些说明](/docs/run-dev-node)设置您自己的节点。\\n\\n</robo-wiki-note>\\n\\n## 1. 1. 导航到 Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. 从可能的外部变量的下拉列表中选择 launch -> launch\\n\\n还要选择要提交外部操作的账户。填写目标地址和参数字段。\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Launch 支持 32 字节长的字符串作为命令（[来源](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)），\\n  所以这里有一个即兴创作的空间：\\n  - 对于切换等基本命令，您可以使用“0x0000000000000000000000000000000000000000000000000000000000000001”或\\n  “0x0000000000000000000000000000000000000000000000000000000000000000”。\\n  - 对于包括 json 之类的高级命令，您可以使用 [IPFS](https://ipfs.tech/) CID 格式\\n  [正确的方法](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes)。\\n\\n</robo-wiki-note>\\n\\n## 3. 提交交易\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. 在事件中查看您的启动\\n\\n为此，导航到*Network -> Explorer*，在右侧找到事件列表。点击三角形图标展开。\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"e82e9ccd4a21a499b354a7f1a38689b8\",\"title\":\"如何更新Robonomics Collator节点版本\",\"path\":\"/docs/zh/how-to-update-collator-node-version/\",\"content\":\"\\n在阅读本文之前，建议您先阅读以下文章：[\\\"如何构建Collator节点\\\"](/docs/how-to-build-collator-node)和[\\\"如何启动Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator)。\\n\\n本文包含更新Robonomics Collator节点（在Ubuntu上运行）所需的命令，并在之后给出一个示例。\\n\\n## **所需命令**\\n\\n0. 在开始之前，建议您以`root`身份登录，如果没有，请使用以下命令：\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. 停止Robonomics服务：\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. 删除之前的Robonomics版本（确保您在正确的目录中）：\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. 获取[最新版本](https://github.com/airalab/robonomics/releases)的Robonomics：\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. 解压文件：\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. 移动文件：\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\n您需要将此文件移动到您安装Robonomics节点的正确目录中）\\n\\n</robo-wiki-note>\\n\\n6. 启动Robonomics：\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\n将Collator节点升级到Robonomics v1.8.4的示例：\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **在未设置基本路径的情况下更改Kusama Relay Chain数据库**\\n\\n有时，Kusama Relay Chain的某些快照会导致您的节点出现错误。这通常会导致节点停止工作。由损坏的Relay Chain数据库引起的示例错误：\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\n为了修复此错误，您应该删除现有的Kusama Relay Chain数据库（可能是RocksDb），并将其替换为其他数据库，如ParityDb。执行以下命令：\\n\\n1. 找到Robonomics节点的目录并检查文件：\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. 确认您看到了polkadot目录，然后进入chains目录：\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3.删除`ksmcc3`目录：\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. 创建一个新的`ksmcc3`目录。\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. 现在您需要下载一个新的快照。此示例使用了一个经过大量修剪的Relay Chain快照，但您可以将其替换为任何您喜欢的快照。\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. 在快照下载时，打开一个新的会话并编辑您的服务文件：\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\n修改与数据库和修剪相关的服务文件中的行：\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\n使用`Ctrl + S`然后`Ctrl + X`保存并退出服务文件。\\n\\n7. 现在您需要重新加载守护程序。\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. 到此时，在您的其他会话中，希望新的数据库已经下载完成，因此解压文件：\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. 解压完成后，执行以下操作：\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. 现在您可以启动服务，监视任何错误，并检查它是否同时连接到Relay Chain和Parachain。\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"d835b0e333dcf0bc50140e5f640dfc09\",\"title\":\"如何启动Robonomics收集器\",\"path\":\"/docs/zh/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  在本文的演示和截图中，我们使用了Robonomics的1.4.0版本。您需要使用相同的命令，但将Robonomics的版本替换为当前版本。\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\n目前，Robonomics网络主要由初始开发者维护，但任何人都可以支持该项目。每个额外的区块链全节点都有助于使其更具可持续性和容错性。Robonomics节点二进制文件可在[发布](https://github.com/airalab/robonomics/releases)资产中获得，或者可以从源代码构建。\\n\\n## 什么是碎片节点\\n\\n收集器是Robonomics平行链的一部分。这种类型的节点为Robonomics链创建新的区块。\\n\\n>碎片节点通过从用户收集碎片链交易并为中继链验证者生成状态转换证明来维护碎片链。换句话说，碎片节点通过将碎片链交易聚合到碎片链块候选项中，并根据这些块为验证者生成状态转换证明来维护碎片链。\\n\\n您可以在相关的[Polkadot维基页面](https://wiki.polkadot.network/docs/learn-collator)上了解更多关于收集器的信息。\\n\\n在 Robonomics 平行链中，每个整理者构建的每个区块都会获得 (**0.001598184 XRT**) 的奖励（奖励在区块被密封到链上时发生）。\\n此外，构建区块的收集器将获得所创建区块中包含的**50%的交易费用**。\\n\\n## 要求\\n\\n建议使用[Polkadot验证器](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware)的**标准硬件要求**来启动收集器：\\n+ x86-64兼容。\\n+ Intel Ice Lake或更新（Xeon或Core系列）；AMD Zen3或更新（EPYC或Ryzen）。\\n+ 4个物理核心@ 3.4GHz。\\n+ 禁用同时多线程（Intel上的超线程，AMD上的SMT）。\\n+ 存储-1 TB的NVMe SSD（因为它应该具有合理的大小以处理区块链的增长）。\\n+ 内存-32 GB DDR4 ECC\\n\\n\\n在本文中，我们使用以下规格：\\n+ 4 vCPU\\n+ 700 GB的NVMe空间用于收集器的数据库。需要能够扩展此磁盘空间。\\n+ 8GB RAM\\n\\n\\n## 重要信息\\n1. 我们在这些说明中使用了一些变量，您需要在所有命令中替换为自己的值：\\n    + **%NODE_NAME%**是节点名称。例如：*my-robonomics-kusama-collator*\\n    + **%BASE_PATH%**是挂载卷的路径。例如：*/mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%**Polkadot生态系统中的帐户地址，以SS58格式表示。例如：*4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. 请注意，在收集器的服务启动中需要包含*--state-cache-size=0*。此参数对于收集器的稳定性很重要。\\n您可以在github上的相关[问题](https://github.com/airalab/robonomics/issues/234)中查看更多信息。\\n\\n## 首次轻松启动Robonomics收集器\\n\\n您可以直接在命令行中轻松启动收集器以检查错误。\\n在执行此操作后，强烈建议将Robonomics收集器作为服务启动（请参阅下一步）。\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## 将Robonomics收集器作为服务启动\\n\\n1. 为服务创建具有主目录的用户\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. 下载、提取并将Robonomics二进制文件移动到*/usr/local/bin/*目录。您需要在本节命令中替换*$ROBONOMICS_VERSION*为Robonomics的当前版本。您可以在github上的[Robonomics存储库的发布页面](https://github.com/airalab/robonomics/releases)上找到当前版本。\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. 创建名为*robonomics.service*的systemd服务文件：\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    并在服务文件中添加以下行：\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. 保存此文件，然后启用并启动服务：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n遥测网址：https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\n可以通过以下方式监控整理器日志：`journalctl -u robonomics.service -f`\\n\\nRobonomics 整理器启动后，它将开始与 Kusama 中继链同步，这可能需要相当长的时间，具体取决于您的网络速度和系统规格，因此我们建议下载 Kusama 快照。 \\n\\n\\n## 使用Kusama快照加速同步过程\\n\\n我们建议在创建和启动Robonomics服务后立即执行此操作。有关照和使用说明的更多信息，请访问以下页面：https://ksm-rocksdb.polkashots.io/\\n\\n说明：\\n\\n1. 停止Robonomics服务并删除当前的Kusama数据库目录：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. 下载实际的快照并解压缩：\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    解压成功后可以删除下载的压缩包：\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. 为数据库文件夹设置正确的所有权：\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. 再次启动Robonomics服务：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. 检查服务日志：\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## 故障排除\\n### 错误：\\\"State Database error: Too many sibling blocks inserted\\\"\\n要修复此错误，您可以在存档模式下启动整理器：\\n\\n1）首先，需要停止Robonomics服务： \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2）然后在服务文件的平行链部分添加参数`--state-pruning=archive`。编辑后的服务文件示例：\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3）重新加载systemd管理器配置：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4）删除现有的平行链数据库：\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5）启动robonomics服务：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    之后需要等待平行链数据库的同步。\\n\\n### 错误：\\\"cannot create module: compilation settings are not compatible with the native host\\\"\\n此错误与虚拟化参数有关。需要使用“host-model”类型的模拟处理器。您可以在虚拟化主机上进行设置。\\n\\n但是，如果您在任何托管平台上遇到此错误，您需要向技术支持咨询此问题。\\n\"}},{\"node\":{\"id\":\"59ee9535da4158da439e9f3f2b2fdcd0\",\"title\":\"如何从源代码构建碎片节点\",\"path\":\"/docs/zh/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  在本文的演示和截图中，我们使用了Robonomics的1.4.0版本。您需要使用相同的命令，但将Robonomics的版本替换为当前版本。\\n</robo-wiki-note>\\n\\n## 什么是碎片节点\\n\\n碎片节点是Robonomics碎片链的一部分。这种节点类型为链创建新的区块。.\\n\\n>碎片节点通过从用户收集碎片链交易并为中继链验证者生成状态转换证明来维护碎片链。换句话说，碎片节点通过将碎片链交易聚合到碎片链块候选项中，并根据这些块为验证者生成状态转换证明来维护碎片链。\\n\\n您可以在相关的[Polkadot wiki页面](https://wiki.polkadot.network/docs/learn-collator)上了解更多关于碎片节点的信息。\\n\\n在 Robonomics 平行链中，如果该区块被密封到链上，则每个整理者都会为其构建的每个区块获得奖励 (**0.000380520 XRT**)。\\n整理者还可以从该区块中获得 **50% 的交易费用**。\\n\\n## 构建过程\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\n确保您已安装Rust和支持软件。Rust安装程序将询问您有关当前安装选项的问题，您应选择“1）继续安装（默认）”选项。\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![安装 Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\n安装所需的夜间工具链和wasm目标。\\n下面的命令适用于Robonomics v2.6.0：\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\n您还需要安装以下软件包：\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\n现在您可以从git源代码安装robonomics节点。\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\n执行此命令后，编译后的robonomics二进制文件将位于“~/.cargo/bin”目录中。\\n\\n下一步是如何启动碎片节点。您可以在[\\\"如何启动Robonomics碎片节点\\\"](/docs/how-to-launch-the-robonomics-collator)文章中阅读相关信息。\"}},{\"node\":{\"id\":\"ef19eafe544cfe7055dc62c564f03d6f\",\"title\":\"升级您的Home Assistant OS\",\"path\":\"/docs/zh/hass-os-upgrade/\",\"content\":\"\\n**本文包含使用Robonomics集成升级现有Home Assistant OS的说明。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## 安装 IPFS Add-on\\n\\n\\nRobonomics集成使用本地IPFS守护程序存储数据，因此您需要先安装它。 \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. 有一个[Home Assistant的IPFS插件](https://github.com/airalab/ipfs-addon)。要安装它，转到`Settings` -> `Add-ons`并按右下角的“ADD-ON STORE”按钮。\\n\\n2. 点击右上角的三个点，选择“Repositories”。在那里添加以下链接：\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. 点击“ADD”按钮。\\n\\n4. 关闭存储库管理器并刷新页面。现在在页面末尾，您可以看到IPFS Daemon插件。\\n\\n5. 打开插件并点击“INSTALL”。安装完成后，点击“START”。\\n\\n## 安装HACS\\n\\n[Home Assistant社区商店（HACS）](https://hacs.xyz/)允许您安装自定义集成。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. 在开始之前，您需要安装用于通过SSH连接到Home Assistant设备的插件。在插件商店中搜索“ssh”。我们建议安装“SSH＆Web终端”插件。\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  如果找不到SSH插件，请尝试在用户配置文件设置中启用高级模式。要做到这一点，点击左下角的个人资料图标，找到高级模式选项。\\n\\n</robo-wiki-note>\\n\\n2. 选择插件并点击“INSTALL”。安装完成后，转到“配置”选项卡并添加“password”或“authorized_keys”。不要忘记保存此部分配置。\\n\\n3. 在“Info”选项卡中点击“START”。如果您想在侧边栏中看到该插件，请不要忘记启用“Show in sidebar”。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. 打开SSH插件并运行以下命令：\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. 重新启动Home Assistant（您可以在 `Settings`->`System`中进行.\\n\\n6. 现在HACS集成将可在“Integrations”菜单中添加。转到“Settings”->“Devices & Services”，点击“Add Integration”并找到HACS。\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  要使用HACS，您需要一个Github帐户。\\n\\n</robo-wiki-note>\\n\\n7. 点击它并按照安装说明进行操作。 \\n\\n## 安装Robonomics集成\\n\\n现在您可以使用HACS安装Robonomics集成。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\n从侧边栏菜单打开HACS，导航到“Integrations”。点击“Explore & Download Repositories”，然后搜索“Robonomics”并点击右下角的“Download”按钮。下载完成后，重新启动Home Assistant。\"}},{\"node\":{\"id\":\"705aaddd938e1afe13c68fa6af99bc64\",\"title\":\"Home Assistant 初始化\",\"path\":\"/docs/zh/hass-init/\",\"content\":\"\\n**安装 Home Assistant 后，需要进行初始化。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\n您正在开始创建 Home Assistant 的所有者账户。该账户是管理员账户，可以进行任何更改。打开浏览器，转到 `http://%RASPBERRY_IP_ADDRESS%:8123`。您可以使用 [Fing 移动应用](https://www.fing.com/products) 或 [nmap CLI 工具](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) 找到 Raspberry Pi 的 IP 地址。\\n\\n<robo-wiki-note type=\\\"note\\\">由于路由器设置的原因，树莓派的地址可能会随时间变化。</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. 在第一页上，输入名称、用户名、密码，然后点击`CREATE ACCOUNT`按钮。\\n\\n2. 在下一个屏幕上，为您的家庭设置一个名称，并设置您的位置和单位系统。点击`DETECT`以找到您的位置，并根据该位置设置您的时区和单位系统。如果您不想发送您的位置，您可以手动设置这些值。\\n\\n3. 然后，Home Assistant 将显示在您的网络上发现的任何设备。如果您看到的项目比下面显示的少，不要担心；您随时可以手动添加设备。现在，只需点击`FINISH`，您将进入主 Home Assistant 屏幕。\\n\\n4. 最后，您将看到 Home Assistant 的 Web 界面，其中将显示您的所有设备。 \\n\\n\\n## 故障排除\\n\\n1. 如果您忘记了本地用户的登录名或密码，请[查看此文章](https://www.home-assistant.io/docs/locked_out/)以恢复您的凭据。\\n\"}},{\"node\":{\"id\":\"eebef247a25c15680d4d0cc223dbd9fe\",\"title\":\"树莓派预装镜像\",\"path\":\"/docs/zh/hass-image-install/\",\"content\":\"\\n**欢迎使用树莓派上安装Home Assistant与Robonomics集成的指南。Home Assistant是一个开源的家庭自动化系统，为您的家庭网络中的智能设备提供了一个集中控制中心。通过与Robonomics集成，一个去中心化的云服务，您可以增强您的智能家居的能和安全性。在本文中，我们将提供逐步指南，教您如何在树莓派上安装Home Assistant与Robonomics，使您能够使用安全和去中心化的解决方案自动化和控制家庭的各个方面。让我们开始吧！**\\n\\n## 安装所需的硬件\\n\\n如果您还没有将Home Assistant纳入您的智能家居设置中，了解您需要建立一个完整的智能家居系统所需的设备是很重要的。\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. 下载Robonomics预装镜像\\n\\nRobonomics预装镜像包含：\\n- Home Assistant Core\\n- IPFS\\n- MQTT代理和集成\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\n您可以在[GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)上检查源代码并下载最新版本的镜像\\n\\n</robo-wiki-note>\\n\\n\\n## 2. 配置镜像\\n\\n在您的计算机上安装[Raspberry Pi Imager](https://www.raspberrypi.com/software/)。然后，插入SD卡。\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\n运行 Raspberry Pi 成像器程序。 选择所需的映像作为操作系统，并确保从存储下拉菜单中选择您的 SD 卡。\\n在设置中：\\n- 设置用户名和密码（保存默认用户名\\\"pi\\\"以便记忆），  \\n- 提供您的Wi-Fi名称和密码， \\n- 从下拉列表中选择您的国家\\n然后`写入`镜像。 \\n                   \\n<robo-wiki-note type=\\\"note\\\">仔细保存用户名和密码，因为在故障排除时将需要这些凭据</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\n您可以在[这里](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)找到国家代码。\\n\\n## 3. 首次启动\\n\\n**安全地弹出SD卡**，将其插入树莓派。然后**插入Zigbee适配器**到树莓派。\\n\\n<robo-wiki-note type=\\\"warning\\\">在首次启动树莓派之前入Zigbee适配器非常重要！ \\n这是为了自动配置Zigbee网络所需的。</robo-wiki-note>\\n\\n**如果您有[JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en)（具有所有必要的固件），您可以直接按照这些说明进行操作。然而，如果您有另一个适配器，您首先需要使用Zigbee2MQTT软件对其进行刷写。您可以在[这里](https://www.zigbee2mqtt.io/information/supported_adapters.html)找到有关您的设备的说明。**\\n\\n接下来，将电源线连接到您的设备。它应该连接到您的Wi-Fi网络。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\n连接 Raspberry Pi 后，红色 LED 将亮起，绿色 LED 将闪烁一段时间。 最多等待 5 分钟，以便 Raspberry Pi 启动并在网络上注册。\\n\\n现在找到树莓派的IP地址。您可以使用[Fing移动应用](https://www.fing.com/products)或 \\n[nmap CLI工具](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)来查找。找到`robots-home`（可选名称可能是`Home(homeassistant)`） \\n主机机器在IP列表中的名称。 \\n\\n在这个例子中，地址是`192.168.43.56`。 \\n\\n要检查一切是否正常工作，请打开Web浏览器并转到网页`http://%RASPBERRY_IP_ADDRESS%:8123`。在这个例子中，它将是`192.168.43.56:8123`。\\n如果一切正常，您将看到Home Assistant的Web界面。如果网页无法打开，请等待最多5分钟让树莓派启动，然后重试。 \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## 故障排除\\n\\n1. 要在以后更改Wi-Fi设置，您应该通过`ssh`命令登录到您的树莓派。为此，在您的计算机上打开终端\\n并使用您在\\\"配置镜像\\\"步骤中创建的用户名输入ssh命令（默认为\\\"pi\\\"）。 \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\n然后使用命令`sudo raspi-config`。在[官方网站](https://www.raspberrypi.com/documentation/computers/configuration.html)上找到有关此命令的更多信息。\\n\"}},{\"node\":{\"id\":\"93058d772af83b96e2ab3da5a3da99a0\",\"title\":\"升级您的Home Assistant Docker（适用于类Unix操作系统）\",\"path\":\"/docs/zh/hass-docker-upgrade/\",\"content\":\"\\n**本文包含使用Robonomics集成升级现有Home Assistant Docker的说明。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. 假设使用默认的Docker镜像和Home Assistant容器，名称为<u>homeassistant</u>。\\n  2. IPFS将作为一个<u>systemd</u>服务安装和运行在主机上。\\n  3. 假设您已安装[Python3.9](https://www.python.org/downloads/)或更版本。\\n\\n</robo-wiki-note>\\n\\n## 安装\\n\\n下载安装脚本并在终端中运行它：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\n您将看到以下输出：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  您可能会看到一个错误，如`mkdir: can't create directory 'custom_components': File exists`。这意味着您已经安装了一些自定义组件的文件夹。只需忽略此消息。\\n\\n</robo-wiki-note>\\n\\n重新启动容器：\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## 验证\\n\\n检查IPFS服务是否正在运行：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\n您将看到以下输出：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"8079822418d7a6a9a9f827c306c156e3\",\"title\":\"升级您的Home Assistant Core\",\"path\":\"/docs/zh/hass-core-upgrade/\",\"content\":\"\\n**本文包含使用Robonomics集成升级现有Home Assistant Core的说明。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. 假设您的Home Assistant Core的安装是按照[官方说明](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core)完成的，并且存在一个<u>homeassistant</u>用户和`venv`环境。如果不是这种情况，请按照下面的说明进行操作，**但相应地编辑脚本**。\\n  2. IPFS将作为一个<u>systemd</u>服务安装和运行在主机上。\\n  3. 假设您已安装[Python3.9](https://www.python.org/downloads/)或更高版本。\\n\\n</robo-wiki-note>\\n\\n## 安装\\n\\n下载安装脚本并在终端中运行它：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\n您将看到以下输出：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n在过程中，您将被要求确认重新启动几个服务。使用`tab`进行导航，选择`yes`选项。\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  您可能会看到一个错误，如`mkdir: can't create directory 'custom_components': File exists`。这意味着您已经安装了一些自定义组件的文件夹。只需忽略此消息。\\n\\n</robo-wiki-note>\\n  \\n完成后，重新启动您的Home Assistant。\\n\\n## 核实\\n\\n检查IPFS服务是否正在运行：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\n您将看到以下输出：\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"a8279727304b57166d3f8762bbaa9bfb\",\"title\":\"Glossary\",\"path\":\"/docs/zh/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\n一个公私钥对的连接，其中公钥是用户的公共地址，私钥是访问该地址控制权的秘密密钥。\\n\\n\\n### Auction (of Parachains)\\n在Polkadot和Kusama生态系统中为平行链租用插槽的机制；平行链必须通过蜡烛拍卖赢得插槽。\\n\\n### Autonomous Agent\\n一个计算系统，从环境中接收感知数据并决定如何响应外部激以实现其目标。\\n\\n### AIRA\\n或称为自主智能机器人代理——这是由Robonomics团队于2015年开发的软件，通过智能责任合同实现经济人机和机机交互的标准。\\n\\n\\n## B\\n\\n### Blockchain\\n在广义上，是一种使用密码学的分布式网络，允许一组参与者在系统的不断变化状态上达成无需信任的共识。\\n\\n### Blockchain 探索r\\n一种应用程序，允许在区块链上探索不同的区块、交易和地址（例如Etherscan、Subscan）。\\n\\n### Blueprint (Hass)\\n一个预先制作的自动化逻辑，可以轻松添加到Home Assistant实例中。\\n\\n### Bridge\\n一种技术和方法，使两个经济主权和技术多样化的链能够相互通信。 \\n\\n\\n## C\\n\\n### Coase (XRT)\\n或 Cs — 一个 XRT 代币的百万分之一，1 XRT = 1 000 000 Cs； 以英国经济学家、制度经济学创始人之一、诺贝尔经济学奖获得者罗纳德·科斯命名。\\n\\n### Collator\\n通过收集平行链交易并为验证者生成状态转换证明来维护平行链的节点。\\n\\n### Consensus\\n区块链网络的节点就网络中数据的当前状态达成一致的过程（例如工作量证明、权益证明）。\\n\\n### Crowdloan\\n一种通过收集代币进行众筹的活动，以在Polkadot/Kusama生态系统的插槽拍卖中进行竞标。\\n\\n### Cybernetics\\n控制和通信在动物和机器中的研究，根据N.维纳的定义。\\n\\n### Cyber-Physical System\\n或称为CPS——多个计算、网络和物理过程的强大统一和相互整合。\\n\\n\\n## D\\n\\n### DAO\\n一种集体拥有、以区块链治理的组织，其资源管理根据预先约定和形式化的规则进行，其执行是自动完成的。\\n\\n### Datalog (Function)\\nRobonomics平行链能，将设备数据存储在区块链上。\\n\\n### Dapp\\n或称为去中心化应用程序——作为分布式网络的一部分运行并以用户友好的方式提供访问其功能的应用程序。\\n\\n### Decentralized Cloud\\n基于去中心化的点对点网络的云计算服务，用户可以加入以使用服务或提供计算、网络、存储等资源。\\n\\n### Digital Twin\\n真实设备的数字版本，复制其技术特性和历史数据。\\n\\n\\n## E\\n\\n### Edge-system\\n作为本地可访问的嵌入式系统和全球网络之间的链接的物联网设备，通常支持通信协议并传输遥测和控制信号。\\n\\n### Embedded System\\n具有有限计算和通信资源的物联网设备，在最低级别提供基本功能（传感器、执行器、按钮），通常没有用户界面。\\n\\n### Ethereum\\n一种去中心化的开源区块链系统，作为许多其他加密货币的平台，以及执行去中心化智能合约。\\n\\n### Ethereum Upgrade\\n以前称为Ethereum 2.0或Eth2——Ethereum协议的升级，旨在使网络更具可扩展性、安全性和可持续性；为此，建议将共识机制更改为权益证明，并添加分片机制以增加网络容量。\\n\\n### Exodus\\n将XRT代币从以太坊网络转移到Robonomics平行链的过程。\\n\\n### Extrinsic\\n在Polkadot和Kusama网络上触发网络状态转换的功能，可以从状态外部触发。\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\n或Gk——XRT代币的千分之一，1 XRT = 1 000 Gk；以苏联数学家维克托·鲁什科夫的名字命名，他是信息技术和控制论在苏联的创始人之一。\\n\\n\\n## H\\n\\n### Home Assistant\\n或 Hass — 一种开源控制系统软件，旨在成为智能设备的中央枢纽。\\n\\n### HRMP\\n或水平中继路由消息传递——在平行链之间传递的安全消息，在将消息发送到平行链之前将所有消息存储在中继链存储中。\\n\\n### HMI\\n或人机界面——将用户与机器、系统或设备连接的用户界面或仪表板。\\n\\n\\n## I\\n\\n### Industry 4.0\\n或第四次工业革命——利用现代智能技术对传统制造和工业实践进行自动化的持续进行。\\n\\n### IPFS\\n或星际文件系统——用于存储和共享数据的点对点软件分布式文件系统。\\n\\n### IoT\\n或物联网——连接到数十亿设备的全球网络，能够收集数据并集成到环境中。\\n\\n### IoT Gateway\\n一种边缘系统，将来自物联网设备的数据聚合和传输到网络，反之亦然；通常这些设备是WiFi路由器的更复杂版本。\\n\\n### IoT Provider\\n为物联网用户提供远程访问数据和分析以及对智能设备的控制的外部服务。\\n\\n### IoT Subscription\\nRobonomics平行链功能，允许在一定时间内免费使用平行链的所有功能。\\n\\n\\n## K\\n\\n### KSM\\nKusama网络的本地代币。\\n\\n### Kusama\\nPolkadot的\\\"金丝雀网络\\\"，由Polkadot软件的早期发布版本组成，未经审计。\\n\\n\\n## L\\n\\n### 启动 (Function)\\nRobonomics平行链功能，通过区块链发送命令启动或停止设备。\\n\\n### Lease Period\\n平行链可以连接到中继链的时间段。\\n\\n### Libp2p\\n用于创建加密的点对点网络的开源库。\\n\\n### Lights-out Factory\\n或智能工厂-一家完全自动化且不需要人员在现场的工厂。\\n\\n### Lighthouse\\n在机器人经济概念中，提供者在承诺人和受托人之间建立市场匹配时执行交易的智能合约。\\n\\n### 责任\\n由互联物理系统之间或与人类之间创建的智能合约，用于执行任务并获得支付。\\n\\n### Liability Market\\n在机器人经概念中，负责在系统的节点之间匹配供求的平台。\\n\\n\\n## M\\n\\n### MQTT\\n或消息队列遥测传输 - 一种为低带宽、高延迟、不可靠网络设计的发布-订阅协议，用于操作大量物联网设备消息。\\n\\n### MQTT Broker\\n一个服务，接收来自MQTT客户端的所有消息，然后将消息路由到适当的订阅客户端。\\n\\n\\n## N\\n\\n### NFT\\n或非同质化代币 - 一种不能互换和与其他代区分的代币，允许唯一物品的代币化，并为这些代币提供独占所有权。\\n\\n### Node (of Robonomics)\\n一个基于Substrate或以太坊的区块链模块，具有用于连接Robonomics网络的Robonomics扩展。\\n\\n\\n## O\\n\\n### On-chain Governance\\n确定网络允许的更改的过程，例如代码修改或资金移动，存在于网络本身中，并可以直接更改它。\\n\\n\\n## P\\n\\n### Pallet\\n用 Rust 编写的 Substrate 模块，捆绑基于 Substrate 的区块链运行时的特定逻辑或算法。 \\n\\n### Parachain\\n一个自定义的、应用特定的数据结构（通常是区块链），集成到中继链中，并可以由验证者验证。\\n\\n### Parathread\\n一个没有插槽的平行链，可以临时参与（按块收费）中继链的安全性。\\n\\n### Polkadot\\n一个异构的、多链网络，允许具有不同特性的各种区块链在共享安全性下进行任意的跨链通信。\\n\\n### Polkadot/Substrate Portal\\n与Polkadot、Kusama和其他Substrate网络进行交互的基本Substrate用户界面。\\n\\n### Proposal (on Polkadot / Kusama)\\n在 Polkadot、Kusama 或平行链公投中进行投票的潜在函数调用。 \\n\\n### Proof-of-Work\\n一种共识机制，为了达成一致，网络参与者需要执行计算工作。\\n\\n### Proof-of-Stake\\n一种共识机制，为了达成一致，网络参与者需要抵押相关加密货币作为抵押品。\\n\\n### Promisee\\n在机器人经济概念中，下达任务执行订单的节点。\\n\\n### Promisor\\n在机器人经济概念中，同意执行任务以获取报酬的节点。\\n\\n### Provider (Robonomics)\\n机器人经济概念中的一个节点，用于监控负债市场的消息并以少量费用匹配报价和需求。\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\n作为链上治理的一部分，投票决定网络用户是否接受提案。\\n\\n### Relay Chain\\n协调Polkadot / Kusama共识和平行链之间通信的主链。\\n\\n### Robofirm\\n一个完全自动化且不需要人类参与的整个业务流程周期的组织。\\n\\n### Rococo\\n在Kusama上测试平行链测试网。\\n\\n### robonomics-interface\\n一个专门用于与Robonomics方便编程的Python库。\\n\\n### Robonomics在以太坊上\\n运行在以太坊之上的Robonomics Network的版本，于2018年发布。\\n\\n### Robot Economy\\n一种经济系统，其中设备作为能够执行以前仅限于人类的关键经济活动的独立代理。\\n\\n### Robot-as-a-Service\\n或RaaS - 公司将其机器人设备租给客户和用户进行短期或长期使用的商业模式。\\n\\n### ROS\\n或机器人操作系统 - 用于机器人软件开发的框架，提供针对异构计算机集群的服务，如硬件抽象、低级设备控制、常用功能的实现、进程间消息传递和软件包管理。\\n\\n### ROS 2\\n具有新功能的更新和重建版本的机器人操作系统，例如支持多机器人和小型嵌入式系统，并与实时系统集成。\\n\\n### ROS 2 Middleware\\n或RMW - 提供标准ROS 2功能（如发现、序列化和传输）的协议；ROS 2支持多个中间件实现，可以根据项目要求选择最适合的。\\n\\n### RWS\\n或Robonomics Web Services - 用于机器人和物联网的分散基础设施服务，可轻松连接设备并与用户应用程序、云服务和其他设备安全交互；它还有自己的代币，也称为RWS，可在Robonomics平行链中提供终身物联网订阅。\\n\\n### 运行time\\n区块链的状态转换函数，定义了确定下一个块状态的有效算法，给定先前的状态。\\n\\n\\n## S\\n\\n### Seed Phrase\\n作为随机单词序列创建的可私钥，用于访问区块链地址及其代币。\\n\\n### Shared Security\\nPolkadot / Kusama的安全模型，通过将平行链块的有效性证明放入中继链中，使所有链都得到同等的安全保障，以至于潜在的攻击者需要攻击整个系统。\\n\\n### SLS Gateway\\n基于ESP32微控制器开发的基于Zigbee设备的开源物联网网关。\\n\\n### Slot (of Parachain)\\nPolkadot / Kusama生态系统中的稀缺资源，允许平行链连接到中继链而无需每个块支付费用。\\n\\n### Smart Leasing\\n机器人作为服务模型的一种变体，租金不是按时间支付，而是按特定操作及其数量支付。\\n\\n### Smart Contract\\n存储在区块链上的在预定条件满足时自动运行的程序或算法。\\n\\n### SSH\\n或 Secure Shell — 一种用于在不安全的网络上安全地操作网络服务的网络协议，它使用公钥加密技术来验证远程计算机。\\n\\n### Staking\\n权益证明共识的一部分，通过抵押代币作为产生有效块和获得奖励的机会的抵押品。\\n\\n### Substrate\\n用于构建类似于Polkadot和Kusama的区块链的模块化框架。\\n\\n\\n## T\\n\\n### Treasury\\n通过一部分块生产奖励、交易费用、质押等收集的资金池，可以通过提出支出提案来使用；如果财政部在支出期结束时没有使用完所有资金，将烧毁一部分资金。\\n\\n### Transaction Costs\\n由于经济主体的有限理性和过程的复杂性，收集和处理信息的成本。\\n\\n\\n## V\\n\\n### Validator\\n通过抵押其代币、验证来自平行链的校对者的证明并与其他验证者一起对共识进行投票，以确保中继链的节点。\\n\\n\\n## W\\n\\n### Web3\\n一个关于Web的新迭代的想法，其中包括去中心化、区块链技术和基于代币的经济等概念。\\n\\n### Wiener (XRT)\\n或Wn —— 一个XRT代币的十亿分之一份额，1 XRT = 10亿Wn；以诺伯特·维纳（Norbert Wiener）命名，他是一位美国数学家，也是控制论和人工智能理论的创始人之一。\\n\\n\\n## X\\n\\n### XCM\\n或跨共识消息格式 —— 在Polkadot / Kusama中不同区块链系统之间进行消息传递的格式。\\n\\n\\n### XRT\\nRobonomics Network的本地代币，独立存在于以太坊和Kusama网络中。\\n\\n\\n## Y\\n\\n### Yggdrasil\\n一种完全端到端加密路由方案的覆盖网络实现，用于网状网络。\\n\\n\\n## Z\\n\\n### Zigbee\\n一种无线通信协议，非常常用于连接智能设备，因为功耗低、易于配置和支持自组织和自恢复的网络拓扑。\\n\\n### Zigbee Adapter\\n一种在Zigbee网络和另一个网络（如Wi-Fi）之间传输数据以控制Zigbee设备的设备。\\n\\n### Zigbee2MQTT\\n一种软件，允许通过将消息从一个网络转换到另一个网络来将 Zigbee 连接到 MQTT 网络。 \"}},{\"node\":{\"id\":\"4ea1b490ba8b23c580c3f8697c5f4c6b\",\"title\":\"如何购买订阅\",\"path\":\"/docs/zh/get-subscription/\",\"content\":\"\\n**在区块链交易中支付佣金非常烦人。想象一下，一个物联网设备每5-10分钟发送一次遥测数据。这将使您在一个月内支付相当多的费用。Robonomics Network的一个关键特性是RWS - Robonomics Web Service订阅。每月支付，忘记交易费用！有关理论背景，请参阅[此](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855)文章。**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  在开始之前，请注意，本教程演示了如何在Robonomics Kusama平行链上购买订阅。您也可以在您的[本地节点](/docs/run-dev-node)上执行相同的步骤。\\n\\n  开始之前还有一件事。这是一种\\\"困难\\\"的购买订阅的方式。还有一种传统的方式是通过[Robonomics DApp](https://dapp.robonomics.network/#/)来完成。\\n\\n</robo-wiki-note>\\n\\n## 竞标拍卖\\n\\nRobonomics中的订阅是通过拍卖模式出售的。要获得一个订阅，您需要竞标并赢得拍卖（不用担心，很快）。\\n\\n在`Developer/Chain state`中，您可以看到可用的拍卖。 \\n选择`rws`和`auctionQueue`，然后点击`+`按钮，您将看到可用拍卖的ID：\\n\\n![queue](../images/rws/queue.png)\\n\\n您可以使用`rws` `auction`和拍卖ID（图片中的拍卖ID为79）查看有关任何订阅的信息：\\n\\n![auction](../images/rws/auction.png)\\n\\n在拍卖信息中，您可以看到`winner`字段，目前为`null`，表示没有人拥有此订阅，您可以获得它。为此，请转到`Developer/Extrinsic`，选择您的账户和`rws -> bid`。还要设置拍卖ID（79）和要竞标的单位数量（超过1000000000 Wn）：\\n\\n![bid](../images/rws/bid.png)\\n\\n提交交易并检查拍卖ID 79的信息（在`链状态`Chain state` `rws -> auction`和ID 79）：\\n\\n![win](../images/rws/auc_win.png)\\n\\n现在在`winner`字段中，您将看到您的账地址，这意味着该账户拥有订阅79。拍卖从第一次竞标开始，持续几个区块，因此如果在接下来的几个区块中有人出价比您更多的代币，那个人将成为赢家并获得订阅。\\n\\n现在您可以添加设备。设备是能够使用此订阅并提交无费用外部交易的账户。\\n要测试它，请创建一个没有令牌的新帐户并将其添加到设备。\\n\\n要添加设备，请在`Developer/Extrinsic中选择`rws -> setDevices`。然后点击`Add Item`按钮，并选择最近创建的没有代币的账户：\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\n提交交易。现在您可以使用`rws -> devices`Chain state`中检查设备列表。在那里，您将看到您的账户地址，没有代币。选择已购买订阅的账户并点击`+`：\\n\\n![devices](../images/rws/devices.png)\\n\\n现在您可以尝试使用订阅[发送启动](/docs/subscription-launch)外部交易。\"}},{\"node\":{\"id\":\"b7d9e0b430c2bbc8dd8da0a66dea2e65\",\"title\":\"Substrate Cumulus Parachain Testsuite для міжланцюжкового обміну повідомленнями\",\"path\":\"/docs/uk/xcm-robobank/\",\"content\":\"\\n\\nОсновною метою цього проекту є спрощення розробки часу виконання парачейну, коли використовуються міжланцюжкові овідомлення. \\nВін дозволяє розробляти код часу виконання з інтеграційними тестами з високим ступенем повторюваності та простим використанням.\\nВін автоматизує побудову, створення попередньо налаштованої конфігурації мережі (тобто 1 реле-ланцюг + 2 парачейни), налаштування каналів передачі повідомлень між парачейнами та запуск тестів повідомлень, відправку повідомлень, використання виклику до часу виконання, все побудовано і складено на Python.\\n\\nXCM Testsuite використовується для тестування виробничого циклу Robobank - набору палет Substrate, які дозволяють роботам реєструватися на зовнішніх парачейнах, отримувати передоплачені замовлення, виконувати їх та отримувати платежі з використанням зовнішніх токенів. Це дозволяє роботам працювати в мережі Robonomics з усією необхідною інфраструктурою, але в той же час пропонувати свої послуги на будь-якому іншому парачейні.\\n\\nПриклад відео доступний на [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nОсновні кроки в демо-сценарії:\\n- запуск реле-ланцюга та двох парачейнів у пакеті з 6 процесами\\n- налаштування каналів передачі повідомлень XCM між парачейнами\\n- реєстрація робота в обох парачейнах\\n- створення замовлення для цього робота в клієнтському парачейні (резервування платежу за виконання замовлення)\\n- відправка повідомлення XCM на парачейн Robonomics\\n- створення \\\"дзеркального\\\" запису замовлення на парачейні Robonomics\\n- робот приймає замовлення на парачейні Robonomics\\n- відправка повідомлення XCM про прийняття замовлення назад на клієнтський парачейн\\n- прийняття замовлення на клієнтському парачейні (резервування штрафу за невиконання замовлення до кінцевого терміну)\\n- робот виконує замовлення на парачейні Robonomics\\n- відправка повідомлення XCM про завершення замовлення на клієнтський парачейн\\n- розрахунок всіх платежів (платіж клієнта передається роботу, а також не використаний штраф за невикористання замовлення)\\n- закриття замовлення1\\n\\n\\n## Вгору\\nЦей проект є форком\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nВін містить код палеток часу виконання, які тестуються.\\nЯк і в оригінальному вузловому коді парачейнів знаходяться в каталогах \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nВідмінності від оригінального \\\"substrate-node-template\\\":\\n- цей час виконання колатора має модуль обробника HRMP і може обробляти повідомлення від парачейнів-сусідів\\n- мок-тестовий час виконання готовий для внутрішніх тестів XCM\\n\\n## Побудова та запуск\\nРекомендована (висока) настройка: \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[ПРИМІТКА] Перша збірка може зайняти багато часу, до кількох годин на нептимальних машинах.\\n\\n[ПРИМІТКА] Скрипт працює з ФІКСОВАНИМИ версіями (хешами комітів) Polkadot(Rococo) в реле-ланцюзі та парачейнах.\\n\\n[ПРИМІТКА] За замовчуванням скрипт перестворює те саме середовище кожного запуску, видаляючи всі попередні стани. Цю поведінку можна змінити в \\\"config.sh\\\", використовуючи параметр \\\"PERSISTENT\\\".\\n\\n\\nЗапустіть скрипт побудови та налаштування.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nОсновні дії скрипта \\\"init.sh\\\":\\n - читання конфігурації (файл \\\"config.sh\\\" з номером ревізії, початковими ключами та ідентифікаторами вузлів, параметром збереження даних ланцюга тощо)\\n - налаштування пакетів ОС, Rust та Python\\n - побудова окремих бінарних файлів для реле-ланцюга та для обох парачейнів\\n    - бінарні файли будуть згенеровані в підкаталозі ./bin. \\n - (необов'язково) видалення всіх попередніх даних ланцюга для всіх ланцюгів\\n    - вимикається, якщо \\\"PERSISTENT=1\\\" встановлено в \\\"config.sh\\\"\\n - працює як окремі процеси (з окремими PID та каналами введення/виведення):\\n    - валідатори реле-ланцюга (тобто 4 валідатори, які працюють на стабільній ревізії Rococo)\\n    - колатори для парачейна-100 (тобто один колатор для першого парачейна, який ви розробляєте)\\n    - колатори для парачейна-200 (тобто один колатор для другого парачейна, який ви розробляєте)\\n - друкує всі кінцеві точки, порти на консоль, що дозволяє вивчати будь-який ланцюг за допомогою фронтенд-додатків (експлорер, DApp)\\n - продовжує друкувати всі вихідні дані всіх ланцюгів на консоль\\n\\n[ПОПЕРЕДЖЕННЯ] Після запуску зачекайте, поки мережа запуститься, переконайтеся, що фіналізація блоку розпочалася, і що парачейни зареєстровані. Ці процеси повинні зайняти приблизно 5 хв (50 блоків x 6 сек).\\n\\n## Перевірка роботи початкової настройки \\n\\nВикористовуйте стандартний фронтенд Polkdot та згенеровані кінцеві точки \\\"--ws-port\\\" для підключення до кожного вузла.\\nВідкрийте [додаток Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) для моніторингу ланцюгів. \\n\\n### Приклад:\\nLocalhost, 4 валідатори реле-ланцюга, один колатор парачейна-100, один колатор парачейна-200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nЯкщо все працює, і консенсус розпочато, ми можемо перейти до запуску наших тестових випадків (у новому терміналі).\\n\\n### Тест передачі повідомлень UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nВін створює повідомлення `Balance.transfer` в `parachain-100` і передає його на реле-ланцюг.\\nКоли реле-ланцюг отримує повідомлення, він переказує 15 токенів з рахунку `para 100` на рахунок Чарлі.\\n\\n\\n### Тест передачі повідомлень HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nВін створює повідомлення `Balance.transfer` в `parachain-100` і передає його на `sibling 200`.\\nПеред цим він надає рахунку `subl 100` 1000 токенів і встановлює комунікаційний канал між паралелізмами.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nНаступні повідомлення можна надсилати, запустивши підкоманду `hrmpm`. Вона не створює каналу, тому працює швидше.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Додаткові параметри\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Локальна тестова мережа\\n\\n### Створити настроюваний специфікацію ланцюжка\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nРедагуйте rococo_local.json, замініть параметри балансів та авторитетів на свої.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nАдреса Polkadot для //Alice//stash (криптографія sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nКлюч сесії Polkadot grandpa для //Alice (криптографія ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nАдреса Polkadot для //Alice (криптографія sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nКонвертувати rococo_local.json у формат raw.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nЩоб використовувати нову специфікацію ланцюжка, замініть файл rococo.json у каталозі ./config/ на цей новий і перезапустіть ланцюжок.\\n```bash\\n./scripts/init.sh run\\n```\\nВи можете вільно редагувати код. Вищезазначена команда перебудує проект та оновить вузловий вузол перед запуском.\\nCumulus - це передвипускне програмне забезпечення, яке все ще перебуває в активній розробці.\\nWe are using a specific commit of polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nВи можете використовувати більш нові версії програмного забезпечення. Для цього змініть POLKADOT_COMMIT у ./scipt/config.sh\\nна останній коміт гілки `rococo-v1`, видаліть ./bin/polkadot та запустіть \\n```bash\\n./scripts/init.sh run\\n```\\n\\nОновлення залежностей проекту коллатора \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nДеякі залежності, ймовірно, вимагають нових функцій інструментарію Rust. Цей проект базується на Rust `nightly-2021-01-26`\\nОновіть версію інструментарію Rust у ./scripts/config.sh перед збіркою.\\n\\n## Взламати паралелізм\\n[Додати зовнішню палету](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - можливо, це повинно бути в розділі \\\"дізнатися більше\\\"?\\n## Learn More\\n\\nЗверніться до вихідного [Шаблон вузла розробника Substrate Developer Hub](https://github.com/substrate-developer-hub/substrate-node-template), щоб дізнатися більше про структуру цього проекту, можливості, які він вкладає, та спосіб, яким ці можливості реалізовані. Ви можете дізнатися більше про [Шлях блоку паралелізму](https://polkadot.network/the-path-of-a-parachain-block/) на офіційному блозі Polkadot. [Паритетний семінар Cumulus](https://substrate.dev/cumulus-workshop/#/)\"}},{\"node\":{\"id\":\"694b03abdee102bcc8c17a99f295e707\",\"title\":\"全球管理\",\"path\":\"/docs/zh/global-administration/\",\"content\":\"\\n**本文将向您展示如何为您的Home Assistant设置新用户。**\\n\\n## 将用户添加到订阅\\n\\n您不能使用先前创建的帐户，因为`SUB_OWNER`和`SUB_CONTROLLER`提供了安全性，而您在首次启动Home Assistant时创建的第一个用户没有Robonomics Parachain帐户。\\n\\n1. 在Robonomics Parachain上创建一个帐户，就像您在[上一篇文章](/docs/sub-activate/)中所做的那样。\\n\\n2. 使用`SUB_OWNER`帐户将新用户帐户添加到[dapp](https://dapp.robonomics.network/#/subscription/devices)的订阅中。现在访问列表中应该有三个地址：`SUB_OWNER`，`SUB_CONTROLLER`和`USER`。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## 授予用户访问权限\\n\\n1. 转到名为[Home Assistant Account](https://dapp.robonomics.network/#/home-assistant)的dapp服务。在右侧边栏中选择您刚刚创建的帐户（通过按下个人资料图标来检查您选择的帐户是否正确）。\\n\\n2. 在所需字段中输入`USER`种子。在管理员信用字段中添加`SUB_OWNER`和`SUB_CONTROLLER`地址。如果一切正确，您将看到验证状态为`已验证`。\\n\\n3. 为您刚刚注册的新用户创建一个密码，然后确认交易，由于订阅，此交易现在将不收取费用。稍后，您可以在恢复选项卡中恢复密码。\\n\\n4. 在注册过程完成后，使用您的用户地址作为登录名和新创建的密码登录Home Assistant。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\n现在您可以使用dapp通过Robonomics控制您的家庭，查看[**\\\"获取智能家居遥测\\\"**](/docs/smart-home-telemetry/)文章。\\n\\n## 故障排除\\n\\n1. 如果您忘记了 Robonomics 帐户的 Home Assistant 密码，请[检查 Dapp。](https://dapp.robonomics.network/#/home-assistant)\\n转到\\\"Your Home Assistant password\\\"部分，选择\\\"Restore\\\"选项卡。\\n\"}},{\"node\":{\"id\":\"0d5e788aea8ad6a402ee38d043ad54bf\",\"title\":\"入门指南\",\"path\":\"/docs/zh/getting-started/\",\"content\":\"\\n## 什么是Robonomics\\n\\nRobonomics平台提供了与机器人经济网络合作的工具。Robonomics允许智能城市和工业4.0区域的设计师在[自主机器人服务](/docs/glossary#cyber-physical-system)中建立信任，通过[dapp直接用户访问](/docs/glossary#dapp)来订购来自自主工厂和城传感器网络的产品。这将使我们能够建立一个全球监控网络物理系统活动的去中心化系统。\\n\\n下图描述了Robonomics在场景中的位置:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\n在[在Robonomics上构建dApps的PPT](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)中了解更多信息\\n\\n## Robonomics网络快速入门\\n**为了新手的方便，Robonomics核心开发人员提出了[6个课程学习曲线](/docs/wschool2021-intro/)！**\\n\\n您将探索无服务器物联网架构！Robonomics Web Services（RWS）是基于Polkadot && IPFS的机器人和物联网的基础设施服务。\\n\\n课程毕业生可以通过跨链交易启动本地中继链并控制ROS兼容设备。\\n\\n**[加入Robonomics开发者Discord](https://discord.gg/jTxqGeF5Qy)与社区联系并获得技术支持。**\\n\\n### Robonomics学院毕业生的好处\\n- 最佳学生的实习   成为Robonomics团队成员并为所选择的产品的开发做出贡献。\\n- 活跃社区和定期活动   成为学习者社区的一部分，与行业专家讨论您的用例。组队并参加黑客马拉松！\\n- 完成课程的证书   在您的作品集中添加一个完成物联网DAPP构建课程的证书。\\n- 协助入学ITMO大学。无论您是学士还是硕士，您都将获得入学的协助。\\n- 资金和速机会: 1)申请高达$50,000的学术支持资助; 2)参加由Web3基金会支持的Robonomics建设者加速计划; 3)在Robonomics之上部署您的独立DAPP; 4)从Robonomics团队获得营销支持并实现盈利。\\n\\n\\n## 文档包含什么内容\\n\\n### 我是一个Dapp开发者\\n\\n- [GitHub上的Robonomics-js](https://github.com/airalab/robonomics-js) - Robonomics Network dApp开发者的简单Javascript SDK。\\n- [dApp模板](https://github.com/airalab/vue-dapp-robonomics-template) - 使用Vue.js\\n- [Wiki文档](/docs/robonomics-js/)\\n\\n### 我是一个机器人工程师\\n\\n查看[案例](/docs/iot-sensors-connectivity/)部分，并通过[示例](/docs/agent-development-examples)开始开发。\\n\\n\"}},{\"node\":{\"id\":\"50d85cb9bd26329676b26109ef6cece6\",\"title\":\"Gaka-Chu设置和软件安装\",\"path\":\"/docs/zh/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**在本文中，我们将通过一些安装和启动步骤来设置一个机器人画家。要求：**\\n- KUKA KR6 R900 sixx与KRC4和SmartPad；\\n- 已安装[ROS melodic](http://wiki.ros.org/melodic/安装ation/Ubuntu)的Intel NUC；\\n- 桌子、油漆、刷子、水。\\n\\n## 在KRC4上安装件\\nKRC4和NUC都需要EKI接口。有关如何在KRC4上设置它的详细信息，请参见[此处](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl)。在机器人控制器上启动它。\\n\\n## 在NUC上安装软件\\n创建一个catkin工作空间：\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\n下载ROS软件包。所有脚本都存储在[这里](https://github.com/airalab/robot_painter/tree/test_branch)。克隆存储库：\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\n您可能需要一些头文件和库来使其正常工作。下载它们：\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\n将源命令添加到`.bashrc`文件中：\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\n到目前为止，您应该能够启动脚本。如果出现问题，请尝试一些[故障排除](https://github.com/airalab/robot_painter/issues)\\n\\n## 填写常量\\n首先，机器人需要知道画布的位置和方向，以及油漆罐的位置。所有这些都在`fake_painter_enviroment_tf/src/tf_broadcaster.cpp`中指定。让我们来看看它。\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\n这些是指定画布在3D空间中位置的平面方程常量。它们在下面描述的校准过程中获得。接下来是油漆。\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\n这些是油漆罐的坐标。它们也可以在校准过程中指定。画布大小在\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\n还有一些重要的常量存储在`local_task_planner/src/Drawing.cpp`中：\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\n它们的名称说明了一切，根据情况填写它们。\\n\\n## 校准Gaka-Chu\\n校准过程本身非常简单。\\n\\n1）在KRC4上启动EKI接口：\\n\\n以'AUT'模式登录，打开驱动程序并启动脚本`eki_hw_interface`\\n\\n2）在NUC上启动EKI接口\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n它应该输出无尽的日志。\\n\\n3）启动RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n您应该看到以下内容：\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\n尝试移动末端执行器并点击'Plan and Execute'。机器人应该移动。在SmartPad上转到**Display -> Actual position**并观察末端执行器的坐标。将画布水平放置在机器人底座上。将刷子插入刷子架并小心地移动它，直到它轻轻触碰画布。在此位置保存末端执行器的坐标。重复12-15次。还要保存画布中心和油漆罐的坐标。\\n当您有一组坐标时，使用[这些](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab脚本解析缺失的常量和四元数。粘贴它们。使用\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## 测试Gaka-Chu校准\\n校准后，需要通过绘制画布边框来测试Gaka-Chu。要执行每个命令，请在新终端中执行：\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\n之后，您应该在RViz中看到一个画布轮廓：\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\n在终端中按下\\\"S\\\"进行测试。机器人的末端执行器应该在画布边框的正上方移动，刷子在整个运动过程中应该轻轻触碰画布。如果不是这样，请尝试重新校准。如果画布模型旋转错误，您可以通过在Matlab中更改四元数来旋转它。\\n\\n## 创作艺术\\n您需要6个基本模块才能使其正常工作：\\n- EKI接口；\\n- MOVEit + RViz;\\n- 环境框架广播；\\n- 图片转换服务；\\n- 轨迹绘制模块；\\n- 启动触发器。\\n\\n让我们逐个启动它们。\\n\\n### Eki接口\\n在KRC4上启动`eki_hw_interface`，在NUC上在新终端中执行：\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz和MOVEit\\n您需要一个规划器和一个仿真。使用以下命令启动它们：\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### 环境\\n告诉机器人油漆罐和画布的位置。请注意，不需要启动`draw workspace`节点，`tf_broadcaster`共享画布大小。它只是在RViz中不显示。\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### 图片处理器\\n所有传入的图片都需要进行处理。启动服务。\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\n当它接收到呼叫时，它会使用HP滤镜处理图片并创建一个包含轨迹的rosbag文件。\\n\\n### 轨迹绘制器\\n这里最主要的脚本就是轨迹绘制器本身。它等待图片，调用TextConverter服务并绘制画作。\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## 发送一张图片给机器人进行绘制\\n机器人监听一个特定的ROS主，您需要传递一个所需图片的路径。图片应为正方形（宽度等于高度），由线条组成。发送路径：\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\n之后，会弹出两个窗口显示轮廓和轨迹。关闭它们，然后观看Gaka-Chu的绘画。请注意安全，并随时准备按下紧急停止按钮。\\n当Gaka-Chu完成他的艺术作品后，您可以发送另一个图片路径，画家将重复整个过程。\\n\"}},{\"node\":{\"id\":\"039925bfe87e740cf455e4e3ef336b2e\",\"title\":\"通过MQTT将Amazon FreeRTOS设备连接到Robonomics\",\"path\":\"/docs/zh/freertos-mqtt/\",\"content\":\"\\n这是一个演示，演示了如何通过MQTT将运行[Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/)的微控制器连接到Robonomics网络。请查看[此存储库](http://github.com/khssnv/freertos_mqtt_robonomics_example)以获取项目源代码。\\n\\n我们使用[ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/)与由[Espressif IoT Development Framework](https://github.com/espressif/esp-idf)提供的FreeRTOS分发和MQTT实现，而Espressif是所使用的微控制器的供应商。\\n\\n还有一个[PMS-3003](http://www.plantower.com/en/content/?107.html)传感器用于演示目的。传感器测量空气中的颗粒物含量，人们可以使用它来估计空气质量。\\n\\n空气质量不是本文的主题，您可以在世界卫生组织的网站上找到更多相关信息：[环境（室外）空气污染](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health)。该系统的目标是将传感器测量结果发布到Airalab的Robonomics网络。\\n\\n## 硬件设置\\n\\n我们将PMS3003的TXD引脚5连接到ESP32 DevKitC的IO17以通过UART传输测量数据。\\n两个设备都需要电源和公共地。\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## 数据流\\n\\n为了将传感器测量结果传递到Robonomics网络，在固件级别上，我们的目标是通过传感器支持的嵌入式通信协议（在我们的案例中为UART）获取数据，并通过MQTT / TCP将其传递给AIRA实例。\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\n在我们的示例中，我们使用公共IP地址和域名分配的AIRA云部署。\\n在AIRA实例上，我们设置`mosquitto` MQTT代理并订`/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`主题以获取来自MQTT的消息。\\n\\n然后我们通过管道将消息传递给`robonomics io`写入器。\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\n现在数据在Robonomics网络中可用，我们可以再次使用`robonomics io`读取它。\\n\\n## 固件\\n\\n我们使用[带有TCP传输的ESP-MQTT示例应用程序](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp)作为基础。\\n\\n我们只修改`main/app_main.c`以进行与传感器的UART连接、SNTP时间同步和定期MQTT发布例程。\\n\\n如果您尝试重复该项目，并且这是您的第一个基于ESP IDF的项目，请首先按照[Espressif的ESP-IDF编程指南](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step)介绍来熟悉固件操作，如配置、构建和使用`idf.py`工具上传。\\n\\n### Wi-Fi配置\\n\\n为了与部署在云中的AIRA实例通信，我们的微控制器需要互联网连接。\\n我们使用ESP32的Wi-Fi进行连接。\\nEspressif提供了配置板载Wi-Fi的工具。\\n在我们的示例中，我们使用带有Ubuntu 20.04 GNU/Linux的开发环境。\\n要配置Wi-Fi，我们进入项目文件夹并运行SDK配置工具。\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\n然后我们在`Example 连接ion 配置`部分设置Wi-Fi接入点的SSID和密码。\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### MQTT端点配置\\n\\n有两个要配置的MQTT事项。\\n第一个是MQTT代理地址。\\n可以使用SDK配置工具进行配置。\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\n在`Example 配置`部分设置`Broker URL`。\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\n第二个事项是MQTT主题。\\n我们在固件中设置它，使用项目名称前缀后跟我们的ESP32 MAC地址。\\n对于我们特定的微芯片，它给出了`/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`。\\n\\n## 从MQTT到Robonomics\\n\\n首先让我们检查我们是否通过MQTT接收到数据。\\n我们可以订阅我们的Mosquitto MQTT代理主题设备发布到。\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\n在这里，我们将`mosquitto`软件包引入我们的环境中，以使用`mosquitto_sub`实用程序。\\n然后，我们订阅固件中设置的主题。\\n我们得到了我们的测量结果，这意味着AIRA通过MQTT正确接收数据。\\n现在让我们将这些消息传输到Robonomics网络。\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\n在这里，我们使用`robonomics`实用程序在pubsub频道`/freertos_mqtt_robonomics_example`中发布消息。\\n我们指定`bootnodes`以确保至少建立一个连接。\\n\\n现在我们正在从同一个pubsub频道中读取这些消息。\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## 使用的原始资源\\n\\n* ESP32 DevKitC引脚图来自GoJimmy的博客 https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* PSM3003数据结构和解码器来自OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**谢谢大家！**\\n\"}},{\"node\":{\"id\":\"7ec46153fdc8ea7a5930542148677e6f\",\"title\":\"How to Edit Wiki\",\"path\":\"/docs/zh/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki是开源的。欢迎任何更正：修复错误，拼写错误，一些不清楚或过时的信息，翻译成任何语言。 您将需要一个 [GitHub](https://github.com/) 帐户。**\\n\\n\\n## 如何编辑\\n\\n如果您需要编辑Robonomics Wiki的文档，请按照以下步骤进行操作\\n\\n确保你有 [Node.js](https://nodejs.org/en/download/package-manager/) 和[Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) 已安装。\\n\\n### 1. 克隆存储库\\n\\n首先，您需要克隆wiki存储库：\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\n转到存储库目录并运行以下命令：\\n\\n`使用npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`使用yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. 本地服务（开发，开发-m1）\\n\\n然后在本地部署项目： \\n\\n```\\ngridsome develop\\n```\\n\\n> 如果出现错误`node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`，请运行以下命令：\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. 创建PR\\n\\n[创建拉取请求](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) 到[wiki repo](https://github.com/airalab/robonomics-wiki)\\n\\n## 组件\\n\\n### Asciinema\\nRobonomics Wiki支持Asciinema。要插入Asciinema，请按照以下说明操作：\\n* 在frontmatter块`import Asciinema from '~/components/Asciinema.vue'`之后导入组件\\n* 作为单独的段落插入`<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`，其中vid是特定asciicast的ID\\n\\n> 您可以通过单击asciicast页面上的“嵌入”链接获取特定asciicast的小部件脚本。\\n> 它看起来像这样：\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Asciinema文档](https://asciinema.org/docs/embedding)\\n\\n在上面的示例中，vid为14。\\n\\n### 代码\\n\\n您可以在代码中添加有用的附加功能：\\n\\n`带有复制按钮的代码`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n或“带有附加行的代码”\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**code-helper 的属性**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nRobonomics Wiki中的文档包含frontmatter块。它必须位于Markdown文件的顶部，并且必须采用三个破折号之间的有效YAML形式。在三个破折号之间，您可以设置或编辑以下选项：\\n\\n```YAML\\n---\\ntitle: How to contribute # 页面标题，您不需要在文本中重复它\\ncontributors: [positivecrash] # 主要贡献者（积极管理此页面的人）。需要GitHub昵称，不需要任何其他符号\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/安装ation\\n    # 用于技术测试的工具\\n---\\n```\\n\\n### Grid \\n帮助为元素添加网格布局：\\n\\n- 首先使用网格包装器组件： \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- 然后在包装器内使用任意数量的网格项组件：\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS 网关</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**robo-wiki-grid-element-wrapper的属性**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### 图片\\n\\n#### 如何上传 \\n在文件夹`/docs/images/url-of-your-doc`中上传图像\\n* 如果图像需要本地化，请将它们全部放在一个文件夹中\\n* 如果图像本地化，请在图像名称中使用区域附录，例如`image_en.jpg`\\n* 确保您的图像经过网络优化，同时看起来不错\\n\\n#### 如何插入 \\n\\n有两种方法可以在文档中插入图片：\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n建议使用内置标签`<robo-wiki-picture>`插入图片，但您也可以使用Markdown文件的标准方式。\\n\\n</robo-wiki-note>\\n\\n`带标题`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`或不带标题` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`或简单图像` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`或带标题的简单图像`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`带alt的图像`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**robo-wiki-picture的属性：**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### 注释和警告\\n您可以添加注释并为其指定特定类型：\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`带标题的注释`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`带内容的注释`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`带标题和内容的注释`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**robo-wiki-note的属性**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\n您可以向文档添加选项卡：\\n\\n- 使用选项卡包装器组件： \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- 然后在包装器内使用任意数量的选项卡项组件：\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`水平选项卡`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`垂直选项卡`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`带边框的选项卡项`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**robo-wiki-tabs（包装器）的属性**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**robo-wiki-tab（项）的属性**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### 带锚点的标题\\n您可以创建带锚点的自定义标题并为其指定特定值\\n\\n`带锚点的标题`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nor\\n\\n`title without anchor`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**robo-wiki-title的属性**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### 视频\\n\\n有两种方法可以在文档中插入视频：\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n建议使用内置标签`<robo-wiki-video>`插入视频，但您也可以使用Markdown文件的标准方式。\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\n您需要指定视频的格式\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### 属性\\n\\n- 如果添加的文件大小超过 <span style=\\\"color:#af1c1c\\\">10MB</span>, 请上传到服务器上，而不是存储库中.\\n\\n- 您可以使用任何属性 [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- 可接受的格式-mp4，webm，ogg。\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\n您可以通过将共享链接作为单独的段落插入文档中来嵌入任何YouTube视频，例如：`https://youtu.be/kQaSwNYHJQ8`\\n\\n但是，如果您需要自动播放，则必须使用特殊组件：\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**robo-wiki-youtube的属性**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## 如何编辑侧边栏导航\\n\\n如果您需要编辑Robonomics Wiki的侧边栏导航，请按照以下步骤操作：\\n\\n* 编辑文件`/data/sidebar_docs.yaml`。\\n\\n* 决定将您的文档放在哪里\\n\\n* 对于`/data/sidebar_docs.yaml`使用有效的YAML，并依赖于现有的文件结构\\n\\n* **重要提示**如果您在不同的部分/子部分中使用相同的文档，例如： \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: 树莓派预装镜像\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\n请确保像这样添加`topic`参数： \\n\\n（导航正常工作）\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## 如何为文档添加自定义导航\\n\\n* 编辑文件“/data/sidebar_docs.yaml”。\\n\\n* 找到正确的文档并添加参数“prev”和“next”，如下所示：\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* 如果想完全删除导航，则添加`withoutNav`参数：\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* 如果您只想删除`上一页`或`下一页`导航，则添加`withoutPrev`或`withoutNext`参数：\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nor\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"5f77629302c61d8117635438011c1cc7\",\"title\":\"当门打开时收到通知\",\"path\":\"/docs/zh/door-notification/\",\"content\":\"\\n在本文中，您将安装Telegram机器人通知集成并配置自动化，当门打开时，将向您的Telegram帐户发送通知。\\n\\n## Telegram机器人通知\\n\\n首先，您需要创建一个个人的Telegram机器人。为此，请转到 [特殊的Telegram机器人 @BotFather](https://t.me/botfather) 并按照说明进操作。 \\n保存您的令牌以访问HTTP API。\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n保持您的令牌**安全**并将其**安全地**存储起来，任何人都可以使用它来控制您的机器人。 \\n\\n</robo-wiki-note>\\n\\n下一步是找到您的 ***User Chat ID***. 为此，请使用下一个 [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\n现在让我们安装\\\"Telegram broadcast\\\"集成。此集成将向您的Telegram发送消息。\\n\\n对于预安装了Robonomics镜像、Home Assistant Docker或Home Assistant Core的用户，您需要编辑`configuration.yaml`文件。通过`ssh`连接到您的Raspberry Pi：\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\n将下面的行粘贴到文件末尾。插入您的 **bot API key** 和**your User Chat ID**. 还要为您的通知服务创建一个名称：\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**保存配置并重新加载Home Assistant。**\\n\\n\\n结果是，在您的Home Assistant服务中将创建一个服务，该服务将向您的Telegram聊天发送任何消息。 \\n您可以在Home Assistant Web界面的开发者工具菜单中进行检查。 \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  门打开通知\\n\\n现在是时候创建自动化了。首先，您从此链接导入蓝图到您的Home Assistant中：\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\n然后创建自动化：\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\n现在，每次门打开时，您都会收到来自Telegram机器人的消息。\\n\\n<robo-wiki-note type=\\\"okay\\\">\\n您可以将此自动化用于家中的任何门窗。\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"633423cf56d3275f188d6f7cc06a3f9e\",\"title\":\"数字孪生\",\"path\":\"/docs/zh/digital-twins/\",\"content\":\"  \\n**想象一下拥有一个复杂的设备或系统，它有几个模块需要维护，并且需要几个帐户来使用。为了将它们都放在一个地方或使用单独的帐户对某些功能进行编码，或者例如为不同的信息流设置不同的数据日志源，需要使用数字孪生模块。**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  请注意，这些教程是在Robonomics节点的本地实例上演示的。按照以下说明设置您自己的节点： [这些说明](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 理论概述\\n任何帐户都可以创建和管理数字孪生。孪生可以想象成一个带有以下内容的表格：\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\n其中：\\n* **DT id** 是无符号整数唯一的数字孪生索引。\\n* **Topic name** 是一个32字节长度的十六进制`H256`或ASCII数据，与 [`启动`](/docs/launch) 外部参数相同。 \\n例如：`0x1234....FF` 或 `hello.parachain.robonomics.world`。\\n* **Source** - 是某个帐户地址。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  正如之前在启动外部概述中讨论的那样，`H256` 可以表示为编码的IPFS CID（参见\\n  [Python工具](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) ）。\\n  因此，主题也可以用作一些数据存储，例如孪生的模块描述。\\n\\n</robo-wiki-note>\\n\\n\\n## 创建数字孪生\\n\\n### 1. 导航到开 Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. 从可能的外部下拉列表中选择 digitalTwin -> create\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\n提交交易。在这里，创建孪生不需要任何参数。它将被授予一个索引，只有数字孪生的所有者才能从现在开始添加/修改孪生的主题。\\n\\n孪生ID可以在浏览器概述页面找到。\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## 添加主题\\n\\n### 从可能的外部下拉列表中选择 digitalTwin->setSource\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID，已在Explorer页面获取。\\n* `topic` - 之前讨论的`H256`主题名称。在这张图片中，它是一个由32个符号组成的字符串。\\n* `source` - 要与主题关联的帐户地址。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  请注意，如果需要，主题可以被另一个源地址覆盖。\\n\\n</robo-wiki-note>\\n\\n签署并提交外部事务。\\n\\n## Explore\\n\\n您可以在`开发者->链状态`存储模块`digitalTwin`中找到有关现有数字孪生的所有信息。\\n\\n- 孪生的总数 - `total()`;\\n- 数字孪生所有者 - `owner(u32)`;\\n- 有关数字孪生主题的信息 - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"42720d9867c1300d26b94880c95e4684\",\"title\":\"数据记录\",\"path\":\"/docs/zh/datalog/\",\"content\":\"\\n**现在您的帐户上已有一些资金，您可以提交外部信息。 第一个尝试的是数据记录。 它允许您将数据持久存储在区块链中。 想象一下您的数据的分布式且受加密保护的存储，就是这样！**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  请注意，本教程和后续教程是在 Robonomics Node 的本地实例上演示的。 设置你的 [这些说明](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. 导航至  Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 从可能的外部因素的下拉列表中选择 datalog->record\\n\\n另请选择您要用于提交外部信息的帐户。 填写记录字段。\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog 支持最大 512 字节的字符串。 为了存储大量数据，人们可能会使用 [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3.提交交易\\n\\n使用之前使用扩展程序或 DApp 创建的帐户签署并提交交易。\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  您还可以通过 *datalog ->erase* 调用删除**所有**记录。\\n\\n</robo-wiki-note>\\n\\n## 4. Review your datalog in the storage\\n\\n为此，导航至 *Developer -> Chain state*，选择 *datalog -> datalogIndex*，指定您的帐户并按 “+”按钮获取您帐户记录的索引，然后通过 *datalog -> datalogItem* 探索您需要的索引。\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"探索r\\\">\\n\\n  所有事件（包括数据记录记录）都可以在 *探索r* 的事件流中看到。\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"2d1ef08ce6f1d34da2db21a67d228da2\",\"title\":\"由以太坊运行的创建数字身份\",\"path\":\"/docs/zh/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nRobonomics服务之一是  [数字护照注册](https://dapp.robonomics.network/#/passport/) 用于任意数据。该服务允许您创建一个数字身份，将数据的哈希保存到公共区块链并分配一个唯一地址。\\n\\n您可以在以下位置找到“电子护照注册”服务 [Robonomics DApp](https://dapp.robonomics.network/) 在“服务”部分或按照此操作 [直接链接](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## 视频演练\\n\\n以下视频展示了 Robonomics 白皮书注册的进度：\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## 一步步看图片\\n\\n### 1.开通服务\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. 添加必要的信息和文件\\n\\n请注意，可以添加多个图像。\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. 签署需求书\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. 批准代币\\n\\n该服务收取少量费用。 但首先您必须批准从您的帐户中支出所需数量的代币。\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n### 5. 接受报价并再次签署消息\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6.查看创建的护照\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\n注册过程需要一些时间。 最后，您将看到指向创建的身份的链接。\\n\"}},{\"node\":{\"id\":\"3b88be7f679f58ed43394396584c000b\",\"title\":\"Create Account for Robonomics Paracha在部分中，超时是以秒为单位的，它将创建包含以下信息的数据日志：\",\"path\":\"/docs/zh/create-account-in-dapp/\",\"content\":\"\\n**为了与 Robonomics 平行链进行交互和操作，开发者和用户需要在 Polkadot / Substrate 门户上创建一个帐户。 该账户执行网络的基本功能：您的公共网络地址（公钥）、对地址和资金的访问控制（私钥）、向网络发送交易、显示您的代币及其金额等。以下是 创建 Robonomics 平行链帐户的两种主要方法.**\\n\\n## 1. 使用Polkadot{.js}浏览器扩展\\n\\nPolkadot扩展提供了一种生成账户并与所有Polkadot / Kusama项目（包括Robonomics Parachain）进行交互的机制。这不是管理您的账户的最安全方式，但在安全性/易用性平衡方面是最方便的。\\n\\n## 1.1. 安装浏览器扩展\\n\\n浏览器扩展适用于 [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) 和 [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) （以及基于Chromium的浏览器）。\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. 打开Robonomics Parachain应用\\n\\n转到 [在Polkadot / Substrate门户上打开Robonomics Parachain应用。如果这是您第一次进入门户，它将请求访问浏览器扩展，请允许访问。](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) 打开应用后，请查看左上角。那里显示了网络的名称、图标和最后一个区块的编号。单击该区域将打开所有Polkadot / Kusama网络的列表，包括测试网络和本地节点。您可以通过选择所需网络并按下 \\n\\n打开应用程序后，请查看左上角。 那里显示网络的名称、图标和最后一个区块的编号。 单击该区域将打开所有 Polkadot / Kusama 网络的列表，包括测试网络和本地节点。 您可以通过选择所需的网络并按 `Switch` 按钮来切换网络。 **确保您现在已连接到 Robonomics 平行链**。\\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. 更新扩展元数据\\n\\n该应用程序很可能会要求您更新扩展程序的元数据，以显示有关您所连接的链的正确信息。 转到 **Settings -> Metadata**，按 `Update metadata` 按钮，然后在弹出窗口中允许扩展程序执行此操作。\\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4。 在扩展中创建帐户\\n\\n打开 Polkadot{.js} 浏览器扩展。 单击大加号按钮或从右上角的小加号图标中选择 `Create new account` 。 您应该看到以下菜单，其中包含生成的十二个单词形式的助记词种子和地址。\\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\n种子是您帐户的密钥。 知道种子后，您（或任何知道种子的人）就可以控制该帐户，甚至在您忘记密码时重新创建它。 **将其安全地存储在某个地方** 非常重要，最好是在纸质或其他非数字设备上，而不是在数字存储或计算机上。\\n\\n保存种子并按下 `Next step`. 您应该看到以下菜单。\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* 允许您选择此帐户将专门用于哪个网络。您可以在多个网络上使用相同的地址，但出于隐私原因，建议您为每个使用的网络创建一个新地址。 \\n从下拉列表中选择Robonomics网络。如果您找不到Robonomics网络，么很可能您没有更新元数据，请返回并进行更新。\\n\\n    - 您会注意到地址和帐户图标的格式会发生变化-这是正常的。不同的网络格式只是同一公钥的其他表示形式。 \\n\\n- *Name* 只是帐户的名称，仅供您使用。它不会存储在区块链上，其他用户也无法看到它。 \\n\\n- *Password* 用于加密帐户信息。在门户上签署交易时，您需要重新输入它。创建一个并记住它。\\n\\n因此，在创建帐户后，您将在Polkadot{.js}扩展的帐户列表中看到它。通过点击三个点，您可以重命名帐户，导出它，从扩展中删除它并更改用于该帐户的网络。 \\n\\n此外，该帐户将显示在门户上的  **Accounts -> Accounts** 菜单中，其中会注意到它是使用扩展程序注入的。\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n## 2. 直接在 Robonomics 平行链应用程序上\\n\\n您可以使用 Polkadot / Substrate 门户上的用户界面来创建帐户。 它可用于开发和测试。\\n\\n\\n## 2.1. 打开 Robonomics 平行链应用程序\\n\\n去 [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/)  在 Polkadot / Substrate Portal 上。 **检查左上角是否已连接到 Robonomics 平行链**.\\n\\n去 **Accounts -> Accounts**  然后按 `Add account` 按钮。\\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. 创建账户\\n\\n您应该会看到以下带有帐户种子的弹出菜单。\\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\n它有两种形式： *Mnemonic* （可读的）和 *Raw* （一串数字和字母）。安全地保存种子短语并按下 `Next`.\\n\\n> 您还可以更改创建帐户的加密类型，打开 `Advanced creation options` 并选择类型 (`ed25519` 在图片上).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\n在下一个菜单中，您需要设置帐户名称和密码，与上述扩展说明类似。\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\n点击 `Next` 按钮带您进入最后一个窗口。点击 `Save` 完成帐户创建。它还将生成一个备份JSON文件，您应该安全地存储。如果您记得密码，以后可以使用此文件恢复您的帐户。\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 将ed25519帐户添加到Polkadot扩展\\n\\n您可能需要将创建的帐户添加到Polkadot.js扩展（对于ed25519帐户，您只能使用备份的JSON文件进行操作）。为此，您需要创建帐户的备份文件。点击您的帐户上的三个点，选择 `Create a backup file for this account` 并输入您的密码。\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\n然后打开扩展并按下右上角的 `+` 按钮，然后选择 `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\n在打开的窗口中放入保存的文件，输入密码并按下 `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. 帐户创建成功 \\n\\n现在您可以完全操作您新创建的帐户。发送和接收代币，消息，编写数据日志等。随意探索应用程序的所有功能。要复制您的帐户地址，只需点击其图标，地址将被复制到剪贴板。 \\n\\n如果您想了解有关Polkadot / Kusama帐户以及创建它们的其他方法的更多信息，可以找到更多信息 [这里](https://wiki.polkadot.network/docs/learn-accounts) 和 [h这里](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"8036aa603f4a8e41a7ea7b956d9addef\",\"title\":\"如何为Robonomics资源做出贡献\",\"path\":\"/docs/zh/contributing/\",\"content\":\"\\nRobonomics Network is an open-source project 。然而，这些路径可能因您的特定设置而有所不同。 we want to make it easy for anyone to contribute. You may create articles, suggest changes, improve documentation or run tests. If you want to contribute, please, open a new issue or create a pull request 在部分中，超时是以秒为单位的，它将创建包含以下信息的数据日志： the same repository.\\n\\n## 主要Robonomics存储库 \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — 主要维基项目\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Robonomics Network 官方主网站\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Robonomics Web Services的主页\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — 官方dapp\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Robonomics Academy的官方网站\\n\\n### 报告规则\\n\\n在打开新问题时，请不要忘记一些基本的报告规则：\\n\\n1.选择要提交问题的确切存储库。\\n\\n2.如果您报告错误，请确保该错误尚未报告。\\n\\n3.请务必包括标题和清晰的描述，尽可能提供相关信息。\\n\\n4.请在您的问题前加上以下之一的前缀： `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## 拉取请求\\n\\n任何 Robonomics 存储库都可能会受到贡献者的拉取请求或更改的影响，您认为您有一些有价值的内容需要添加或更改。 请不要忘记贡献者的基本规则。\\n\\n### 贡献规则\\n\\n1.如果您有一些修复，尤其是对于小的更改（如拼写错误），请优先使用拉取请求而不是问题。\\n\\n2.请确保PR描述清楚地描述了问题和解决方案。如果适用，请包括相关问题编号。\\n\\n3.请不要修复空格，格式化代码或进行纯粹的外观修补程序。\\n\\n4.请尽量遵守主流的Markdown样式，语言和布局。\\n\\n\\n\"}},{\"node\":{\"id\":\"23132e5800dfbf8e7fc9c673e8d2e6c3\",\"title\":\"抵消服务\",\"path\":\"/docs/zh/carbon-footprint-service/\",\"content\":\"\\n工作示例在视频中：\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\n通过燃烧 Statemine 网络中的代币来抵消二氧化碳足迹的服务。\\n产生的 CO2 计算如下：设备数据（以 Wh 为单位）乘以系数（取决于区域）。 消耗 1 个代币即可覆盖 1 吨 CO2。 [此处](/docs/carbon-footprint-sensor)是连接设备的说明。\\n\\n## 设想\\n\\n1. 在 Robonomics 网络的数字孪生中注册一个新设备\\n2. 在一个时间间隔内从所有设备获取最后的数据并乘以取决于区域的系数\\n3. 汇总数据并将其转换为二氧化碳吨\\n4、当前数据减去销毁代币总数\\n5. 在 Statemine 网络中销毁整数数量的代币\\n6. 保存本地DB和Datalog中的销毁代币总数 \\n\\n\\n## 安装中\\n\\n克隆存储库并编辑配置文件。\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## 配置说明\\n\\n不要编辑 `config/config_template.yaml`！\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network w这里 Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\n\\n不可再生能源的系数取自[Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg)并存储在 `utils/coefficients.py`。\\n\\n## 发射\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"a4d8b350effc8d2550450e69a06c2e40\",\"title\":\"连接传感器\",\"path\":\"/docs/zh/carbon-footprint-sensor/\",\"content\":\"\\n工作示例在视频中：\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## 要求\\n\\n* [Aqara智能插座](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (或其中之一 [支持](https://www.zigbee2mqtt.io/在部分中，超时是以秒为单位的，它将创建包含以下信息的数据日志：formation/supported_adapters.html))\\n\\n服务在 Raspberry Pi 上运行，并通过 zigbee 协议联系智能插头。\\n\\n## Zigbee棒\\n\\n如果您有JetHome USB JetStick Z2，则已经具备必要的固件，因您不需要刷新它。但是，如果您有另一个适配器，首先需要使用zigbee2MQTT软件刷新它。您可以在您的设备上找到说明 [这里](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\n连接适配器并验证适配器地址 (它也可能是 `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\n您可能需要先访问 USB 端口。 将您的用户添加到 `dialout` 组（在ubuntu上有效，但是在其他操作系统上组的名称可能不同）。\\n\\n对于ubuntu：\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\n对于arch：\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\n然后注销并登录或重新启动计算机。\\n\\n## 安装\\n\\n克隆存储库：\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## 配置\\n\\n转到 `data/configuration.yaml` 并设置 `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\n此外，您可能想用相应的信息填充字段 `server` 和 `port`。 在 `server` 字段中使用 `docker0` 网桥的 IP 来建立连接：\\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\n\\n这里你的地址是 `172.17.0.1`。\\n\\n然后使用以下信息创建文件 config/config.yaml 并设置您的位置（您可以查找 https://countrycode.org/ 获取 3 个字母的 ISO 代码）：\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## 连接插头\\n\\n第一次运行：\\n\\n```\\ndocker-compose up     \\n```\\n\\n要切换到插头上的配对模式，请长按电源按钮几秒钟，直到指示灯开始快速闪烁蓝色。\\n\\n在日志中，您现在应该看到您的插件开始发布到 mqtt。 \\n\\n\\n## 配对后\\n\\n如果您不想让其他设备与您的棒配对，现在您应该转到 `data/configuration.yaml` 并设置`permit_join: false`。 重新启动服务（使用 `Ctrl+C` 并\\n\\n```bash\\ndocker-compose up     \\n```\\n再次提交更改）。\\n\\n## 跑步\\n\\n首次启动时，将创建该插件的帐户。\\n> 如果您已经有一个帐户，则应将其种子添加到 `device_seed` 部分中的 `config.config.yaml`文件中：\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\n创建帐户后，您将在日志中看到地址（种子将添加到 `config/config.yaml`）:\\n\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\n您需要向该账户转入一些代币作为交易费用，您可以在 [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts) 上进行. \\n\\n服务将看到您有足够的令牌，在日志中您将看到：\\n```\\nplug               | Balance is OK\\n```\\n服务将看到来自插头的 mqtt 消息和安全用电情况。 每小时（您可以在 `sending_timeout` 部分更改 `config/config.yaml` 中的超时，超时以秒为单位）它将创建包含以下信息的数据日志：\\n\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"2b128a2cdd0ead0b8f8d5a7d7d2ad237\",\"title\":\"备份服务\",\"path\":\"/docs/zh/backup-services/\",\"content\":\"\\n**在本文中，您将学习如何生成Home Assistant配置的备份，并在需要时进行恢复。为了创建备份，调用一个服务来生成带有配置文件的安全存档。如果存在，该服务还会添加Mosquitto代理和Zigbee2MQTT配置到备份中。然后，该服务将存档添加到IPFS并将结果CID存储在Robonomics数字孪生中。**\\n## 创建Home Assistant配置的备份\\n\\n创建备份可以在发生故障时轻松恢复Home Assistant配置。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"警告\\\">\\n\\n为了备份和恢复配置，需要使用一个 **自定义IPFS网关** ，如Pinata。如果没有它，您的备份将仅存储在本地IPFS节点上，这可能会阻止您在本地节点故障时恢复Home Assistant配置。\\n\\n</robo-wiki-note>\\n\\n1. 在Home Assistant的Web界面中，转到 `Developer Tools` -> `Services`. 搜索 `Robonomics: Save Backup to Robonomics` 并点击 `CALL SERVICE`.\\n\\n2. 等待直到您看到通知 `Backup was updated in Robonomics` 出现在 `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\n请勿在加载Home Assistant和Robonomics Integration后立即尝试创建备份或恢复配置。请 **等待约5分钟** 以完成初始设置。\\n\\n</robo-wiki-note>\\n\\n服务参数：\\n- **完整备份**  (default: False) - 将数据库添加到备份中，以便存储实体状态的历史记录.\\n- **Mosquitto密码文件的路径** (default: `/etc/mosquitto`) - 如果您使用Home Assistant Core或Docker安装方法，并且没有默认的Mosquitto代理路径，您应该更改此参数。 *Home Assistant OS或Superviser不需要*.\\n\\n## 从备份中恢复Home Assistant配置\\n\\n为了恢复配置，您需要安装Home Assistant和Robonomics Integration。 \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\n为了确保在Home Assistant Core和Docker安装方法中成功恢复配置，您需要执行本页末尾所述的其他设置步骤。\\n\\n</robo-wiki-note>\\n\\n1. 使用所需的安装方法按照文章中的步骤安装Home Assistant与Robonomics Integration（如果尚未安装） [期望的安装方法](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2. [设置Robonomics集成](https://wiki.robonomics.network/docs/robonomics-hass-integration)使用您在之前的 Robonomics 配置中使用的 **相同的种子**。 如果您的订阅已结束，[重新激活](https://wiki.robonomics.network/docs/sub-activate).\\n\\n\\n3. 在 Home Assistant 的 Web 界面中，转到`Developer Tools` -> `Services`。 搜索“Robonomics: Restore from the Backup in Robonomics`，`CALL SERVICE`。 导航到`Overview`页面，检查备份的状态。\\n\\n4. 恢复后，Home Assistant会自动重启。 如果由于某种原因 Home Assistant 没有重新启动，您可以通过监视 `robonomics.backup` 实体的状态来检查恢复状态。 如果状态为 `restored`，您将需要导航到 `Settings` > `System` 并单击右上角的 `RESTART` 按钮来手动重新启动 Home Assistant。\\n \\n5. 如果您的备份包括Zigbee2MQTT或Mosquitto配置，您需要重新启动这些服务以启用新的配置。您可以通过逐个重新启动服务来手动执行此操作，或者您可以简单地重新启动Home Assistant计算机以确保所有服务都重新启动。\\n\\n如果您使用的是Home Assistant Core或Docker安装方法，并且没有默认的Mosquitto brocker路径，您应该更改此参数。\\n\\nService arguments:\\n- **Path to mosquitto password file** (default: `/etc/mosquitto`) - 如果您使用的是Home Assistant Core或Docker安装方法，并且没有默认的Mosquitto brocker路径，您应该更改此参数。*Home Assistant OS或Superviser不需要*\\n- **Zigbee2MQTT 配置的路径**  (default: `/opt/zigbee2mqtt`) - 如果您使用 Home Assistant Core 或 Docker 安装方法并且没有 Zigbee2MQTT 的默认路径，则应更改此参数。 *Home Assistant OS或Superviser不需要*\\n\\n## 恢复Home Assistant核心安装方法的Mosquitto和Zigbee2MQTT配置\\n\\n如果备份包含 Mosquitto 或 Zigbee2MQTT 的配置，则在恢复过程中，它们将被放置在默认路径或参数中指定的路径中。 但是，如果您在现有 Home Assistant Core  *(不是从预安装的 Robonomics 映像中)* 安装了 Robonomics 集成，则 `homeassistant` 用户可能无权访问此路径。\\n\\n因此，要恢复 Mosquitto 和 Zigbee2MQTT 的配置，您需要向用户“homeassistant”授予必要的读取权限：\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Home Assistant Docker安装方法的备份Mosquitto和Zigbee2MQTT配置\\n\\n要从 Docker 容器备份 Mosquitto 和 Zigbee2MQTT 配置，您需要为其各自的配置创建卷。 这可以通过使用附加参数运行 Home Assistant 容器来实现：\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\n或在 `compose.yaml` 文件中进行更改：\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\n请注意，Mosquitto 和 Zigbee2MQTT 配置的默认路径分别是 `/etc/mosquitto` 和 `/opt/zigbee2mqtt`。 但是，这些路径可能会根据您的具体设置而有所不同。\\n\\n</robo-wiki-note>\\n\\n## 备份按钮\\n\\n除了使用服务处理备份之外，您还可以使用 Robonomics 集成中的 `button.create_backup` 和`button.restore_from_backup` 按钮来简化流程。 这些按钮使用默认参数调用相应的服务（备份按钮创建没有历史记录的备份）。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\n要将按钮添加到仪表板，请按照下列步骤操作：\\n\\n1. 点击仪表板右上角的三个点。\\n2. 选择 `Edit Dashboard`.\\n3. 单击右下角的 `Add Card` 按钮。\\n4. 选择 `Entities` 卡。\\n5. 在 `Entities` 字段中，搜索button.create_backup 和button.restore_from_backup 实体。\\n6. 按 `Save` 将实体添加到卡中。\\n7. 单击右上角的 `Done` 按钮完成编辑。\\n\\n\\n\"}},{\"node\":{\"id\":\"f1dc01e925bae2618f207ad497de0f2a\",\"title\":\"在 Robonomics 门户上向您的账户添加资金\",\"path\":\"/docs/zh/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**在成功创建您的Robonomics门户帐户之后，现在是时候为它们添加资金，以便您能够发起交易了。**\\n\\n<robo-wiki-note type=\\\"warn在部分中，超时是以秒为单位的，它将创建包含以下信息的数据日志：g\\\" title=\\\"Dev Node\\\">\\n\\n请注意，此教程及其后续教程是在Robonomics节点的本地实例上演示的。请按照以下说明设置您[自己的实例](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 。1. 在Robonomics门户的“帐户”部分导航。 \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. 择您想要从中转移资金的帐户 \\n\\n在开发模式下，存在几个帐户，每个帐户都有10000个单位的资金，可以用于向开发网络中创建的其他帐户转移资金。这些帐户旁边有扳手标志。  <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> \\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- 点击您想要从中转移资金的帐户的“发送”按钮，例如BOB。\\n\\n## 3. 选择您想要将资金转移到的帐户。\\n点击“发送”按钮后，您将收到“发送资金窗口”的提示。在提示窗口中：\\n\\n- 从可用帐户列表中选择您想要发送资金的帐户。\\n- 输入您想要发送的单位数量。\\n- 按下“进行转账”。\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. 授权交易。\\n\\n在前一阶段按下“进行转账”后，您将收到“授权交易窗口”的提示。<br/>\\n查看交易的详细信息，最后点击“签名并提交”按钮。\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\n\\n在此示例中，我们将500个单位的资金从“BOB”转移到“EMPLOYER”。您可以看到EMPLOYER的帐户最初没有任何资金，现在有500个单位的资金。\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**确保您在游乐场中要使用的帐户中有足够的资金。.**\"}},{\"node\":{\"id\":\"ac03fa5bbfdd563218219b893bef7a3d\",\"title\":\"Адаптер Zigbee з Zigbee2MQTT для попередньо встановленого зображення\",\"path\":\"/docs/uk/zigbee-to-mqtt-image/\",\"content\":\"\\n**У цій статті ви будете парувати розумні пристрої.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nВідкрийте веб-переглядач і перейдіть за адресою `http://%RASPBERRY_IP_ADDRESS%:8099`. Ви можете знайти IP-адресу Raspberry Pi за допомогою [мобільного додатку Fing](https://www.fing.com/products) або [інструменту командного рядка nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nВи побачите веб-інтерфейс Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nЧас підключити ваш розумний пристрій. \\nСпочатку натисніть кнопку `Permit join (All)` у верхній частині веб-інтерфейсу Zigbee2MQTT. \\n\\nПотім почніть парувати пристрої. Найпоширеніший спосіб переключення пристрою в режим підключення - утримуйте його кнопку живлення або включайте / виключайте його 5 разів. Переконайтеся, що Zigbee2MQTT працює.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nКоли пристрій підключається, ви побачите їх у веб-інтерфейсі:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nТепер ви повинні побачити цей датчик у вашому веб-інтерфейсі Home Assistant. Перейдіть до `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nПісля додавання всіх датчиків ви можете закрити веб-інтерфейс Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"5ef85c62cb3a45d189681c6890e5ade5\",\"title\":\"Як використовувати шаблони\",\"path\":\"/docs/uk/use-blueprints/\",\"content\":\"\\nУ цій статті ви дізнаєтеся, як додати автоматизаційні шаблони до вашого Home Assistant та налаштувати їх.\\n\\n## Автоматизації на основі шаблонів\\n\\nДеякі шаблони уже встановлені. Автоматизації на основі таких шаблонів потребують лише налаштування. У веб-інтерфейсі ви можете знайти попередньо встановлені шаблони в розділі `Settings/Automations & Scenes`. Відкрийте `Blueprints` та знайдіть шаблон, який ви хочете використовувати. У цьому прикладі буде використано `Motion-activated Light`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nКлацніть `Create Automation`,  щоб відкрити редактор автоматизацій. Вкажіть назву, виберіть шаблон для використання (`Motion-activated Light` у нашому випадку). Після цього вам потрібно вибрати датчик руху та лампу. Коли налаштування завершено, клацніть ``Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Конфігурація\\\" />\\n\\nЯкщо ви хочете внести зміни, ви можете знайти їх, перейшовши до `Settings/Automations & Scenes`, а потім `Automations`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Імпорт шаблонів\\n\\nHome Assistant мож імпортувати шаблони з форумів Home Assistant, GitHub та GitHub gists. Список всіх шаблонів розташований на [Біржі шаблонів](https://community.home-assistant.io/c/blueprints-exchange/53). Після вибору перейдіть до `Settings/Automations & Scenes` та відкрийте `Blueprints`. Клацніть `Import Blueprint` та вставте URL обраного шаблону. Потім клацніть `PREVIEW BLUEPRINT`. У цьому випадку ми використовуватимемо [Виявлення та сповіщення про низький рівень заряду батареї для всіх датчиків батареї](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nЦе завантажить шаблон та покаже попередній перегляд у діалоговому вікні імпорту. Ви можете змінити назву та завершити імпорт. Клацніть `Create Automation`, щоб відкрити редактор автоматизацій. Тут ви можете налаштувати параметри автоматизації та додати дії для отримання сповіщень.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"94ac3e6a3052cd0756352bab9b2a61fd\",\"title\":\"Як надіслати запуск з передплатою\",\"path\":\"/docs/uk/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Зверніть увагу, що цей посібник демонструє використання передплати на паракейні Robonomics Kusama. Ви також можете виконати всі ті ж самі кроки на своєм [локальному вузлі](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nЯкщо ваша адреса має активну передплату, то будь-які пристрої, налаштовані з використанням секретного ключа цього облікового запису, можуть надсилати екстрикси без комісії. \\nСпробуємо надіслати команду `launch`.\\n\\nПерейдіть на сторінку `Developer/Extrinsics`, потім виберіть свій обліковий запис (той, що зі списку пристроїв) і виберіть `rws -> call(subscriptionId, call)`.  \\nПотім у полі `subscriptionId` вставте адресу власника передплати (того, хто зробив ставку на аукціоні), а в наступному полі виберіть `launch -> launch(robot, param)`. У полі `robot` введіть адресу, на яку ви хочете надіслати транзакцію `launch`, і вставте команду (для опису команди запуску див. [тут](/docs/launch)). Потім надішліть транзакцію:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\nТепер перейдіть на сторінку `Network/Explorer`, і в області `Recent Events` ви побачите дві події, які ви створили: `rws.NewCall` та `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"560166ff1c039ace27b51efc2a21d767\",\"title\":\"Активувати підписку\",\"path\":\"/docs/uk/sub-activate/\",\"content\":\"\\nУ цій статті ви створите облікові записи підприємств Robonomics та придбаєте підписку на Інтернет речей. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nДля керування Home Assistant за допомогою Robonomics вам потрібно мати 2 облікові записи на підприємстві Robonomics. Для одного з облікових записів (`sub_owner`) ви придбаєте підписку Robonomics. Другий обліковий запис (`sub_controller`) буде керувати всіма процесами Home Assistant (такими як телеметрія) та надавати доступ іншим користувачам. Ці облікові записи забезпечать безпеку вашого Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nОбидва облікові записи мають бути створені з шифруванням **ed25519**. Через це вам потрібно створити обліковий запис за допомогою інтерфейсу користувача Polkadot-JS і вибрати необхідне шифрування.\\n\\nЦя функція за замовчуванням вимкнена в Polkadot-JS UI. Щоб увімкнути її, перейдіть до `Settings` -> `General` -> `account options` та виберіть  `Allow local in-browser account storage` у розкривному меню `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Створення облікових записів власника та контролера\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Перейдіть до [додатку Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) на порталі Polkadot / Substrate. **Перевірте верхній лівий кут, щоб переконатися, що ви підключені до Robonomics Parachain.**\\n\\n2. Перейдіть до `Accounts` -> `Accounts` та натисніть кнопку `Add account`. Ви побачите спливаюче меню з насінням облікового запису. Воно має дві форми: *Мнемонічний* (зрозумілий для людини) та *Сире* (послідовність цифр і літер). \\n\\n3. Відкрийте `Advanced creation options`, змініть тип криптографії створення облікового запису на `Edwards - ed25519` та натисніть `Next`.\\n\\n\\n4. Безпечно збережіть мнемонічну фразу насіння та натисніть `Next`.\\n\\n5. У наступному меню потрібно встановити ім'я облікового запису та пароль. Дайте йому ім'я `sub_owner` для зручності. Натисніть `Next`.\\n\\n6. У останньому вікні натисніть `Save`, щоб завершити створення облікового запису. Воно також згенерує резервні JSON-файли, які ви повинні безпечно зберігати. Ви пізніше можете використовувати цей файл для відновлення облікового запису, якщо ви запам'ятаєте пароль.\\n\\n7. Повторіть ці кроки для облікового запису з назвою `sub_controller`.\\n\\n\\n## Додавання облікових записів до Polkadot.js\\n\\nДля зручності вам слід використовувати [розширення Polkadot.js](https://polkadot.js.org/extension/) та додати до нього ці новостворені облікові записи. Для облікового запису ed25519 ви можете зробити це лише за допомогою резервного JSON-файлу. Ви можете використовувати файли, збережені під час створення облікових записів.\\n\\nВи можете отримати ці файли знову, створивши резервну копію облікового запису. Натисніть на три крапки на своєму обліковому записі, виберіть `Create a backup file for this account`  та введіть свій пароль.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Відкрийте розширення та натисніть кнопку `+` у правому верхньому куті, потім виберіть `Restore account from backup JSON file`.\\n\\n2. У відкритому вікні завантажте JSON-файл, введіть пароль та натисніть `Restore`.\\n\\n3. Переконайтеся, що для облікових записів у розширенні Polkadot.js вибрана мережа Robonomics. На порталі Polkadot / Substrate перейдіть до `Setting` -> `Metadata` та натисніть кнопку `Update metadata`.\\n\\n4. Підтвердьте оновлення метаданих у спливаючому вікні. Тепер розширення буде показувати мітку мережі, для якої використовується адреса.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Активація підписки Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nДля цього кроку вам потрібно мати достатню кількість токенів XRT (мінімум 2-3 XRT) на вашому обліковому записі `sub_owner`.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Перейдіть до додатку Robonomics на [сторінку підписк](https://dapp.robonomics.network/#/subscription) та натисніть кнопку підключення облікового запису у правій бічній панелі.\\n\\n2. У випливаючому меню підключіть розширення Polkadot.js. Ви побачите адресу вашого облікового запису з балансом.\\n\\n3. Перед покупкою переконайтеся, що ви вибрали обліковий запис `sub_owner`. Натисніть значок профілю адреси, ви повинні побачити обліковий запис `sub_owner` у полі `Check owner account`.\\n\\n4. Натисніть кнопку `SUBMIT` та введіть пароль для вашого облікового запису. Після цього зачекайте, поки процес активації завершиться. Через деякий час ви побачите стан вашої підписки.\\n\\n\\n## Додавання облікових записів до підписки\\n\\nТепер вам потрібно додати обліковий запис `sub_controller` до **списку доступу**.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Відкрийте розширення та натисніть на значок поряд з ім'ям облікового запису. Він скопіює адресу облікового запису.\\n\\n\\n2. Вставте цю адресу в поле `Robonomics parachain address` в розділі **Керування доступом**. Дайте йому ім'я та натисніть кнопку `+`. \\n\\n3. Повторіть кроки 1 і 2 для облікового запису `sub_owner`.\\n\\n4. Натисніть `Save`. У спливаючому вікні введіть пароль вашого облікового запису `sub_owner` та зачекайте, поки процес активації завершиться.\\n\"}},{\"node\":{\"id\":\"6ced9b9b1f9fae057853b8f94c08bd55\",\"title\":\"Отримайте телеметрію розумного будинку\",\"path\":\"/docs/uk/smart-home-telemetry/\",\"content\":\"\\n**У цій статті ви будете використовувати сервіс Robonomics, який запитує телеметрію пристроїв розумного будинку.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Перейдіть до додатку та виберіть сервіс [Телеметрія розумного будинку](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. У полі контролера введіть адресу `SUB_CONTROLLER`. Вставте фразу-сід для шифрування даних.\\n\\n3. У блоку `Get telemetry` виберіть мітку часу зі списку та натисніть кнопку `DOWNLOAD TELEMETRY`.\\n\\n4. Завантаження телеметрії може зайняти деякий час. Після завершення ви побачите інформацію з ваших пристроїв та датчиків.\\n\\n\\n<!---\\n## Запуск devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Запуск\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"0491b208b28ab88f02fe261d308c8942\",\"title\":\"Robonomics SLS Шлюз\",\"path\":\"/docs/uk/sls-gateway/\",\"content\":\"\\n**У цій статті ви налаштуєте Robonomics SLS Шлюз. Ви встановите необхідне програмне забезпечення для шлюзу, налаштуєте його та підключите його до Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Прошивка\\n\\nСпочатку вам потрібно встановити прошивку мікроконтролера шлюзу. Підготуйте шлюз, встановивши перемикачі `1` та `3` в нижній частині SLS Шлюзу в положення `ON`, інші повинні бути `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nПідключіть шлюз до Raspberry Pi за допомогою порту USB type-C на шлюзі.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nКлонуйте репозиторій з прошивкою на Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nПерейдіть до `robonomics-hass-utils/esp_firmware/linux`. Щоб прошити SLS шлюз, вам потрібно запустити скрипти `Clear` та `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Усунення неполадок\\n\\nЯкщо у вас виникають проблеми з оновленням прошивки шлюзу, вам потрібно виконати додаткові кроки:\\n\\n1. Переконайтеся, що встановлено модуль pySerial:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Надайте своєму користувачеві права доступу до USB-порту та перезавантажте комп'ютер:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. У деяких випадках необхідно змінити налаштування пропускної здатності в скрипті для оновлення прошивки. Відкрийте скрипт `Flash_16mb.sh` за допомогою редактора `nano` та змініть параметр baud з `921600` на менше значення (наприклад, `115200`).\\n\\n## Конфігурація\\n\\n1. Відключіть SLS Шлюз від комп'ютера. Встановіть перемикачі на задній панелі шлюзу в правильне положення. Перемикачі `5` (RX Zigbee до ESP) та `6` (TX Zigbee до ESP) повинні бути в положенні `ON`, інші повинні бути `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Підключіть кабель живлення типу C. Індикаторне світло в центрі повинно загорітися зеленим.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. При першому запуску шлюз буде починати роздавати Wi-Fi з SSID `zgw****`. Підключіться до цієї мережі. Майте на увазі, що сигнал може бути досить слабким, тому краще тримати SLS шлюз ближче до комп'ютера. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Якщо підключення вдале, відкриється веб-інтерфейс (або ви можете знайти його за адресою 192.168.1.1). \\n\\n5. Ви побачите сторінку `Wi-Fi Settings`. Виберіть свою Wi-Fi та введіть пароль. Натисніть кнопку `Apply`. Шлюз перезавантажиться та підключиться до вашої Wi-Fi мережі. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Знайдіть локальну IP-адресу SLS шлюзу для доступу до веб-інтерфейсу. Щоб знайти його, ви можете використовувати [мобільний додаток Fing](https://www.fing.com/products) або [інструмент командного рядка nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Ім'я шлюзу повинно виглядати так: `zgw****`. Відкрийте веб-інтерфейс шлюзу, вставивши IP-адресу шлюзу в браузер.\\n\\n7. Перейдіть до `Setting` -> `Hardware` та переконайтеся, що налаштування виглядають так, як на зображенні. Виправте налаштування за потреби та натисніть кнопку `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nТаблиця з необхідними значеннями:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Потім перезавантажте шлюз. Виберіть `Actions` -> `Reboot system` в правому верхньому куті.\\n\\n9. Переконайтеся, що шлюз працює належним чином у вікні інформації Zigbee. DeviceState повинен бути `OK`.\\n\\n10. Налаштуйте автоматичне додавання пристроїв до Home Assistant. Перейдіть до `Zigbee` -> `Config`, потім виберіть `Home Assistant MQTT Discovery` та `Clear States`. Збережіть зміни та знову **перезавантажте** SLS шлюз.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nЯкщо у вас вже є активний SLS шлюз у вашому будинку, і ви зараз налаштовуєте ще один, то вони будуть конфліктувати один з одним. Щоб вирішити цю проблему, вам потрібно змінити канал на новому пристрої. Для цього перейдіть до `Zigbee` -> `Config` та змініть канал на інший (наприклад, канал 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Парування SLS з MQTT\\n\\nПісля налаштування SLS Шлюзу вам потрібно підключити SLS Шлюз до Home Assistant. Відкрийте веб-інтерфейс SLS Шлюзу та перейдіть до `Settings/Link` -> `MQTT Setup`:\\n\\n\\nДодайте адресу вашого брокера (адреса Raspberry Pi з Home Assistant у локальній мережі, ви можете знайти її за допомогою [мобільного додатку Fing](https://www.fing.com/products) або [інструменту командного рядка nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), порт (за замовчуванням `1883`), ім'я користувача та пароль брокера (які ви створили раніше) та назву теми (ви можете вибрати будь-яку). Також, IP-адреса Raspberry Pi повинна бути статичною. Натисніть `Enable` та `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nЗбережіть зміни. Тепер пристрої будуть автоматично відображатися в Home Assistant.\\n\\n## Підключення пристроїв\\n\\nПідключіть ваші пристрої, перейшовши до розділу `Zigbee` -> `Join`. Поставте ваші сенсори в режим парування, найпоширеніший спосіб переключити пристрій в режим підключення - утримувати його кнопку живлення або включати / вимикати його 5 разів. Натисніть кнопку `Enable Join`, щоб почати пошук пристроїв Zigbee. Ви побачите активні сенсори.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nТепер ви можете перейти до розділу [**Підписка на IoT**](/docs/sub-activate) та почати активувати підписку Robonomics.\\n\"}},{\"node\":{\"id\":\"2a146f666011159e0bde9440e98d2bd0\",\"title\":\"Децентралізована мережа датчиків\",\"path\":\"/docs/uk/sensors-network-introduction/\",\"content\":\"\\nСтатті про децентралізовану мережу датчиків були перенесені до Robonomics Academy: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"c350675229384183c89124cc32228fd4\",\"title\":\"Безпечне підключення хмарного штучного інтелекту до заводського цеху\",\"path\":\"/docs/uk/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nТехнології Robonomics вже можуть вирішувати проблеми, з якими стикається Індустрія 4.0, і вони вже застосовуються  реальних сценаріях в промисловому середовищі.\\n\\nВелика кількість компаній зі штучним інтелектом будують рішення для оптимізації процесів на заводському цеху, що дозволяє заводам виробляти більше за менші витрати. Однак, більшість заводів сумніваються підключати свою інфраструктуру безпосередньо до хмари, оскільки це призводить до потенційних кібербезпекових ризиків, які можуть призвести до втрат мільйонів доларів і навіть втрати людського життя.\\n\\n[MerkleBot](https://merklebot.com) використовував [Robonomics Network](https://robonomics.network), щоб створити рішення для промислових клієнтів для безпечного підключення їх заводу до хмарного штучного інтелекту.\\n\\nЦя стаття написана на основі експерименту, який ми провели з [Veracity Protocol](https://www.veracityprotocol.org/), який використовує алгоритми для створення неінвазивного захисту будь-якого фізичного предмета на основі фотографій з мобільного пристрою.\\n\\nЦей випадок використання показує процес сканування промислових деталей за допомогою роботизованої руки.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Крок за кроком процес\\n\\n### DApp як інтерфейс користувача\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp виступає в якості інтерфейсу користувача для оператора. Він використовується для запиту запуску робота для збору фотографій, а його мета - дозволити безпечну комунікацію між промисловим середовищем та хмарним штучним інтелектом.\\n\\n### Запуск робота\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nОператор запускає роботизоване сканування, підписуючи транзакцію в DApp. Цей крок гарантує, що процес на заводському цеху може початися лише на основі транзакції в публічному блокчейні.\\n\\nРобот отримує команду з блокчейну через мережу Robonomics і починає сканування. Технології мережі Robonomics дозволяють зменшити розрив між бізнес-цілями та роботизованою роботою.\\n\\n### Збір даних та надсилання до хмарного штучного інтелекту\\n\\nУ DApp оператор бачить підтвердження, і робот починає сканувати розміщені на столі предмети, як у цьому випадку, або безпосередньо на заводській лінії, якщо виникає потреба.\\n\\n<!-- ![](../images/Veracity_Protocol_Запуск.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nКоли робот збирає дані, він зберігає їх локально і робить їх доступними для хмарного штучного інтелекту за допомогою протоколу IPFS. Шифруючи дані та організовуючи обмін даними через транзакцію блокчейну, ми можемо авторизувати доступ до хмарного штучного інтелекту, забезпечуючи безпеку та збереження даних на місці.\\n\\nМеханізм безпеки, вбудований у Robonomics на основі загальної безпеки публічних блокчейнів, дозволяє отримати рівень безпеки, який є надто дорогим для більшості заводів для організації самостійно.\\n\\n### Створення цифрового паспорта\\n\\nКоли хмарний штучний інтелект аналізує дані, журнал та рекомендації записуються автоматично як [Цифровий паспорт](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/). Кожна операція та сканування можуть бути відстежені, оскільки блокчейн-запис має хеш до всіх цих файлів через протокол IPFS.\\n\\n## Коментарі щодо випадку використання\\n\\nУ цьому випадку використовувався промисловий робот Universal Robot UR3. Але завдяки підтримці Robonomics для ROS, можна використовувати та безпечно підключати більшість основних промислових маніпуляторів, включаючи KUKA, Fanuc та Yaskawa.\\n\\nЯкщо ви заціавлені дізнатися більше про розгортання та інтеграцію безпечних хмарних інструментів штучного інтелекту, будь ласка, [звертайтеся](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"9ee0ed65146891661de0e99a89344637\",\"title\":\"Як додати датчик SDS011 до Home Assistant\",\"path\":\"/docs/uk/sds-sensor-hass/\",\"content\":\"\\nУ цій статті пояснюється, як підключити датчик якості повітря SDS до [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) та [Robonomics](https://github.com/airalab/sensors-software) Прошивка до Home Assistant.\\n\\n## Установка \\nІснує два варіанти установки:\\n\\n### Варіант 1: HACS\\n\\nНайпростіший спосіб додати локальний датчик Luftdaten - це через HACS. [Тут](https://hacs.xyz/docs/setup/download/) ви можете знайти коротке пояснення, як налаштувати HACS.\\n\\nПісля встановлення HACS перейдіть до HACS -> Інтеграції та знайдіть інтеграцію `Local Luftdaten Sensor`. Натисніть кнопку завантаження та перезапустіть Home Assistant після завантаження інтеграції.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Варіант 2: Ручна установка\\n\\nПід користувачем homeassistant клонуйте репозиторій проекту:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nЯкщо у вас вже є будь-які власні інтеграції, скопіюйте `custom_components/local_luftdaten/` до вашого каталогу `custom_components`, наприклад:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nЯкщо у вас немає жодних власних інтеграцій, скопіюйте весь каталог `custom_components` до каталогу конфігурації вашого Home Assistant, наприклад:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Конфігурація\\n\\nСтворіть новий запис датчика у вашому `configuration.yaml` та налаштуйте ім'я хоста або IP-адресу. Щоб знайти локальну IP-адресу вашого датчика, ви можете використовувати [мобільний додаток Fing](https://www.fing.com/products) або [інструмент командного рядка nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Ім'я може бути будь-яким.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> Список всіх підтримуваних датчиків можна знайти у [репозиторії](https://github.com/lichtteil/local_luftdaten).\\n\\nПерезапустіть Home Assistant.\\nПісля цього ви можете додати датчик до своєї панелі керування. Ім'я сутності буде ім'ям, яке ви додали до `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"77f0b275e00e0fd11b01f3b9bbc8eab6\",\"title\":\"Як підключити датчик SDS011\",\"path\":\"/docs/uk/sds-sensor-connect/\",\"content\":\"\\n** Ось пошаговий посібник з підключення вашого датчика до мережі датчиків Robonomics. Наші датчики використовують прошивку Robonomics, яка є покращеною версією прошивки sensor.community. Вона містить додаткові датчики та має змінений механізм відправки даних. **\\n\\n1. Підключіть датчик до розетки для його живлення.\\n2. Плата створить бездротову мережу Wi-Fi з назвою `RobonomicsSensor-xxxxxxxxx`. Підключіться до неї з вашого телефону або комп'ютера: ви побачите вікно авторизації (якщо цього не сталося, відкрийте браузер і перейдіть за адресою `192.168.4.1`).\\n3. Виберіть свою бездротову мережу зі списку (або введіть її вручну, якщо вона не в списку) та заповніть поле пароля.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nДатчик можна підключити лише до мережі Wi-Fi 2,4 ГГц.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Введіть координати місця, де буде встановлений датчик. Ви можете отримати їх з будь-яких карт або отримати за адресою, використовуючи [це посилання.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nКоординати датчика потім будуть відображені на загальнодоступній карті. Якщо и не хочете показувати свою приватну інформацію, введіть близькі, але не точні координати.\\n</robo-wiki-note> \\n5. Натисніть на `Save configuration and restart` та перезавантажити`. Плата перезавантажиться та підключиться до вказаної бездротової мережі.\\n6. Відкрийте [карту датчиків Robonomics](https://sensors.robonomics.network/#/) та знайдіть місце, де ви встановили датчик. Через кілька хвилин ви зможете побачити свій датчик з даними на карті.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"6a2a2958e05e294356a0e10f46a190ca\",\"title\":\"Як запустити вузол розробника Robonomics\",\"path\":\"/docs/uk/run-dev-node/\",\"content\":\"\\n** Для тестування ваших додатків на Robonomics ви можете запустити його в режимі розробника. Ця стаття показує крок за кроком\\nінструкції, як отримати власний локальний тестовий екземпляр Robonomics. **\\n\\n\\n## Отримати бінарний вузол\\n\\n1. Спочатку вам потрібен бінарний файл, завантажте архів з ним з останнього [релізу](https://github.com/airalab/robonomics/releases).\\n\\n2. Перейдіть до папки з архівом, розпакуйте бінарний файл і змініть дозволи:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Запустити\\n\\nЗапустіть вузол з:\\n\\n```bash\\n./robonomics --dev\\n```\\nВи побачите наступний вивід:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Якщо ви хочете очистити існуючі блоки, ви можете зробити це, видаливши RocksDB за адресою `/tmp/substrate******/chains/dev/db/full`.\\n  Замініть `******` на відповідний ідентифікатор, відображений у журналах при запуску.\\n\\n  Якщо ви хочете кожного разу запускати вузол з нуля, використовуйте прапорець `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Підключитися\\n\\nТепер ви можете підключитися до свого локального вузла через [Polkadot Portal](https://polkadot.js.org/apps/#/explorer).\\n\\nЗмініть мережу на `Local Node` в верхньому лівому куті та натисніть `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nЛаскаво просимо до локального екземпляра Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"51ffcb8f35f145af5842188328b1191a\",\"title\":\"Огляд розумного будинку Robonomics\",\"path\":\"/docs/uk/robonomics-smart-home-overview/\",\"content\":\"\\n## Безпечний Інтернет речей з блокчейном \\n\\nДля вашого розумного будинку сучасний ринок Інтернету речей надає широкий спектр рішень. Але ви зазвичай завежите від централізованих хмарних постачальників або дорогих пропрієтарних шлюзів. В результаті ви, як користувач, завжди залежите від апаратного забезпечення та інфраструктури виробника для роботи вашої розумної системи. У той же час ваш розумний будинок не може бути дійсно розумним без хмарних статистичних даних та аналітики.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Ми бачимо дві основні проблеми з поточними розумними будинками:**\\n\\n1. Ви не маєте контролю над тими даними, які ви ділитеся з виробником або третьою стороною.\\n2. Ваш розумний будинок вразливий до вимкнень централізованих хмарних серверів. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nЩоб вирішити обидві проблеми, ми пропонуємо вам спробувати Robonomics, нашу **безпечну**, **безсерверну** та **футуристичну** децентралізовану хмару.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Кроки до безкоштовної корпоративної хмари\\n\\nОсь кілька простих кроків для створення доступного розумного будинку за допомогою Home Assistant як програми зв'язку з пристроями та Robonomics як безкоштовної корпоративної, децентралізованої платформи хмарного зберігання. Robonomics використовує сучасні та безпечні технології Web3, забезпечуючи підвищену безпеку на всьому процесі.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Почніть тут свій розумний будинок\\n\\nМи підготували детальні посібники з налаштування розумного будинку на Robonomics. Кроки можуть варіюватися залежно від вашої конкретної ситуації: чи вже у вас є працюючий Home Assistant з парованими пристроями, чи ви починаєте з нуля для створення свого розумного будинку.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/uk/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/uk/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"345ca73c2d549db546c04167111bb83c\",\"title\":\"Сервіс відео Robonomics\",\"path\":\"/docs/uk/robonomics-video/\",\"content\":\"\\nУ цій статті показано, як додати IP-камеру до Home Assistant та надсилати відео на веб-сервіс Robonomics.\\n\\nДля підключення камери до Home Assistant вам потрібно знати його IP-адресу та створити локальний обліковий запис камери для підключення до потоку RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nОскільки це робиться по-різному для кожної камери, цей процес не розглядається в цій статті.\\n</robo-wiki-note>\\n\\nВимоги:\\n- IP-камера\\n- Налаштований локальний обліковий запис камери\\n- IP-адреса камери\\n- Налаштований Home Assistant\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nУ цій статті припускається, що у вас є загальна IP-камера без опцій RTZ (поворот, нахил, збільшення). \\nЯкщо у вас є камера RTZ, перевірте статтю [\\\"Камера RTZ\\\"](/docs/ptz-camera). А потім поверніться до другого кроку тут.\\n\\n</robo-wiki-note>\\n\\n## Підключіть камеру\\n\\nПо-перше, вам потрібно дізнатися URL-адресу потоку RTSP камери. \\nДля цього спробуйте ввести наступний запит в Інтернеті: \\\"<НАЗВА_КАМЕРИ> RTSP-потік\\\".\\nURL потоку повинен починатися з `rtsp://<IP_Адреса>...`. \\n\\nУ цій статті використовується камера \\\"Tapo\\\", а шлях потоку - `rtsp://<IP_Адреса>/stream1`.\\n\\nВідкрийте Home Assistant та перейдіть до \\\"Settings\\\"-> \\\"Devices & Services\\\". Натисніть кнопку \\\"ADD INTEGRATION\\\" та\\nпочніть вводити інтеграцію \\\"Generic Camera\\\". Виберіть її.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nУ вікні конфігурації надайте наступну інформацію:\\n- Stream Source URL - URL потоку RTSP камери\\n- Username - введіть ім'я користувача вашого локального облікового запису камери\\n- Password - введіть пароль для вашого локального облікового запису камери\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nПрокрутіть налаштування вниз і натисніть кнопку \\\"Submit\\\".\\n\\nУ попередньому вікні активуйте прапорець \\\"This image looks good.\\\" і натисніть кнопку \\\"Submit\\\". Потім - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Додати до панелі інструментів\\n\\nКрім того, ви можете додати потік на свою панель інструментів. Для цього перейдіть на панель і створіть нову картку \\n\\\"Picture Glance\\\". Далі кроки:\\n- введіть бажану \\\"Title\\\"\\n- видаліть дані з \\\"Image Path\\\"\\n- виберіть камера в \\\"Camera Entity\\\"\\n- у \\\"Camera View\\\", виберіть \\\"live\\\", щоб зменшити затримку\\n\\nІ збережіть це.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Перевірте папку з медіа\\n\\nBefore being sent to the Robonomics Video Service, the video must be saved in a folder, and Home Assistant must have access to this folder. \\nНайпростіший варіант у цьому випадку - використовувати медіа-пакет, в якому Home Assistant зберігає всі медіа-файли.\\n\\n- Якщо ви використовуєте HAOS або попередньо встановлене зображення, ваш Home Assistant **вже має папку Media**.\\n- Якщо ви використовуєте Home Assistant Core, вам слід перейти до папки `.homeassistant` і створити в ній папку `media`.\\n- Якщо ви використовуєте Home Assistant Docker, додайте рядок ` -v /ШЛЯХ_ДО_ВАШОГО_МЕДІА:/media \\\\` до команди Docker.\\n\\nЩоб перевірити, що все налаштовано правильно, перейдіть на вкладку “Media” -> “local media” в своєму Home Assistant. \\nВи повинні побачити порожню папку (без помилок):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Виклик сервісу\\n\\nЩоб надіслати відео на Robonomics, вам слід викликати спеціальний сервіс в Home Assistant. \\nУ цій статті це робиться вручну, але ви можете створити для цього автоматизацію.\\n\\nДля цього перейдіть до \\\"Developer tools\\\" -> \\\"Services\\\" та знайдіть \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nУ \\\"Цілі\\\" виберіть сутність вашої камери.\\nУ \\\"Шляху для збереження запису\\\" ви повинні вказати абсолютний шлях до папки,\\nде Home Assistant може зберігати відео:\\n- Для попередньо встановленого зображення - `/home/homeassistant/.homeassistant/media`;\\n- Для HA OS або Home Assistant Docker- `/media`;\\n- Для Home Assistant Core - Шлях до раніше створеної папки media.\\n\\nКрім того, ви можете вибрати тривалість запису. \\n\\nЗаповніть дані та викличте сервіс за допомогою кнопки \\\"CALL SERVICE\\\".\\n\\n## DAPP\\n\\nЩоб переглянути отримане відео, перейдіть до [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nВставте адресу вашого контролера та натисніть кнопку нижче. Зачекайте процесу \\\"Search for Twins\\\". \\nВ результаті ви отримаєте IPFS CID з усіма записаними відео.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nДалі виберіть обліковий запис контролера (або будь-який інший) зі списку та підпишіть повідомлення для авторизації в\\nвеб-порталі Web3 IPFS для завантаження всіх відео. В результаті ви отримаєте всі відео, записані вашим розумним будинком.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nОскільки всі відео в папці зашифровані ключем контролера, вам потрібно вставити його для розшифрування відео.\\nПісля цього кнопка відтворення відео активується. Натисніть на неї, щоб завантажити відео.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"a6637f24af2d22e3ee12b6bfe547b1f7\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/uk/robonomics-prometheus-grafana/\",\"content\":\"\\n**Наступна інструкція надана [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**Оригінальна стаття розташована [тут](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Вступ\\nДля кращого моніторингу та підтримки вузлів Robonomics бажано налаштувати моніторинг на основі сервера Prometheus та Grafana. Цей документ покаже, як налаштувати кожен з них для повного моніторингу вашого вузла.\\n\\n##  Передумови\\n* [Налаштування сервера з Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Встановлений коллатор Robonomics parachain](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Переконайтеся, що на вашому комп'ютері працює robonomics.service і порт 9615 доступний \\n\\n## Крок 1 — Створення користувачів служби\\n\\nЗ метою безпеки ми почнемо з створення двох нових облікових записів користувачів, prometheus та node_exporter. Створіть цих двох користувачів і використовуйте параметри _--no-create-home_ та _--shell /bin/false_, щоб ці користувачі не могли увійти на сервер.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nПеред тим, як ми завнтажимо бінарні файли Prometheus, створимо необхідні каталоги для зберігання файлів та даних Prometheus. Відповідно до стандартних конвенцій Linux, ми створимо каталог у _/etc_ для файлів конфігурації Prometheus та каталог у _/var/lib_ для його даних.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nТепер встановіть власника користувача та групи для нових каталогів на користь користувача prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Крок 2 — Завантаження Prometheus\\n\\nСпочатку завантажте та розпакуйте поточну стабільну версію Prometheus у ваш домашній каталог. Ви можете знайти останні бінарні файли на [сторінці завантаження Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nТепер розпакуйте завантажений архів.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nЦе створить каталог з назвою prometheus-2.21.0.linux-amd64, що містить два бінарних файли (prometheus та promtool), каталоги _consoles_ та _console_libraries_ з файлами інтерфейсу веб-сторінки, ліцензию, повідомлення та кілька прикладових файлів.\\n\\nСкопіюйте два бінарних файли в каталог _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nВстановіть власника користувача та групи для бінарних файлів на користь користувача prometheus, створеного на кроці 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nСкопіюйте каталоги consoles та _console_libraries_ в _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nВстановіть власника користувача та групи для каталогів на користь користувача prometheus. Використання прапорця -R забезпечить встановлення власності для файлів всередині каталогу.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nТепер, коли Prometheus встановлено, ми створимо його конфігураційні та службові файли в підготовці до першого запуску.\\n\\n## Крок 3 — Налаштування Prometheus\\n\\nУ каталозі _/etc/prometheus_ використовуйте nano або ваш текстовий редактор, щоб створити файл конфігурації з назвою _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nУ глобальних налаштуваннях визначте типовий інтервал для збору метрик. Зверніть увагу, що Prometheus застосовуватиме ці налаштування до кожного експортера, якщо власні налаштування експортера не перевизначають глобальні.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nЦе значення scrape_interval вказує Prometheus збирати метрики з його експортерів кожні 15 секунд, що достатньо для більшості експортерів.\\nТепер додайте самого Prometheus до списку експортерів для збору з директивою scrape_configs:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus використовує _job_name_ для позначення експортерів у запитах та на графіках, тому оберіть щось описове тут.\\n\\nІ, оскільки Prometheus експортує важливі дані про себе, які можна використовувати для моніторингу продуктивності та налагодження, ми перевизначили глобальну директиву scrape_interval з 15 секунд на 5 секунд для більш частого оновлення.\\n\\nНарешті, Prometheus використовує директиви _static_configs_ та _targets_ для визначення місця розташування експортерів. Оскільки цей експортер працює на тому ж сервері, що й сам Prometheus, ми можемо використовувати localhost замість IP-адреси разом з типовим портом, 9090.\\n\\nВаш файл конфігурації тепер повинен виглядати так:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nЗбережіть файл і закрийте текстовий редактор.\\n\\nТепер встановіть власника користувача та групи для файлу конфігурації на користь користувача prometheus, створеного на кроці 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nЗавершивши налаштування, ми готові протестувати Prometheus, запустивши його вперше.\\n\\n## Крок 4 — Запуск Prometheus\\n\\nЗапустіть Prometheus як користувач _prometheus_, вказавши шлях до файлу конфігурації та каталогу даних.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nВивід містить інформацію про прогрес завантаження Prometheus, файл конфігурації та пов'язані служби. Він також підтверджує, що Prometheus прослуховує порт _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nЯкщо ви отримуєте повідомлення про помилку, перевірте, чи використовуєте ви синтаксис YAML у своєму файлі конфігурації, а потім дотримуйтесь інструкцій на екрані, щоб вирішити проблеу.\\n\\nТепер зупиніть Prometheus, натиснувши _CTRL+C_, а потім відкрийте новий файл служби _systemd_.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nФайл служби повідомляє _systemd_, щоб запустити Prometheus як користувача prometheus, з файлом конфігурації, розташованим у каталозі _/etc/prometheus/prometheus.yml_, і зберігати дані у каталозі _/var/lib/prometheus_. Скопіюйте наступний вміст у файл:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nНаостанок, збережіть файл і закрийте текстовий редактор. Щоб використовувати новостворену службу, перезавантажте systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nТепер ви можете запустити Prometheus за допомогою наступної команди:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nЩоб переконатися, що Prometheus працює, перевірте статус служби.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nВивід показує статус Prometheus, ідентифікатор основного процесу (PID), використання пам'яті та інше.\\n\\nЯкщо статус служби не є активним, дотримуйтесь інструкцій на екрані та повторно пройдіть попередні кроки, щоб вирішити проблему перед продовженням навчального посібника.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nКоли ви будете готові перейти далі, натисніть _Q_, щоб вийти з команди статусу. Нарешті, активуйте службу, щоб вона запускалася при завантаженні.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nТепер, коли Prometheus працює, ми можемо встановити додатковий експортер для генерації метрик про ресурси нашого сервера.\\n\\n## Крок 5 — Завантаження Node Exporter\\n\\nЩоб розширити Prometheus поза метриками лише про себе, ми встановимо додатковий експортер під назвою Node Exporter. Node Exporter надає детальну інформацію про систему, включаючи використання процесора, диска та пам'яті. Завантажте поточну стабільну версію Node Exporter у ваш домашній каталог. Останні бінарні файли можна знайти на [сторінці завантаження Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nТепер розпакуйте завантажений архів.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nЦе створить каталог під назвою _node_exporter-1.0.1.linux-amd64_, що містить бінарний файл з назвою _node_exporter_, ліцензію та повідомлення.\\n\\nСкопіюйте бінарний файл до каталогу _/usr/local/bin_ та встановіть власника та групу користувачів на користувача node_exporter, якого ви створили на кроці 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nТепер, коли ви встановили Node Exporter, давайте спробуємо його запустити, виконавши його перед створенням файлу служби, щоб він запускався при завантаженні.\\n\\n## Крок 6 — Запуск Node Exporter\\n\\nКроки для запуску Node Exporter схожі на кроки для запуску самого Prometheus. Спочатку створіть файл служби Systemd для Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nСкопіюйте наступний вміст у файл служби:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nЗбережіть файл і закрийте текстовий редактор. Нарешті, перезавантажте systemd, щоб використовувати новостворену службу.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nТепер ви можете запустити Node Exporter за допомогою наступної команди:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nПеревірити that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nЯк і раніше, цей вивід показує статус Node Exporter, ідентифікатор основного процесу (PID), використання пам'яті та інше. Якщо статус служби не є активним, дотримуйтесь інструкцій на екрані та повторно пройдіть попередні кроки, щоб вирішити проблему перед продовженням.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nНарешті, активуйте Node Exporter, щоб він запускався при завантаженні.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nЗ Node Exporter повністю налаштованим і працюючим, ми скажемо Prometheus почати збирати нові метрики.\\n\\n## Крок 7 — Налаштування Prometheus для збору метрик Node Exporter\\n\\nОскільки Prometheus збирає лише експортери, які визначені в частині scrape_configs його файлу конфігурації, нам потрібно додати запис для Node Exporter, так само, як ми це зробили для самого Prometheus. Відкрийте файл конфігурації.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nВ кінці блоку scrape_configs додайте новий запис з назвою node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nОскільки цей експортер також працює на тому самому сервері, що й сам Prometheus, ми можемо використовувати localhost замість IP-адреси разом зі стандартним портом Node Exporter, 9100. Весь ваш файл конфігурації повинен виглядати так:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nЗбережіть файл і закрийте текстовий редактор, коли будете готові продовжити. Нарешті, перезапустіть Prometheus, щоб зміни набули чинності.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nЗнову перевірте, що все працює правильно за допомогою команди статусу.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nЯкщо статус служби не встановлено як активний, дотримуйтесь інструкцій на екрані та повторно пройдіть попередні кроки перед продовженням.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nТепер у нас встановлені, налаштовані та працюють Prometheus та Node Exporter.\\n\\n## Крок 8 - Додавання вбудованого експортера Robonomic до node_exporter\\n\\nПісля успішного встановлення Prometheus та node_exporter нам потрібно використовувати вбудований експортер prometheus в кожному проекті підстрати. Щоб це зробити, ми повинні додати додатковий запис до _/etc/prometheus/prometheus.yml_. \\nВідкрийте файл конфігурації.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nВ кінці блоку scrape_configs додайте новий запис з назвою robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nЗбережіть файл і вийдіть з текстового редактора. Ваш файл конфігурації повинен виглядати так:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nНаостанку, перезапустіть Prometheus, щоб зробити зміни дійсними.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nЗнову перевірте, що все працює правильно за допомогою команди статусу.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nТепер у нас встановлені, налаштовані та працюють _Prometheus_, _Node Exporter_ та _Robonomic Exporter_. Тепер перейдіть до Grafana.\\n\\n## Крок 9 - Налаштування Grafana\\n\\nОстаннім кроком є підключення Prometheus як джерела даних у Grafana. Для цієї підручника ми використовуватимемо безкоштовну хмарну версію Grafana, яка дозволяє мати до 5 панелей і спеціальну [панель Robonomics](https://grafana.com/grafana/dashboards/13015). Просто перейдіть на [grafana.com](https://grafana.com/), створіть новий обліковий запис і увійдіть до свого новоствореного екземпляру Grafana.\\n\\nСпочатку нам потрібно додати до Grafana нове _**Джерело даних**_, яким у нашому випадку буде сервер Prometheus.\\nПерейдіть до Джерела даних:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nПотім натисніть **_Додати джерело даних_**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext виберіть _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nНа новому екрані введіть вашу **_IP-адресу сервера Prometheus з портом 9090_**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nПісля цього натисніть _**Зберегти та перевірити**_, якщо ви виконали всі кроки, то все повинно бути зеленим і готовим до імпорту панелі. На головній сторінці натисніть **+**, а потім **Імпортувати**, як показано на зображенні нижче:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nПотім ви повинні побачити сторінку Імпорту:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nУ полі _URL або ідентифікатор панелі Grafana.com_ введіть _**13015**_ (це ID панелі Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nПісля завантаження зовнішньої панелі ви побачите цей екран:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nОстаннім кроком є вибір раніше створеного **_Джерела даних_** і натискання _**Імпортувати**_\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nЦе все! На цьому етапі ви повинні побачити імпортовану панель. \\n\\n\\n## Посилання\\n\\n* [Як встановити Prometheus на Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Створення моніторингової панелі за допомогою Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Підтримка Grafana для Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Моніторинг метрик хоста Linux за допомогою експортера вузла](https://prometheus.io/docs/guides/node-exporter/)\\n* [Запити до Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Візуалізація метрик вузла](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Експортер Prometheus для Substrate](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Метрика вузла Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [Панель експортера вузла для Prometheus](https://grafana.com/grafana/dashboards/11074)\\n* [Метрики ROBONOMICS (XRT) Grafana](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"19efa45d30181838073ec7f9ea8647fa\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/uk/robonomics-opengov/\",\"content\":\"\\n## Вступ\\n\\nRobonomics змінив модель управління парапланом на вищий рівень Polkadot's OpenGov, що дозволяє ланцюжку еволюціонувати з часом, на вимогу власників токенів.\\nПерехід Robonomics до OpenGov абезпечує те, що DAO власників токенів, які контролюють більшість стейку, завжди можуть керувати напрямком роботи параплану Robonomics, впроваджуючи будь-які зміни в мережу, які вони вважають доцільними.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov застосовується тільки до параплану Robonomics, який є ланцюжком на основі Substrate, пов'язаним з ланцюжком Kusama Relay. OpenGov не застосовується до реалізації Robonomics Ethereum, оскільки головна мережа Ethereum наразі не підтримує складні системи управління, такі як OpenGov.\\n</robo-wiki-note>\\n\\nOpenGov змінює спосіб проведення повсякденних операцій та прийняття рішень на параплані. Він надає більшу ясність стосовно обсягу референдумів і має потенціал значно збільшити пропускну здатність рішень, які приймаються на параплані.\\n\\nOpenGov був активований на ланцюжку Kusama Relay кілька місяців тоу, на момент написання, і довів, що значно збільшує кількість рішень (індивідуальних та окремих референдумів), які може запропонувати, проголосувати і керувати напрямком протоколу DAO власників токенів.\\n\\n**Наступний вміст, що міститься в цьому розділі вікі, розгляне основні принципи OpenGov на параплані Robonomics і має на меті допомогти вам краще зрозуміти концепції, що стоять за OpenGov.**\\n\\n*Важливо зазначити, що управління є постійно еволюціонуючим механізмом в протоколі, особливо на ранніх етапах впровадження.*\\n\\nДля тих, хто цікавиться лише параметрами Robonomics OpenGov Track, див. [тут](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## Про референдуми\\n\\nРеферендуми - це прості, всеосяжні та засновані на стейку схеми голосування. Кожен референдум має певну пропозицію, пов'язану з ним, яка приймає форму привілейованого виклику функції в робочому часі ланцюжків. Це також може включати найпотужніший виклик `set_code``, який має можливість вимикати весь код середовища виконання ланцюжків – це унікально для ланцюжків на основі субстрату та усуває вимогу щодо «хардфорку» ланцюжка під час оновлення бізнес-логіки ланцюжків ( час виконання).\\n\\nРеферендуми - це окремі події, які мають фіксований період голосування (докладніше про різні періоди під час життєвого циклу референдуму пізніше). Індивідуальні власники токенів можуть голосувати за референдум одним з трьох способів - ЗА (погоджуюсь/так), ПРОТИ (не погоджуюсь/ні) або УТРИМУВАТИСЯ від голосування взагалі.\\n\\nУ всіх референдумів є затримка виконання. Це період між закінченням референдуму та, за умови, що референдум був схвалений, впровадження змін в мережу. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Існує **Мінімальний** період виконання, спеціально встановлений для кожного різновиду Origin, але ініціатор певного референдуму може встановити завдання цього конкретного референдуму на виконання через багато блоків у майбутньому\\n\\n</robo-wiki-note>\\n\\nРеферендуми вважаються \\\"приготованими\\\", якщо вони закриті і підраховані голоси. За умови, що референдум був схвалений, він буде запланований для виконання (в планувальнику ланцюжка). Референдуми вважаються \\\"неприготованими\\\", якщо результат ще не відомий - наприклад, якщо референдум все ще голосується.\\n\\nЗ введенням OpenGov будь-хто може розпочати референдум у будь-який час і може робити це стільки разів, скільки завгодно. OpenGov усуває обмеження можливості обробки лише 1 референдуму одночасно (зауважте, що в Gov v1 можна голосувати лише за 1 референдум одночасно. Єдиним винятком є додатковий надзвичайний референдум Технічного комітету, який також може одночасно голосуватися спільнотою).\\n\\nOpenGov вводить кілька нових функцій / концепцій, відомих як Origins та Tracks, і вони вводяться для полегшення потоку та обробки референдумів в протоколі.\\n\\nКожен Origin пов'язаний з одним класом референдуму, а кожен клас пов'язаний з треком. Трек визначає життєвий цикл референдуму і є специфічним для цього конкретного Origin, з якого походить референдум. Наявність треків з власними конкретними параметрами дозволяє мережі динамічно змінювати життєвий цикл референдумів на основі їх рівня привілеїв (можна уявляти рівень привілеїв як те, наскільки потужним може бути референдум / які типи змін він може вносити в протокол).\\n\\n*Думайте про Origins як про владу, пов'язану з референдуом, і про Tracks як про параметри голосування, пов'язані з референдумом, такі як тривалість його періодів, критерії схвалення та підтримки.*\\n\\nНаприклад, оновлення робочого часу не має таких наслідків для протоколу, як невеликий підказка скарбниці, і тому потрібні різні походження, в яких будуть заздалегідь визначені різні обороти, схвалення, депозити та періоди виконання (Tracks) в палетах ланцюжка.\\n\\n## Пропозиція референдуму та життєвий цикл референдуму \\n\\n### Період підготовки\\n\\nУ OpenGov, коли референдум створюється вперше, його можна відразу проголосувати спільнотою власників токенів. Однак, він не знаходиться в стані, коли може завершитися або мати підраховані голоси, бути затвердженим і негайно введеним в дію. Замість цього референдуми повинні відповідати кільком критеріям, перш ніж вони будуть перенесені в Період прийняття рішень. До тих пір, поки референдуми не увійдуть в Період прийняття рішень, вони залишатимуться невирішеними - і врешті-решт знімуться з розгляду після закінчення загального життєвого циклу, як вказано в окремому треку.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nКритерії для входу референдуму в Період прийняття рішень наступні:\\n1. Період підготовки, в якому вказується час, який повинен пройти, перш ніж може початися Період прийняття рішень. Цей період підготовки допомагає запобігти можливості \\\"снайперського рішення\\\", коли нападник, що контролює значну кількість голосів, може намагатися використовувати свою велику частку, щоб референдум був прийнятий безпосередньо після його пропозиції, обхід можливості для інших учасників DAO власників токенів мати достатньо часу для розгляду референдуму та участі в голосуванні. Тому початкові треки з вищими рівнями привілеїв мають значно довший період підготовки.\\n\\n2. Повинно бути місце для прийняття рішення. Кожен трек має свої власні обмеження для кількості референдумів, які можуть бути прийняті одночасно (max_deciding). Треки з більш потужними рівнями привілеїв матимуть нижчі обмеження. Наприклад, початковий трек рівня Root матиме значно меншу кількість референдумів, які можуть бути прийняті одночасно, порівняно з треками нижих рівнів привілеїв, такими як Small Tipper.\\n\\n3. Повинен бути поданий Депозит прийняття рішення. Створення референдуму спочатку є досить дешевим, і вартість Депозиту подання (зарезервованого при створенні референдуму) досить низька і головним чином складається з вартості, яку коштує зберігання на ланцюжку, пов'язаному з референдумом. Депозити прийняття рішень значно вищі, що потрібно для боротьби зі спамом і відіграють роль в економічній грі, яку пропонує OpenGov, про яку ми розповімо пізніше.\\n\\nПісля виконання всіх трьох вищезазначених критеріїв референдум перейде в Період прийняття рішень. Голоси за референдум будуть підраховуватися для визначення результату.\\n\\n### Період прийняття рішень\\n\\n*Для швидкого відеодемонстрації Періоду прийняття рішень дивіться [це відео](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nПісля того, як референдум відповідає всім критеріям, які детально описані вище, він перейде в Період прийняття рішень.\\n\\nПеріод прийняття рішень базується на двох основних концепціях, а саме критеріях Затвердження та Підтримки. \\n\\nЗатвердження визначається як частка ваги голосу ЗА (AYEs) порівняно з загальною вагою голосу (усі голоси ЗА та ПРОТИ разом). Кожен голос враховується при визначенні загальної ваги голосів ЗА/ПРОТИ (докладніше про голосування з переконанням / добровільну блокування в наступному розділі).\\n\\nПідтримка - це загальна кількість голосів (токенів), які взяли участь у референдумі (і не коригується за переконанням), порівняно з загальною кількістю можливих голосів, які можуть бути подані в системі (можна уявити це як загальне випуску XRT на паралелельному ланцюжку - слід зазначити, що загальний обіг XRT тут не є основним фактором, через те, що певна частина цього числа існує на Ethereum у вигляді токенів ERC-20).\\n\\n**Голоси, які спрямовані на УТРИМАННЯ, НЕ сприяють критеріям Затвердження, але вони включаються / враховуються в критеріях Підтримки**\\n\\nРеферендум повинен відповідати критеріям Підтримки І Затвердження протягом Періоду прийняття рішень, щоб перейти до Періоду підтвердження.\\n\\nДля отримання деталей щодо окремих критеріїв Підтримки та Затвердження для кожного треку див. [таблицю](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Період підтвердження\\n\\nКожен трек має свій власний специфічний еріод тривалості для Періоду підтвердження. Треки, які мають вищі рівні привілеїв (наприклад, Root), мають значно довші періоди підтвердження, ніж ті, що мають нижчі рівні привілеїв (наприклад, Small Tipper).\\n\\nРеферендуми повинні продовжувати відповідати критеріям Підтримки та Затвердження протягом всього періоду підтвердження, інакше вони знову повернуться до Періоду прийняття рішень (зауваження: Період прийняття рішень не призупиняється протягом Періоду підтвердження, тому цілком можливо, що Період прийняття рішень може закінчитися протягом Періоду підтвердження, що означає, що якщо референдум виходить з Періоду підтвердження через невідповідність критеріям Підтримки та Затвердження, він буде вважатися неуспішним референдумом і не буе введений в дію).\\n\\n**Можливо налаштувати критерії затвердження та підтримки для окремих треків через референдум з привілеями Root Origin.**\\n\\nПочаткові точки з нижчими рівнями привілеїв мають значно спрощні критерії затвердження та підтримки (встановлені треком), ніж ті, що мають вищі рівні привілеїв. Аналогічно, початкові точки з вищими рівнями привілеїв мають менш круті криві, ніж ті, що мають менші привілеї (як визначено в треку), щоб забезпечити затвердження референдуму DAO власників токенів та уникнути референдумного снайпінгу для референдумів з високими привілеями.\\n\\nУ OpenGov референдуми, які не були затверджені після закінчення періоду прийняття рішень, вважаються відхиленими за замовчуванням, і як подання, так і депозити рішень повертаються їх авторам (зауваження: депозит рішення може бути розміщений кимось іншим, а не автором референдуму).\\n\\nЯкщо референдум постійно відповідає критеріям затвердження та підтримки протягом всього періоду підтвердження, то він вважається затвердженим і буде запланований для виконання з запропонованого джерела, але референдум виконуватиметься лише після минулого мінімального періоду введення в дію.\\n\\n### Період введення в дію\\n\\nПеріод введення в дію вказується автором при запропонуванні референдуму, але він підлягає Мінімальному періоду введення в дію, який вказується в кожному треку. Більш потужні початкові точки мають набагато більший мінімальний період введення в дію, ніж ті, що мають менші привілеї. Це забезпечує достатній час мережі для підготовки до будь-яких змін, які може накласти потужний референдум.\\n\\n## Добровільне блокування / переконання\\n\\nRobonomics використовує концепцію, відому як добровільне блокування або голосування за переконанням. Це дозволяє власникам токенів збільшити свою виборчу силу, вирішивши, на який термін вони готові заблокувати свої токени для певного референдуму. Цей механізм впливає лише на критерії затвердження для кожного референдуму, а голосування за переконанням не впливає на критерії підтримки.\\n\\nГолосування за переконанням можна розрахувати за допомогою такої формули:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nУ цій таблиці показано, як кожний зростаючий період блокування множить ваш голос за критерії затвердження:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nМаксимальна кількість переконання, яку власник токена може використовувати, - 6x переконання. Ви можете встановити переконання лише згідно з таблицею вище, і ви не можете, наприклад, використовувати 5,5x переконання.\\n\\nПоки токен заблокований через голосування, його все ще можна використовувати для голосування в іших референдумах, однак він не буде враховуватися у вашому переказному балансі (ви не можете відправити його на інший рахунок) - і баланс стане переказним знову лише після закінчення всього періоду блокування.\\n\\n## Делегування голосу\\n\\nУ OpenGov було додано механізм, щоб дозволити власникам токенів, які не мають достатньо часу для огляду кожного референдуму, все ж використовувати свої токени як частину системи управління, це відомо як делегування голосу.\\n\\nВласники токенів можуть вибрати делегувати свою виборчу силу іншому голосувачу в системі (іншому рахунку). Голосувачі можуть вказати, щоб делегувати свою виборчу силу гнучким способом, дозволяючи їм призначати свою виборчу силу для кожного окремого походження. Голосувачі також можуть встновити різну кількість виборчої сили для кожного походження (кількість токенів і рівень переконання).\\n\\nЦя функція делегування має одну мету - збільшити явку виборців і допомогти забезпечити виконання критеріїв затвердження та підтримки.\\n\\nЩоб делегувати свою виборчу силу, ви можете використовувати функцію \\\"Delegate\\\", яку ви знайдете в розділі Управління -> Референдум на [Порталі Robonomics](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). Крім того, користувачі можуть надсилати витяги convictionVoting(Delegate), використовуючи розділ Розробник -> Витяги порталу Robonomics, проте використання функції \\\"Delegate\\\" в розділі референдуму порталу є набагато простіше.\\n\\n## Скасування / Вбивство референдуму та економічна гра управління\\n\\nУ OpenGov є походження, які призначні для відхилення поточних референдумів, незалежно від їх статусу. Це відомо як дорожка відмови управління та дорожка вбивці.\\n\\nЦі походження втручаються в референдум, який вже був проголосований. Ці походження, якщо референдум, що походить від них, затверджений, негайно відхилять поточний референдум, незалежно від його статусу. \\n\\nСкасування само по собі є типом референдуму, який повинен бути проголосований власниками токенів, щоб бути виконаним. Скасування має своє власне походження та доріжку, які мають менший термін виконання (період прийняття рішення і т. Д.) І мають криві затвердження та підтримки з більш крутим / гострим спуском (що означає, що їх критерії набагато легше виконати з часом) ніж інші походження. Це пов'язано з тим, що скасування референдуму зазвичай супроводжується почуттям терміновості.\\n\\nЦілью управління відмовою є негайне відхилення вже поточного референдуму. Коли референдум скасовується цим походженням, як власникам, так і рішенням, повертаються внески за подання та прийняття. Прикладом ситуації, коли референдум може бути скасований, є випадок, коли походження зробило деяку помилку людини в змісті свого референдуму і не намагалося зробити щось зловмисне.\\n\\nЦіллю управління вбивцею є негайне відхилення вже поточного референдуму. Тут вступає в гру економічна гра управління. Походження з високими рівнями привілеїв, такими як Root, мають внесок прийняття рішення, який вимагає великої кількості капіталу (токенів XRT), щоб референдум увійшов у період прийняття рішення. \\n\\nЯкщо зловмисник подає референдум, наприклад, референдум з кореневими походженнями, який має на меті `set_code` робочого часу ланцюжка на щось, що припинить виробництво блоків ланцюжка, тоді DAO власників токенів може підняти проти цієї дії контрреферендум від походження вбивці управління. Якщо зловмисний референдум відхиляється через походження вбивці управління, тоді як внески за подання та прийняття будуть зменшені, що означає, що походження (рахунки), які подали ці внески, втратять ці кошти. \\n\\nЦе означає, що зловмисникам загрожує серйозна економічна кара за спробу підняти референдум, який може мати серйозні негативні наслідки для ланцюжка, що в теорії зупинить будь-якого зловмисника від спроби цього.\\n\\nРішення про депозит для самої доріжки Governance Killer досить високе, це зроблено для того, щоб зупинити рівно таких же зловмисників, які намагаються знищити депозити інакше гарних референдумів. **Існуючий референдум Governance Killer може бути знищений наступним референдумом Governance Killer.**\\n\\n## Технічний комітет Robonomics та Whitelisted Origin\\n\\nЦя група є самоуправляючим експертним органом, метою якого є представлення людей, які втілюють і володіють технічними знаннями мережі протоколу Robonomics. \\n\\nЦя група (і тільки ця група) може походити референдуми з палетки Whitelist. Ця палетка робить одну річ, вона дозволяє одному Origin підвищити рівень привілеїв іншого Origin для певної операції. \\n\\nЦя група може авторизувати референдум від походження, відомого як Whitelisted-Root, і ці референдуми можуть бути виконані з привілеями рівня Root, але ці референдуми будуть успішно працювати тільки з певними визначеними командами, які були авторизовані групою. Палетка Whitelist перевряє дві речі:\\n1. Походження дійсно є Whitelisted-Root (тобто референдум пройшов через доріжку цього походження).\\n2. Пропозиція дійсно була включена до білого списку групою.\\n\\nЯкщо обидва умови виконуються, тоді операція буде виконана з привілеями рівня Root.\\n\\nЦя система дозволяє мати нову паралельну доріжку (Whitelisted-Root Origin), параметри якої дозволяють скоротити час голосування (критерії схвалення та підтримки трохи легше виконати, ніж для Root). Цей відкритий і прозорий процес дозволяє цій групі експертів протоколу мережі Robonomics запропонувати референдуми, які вони визначили як безпечні та часово критичні.\\n\\nВарто зазначити, що критерії підтримки для референдумів, ініційованих з походження Whitelisted-Root, не зменшуються до 0, як у багатьох інших походжень/доріжках. Це забезпечує, що ця група не має фактичного контролю над усім протоколом мережі Robonomics і вимагає мінімального рівня підтримки (виборчої участі) від загального DAO власників токенів.\\n\\n\\n## Тривалість референдумів \\n\\nВажливо розуміти, що тривалість кожного окремого референдуму не є конкретною річчю, вона не є вкаменілою. Деякі періоди у життєвому циклі референдуму, такі як мінімальний період виконання, дійсно мають конкретну тривалість, але інші, включаючи період прийняття рішення, - ні. Наприклад, не точно додавати максимальні тривалості для періодів Підготовки, Прийняття рішення, Підтвердження та Мін. Період виконання і стверджувати, що \\\"кожен референдум займе X кількість днів\\\", це набагато більш гнучко.\\n\\nДавайте розглянемо е крізь призму кількох окремих референдумів, які походять з одного Істочника, у цьому випадку, з кореневого походження. \\n\\nКореневе походження має свою власну доріжку, де встановлені тривалості для кожного періоду, а також криві схвалення та підтримки.\\n\\nВажливо пам'ятати, що референдуми перейдуть до наступного етапу свого життєвого циклу, якщо виконуються певні умови. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nВи повинні припускати, що на наступних зображеннях, для того, щоб референдум перейшов до наступного етапу свого життєвого циклу, умови, описані на попередньому зображенні, повинні бути виконані (якщо не зазначено інше).\\n\\n\\n### Максимально можлива тривалість з дуже малою виборчою участю\\n\\nНижче наведено зображення максимально можливого графіка для референдуму, подумайте ро це як про референдум, який:\\n1. Має опублікований Депозит рішення, тому перейшов до періоду Прийняття рішення.\\n2. Має один голос, наприклад, 1 XRT, в напрямку ЗА - це означатиме, що вимоги до підтримки (виборчої участі) будуть виконані лише в кінці періоду Прийняття рішення (так як загальна підтримка дуже низька), але має 100% схвалення, тому врешті-решт буде відповідати вимогам для переходу до періоду Підтвердження.\\n3. Продовжує відповідати вищезазначеним критеріям протягом періоду Підтвердження.\\n4. Пропозиція, піднята референдумом, буде виконана точно в той же блок, що і закінчується Мінімальний період виконання - технічно походження референдуму може встановити зміни в мережі, які детально описані в референдумі, щоб виконати багато блоків у майбутньому, тому реальний життєвий цикл окремого референдуму може тривати декілька днів, тижнів, місяців або років.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nМи бачимо, що в цьому прикладі життєвий цикл референдуму буде (приблизно) 17 днів.\\n\\n\\n### Тривалість з великою виборчою участю (з великою кількістю голосів ЗА)\\n\\nТепер давайте розглянемо референдум, на який власник токенів XRT DAO висловив великий інтерес. У цьому прикладі ми припустимо, що загальна кількість голосів становить близько 248 771 XRT, і всі голосують за напрямком AYE (зауваження: технічно на цьому етапі референдуму Root, згідно з треком, лише 60% голосів повинні бути за напрямком AYE, щоб референдум відповідав критеріям схвалення).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Завжди переглядайте найактуальнішу інформацію про трек для точної інформації щодо кожного треку, додаткову інформацію можна знайти у цій [таблиці](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nУ цьому прикладі:\\n1. Рішення про внесення депозиту було опубліковано під час підготовчого періоду, тому воно змогло перейти до періоду прийняття рішення в кінці підготовчого періоду.\\n2. Багато виборців проголосували на цьому референдумі - отримано загальну кількість голосів близько 248 771 XRT за відносно короткий час.\\n3. Голоси були більшістю за напрямком AYE (будь-яке значення понад 60% AYE).\\n4. Референдум постійно відповідає критеріям періоду підтвердження протягом всього періоду підтвердження (зауваження: якщо референдум перестає відповідати критеріям періоду підтвердження, то він повертається до періоду прийняття рішення).\\n5. Пропозиція, піднята референдумом, буде введена в дію саме на тому блоку, на якому закінчується мінімальний період введення в дію.\\n\\nЧерез те, що загальна кількість голосів становить близько 248 771 XRT, референдум відповідатиме критеріям для входу в період підтвердження після приблизно 168 годин (7 днів).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nМи бачимо, що в цьому другому прикладі через те, що була велика кількість голосів, період прийняття рішення фактично закінчився наполовину раніше, ніж максимально відведений час. Це призводить до референдуму, який може бути введений в дію протягом приблизно 10 днів.\\n\\n\\n### Тривалість, коли рішення про внесення депозиту ніколи не опубліковано\\n\\nТепер давайте розглянемо референдум, який був започаткований, але рішення про внесення депозиту ніколи не було опубліковано. Такі референдуми перебувають у своєрідному стані \\\"лімбо\\\", де їх підготовчий період закінчився, але, оскільки рішення про внесення депозиту не було опубліковано, референдум залишається у стані \\\"підготовки\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nМи бачимо, що в цьому третьому прикладі через те, що рішення про внесення депозиту ніколи не було опубліковано, референдум фактично ніколи не увійде в період прийняття рішення, замість цього він залишається у стані \\\"підготовки\\\". Це означає, що в кінцевому підсумку, якщо рішення про внесення депозиту ніколи не буде опубліковано, референдум закінчиться після того, як мине тривалість, визначена в константі timeOut палетки.\\n\\nЦе вже траплялося раніше на Kusama, коли референдум був опублікований з кореневими походженнями, але через високі капіталовкладення для опублікування рішення про внесення депозиту референдум ніколи не увійшов у пізніші стадії свого життєвого циклу. Такі референдуми завершуються позначкою \\\"тайм-аут\\\".\\n\\n\\n### Тривалість, коли рішення про внесення депозиту опубліковано пізно\\n\\nНарешті, давайте розглянемо приклад, коли рішення про внесення депозиту не було опубліковано досить довго після того, як референдум був започаткований. Це вже траплялся раніше на Kusama, коли референдум був опублікований з кореневим походженням, але ініціатору довелося витратити час, щоб знайти когось з великою кількістю капіталу, хто опублікує рішення про внесення депозиту від їх імені.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nУ цьому останньому прикладі через те, що рішення про внесення депозиту було опубліковано після закінчення підготовчого періоду, але до закінчення тайм-ауту референдуму, життєвий цикл референдуму фактично триває набагато довше, оскільки він входить у період прийняття рішення після більш тривалого часу.\\n\\nВажливо зазначити, що DAO власників токенів може голосувати AYE/NAY за референдуми, які перебувають у підготовчому періоді або застрягли в стані \\\"підготовки\\\".\\n\"}},{\"node\":{\"id\":\"801f385305d4ba7da1158dda38927edf\",\"title\":\"Налаштування інтеграції Robonomics\",\"path\":\"/docs/uk/robonomics-hass-integration/\",\"content\":\"\\n**У цій статті ви додасте Robonomics до Home Assistant. Це дозволяє Home Assistant записувати журнали даних з зашифрованими даними на Robonomics Parachain та слухати команди запску з parachain для керування розумними пристроями. Інтеграція використовує IPFS для зберігання даних та відправки хешів IPFS до функцій журналу даних або запуску.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. У веб-інтерфейсі Home Assistant перейдіть до `Settings` -> `Device & Services` та натисніть `ADD INTEGRATION`. Знайдіть `Robonomics`.\\n\\n2. Клацніть на Robonomics та заповніть конфігурацію: \\n\\n- Додайте насіння з облікового запису `SUB_CONTROLLER` до насіння облікового запису контролера.\\n- Додайте публічну адресу облікового запису `SUB_OWNER` до адреси власника підписки.\\n- Встановіть інтервал відправки даних (за замовчуванням це 10 хвилин).\\n- (Необов'язково) Ви можете додати облікові дані для сервісу підтримки Pinata або іншого користувацького шлюзу, щоб розповсюджувати свої дані ширше по мережі IPFS.\\n\\n3. Натисніть `SUBMIT` після завершення конфігурації. Якщо ви заповнили все правильно, ви побачите вікно успіху.\\n\\nОсь і все! Ви повністю налаштували інтеграцію Robonomics в Home Assistant. Тепер ви можете використовувати всі \\nRobonomics веб-сервіси. Щоб дізнатися більше про них, перейдіть до розділу [\\\"Використання\\\"](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"f44a0a14aa3c05472617d71ba2d6d1da\",\"title\":\"Robonomics на Ethereum\",\"path\":\"/docs/uk/robonomics-ethereum/\",\"content\":\"\\nВся інформація про Robonomics на Ethereum перенесена до репозиторію GitHub. Усю необхідну інформацію можна знайти [тут](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"ff01b45aa51111dad0c940112768e427\",\"title\":\"Python інтерфейс та Robonomics IO\",\"path\":\"/docs/uk/rinterface/\",\"content\":\"\\n**Деякі екстрикси, реалізовані в палетах Robonomics, важко подати з додатка Polkadot. Більше того, є \\nпотреба взаємодіяти з цим функціоналом за допомогою мов програмування. Для цієї цілі було розроблено простий інструмент на Python\\nпід назвою [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface). Це обгортка, яка підтримується polkascan\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). Нижче наведено короткий опис цього пакету\\nта кілька корисних посилань і прикладів. Також обговорюються інструменти командного рядка.**\\n\\n## robonomics-interface\\n\\nДоступний на [PyPi](https://pypi.org/project/robonomics-interface/) пакет готовий до завантаження та налаштування.\\nІснує детальна згенерована з docstring [документація](https://multi-agent-io.github.io/robonomics-interface/).\\n\\nВ цілому, це інструмент для розробників, які бажають взаємодіяти з блокчейном Robonomics за допомогою програмних інструментів. Майже \\nвсі проекти на Python команди Robonomics, які взаємодіють з паралельним ланцюжком, використовують цей інтерфейс.\\n\\n### Установка\\n\\nПроцес установки вимагає наявності у користувача Python 3.8 або вищ. Ні `x86`, ні `arm7`, ні `arm8`\\nархітектури не потребують процесу компіляції. Усі пакети залежностей побудовані та опубліковані розробниками залежностей.\\n\\n`pip` використовується як інструмент установки:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Приклад використання\\n\\nОсновна ідея полягає в створенні екземпляру `Account`, а потім використанні його для створення екземплярів, присвячених палетам.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  Також можливо використовувати власні кінцеві точки (наприклад, локальний вузол для тестування):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nТакож можливо подати екстрикси:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Як вже було сказано, більше прикладів доступно на сторінці [документації](https://multi-agent-io.github.io/robonomics-interface/).\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` також містить інструменти командного рядка Python `click`, які можна використовувати для прототипування та швидких тестів. Вони встановлюються\\nразом з пакетом і доступні в терміналі:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nВи можете спробувати використовувати його з локальним вузлом. Використовується філософія конвеєра.\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"a08c3b5cc1c7359efeddf5b848a5f256\",\"title\":\"Керування камерою PTZ в Home Assistant\",\"path\":\"/docs/uk/ptz-camera/\",\"content\":\"\\nЦя стаття охоплює процес налаштування PTZ-камери в Home Assistant. \\nБуде використано протокол ONVIF. Для цього потрібен локальний обліковий запис камери.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nПроцес налаштування локального облікового запису камери не розглядається в цій статті.\\n</robo-wiki-note>\\n\\nВимоги:\\n- Камера PTZ\\n- Локальний обліковий запис камери\\n- IP-адреса камери\\n- Налаштований Home Assistant\\n\\n## Інтеграція ONVIF\\n\\nПочнемо з встановлення **інтеграції ONVIF**. \\n\\nПерейдіть до \\\"\\\"Devices & Services\\\" в \\\"Settings\\\" та натисніть кнопку \\\"ADD INTEGRATION\\\".\\nВведіть \\\"ONVIF\\\" та виберіть інтеграцію. Ви побачите наступне вікно.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nНатисніть кнопку \\\"Submit\\\". Вона спробує автоматично знайти вашу камеру. Якщо вдалося, \\nвиберіть свою камеру зі списку та заповніть порожні поля. \\nВ іншому випадку вам потрібно буде заповнити всі поля вручну. Ви побачите наступне вікно.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nЗаповніть прогалини:\\n- Name - надайте назву своїй камері\\n- Host - вкажіть IP-адресу вашої камери\\n- Port - зазвичай це 2020 рік, але ваш постачальник камер може змінити це\\n- Username - введіть ім'я користувача вашого локального облікового запису камери\\n  - Password - введіть пароль для вашого локального облікового запису камери\\n\\nта натисніть \\\"Submit\\\". Виберіть область для вашої камери та натисніть \\\"Finish\\\".\\n\\n## Додайте керування камерою до панелі інструментів\\n\\nТепер, коли ви повністю налаштували камеру, ви можете додати її потік та кнопки керування до панелі інструментів.\\n\\nПерейдіть до панелі інструментів та почніть з створення нової картки. Виберіть \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nЗаповніть дані:\\n- Title - виберіть заголовок зображення камери\\n- Camera Entity - виберіть сутність камери зі списку\\n- Camera View - виберіть \\\"live\\\" для отримання меншої затримки\\n\\nДалі, перейдіть до режиму \\\"Code Editor\\\", натиснувши кнопку внизу лівого боку. Ви побачите наступний код:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nЗамініть вміст `entities: []` згідно з прикладом нижче (`<YOUR_CAMERA_ENTITY>` такий самий, як параметр `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nЦе все. Тепер ви повинні побачити картку камери PTZ на панелі інструментів разом з кнопками керування.\\n\\n## Усунення неполадок\\nЯкщо ви використовуєте Home Assistant Core і не бачите потоку з камери, вам слід встановити інтеграції \\\"stream\\\" та \\\"FFMPEG\\\". \\nДля цього вам потрібно додати рядки `stream: ` та `ffmpeg: ` в кінець configuration.yaml.\"}},{\"node\":{\"id\":\"6ea117f357f0f787e6f9c2a546a82b57\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/uk/notifications/\",\"content\":\"\\nВи можете отримувати сповіщення на свій смартфон за допомогою [notify](https://notify.events/). Спочатку зареєструйтесь там і на `Control Panel` створіть новий канал:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nДодайте заголовок і натисніть `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nПотім натисніть `Add Source` і виберіть `Home Assistant` в закладці `IoT and Smart Home`:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nНапишіть заголовок і натисніть `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nТам ви побачите токен, який вам потрібно додати до файлу конфігурації для Home Assistant. Збережіть його десь і натисніть `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nпотім натисніть `Subscribe`, щоб додати підписників:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nВиберіть будь-якого підписника, якого ви хочете, і дотримуйтесь інструкцій.\\n\\nТепер вам потрібно відредагувати конфігурацію на своєму комп'ютері з Home Assistant. Відкрийте файл `configuration.yaml` під користувачем `homeassistant`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nІ додайте ці рядки:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nТакож додайте нову автоматизацію після рядка `automation:`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nЦя автоматизація надсилатиме повідомлення `Door was changed to on/off`, коли датчик з ідентифікатором сутності `binary_sensor.contact_sensor_contact` змінює стан з `off` на `on`.\\n\\nІ перезапустіть Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"d29a5b1c948b532cc27df7da6ad2c79c\",\"title\":\"Відповідальність\",\"path\":\"/docs/uk/liability/\",\"content\":\"\\n**Щоб перетворити роботів на економічних агентів, потрібен інструмент договору. Знайомтеся з Liability - палеткою Robonomics, яка реалізує контракти між рахунками парачейну!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Зверніть увагу, що цей посібник демонструється на локальному екземплярі Robonomics Node. Налаштуйте свій за допомогою [цієї інструкції](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Огляд теорії\\n\\nНа Ethereum існувала досить складна структура взаємодії відповідальності. Ви можете ознайомитися з нею [тут](/docs/robonomics-how-it-works). Зараз речі трохи спрощені з Kusama!\\n\\n### Переговори\\n\\nДля підписання контракту сторони повинні спочатку домовитися. Це можна зробити кількома способами, зокрема [IPFS PubSub ](https://blog.ipfs.tech/25-pubsub/) або Robonomics PubSub. Зразок коду Python із використанням Robonomics PubSub представлено [тут](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub). \\n\\nПропозиція та попит - це повідомлення, що містять дві основні характеристики контракту: **опис роботи** та **ціна**. Формат повідомлення повинен бути розроблений користувачем для кожної конкретної програми. У процесі переговорів необов'язково дотримуватися жорсткого правила формату. Можливий потік представлений на наступному малюнку.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Зверніть увагу, що PubSub - це відкритий протокол, тому немає потреби передавати конфіденційні дані. Для цього слід використовувати інші протоколи.\\n\\n</robo-wiki-note>\\n\\n\\n### Підписи\\n\\nПісля успішного завершення переговорів кожна сторона повинна підписати свою так звану угоду, яка називається підписом. Це повідомлення, що містить опис роботи та ціну **в певному форматі**, підписане закритим ключем облікового запису. Для цього також існує [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability).\\n - Опис роботи називається **технікою**. Це рядок довжиною 32 байти, який може бути закодованим IPFS CID.\\n - Ціна називається **економікою**. Це десяткове число XRT - Вейнер. 1 Вейнер = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Можна отримати [IPFS](https://ipfs.tech/) CID у правильному форматі за допомогою [бібліотеки Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  При використанні функції `sign_liability` немає потреби перетворювати хеш, це буде зроблено автоматично.\\n\\n</robo-wiki-note>\\n\\nЗа прикладом з кавою:\\n\\n1. Завдання - це JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Його IPFS CID - `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Таким чином, **техніка** (перетворений CID) - `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **Економіка** - `1.5 XRT`.\\n\\nПісля підписання настав час створити відповідальність! Це може зробити одна зі сторін (або обіцяючий, або обіцяний) або обліковий запис третьої сторони, так званого постачальника.\\n\\n## Створити відповідальність\\n\\n### Підготовка\\n\\nЯк вже зазначалося раніше, у процесі задіяні принаймні дві сторони. Для цього прикладу використовуємо три і створимо окремого постачальника. Припустимо, що переговори вже відбулися якимось чином.\\n\\n### 1. Створіть три облікові заиси та додайте кошти на них\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nТут ми надали постачальнику 100 XRT для підписування екстриксів відповідальності, обіцяючому було надано 2 XRT для оплати роботи.\\nОбіцяний не отримав жодних коштів (крім існуючого депозиту, що становить принаймні 1 мXRT).\\n\\n### 1. Перейдіть до Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Виберіть liability -> create зі списку можливих екстриксів\\n\\nТакож виберіть обліковий запис, з яким ви хочете подати екстрикс. Заповніть всі параметри.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  Оскільки тут використовується постачальник, не потрібно знати насіння учасників. Потрібні лише їх підписи.\\n\\n</robo-wiki-note>\\n\\n### 3. Відправити транзакцію\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Перегляньте свою відповідальність у подіях\\n\\nДля цього перейдіть до `Network -> Explorer` та знайдіть список подій справа. Клацніть на трикутник, щоб розгорнути.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  Хеш можна перетворити на IPFS CID за допомогою того самого [інструмента Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Дослідження сховища\\n\\nВи також можете досліджуват деякі характеристики відповідальностей у модулі сховища `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  Функція сховища `Next Index` показує останній індекс відповідальності +1, тому навіть якщо він дорівнює `1`, відповідальність `0` досліджується.\\n\\n</robo-wiki-note>\\n\\n## Звіти\\n\\nУявіть, що кава була приготована, і тепер кавоварка повинна якось про це повідомити. Ось де з'являються звіти про відповідальність. Як доказ праці, рахунок додає ще один IPFS CID як зміст звіту при завершенні існуючої відповідальності. Це знову вимагає підпису обіцяючого.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  Підписане повідомлення містить індекс існуючого зобов'язання та код IPFS CID звіту, закодований у 32-байтовому представленні. Ще раз, [інструмент Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) може допомогти підписати звіт.\\n\\n</robo-wiki-note>\\n\\nПродовжуючи приклад з кавоваркою:\\n\\n1. Звіт - це JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Його IPFS CID - `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. Таким чином, **корисне навантаження** (трансформований CID) є `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2`\\n4. **Індекс** - `0`, це існуючий індекс зобов'язання.\\n\\n### 1. Перейдіть до extrinsics, liability -> finalize(report)\\n\\nЗаповніть параметри та надішліть зовнішній. Знову ж таки, це можна зробити за допомогою стороннього облікового запису.\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Зверніть увагу, що рахунок обіцяючого не повинен бути \\\"мертвим\\\" - він повинен мати існуючий депозит не менше 1 мXRT.\\n\\n</robo-wiki-note>\\n\\nПідпишіть та надішліть звіт. Після завершення ви можете дослідити його в подіях.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Досліджуйте звіти\\n\\nВи також можете спостерігати за звітом у сховищі. Перейдіть до `Developer -> Storage` та виберіть `liability` зі списку.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Перевірте баланси\\n\\nНа зображенні показано, що тепер обіцяючий отримав \\\"зарплату\\\". Економічні відносини стали можливими!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  Наразі немає способу перевірити, що робота виконана, тому як тільки обіцяючий повідомляє, токени перекладаються на його рахунок. \\n  Функцію перевірки планується додати у майбутньому.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"4c61f9214feab2ac009be2c912d74ead\",\"title\":\"Запуск\",\"path\":\"/docs/uk/launch/\",\"content\":\"\\n**Ще одна основна функція палети Robonomics - це палета запуску. Вона дозволяє відправляти команди на рахунки/будь-які сутності, що стоять за ними. Ці команди включають параметр, що вказує завдання, яке має бути виконане.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Зверніть увагу, що ці та наступні посібники демонструються на локальному екземплярі вузла Robonomics. Налаштуйте свій за допомогою [цієї інструкції](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Перейдіть до Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Виберіть launch -> launch зі списку можливих екстриксів\\n\\nТакож виберіть рахунок, з яким ви хочете відправити екстрикс. Заповніть поле цільової адреси та параметрів.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Launch підтримує рядки довжиною 32 байти як команди ([джерело](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)), \\n  тож тут є місце для імпровізації:\\n  - Для основних команд, таких як перемикання, ви можете використовувати \\\"0x0000000000000000000000000000000000000000000000000000000000000001\\\" або \\\"0x00000000000000000000000000000000000000000000000000000000000000000\\\".\\n  - - Для розширених команд, включаючи json-подібні, ви можете використовувати [IPFS](https://ipfs.tech/) CID у форматі\\n  [правильний спосіб](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Відправити транзакцію\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Перегляньте свій запуск у подіях\\n\\nДля цього перейдіть до *Network -> Explorer* і знайдіть список подій праворуч. Натисніть піктограму трикутника, щоб розгорнути.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"f89093959a576a9b7409427c7703d301\",\"title\":\"Як оновити версію вузла Robonomics Collator\",\"path\":\"/docs/uk/how-to-update-collator-node-version/\",\"content\":\"\\nРекомендується прочитати наступні статті перед читанням цього посту: [\\\"Як побудувати вузол Collator\\\"](/docs/how-to-build-collator-node) та [\\\"Як запустити Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nУ цій статті наведені команди, необхідні для оновлення вузла Robonomics Collator (працюючого на Ubuntu), а також наведено приклад після цього.\\n\\n## **Необхідні команди**\\n\\n0. Перш ніж почати, рекомендується увійти як `root`, якщо ні, то рекомендується використовувати:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Зупиніть службу Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Видаліть попередню версію Robonomics (переконайтеся, що ви знаходитесь у правильній директорії):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Отримайте [останню версію](https://github.com/airalab/robonomics/releases) Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Розпакуйте файл:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Перемістіть файл:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nВам потрібно перемістити цей файл у правильну директорію, в якій ви встановили вузол Robonomics)\\n\\n</robo-wiki-note>\\n\\n6. Запустіть Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nПриклад оновлення вузла Collator до Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Зміна бази даних ланцюжка ретрансляції Kusama без встановленого базового шлху**\\n\\nІноді певні знімки ланцюжка ретрансляції Kusama призводять до помилок вашого вузла. Це часто призводить до зупинки роботи вузла. Приклад помилки, спричиненої пошкодженою базою даних ланцюжка ретрансляції:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nЩоб виправити цю помилку, вам слід видалити існуючу базу даних ланцюжка ретрансляції Kusama (найімовірніше, RocksDb) та замінити її іншою базою даних, такою як ParityDb. Виконайте наступні команди:\\n\\n1. Знайдіть директорію вузла Robonomics та перевірте файли:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Підтвердіть, що ви бачите директорію polkadot, а потім перейдіть до директорії chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Видаліть каталог `ksmcc3`:\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Створіть нову директорію `ksmcc3`.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Тепер вам потрібно завантажити новий знімок. У цьому прикладі використовується сильно обрізаний знімок ланцюжка ретрансляції, але ви можете замінити його на будь-який зімок, який вам подобається.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Поки знімок завантажується, відкрийте нову сесію та відредагуйте свій файл служби:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nЗмініть рядки в файлі служби, які стосуються бази даних та обрізки:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nВикористовуйте `Ctrl + S`, а потім `Ctrl + X`, щоб зберегти та вийти з файлу служби.\\n\\n7. Тепер вам потрібно перезавантажити свій демон.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. До цього часу, у вашій іншій сесії, сподіваюся, що нова база даних завантажена, тому розпакуйте файл:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. Після завершення розпакування виконайте наступне:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Тепер ви можете запустити службу, слідкувати за помилками та перевірити, чи вона підключена як до ланцюжка ретрансляції, так і до паралельного ланцюжка:\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"7e185585d1b303b2f68e9dcd62a78d0d\",\"title\":\"Як запустити колатор Robonomics\",\"path\":\"/docs/uk/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  У відео та знімках екрану цієї статті ми використовували версію 1.4.0 Robonomics. Вам потрібно використовувати ті ж команди, але замінити весію Robonomics на поточну.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nНаразі мережу Robonomics в основному підтримують початкові розробники, але будь-хто може підтримати проект. Кожен додатковий повний вузол блокчейну допомагає йому стати більш стійким та відмовостійким. Бінарні файли вузлів Robonomics доступні в [релізі](https://github.com/airalab/robonomics/releases) або їх можна [побудувати з вихідних кодів](/docs/how-to-build-collator-node/).\\n\\n## Що таке колатор\\n\\nКолатор є частиною паралельної мережі Robonomics. Цей тип вузла створює нові блоки для ланцюжка Robonomics.\\n\\n>Колатори підтримують парачейни, збираючи транзакції парачейну від користувачів та створюючи докази переходу стану для перевіряючих ланцюжок ретрансляції. Іншими словами, колатори підтримують парачейни, агрегуючи транзакції парачейну в кандидати на блоки парачейну та створюючи докази переходу стану для перевіряючих на основі цих блоків.\\n\\nВи можете дізнатися більше про колатори на відповідній [сторінці вікі Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nУ парачейні Robonomics кожен збирач отримує винагороду в розмірі (**0,001598184 XRT**) за кожен створений збиральником блок (винагороди виникають, коли блоки запечатані в ланцюжку).\\nТакож колатор, який створює блок, отримує **50% комісійних з операцій**, що містяться у створеному блоку.\\n\\n## Вимоги\\n\\nРекомендується запускати колатор з використанням **стандартних апаратних вимог** для [валідаторів Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ Сумісний з x86-64.\\n+ Intel Ice Lake або новіший (Xeon або серія Core); AMD Zen3 або новіший (EPYC або Ryzen).\\n+ 4 фізичні ядра @ 3.4GHz.\\n+ Вимкнена одночасна багатопотоковість (Hyper-Threading на Intel, SMT на AMD).\\n+ Зберігання - NVMe SSD об'ємом 1 ТБ (так як воно повинно бути розумно розміром для роботи з ростом блокчейну).\\n+ Пам'ять - 32 ГБ DDR4 ECC\\n\\n\\nУ цій статті ми використовуємо наступні специфікації:\\n+ 4 vCPU\\n+ 700 ГБ простору NVMe для баз даних колатора. Необхідна можливість розширення цього дискового простору.\\n+ 8 ГБ ОЗУ\\n\\n\\n## Важлива інформація\\n1. Ми використовуємо деякі змінні в цих інструкціях, і вам потрібно замінити значення на власні в усіх командах:\\n    + **%NODE_NAME%** - це назва вузла. Наприклад: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** - це шлях до підключеного тома. Наприклад: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** - це адреса облікового запису в екосистемі Polkadot у форматі SS58. Наприклад: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Зверніть увагу, що ви повинні включити *--state-cache-size=0* при запуску служби колатора. Цей параметр важливий для стабільності колатора.\\nВи можете побачити більше інформації в відповідному [запиті](https://github.com/airalab/robonomics/issues/234) на github.\\n\\n## Легко вперше запустіть колатор Robonomics\\n\\nВи можете легко запустити колатор безпосередньо з командного рядка, щоб перевірити наявність помилок.\\nПісля цього настійно рекомендується запустити колатор Robonomics як службу (див. наступний крок).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Запустіть колатор Robonomics як службу\\n\\n1. Створіть користувача для служби з домашнім каталогом\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Завантажте, розпакуйте та перемістіть бінарний файл Robonomics до каталогу */usr/local/bin/*. Ви повинні замінити *$ROBONOMICS_VERSION* на поточну версію Robonomics у командах цього озділу. Поточну версію можна знайти на [сторінці релізів репозиторію Robonomics на github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Створіть файл служби systemd з назвою *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    І додайте наступні рядки у файл служби:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Збережіть цей файл, потім активуйте та запустіть службу:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nURL телеметрії: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nЖурнали Collators можна відстежувати за допомогою: `journalctl -u robonomics.service -f`\\n\\nПісля запуску сортувальника Robonomics він почне синхронізуватися з ланцюгом ретрансляції Kusama. Це може зайняти значний проміжок часу, залежно від швидкості вашої мережі та характеристик системи, тому ми рекомендуємо завантажити знімок Kusama.\\n\\n\\n## Прискорення процесу синхронізації за допомогою знімка Kusama\\n\\nМи рекомендуємо це зробити одразу після створення та запуску служби Robonomics. Більше інформації про знімки та інструкції з використання можна знайти на наступній сторінці: https://ksm-rocksdb.polkashots.io/\\n\\nІнструкції:\\n\\n1. Зупиніть службу Robonomics та видаліть поточний каталог бази даних Kusama:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Завантажте актуальний знімок та розпакуйте його:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    Ви можете видалити завантажений архів після успішного розпакування:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Встановлення правильної власності для папки бази даних:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Запустіть службу Robonomics знову:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Перевірте журнали служби:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Усунення неполадок\\n### Помилка: \\\"State Database error: Too many sibling blocks inserted\\\"\\nЩоб виправити цю помилку, ви можете просто запустити свій сортувальник у режимі архіву:\\n\\n1) Спочатку потрібно зупинити службу Robonomics: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Потім додайте параметр `--state-pruning=archive` до частини сервісного файлу парачейну. Приклад відредагованого сервісного файлу:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Перезавантажте конфігурацію менеджера systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Видалть існуючу базу даних парачейну:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Запустіть сервіс робономіки:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    Після цього потрібно зачекати синхронізацію бази даних парачейну.\\n\\n### Помилка: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nЦя помилка пов'язана з параметрами віртуалізації. Потрібно використовувати тип \\\"host-model\\\" емульованого процесора. Ви можете налаштувати це на хості віртуалізації.\\n\\nАле якщо ви зустрінете цю помилку на будь-якому хостингу, вам потрібно звернутися до служби підтримки з тільки цією проблемою.\\n\"}},{\"node\":{\"id\":\"1236b911932ecc305c546044eaebf5bf\",\"title\":\"Як побудувати вузол колатора з вихідного коду\",\"path\":\"/docs/uk/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  У відео та знімках екрану цієї статті ми використовували версію 1.4.0 Robonomics. Вам потрібно використовувати ті ж команди, але замінити весію Robonomics на поточну.\\n</robo-wiki-note>\\n\\n## Що таке колатор\\n\\nКолатор є частиною парачейну Robonomics. Цей тип вузлів створює нові блоки для ланцюжка..\\n\\n>Колатори підтримують парачейни, збираючи транзакції парачейну від користувачів та створюючи докази переходу стану для перевіряючих ланцюжок ретрансляції. Іншими словами, колатори підтримують парачейни, агрегуючи транзакції парачейну в кандидати на блоки парачейну та створюючи докази переходу стану для перевіряючих на основі цих блоків.\\n\\nВи можете дізнатися більше про колатор на відповідній [сторінці вікі Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nУ парачейні Robonomics кожен збирач отримує винагороду (**0,000380520 XRT**) за кожен створений ним блок, якщо цей блок був запечатаний у ланцюжку.\\nТакож Collator отримує **50% комісії за транзакції** з цього блоку.\\n\\n## Процес будівництва\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nПереконайтеся, що у вас встановлені Rust та необхідне програмне забезпечення. Інсталятор Rust запитає вас про поточні параметри встановлення, ви повині вибрати опцію `1) Продовжити із встановленням (за замовчуванням)`.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Встановити Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nВстановіть необхідний нічний інструментарій та ціль wasm.\\nНаступні команди актуальні для Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nВам також потрібно встановити наступні пакети:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nТепер ви можете встановити вузол robonomics з вихідного коду git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nПісля цієї команди скомпільований бінарний файл robonomics буде знаходитися в каталозі `~/.cargo/bin`.\\n\\nНаступним кроком є запуск вузла колатора. Ви можете прочитати про це в статті [\\\"Як запустити колатор Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"de8e47ea926c72390d5bd0d2216c4c0e\",\"title\":\"Оновіть вашу операційну систему Home Assistant\",\"path\":\"/docs/uk/hass-os-upgrade/\",\"content\":\"\\n**У цій статті містяться інструкції щодо оновлення вашої існуючої операційної системи Home Assistant з інтеграцією Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Встановити IPFS Add-on\\n\\n\\nІнтеграція Robonomics зберігає дані за допомогою локального демона IPFS, тому спочатку вам потрібно встановити його. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. Існує [додаток IPFS для Home Assistant](https://github.com/airalab/ipfs-addon). Щоб встановити його, перейдіть до `Settings` -> `Add-ons` та натисніть кнопку `ADD-ON STORE` в нижньому правому куті.\\n\\n2. Натисніть на три крапки в правому верхньому куті та виберіть `Repositories`. Додайте туди наступне посилання:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Натисніть кнопку `ADD`.\\n\\n4. Закрийте менеджер репозиторіїв і оновіть сторінку. Тепер в кінці сторінки ви можете побачити додаток IPFS Daemon.\\n\\n5. Відкрийте додаток і натисніть `INSTALL`. Після встановлення натисніть `START`.\\n\\n## Встановіть HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) дозволяє встановлювати користувацькі інтеграції.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Перед початком вам потрібно встановити додаток для підключення до пристрою Home Assistant за допомогою SSH. У магазині додатків шукайте `ssh`. Рекомендуємо встановити додаток `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Якщо додаток SSH не знайдено, спробуйте увімкнути розширений режим у налаштуваннях вашого користувацького профілю. Для цього натисніть на значок профілю в лівому нижньому куті та знайдіть опцію Розширений режим.\\n\\n</robo-wiki-note>\\n\\n2. Виберіть додаток і натисніть `INSTALL`. Після завершення встановлення перейдіть на вкладку `Конфігурація` та додайте `password` або `authorized_keys`. Не забудьте зберегти цю частину конфігурації.\\n\\n3. На вкладці `Info` натисніть `START`. Якщо ви хочете побачити додаток у бічній панелі, не забудьте увімкнути `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Відкрийте додаток SSH і виконайте наступну команду:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Перезапустіть Home Assistant (це можна зробити в `Settings`->`System`). \\n\\n6. Тепер інтеграція HACS буде доступна для додавання в меню `Integrations`. Перейдіть до `Settings`->`Devices & Services`, натисніть `Add Integration` та знайдіть HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Для використання HACS вам потрібен обліковий запис Github.\\n\\n</robo-wiki-note>\\n\\n7. Натисніть на нього та дотримуйтесь інструкцій щодо встановлення. \\n\\n## Встановіть інтеграцію Robonomics\\n\\nТепер ви можете встановити інтеграцію Robonomics за допомогою HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nВідкрийте HACS із меню бічної панелі та перейдіть до `Integrations`. Натисніть `Explore & Download Repositories`, потім знайдіть `Robonomics` і натисніть кнопку `Download`, розташовану в нижньому правому куті. Після завершення завантаження перезапустіть Home Assistant.\\n\\n\"}},{\"node\":{\"id\":\"b43a5e74100465e3dd1f14ad0ee6e85a\",\"title\":\"Ініціалізація Home Assistant\",\"path\":\"/docs/uk/hass-init/\",\"content\":\"\\n**Після встановлення Home Assistant, його потрібно ініціалізувати.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nВи починаєте з створення облікового запису власника Home Assistant. Цей обліковий запис є адміністратором і може вносити будь-які зміни. Відкрийте веб-браузер та перейдіть за адресою `http://%RASPBERRY_IP_ADDRESS%:8123`. Ви можете знайти IP-адресу Raspberry Pi за допомогою [мобільного додатку Fing](https://www.fing.com/products) або [інструменту командного рядка nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">Адреса Raspberry Pi може змінюватися з часом через налаштування маршрутизатора.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. На першій сторінці введіть ім'я, ім'я користувача, пароль та натисніть кнопку `CREATE ACCOUNT`.\\n\\n2. На наступному екрані введіть назву свого будинку, встановіть своє місцезнаходження та систему одиниць вимірювання. Натисніть `DETECT`, щоб знайти своє місцезнаходження та встановити свою часову зону та систему одиниць вимірювання на основі цього місцезнаходження. Якщо ви не хочете надсилати своє місцезнаходення, ви можете встановити ці значення вручну.\\n\\n3. Після цього Home Assistant покаже будь-які пристрої, які він виявив у вашій мережі. Не хвилюйтеся, якщо ви бачите менше елементів, ніж показано нижче; ви завжди можете додати пристрої вручну пізніше. Наразі просто натисніть `FINISH`, і ви потрапите на головний екран Home Assistant.\\n\\n4. Нарешті, ви побачите веб-інтерфейс Home Assistant, на якому будуть відображені всі ваші пристрої. \\n\\n\\n## Усунення неполадок\\n\\n1. Якщо ви забули свої дані для входу або пароль для локального користувача, [перевірте цю статтю](https://www.home-assistant.io/docs/locked_out/), щоб відновити свої облікові дані.\\n\"}},{\"node\":{\"id\":\"9792c41c4aa760694e78d1804b812ecb\",\"title\":\"Попередньо встановлене зображення для Raspberry Pi\",\"path\":\"/docs/uk/hass-image-install/\",\"content\":\"\\n**Ласкаво просимо до посібника з встановлення Home Assistant з інтеграцією Robonomics на Raspberry Pi. Home Assistant - це система автоматизації домашнього використання з відкритим кодом, яка надає централізовану платформу для керування розумними пристроями в домашній мережі. Інтегруючись з Robonomics, децентралізованою хмарною службою, ви можете покращити функціональність та безпеку вашого розумного будинку. У цій статті ми надамо пошагові інструкції щодо встановлення Home Assistant з Robonomics на Raspberry Pi, що дозволить вам автоматизувати та керувати різними аспектами вашого будинку за допомогою безпечного та децентралізованого рішення. Почнемо!** \\n\\n## Апаратне забезпечення, яке вам потрібно для встановлення\\n\\nЯкщо ви ще не включили Home Assistant до своєї системи розумного будинку, важливо знати про обладнання, яке вам знадобиться для створення повноцінної системи розумного будинку з нуля.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Завантажте почередньо встановлене зображення Robonomics\\n\\nПопередньо встановлене зображення Robonomics містить:\\n- Home Assistant Core\\n- IPFS\\n- MQTT брокер та інтеграцію\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nВи можете перевірити вихідний код та завантажити останню версію зображення на [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Налаштуйте зображення\\n\\nВстановіть [Raspberry Pi Imager](https://www.raspberrypi.com/software/) на свій комп'ютер. Потім вставте SD-карту. \\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nЗапустіть програму Raspberry Pi Imager. Виберіть потрібне зображення як операційну систему та переконайтеся, що ви вибрали SD-карту зі спадного меню пам’яті.\\nУ налаштуваннях:\\n- Встановіть ім'я користувача та пароль (збережіть типове ім'я користувача \\\"pi\\\", щоб його легко запам'ятати),  \\n- надайте назву та пароль Wi-Fi, \\n- виберіть свою країну зі списку випадаючих меню\\nа потім `Записати` зображення.  \\n                   \\n<robo-wiki-note type=\\\"note\\\">Уважно зберігайте ім'я користувача та пароль, оскільки ці облікові дані знадобляться у разі усунення неполадок</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nВи можете знайти коди країн [тут](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). \\n\\n## 3. Перший запуск\\n\\n**Безпечно витягніть SD-карту**, вставте її в Raspberry Pi. Потім вставте адаптер Zigbee в Raspberry Pi. \\n\\n<robo-wiki-note type=\\\"warning\\\">Важливо вставити адаптер Zigbee перед першим запуском Raspberry Pi! \\nЦе необхідно для автоматичної конфігурації мережі Zigbee. </robo-wiki-note>\\n\\n**Якщо у вас є [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (який має всю необхідну прошивку), ви можете просто продовжити за цими інструкціями. Однак, якщо у вас є інший адаптер, першим, що вам потрібно зробити, є його прошивка за допомогою програмного забезпечення Zigbee2MQTT. Інструкції для вашого пристрою можна знайти [тут](https://www.zigbee2mqtt.io/information/supported_adapters.html).** \\n\\nДалі підключіть кабель живлення до вашого пристрою. Він повинен підключитися до вашої Wi-Fi мережі.  \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nПісля підключення Raspberry Pi засвітиться червоний світлодіод, а зелений світлодіод блимає деякий час. Зачекайте до 5 хвилин, поки Raspberry Pi завантажиться та зареєструється в мережі. \\n\\nТепер знайдіть IP-адресу Raspberry Pi. Щоб знайти її, ви можете використовувати [мобільний додаток Fing](https://www.fing.com/products) або \\n[інструмент командного рядка nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Знайдіть `robots-home` (необов'язкове ім'я може бути `Home (homeassistant)`) \\nназва хост-машини в списку IP. \\n\\nУ цьому прикладі адреса - `192.168.43.56`.  \\n\\nЩоб перевірити, що все працює, відкрийте веб-переглядач та перейдіть на веб-сторінку `http://%RASPBERRY_IP_ADDRESS%:8123`. У цьому прикладі це буде `192.168.43.56:8123`. \\nЯкщо все гаразд, ви побачите веб-інтерфейс Home Assistant. Якщо веб-сторінка не відкривається, зачекайте до 5 хвилин, щоб Raspberry Pi завантажився і спробуйте знову.  \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Усунення неполадок\\n\\n1. Щоб змінити налаштування Wi-Fi пізніше, вам потрібно увійти до Raspberry Pi за допомогою команди `ssh`. Для цього відкрийте термінал на своєму комп'ютері\\nі введіть команду ssh з вашим ім'ям користувача, яке ви створили на кроці \\\"Налаштування зображення\\\" (типове - \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\nа потім використовуйте команду `sudo raspi-config`. Докладнішу інформацію про цю команду можна знайти на [офіційному сайті.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"eaaf07e71d5009e7a03e7c0e171d4a59\",\"title\":\"Оновіть свій Home Assistant Docker для операційної системи, подібної до Unix\",\"path\":\"/docs/uk/hass-docker-upgrade/\",\"content\":\"\\n**Ця стаття містить інструкції щодо оновлення вашого існуючого Home Assistant Docker (на операційній системі, подібній до Unix) з інтеграцією Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Передбачається, що використовуються типові образи та контейнер Docker для Home Assistant з назвою <u>homeassistant</u>.\\n  2. IPFS буде встановлено та запущено як службу <u>systemd</u> на хост-машині.\\n  3. Передбачається, що у вас встановлено [Python3.9](https://www.python.org/downloads/) або новішу версію.\\n\\n</robo-wiki-note>\\n\\n## Встановити\\n\\nЗавантажте скрипт встановлення та запустіть його в терміналі:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nВи побачите наступний вивід:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Можливо, ви побачите помилку типу `mkdir: can't create directory 'custom_components': File exists`. Це означає, що у вас вж є ця папка з деякими встановленими власними компонентами. Просто ігноруйте це повідомлення.\\n\\n</robo-wiki-note>\\n\\nПерезапустіть контейнер:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Перевірити\\n\\nПеревірте, що служба IPFS працює та запущена:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nВи побачите наступний вивід:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"4c5d5f095b48f90410bd4bb1fc687ee6\",\"title\":\"Оновіть свій основний додаток Home Assistant\",\"path\":\"/docs/uk/hass-core-upgrade/\",\"content\":\"\\n**У цій статті містяться інструкції щодо оновлення вашого існуючого основного додатку Home Assistant з інтеграцією Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Передбачається, що встановлення вашого основного додатку Home Assistant було завершено відповідно до [офіційних інструкцій](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) і є користувач <u>homeassistant</u> та середовище `venv`. Якщо це не так, дотримуйтесь наведених нижче інструкцій, **але відредагуйте скрипт відповідно**.\\n  2. IPFS буде встановлено та запущено як службу <u>systemd</u> на хост-машині.\\n  3. Передбачається, що у вас встановлено [Python3.9](https://www.python.org/downloads/) або новішу версію.\\n\\n</robo-wiki-note>\\n\\n## встановити\\n\\nЗавантажте скрипт встановлення та запустіть його в терміналі:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nВи побачите наступний вивід:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nПід час процесу вас буде запрошено підтвердити перезавантаження кількох служб. Виберіть опцію `yes`, натискаючи `tab`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Можливо, ви побачите помилку типу `mkdir: can't create directory 'custom_components': File exists`. Це означає, що у вас вж є ця папка з деякими встановленими власними компонентами. Просто ігноруйте це повідомлення.\\n\\n</robo-wiki-note>\\n  \\nПісля завершення перезавантажте свій основний додаток Home Assistant.\\n\\n## Підтвердити\\n\\nПеревірте, що служба IPFS працює та запущена:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nВи побачите наступний вивід:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"947e21eb5444036a22cd7b05a29a24f2\",\"title\":\"Glossary\",\"path\":\"/docs/uk/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\nсполучення публічного-приватного ключової пари, публічна частина якої є публічною адресою користувача, а приватна частина - секретним ключем для доступу до контролю цієї адреси.\\n\\n\\n### Auction (of Parachains)\\nмеханізм оренди слотів для парачейнів в екосистемах Polkadot та Kusama; парачейн повинен виграти аукціон, щоб отримати слот.\\n\\n### Autonomous Agent\\nобчислювальна система, яка отримує сенсорні дані з навколишнього середовища та вирішує, як реагувати на зовнішні подразники, щоб досягти своїх цілей.\\n\\n### AIRA\\nабо Автономний Інтелектуальний Робот-Агент - програмне забезпечення, розроблене командою Robonomics у 2015 році, яке реалізує стандарт економічної взаємодії людина-машини та машина-машина через інтелектуальний договір про відповідальність.\\n\\n\\n## B\\n\\n### Blockchain\\nу широкому сенсі, розподілена мережа, яка використовує криптографію для забезпечення можливості групі учасників безпечно досягти згоди щодо змінного стану системи.\\n\\n### Blockchain Досліджуватиr\\nдодаток, який дозволяє досліджувати різні блоки, транзакції та адрси на блокчейні (наприклад, Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\nготова автоматизована логіка, яку можна легко додати до екземпляра Home Assistant.\\n\\n### Bridge\\nтехнологія та методи, за допомогою яких дві економічно незалежні та технологічно різноманітні ланки можуть спілкуватися одна з одною. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nабо Cs — мільйонна частка одного токена XRT, 1 XRT = 1 000 000 Cs; названа на честь Рональда Коуза, британського економіста, одного із засновників інституційної економіки, лауреата Нобелівської премії з економіки.\\n\\n### Collator\\nвузол, який підтримує парачейн, збираючи транзакції парачейну та створюючи докази переходу стану для валідаторів.\\n\\n### Consensus\\nпроцес, у якому вузли мережі блокчейн досягають згоди щодо поточного стану даних у мережі (наприклад, Proof-of-Work, Proof-of-Stake).\\n\\n### Crowdloan\\nкраудфандингова кампанія зі збору токенів для участі в аукціоні слотів в екосистемі Polkadot / Kusama.\\n\\n### Cybernetics\\nвивчення управління та комунікації в тварині та машині, згідно з визначенням Н. Вінера.\\n\\n### Cyber-Physical System\\nабо CPS - сильне об'єднання та взаємне інтегрування кількох обчисювальних, мережевих та фізичних процесів.\\n\\n\\n## D\\n\\n### DAO\\nколективно власницька, блокчейн-управляєма організація, в якій управління ресурсами здійснюється відповідно до попередньо узгодженого та формалізованого набору правил, забезпечення яких здійснюється автоматично.\\n\\n### Даталог (Function)\\nфункція парачейну Robonomics, яка зберігає дані пристрою на блокчейні.\\n\\n### Dapp\\nабо децентралізована програма - програма, яка працює як частина розподіленої мережі та надає доступ до своїх функцій у зручний для користувача спосіб.\\n\\n### Decentralized Cloud\\nхмарний обчислювальний сервіс на основі децентралізованої пірингової мережі, до якої користувачі можуть приєднатися або для використання послуг, або для надання своїх ресурсів, таких як обчислення, мережа, сховище тощо.\\n\\n### Digital Twin\\nцифрова версія реального обладнання, яка копіює його технічні характеристики та історичні дані.\\n\\n\\n## E\\n\\n### Edge-system\\nпристрій Інтернету речей, який виступає як зв'язок між доступними локально вбудованими системами та глобальною мережею, зазвичай підтримуючи протоколи зв'язку та передавання телеметрії та сигналів керування.\\n\\n### Embedded System\\nпристрій Інтернету речей з обмеженими обчислювальними та комунікаційними ресурсами, який надає базові функції (датчики, приводи, кнопки) на найнижчому рівні, зазвичай без інтерфейсів користувача.\\n\\n### Ethereum\\nдецентралізована відкрита блокчейн-система, яка працює як платформа для численних інших криптовалют, а також для виконання децентралізованих смарт-контрактів.\\n\\n### Ethereum Upgrade\\nраніше відомий як Ethereum 2.0 або Eth2 - оновлення протоколу Ethereum, яке повинно зробити мережу більш масштабованою, бзпечною та стійкою; для цих цілей пропонується змінити консенсус на Proof-of-Stake та додати механізм шарування для збільшення мережевої потужності.\\n\\n### Exodus\\nпроцес переказу токенів XRT з мережі Ethereum на парачейн Robonomics.\\n\\n### Extrinsic\\nфункція на мережі Polkadot та Kusama, яка може спричинити переходи стану мережі ззовні стану.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nабо Gk - тисячна одиниця одного токена XRT, 1 XRT = 1 000 Gk; названий на честь Віктора Глушкова, радянського математика, одного з засновників інформаційних технологій та кібернетики в СРСР.\\n\\n\\n## H\\n\\n### Home Assistant\\nor Hass — an open source control system software, designed to be a central hub for smart devices. \\n\\n### HRMP\\nабо Horizontal Relay-routed Message Passing — захищене повідомлення, що передається між парачейнами, яке зберігає всі повідомлення в сховищі Relay Chain перед надсиланням до парачейнів.. \\n\\n### HMI\\nабо Інтерфейс Людина-Машина - інтерфейс користувача або панель приладів, яка з'єднує користувача з машинами, системами або пристроями.\\n\\n\\n## I\\n\\n### Industry 4.0\\nабо Четверта Промислова Революція - неперервна автоматизація традиційного виробництва та промислових практик за допомогою сучасних інтелектуальних технологій.\\n\\n### IPFS\\nабо Міжпланетна Файлова Система - пірингове програмне забезпечення для зберігання та обміну даними в розподіленій файловій системі.\\n\\n### IoT\\nабо Інтернет речей - підключення до глобальної мережі мільярдів пристроїв, здатних збирати дані та інтегруватися в середовище.\\n\\n### IoT Gateway\\nкрайова система, яка агрегує та передає дані від пристроїв Інтернету речей до мережі та навпаки; часто ці пристрої є більш сладною версією маршрутизатора WiFi.\\n\\n### IoT Provider\\nзовнішній сервіс, який надає користувачам Інтернету речей віддалений доступ до даних та аналітики, а також керування розумними пристроями через Інтернет.\\n\\n### IoT Subscription\\nфункція парачейну Robonomics, яка дозволяє використовувати всі функції парачейну протягом певного періоду без оплати.\\n\\n\\n## K\\n\\n### KSM\\nвнутрішній токен для мережі Kusama.\\n\\n### Kusama\\n\\\"канарська мережа\\\" для Polkadot, яка складається з ранньої версії програмного забезпечення Polkadot, яка не пройшла аудит.\\n\\n\\n## L\\n\\n### Запуск (Function)\\nфункція парачейну Robonomics, яка запускає або зупиняє пристрій, надсилаючи команду через блокчейн.\\n\\n### Lease Period\\nчас, протягом якого парачейн може підключатися до Реле-ланцюга.\\n\\n### Libp2p\\nбібліотека з відкритим кодом для створення зашифрованих пірингових мереж.\\n\\n### Lights-out Factory\\nабо розумна фабрика — фабрика, яка повністю автоматизована і не потребує присутності людини на місці.\\n\\n### Lighthouse\\nрозумний контракт, в концепції роботичної економіки, який виконує транзакціi, коли Постачальник встановлює ринкову відповідність між Обіцяючим і Отримувачем.\\n\\n### Відповідальність\\nрозумний контракт, створений кіберфізичними системами між собою або з людьми, для виконання завдання за оплату.\\n\\n### Liability Market\\nплатформа, в концепції роботичної економіки, відповідальна за відповідність пропозицій та попиту серед вузлів системи.\\n\\n\\n## M\\n\\n### MQTT\\nабо Протокол передачі телеметрії повідомлень — протокол публікації-підписки, розроблений для низькосмугових, високолатентних, ненадійних мереж для роботи з великими обсягами повідомлень пристроїв Інтернету речей.\\n\\n### MQTT Broker\\nсервіс, який отримує всі повідомлення від клієнтів MQTT, а потім маршрутизує їх до відповідних підписуючих клієнтів.\\n\\n\\n## N\\n\\n### NFT\\nабо Незамінний токен — токен, який не може бути замінений і не відрізняється від інших токенів, що дозволяють токенізацію унікальних предметів і надають виключну власність цим токенам.\\n\\n### Node (of Robonomics)\\nмодуль на основі Substrate або Ethereum з розширеннями Robonomics для підключення до мережі Robonomics.\\n\\n\\n## O\\n\\n### On-chain Governance\\nпроцес визначення допустимих змін в мережі, таких як зміни в коді або переміщення коштів, які існують у самій мережі і можуть безпосередньо змінювати її.\\n\\n\\n## P\\n\\n### Pallet\\nмодуль Substrate, написаний на Rust, який об’єднує певну логіку або алгоритм для виконання блокчейну на основі Substrate.\\n\\n### Parachain\\nспеціальна, специфічна для додатків структура даних (зазвичай, блокчейн), яка інтегрується з Relay Chain і може бути перевірена валідаторами.\\n\\n### Parathread\\nпарачейн без слоту, який тимчасово може брати участь (на блоковій основі з використанням плати) в безпеці Relay Chain.\\n\\n### Polkadot\\nгетерогенна, багатоланцюжкова мережа, що дозволяє різним блокчейнам з різними характеристиками виконувати довільну міжланцюжкову комунікацію за спільною безпекою.\\n\\n### Polkadot/Substrate Portal\\nбазовий Substrate UI для взаємодії з мережею Polkadot, Kusama та іншими мережами Substrate.\\n\\n### Proposal (on Polkadot / Kusama)\\nпотенційний виклик функції для голосування на референдумі Polkadot, Kusama або parachains.\\n\\n### Proof-of-Work\\nмеханізм консенсусу, в якому для досягнення згоди вимагається виконання обчислювальної роботи учасниками мережі.\\n\\n### Proof-of-Stake\\nмеханізм консенсусу, в якому для досягнення згоди вимагається ставка капіталу пов'язаної криптовалюти, яка виступає як застава.\\n\\n### Promisee\\nвузол, який розміщує замовлення на виконання завдання в концепції роботичної економіки.\\n\\n### Promisor\\nвузол, який погоджується виконати завдання за плату в концепції роботичної економіки.\\n\\n### Provider (Robonomics)\\nвузол у концепції роботизованої економіки, який відстежує повідомлення ринку зобов’язань і узгоджує пропозицію та попит за невелику плату.\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\nчастина управління мережею, голосування за те, чи повинні користувачі мережі прийняти пропозицію.\\n\\n### Relay Chain\\nосновний ланцюжок, який координує консенсус Polkadot / Kusama та комунікацію між парачейнами.\\n\\n### Robofirm\\nорганізація, в якій весь цикл бізнес-процесу повністю автоматизований і не потребує участі людини.\\n\\n### Rococo\\nтестова мережа для тестування парачейнів на Kusama\\n\\n### robonomics-interface\\nбібліотека Python, яка спеціалізується на взаємодії з Robonomics для зручного програмування.\\n\\n### Robonomics на Ethereum\\nверсія мережі Robonomics, яка працює на основі Ethereum, випущена в 2018 році.\\n\\n### Robot Economy\\nекономічна система, в якій пристрої діють як незалежні агенти, здатні виконувати ключові економічні дії, раніше властиві людям.\\n\\n### Robot-as-a-Service\\nабо RaaS — бізнес-модель, в якій компанії здають в оренду своє робототехнічне обладнання клієнтам на короткострокове або довгострокове використання.\\n\\n### ROS\\nабо Robot Operating System — фреймворк для розробки програмного забезпечення роботів, який надає послуги, розроблені для гетерогенного комп'ютерного кластера, такі як абстракція апаратного забезпечення, керування пристроями нижнього рівня, реалізація загальновживаних функцій, передача повідомлень між процесами та управління пакетами.\\n\\n### ROS 2\\nоновлена і перебудована версія Robot Operating System з новими функціями, такими як підтримка багатороботних та вбудованих систем, і інтеграція з реальним часом.\\n\\n### ROS 2 Middleware\\nабо RMW — протокол, який надає стандартні функції ROS 2, такі як виявлення, серіалізація та транспортування; ROS 2 підтримує кілька реалізацій проміжного програмного забезпечення, які можна вибрати відповідно до вимог проекту.\\n\\n### RWS\\nабо Robonomics Web Services — децентралізовані інфраструктурні сервіси для робототехніки та Інтернету речей, які дозволяють легко підключати пристрої та взаємодіяти з користувацькими додатками, хмарними сервісами та іншими пристроями в безпеці; в нього є власний токен, також називається RWS, який надає пожиттєву підписку на Інтернет речей в парачейні Robonomics.\\n\\n### Запуститиtime\\nфункція переходу до стану блокчейну, яка визначає дійсний алгоритм для визначення стану наступного блоку на основі попереднього стану.\\n\\n\\n## S\\n\\n### Seed Phrase\\nлюдиночитний приватний ключ, створений як послідовність випадкових слів і необхідний для доступу до адреси блокчейну та його токенів.\\n\\n### Shared Security\\nмодель безпеки Polkadot / Kusama, при якій всі ланцюжки рівномірно захищені шляхом розміщення доказів про валідність блоків парачейну в Relay Chain таким чином, що потенційному атакувальнику потрібно атакувати весь систему.\\n\\n### SLS Gateway\\nвідкритий IoT-шлюз для пристроїв Zigbee на основі мікроконтролера ESP32, розроблений Smart Logic System.\\n\\n### Slot (of Parachain)\\nрідкісний ресурс в екосистемі Polkadot / Kusama, який дозволяє підключати парачейн до Relay Chain без плати за кожен блок.\\n\\n### Smart Leasing\\nваріант моделі Robot-as-a-Service, в якому оренда оплачується не за час, а за конкретні операції та їх кількість.\\n\\n### Smart Contract\\nпрограма або алгоритм, збережений на блокчейні, який автоматично запускається, коли виконуються попередньо визначені умови.\\n\\n### SSH\\nабо Secure Shell — мережевий протокол для безпечної роботи мережевих служб у незахищеній мережі, який використовує криптографію з відкритим ключем для автентифікації віддаленого комп’ютера.\\n\\n### Staking\\nчастина консенсусу Proof-of-Stake, акт забезпечення токенів шляхом їх застави як застави для можливості виробити дійсний блок та отримати винагороду.\\n\\n### Substrate\\nмодульний фреймворк для побудови блокчейнів, таких як Polkadot і Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nфонд коштів, зібраних за рахунок частини винагород за виробництво блоків, комісій за транзакції, стейкінгу і т. д., які можуть бути витрачені шляхом подання пропозиції про витрати; якщо Казначейство закінчує період витрат, не витративши всі свої кошти, воно зазнає спалювання певного відсотка коштів.\\n\\n### Transaction Costs\\nвартість збору та обробки інформації через обмежену раціональність економічних агентів та складність процесів.\\n\\n\\n## V\\n\\n### Validator\\nвузол, який забезпечує безпеку Relay Chain, ставлячи свої токени, перевіряючи докази від коллаторів на паралельних ланцюгах та голосуючи за консенсус разом з іншими валідаторами.\\n\\n\\n## W\\n\\n### Web3\\nідея нової ітерації Вебу, яка включає такі концепції, як децентралізація, технології блокчейну та економіка на основі токенів.\\n\\n### Wiener (XRT)\\nабо Wn — мільярдна частка одного токена XRT, 1 XRT = 1 000 000 000 Wn; названий на честь Норберта Вінера, американського математика, одного засновників кібернетики та теорії штучного інтелекту.\\n\\n\\n## X\\n\\n### XCM\\nабо Cross-Consensus Message Format — формат обміну повідомленнями між різними блокчейн-системами в Polkadot / Kusama.\\n\\n\\n### XRT\\nвласний токен для мережі Robonomics, який існує незалежно на мережах Ethereum та Kusama.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nреалізація накладної мережі повністю зашифрованої схеми маршрутизації для мереж меш.\\n\\n\\n## Z\\n\\n### Zigbee\\nбездротовий протокол зв'язку, дуже поширений для підключення розумних пристроїв через низьке споживання енергії, легкість налаштування та гнучкість конфігурації, а також підтримку самоорганізації та самовідновлення топології мережі.\\n\\n### Zigbee Adapter\\nпристрій, який передає дані між мережею Zigbee та іншою мережею (наприклад, Wi-Fi) для керування пристроями Zigbee.\\n\\n### Zigbee2MQTT\\nпрограмне забезпечення, яке дозволяє підключати Zigbee до мереж MQTT шляхом перекладу повідомлень з однієї мережі в іншу.\"}},{\"node\":{\"id\":\"e06b06d0fc768d010e8e2db51abaab7a\",\"title\":\"Глобальне управління\",\"path\":\"/docs/uk/global-administration/\",\"content\":\"\\n**У цій статті ви дізнаєтеся, як налаштувати нового користувача для вашого Home Assistant.**\\n\\n## Додавання користувачів до підписки\\n\\nВи не можете використовувати раніше створені облікові записи, оскільки `SUB_OWNER` та `SUB_CONTROLLER` забезпечують безпеку, а перший користувач, якого ви створили, коли ви вперше запустили Home Assistant, не має облікового запису Robonomics Parachain.\\n\\n1. Створіть обліковий запис на Robonomics parachain, як ви це зробили в [попередній статті](/docs/sub-activate/).\\n\\n2. Використовуючи обліковий запис `SUB_OWNER`, додайте новий обліковий запис користувача до підписки в [dapp](https://dapp.robonomics.network/#/subscription/devices). Тепер у списку доступу повинно бути три адреси: `SUB_OWNER`, `SUB_CONTROLLER` та `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Надання доступу користувачу\\n\\n1. Перейдіть до служби dapp під назвою [Обліковий запис Home Assistant](https://dapp.robonomics.network/#/home-assistant). Виберіть обліковий запис, який ви щойно створили, у правій бічній панелі (перевірте, що ви вибрали потрібний обліковий запис, натиснувши значок профілю).\\n\\n2. Введіть `USER` seed у відповідне поле. Додайте адреси `SUB_OWNER` та `SUB_CONTROLLER` у поля кредитів адміністратора. Якщо все вірно, ви побачите статус перевірки `ПЕРЕВІРЕНО`.\\n\\n3. Створіть пароль для нового користувача, якого ви щойно зареєстрували, а потім підтвердіть транзакцію, яка тепер буде безкоштовною через підписку. Пізніше ви зможете відновити пароль у вкладці Відновлення.\\n\\n4. Після процесу реєстрації увійдіть до Home Assistant за допомогою вашої адреси користувача як логіну та новоствореного пароля.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nТепер ви можете використовувати dapp для керування вашим будинком через Robonomics, перегляньте статтю [**\\\"Отримання телеметрії розумного будинку\\\"**](/docs/smart-home-telemetry/).\\n\\n## Усунення неполадок\\n\\n1. Якщо ви забули пароль до домашнього помічника зі свого облікового запису Robonomics, [перевірте Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nПерейдіть до частини \\\"Your Home Assistant password\\\" та виберіть вкладку \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"a793e847d57c6e5924d9e6d9e1f49bf4\",\"title\":\"Початок роботи\",\"path\":\"/docs/uk/getting-started/\",\"content\":\"\\n## Що таке Робономіка\\n\\nПлатформа Робономіка надає інструменти для роботи з мережею роботичної економіки. Робономіка дозволяє розробникам розумних міст і зон промиловості 4.0 будувати довіру серед [автономних роботів та сервісів](/docs/glossary#cyber-physical-system), надавати [прямий доступ користувача через додаток](/docs/glossary#dapp) для замовлення продуктів з автономних фабрик та сервісів міських сенсорних мереж. Це, в свою чергу, дозволить нам створити децентралізовану систему, яка глобально контролює діяльність кіберфізичних систем.\\n\\nУ наступній діаграмі описано місце, яке займає Робономіка в сценарії:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nДізнайтеся більше в [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Швидкий старт мережі Робономіка\\n**Для зручності новачків розробники ядра Робономіка придумали [6-ти уроків навчальну криву](/docs/wschool2021-intro/)!**\\n\\nВи досліджуватимете безсерверну архітектуру Інтернету речей! Робономіка Веб-сервіси (RWS) є базовим інфраструктурним сервісом для робототехніки та Інтернету речей на основі Polkadot && IPFS.\\n\\nВипускники курсу можуть запустити локальний реле-ланцюжок та керувати пристроєм, сумісним з ROS, за допомогою транзакцій між ланцюжками.\\n\\n**[Приєднуйтесь до Discord розробників Робономіка](https://discord.gg/jTxqGeF5Qy), щоб зв'язатися зі спільнотою та отримати технічну підтримку.**\\n\\n### Переваги для випускників Робономіка Academy\\n- Стажування для найкращих студентів   Станьте членом команди Робономіка та внесіть свій внесок у розвиток обраного продукту.\\n- Активна спільнота та регулярні заходи   Станьте частиною спільноти учнів, обговорюйте свої випадки використання з експертами галузі. Об'єднуйтесь та беріть участь у хакатонах!\\n- Сертифікат про завершення   Додайте сертифікат про завершення курсу з розробки DAPPs для Інтернету речей до свого портфоліо.\\n- Допомога при вступі до університету ITMO. Незалежно від того, чи ви бакалавр, чи магістр, ви отримаєте допомогу при вступі до університету.\\n- Можливості фінансування та прискорення: 1)Подайте заявку на отримання гранту Academia - підтримки до $50.000; 2)Візьміть участь у програмі прискорення будівельників Робономіка, підтриманій Web3 Foundation; 3)Розгорніть свій самостійний DAPP на основі Робономіка; 4)Монетизуйте його та отримайте маркетингову підтримку від команди Робономіка.\\n\\n\\n## Що містить документація\\n\\n### Я розробник Dapp\\n\\n- [Robonomics-js на GitHub](https://github.com/airalab/robonomics-js) - простий Javascript SDK для розробників додатків Робономіка Network.\\n- [Шаблон dApp](https://github.com/airalab/vue-dapp-robonomics-template) - використовує Vue.js\\n- [Документація Wiki](/docs/robonomics-js/)\\n\\n### Я робототехнік\\n\\nПерегляньте розділ [cases](/docs/iot-sensors-connectivity/) та почніть розробляти за [прикладами](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"d6e5bb089afb4244337cab24aaf76bb0\",\"title\":\"Як придбати підписку\",\"path\":\"/docs/uk/get-subscription/\",\"content\":\"\\n**Сплачувати комісії за транзакції в блокчейні - неприємно. Уявіть пристрій Інтернету речей, який надсилає телеметрію кожні 5-10 хвилин. Це змусить вас платити осить багато протягом місяця. Одна з ключових функцій мережі Robonomics - це підписка на веб-сервіс Robonomics (RWS). Платіть щомісяця і забудьте про витрати на транзакції! Для теоретичного опису дивіться статтю [тут](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855).**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Зверніть увагу, що цей посібник демонструє придбання підписки на параплан Robonomics Kusama. Ви також можете виконати всі ті ж самі кроки на своєму [локальному вузлі](/docs/run-dev-node).\\n\\n  Ще одна річ перед початком. Це \\\"складний\\\" спосіб придбання підписки. Існує звичайний спосіб зробити це через [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Зробіть ставку на аукціон\\n\\nПідписки в Robonomics продаються за моделлю аукціону. Щоб отримати одну, вам потрібно зробити ставку на аукціон і виграти його (не хвилюйтеся, це швидко).\\n\\nУ розділі `Developer/Chain state` ви можете побачити доступні аукціони. \\nВиберіть `rws` та `auctionQueue` і натисніть кнопку `+`, ви побачите ідентифікатори доступних аукціонів:\\n\\n![queue](../images/rws/queue.png)\\n\\nВи можете побачити інформацію про будь-яку підписку за допомогою `rws` `auction` та ідентифікатора аукціону (ідентифікатор аукціону на зображенні - 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nУ інформації про аукціон ви можете побачити поле `winner`, наразі воно має значення `null`, тому ніхто не має цієї підписки, і ви можете її отримати. Для цього перейдіть до розділу `Developer/Extrinsic`, виберіть свій обліковий запис та `rws -> bid`. Також встановіть ідентифікатор аукціону (79) та кількість одиниць для ставки (більше 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nНадішліть транзакцію та перевірте інформацію про аукціон з ідентифікатором 79 (у розділі `Chain state`  виберіть `rws -> auction` та ідентифікатор 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nТепер у полі `winner` ви побачите адресу вашого облікового запису, це означає, що цей обліковий запис має підписку 79. Аукціон починається з першої ставки і триває кілька блоків, тому якщо хтось зробить більше токенів, ніж ви, в наступні кілька блоків, цей хтось стане переможцем і отримає підписку.\\n\\nТепер ви можете додавати пристрої. Пристрої - це облікові записи, які можуть використовувати цю підписку та надсилати екстрики без комісії.\\nЩоб перевірити це, створіть новий обліковий запис без маркерів і додайте його до пристроїв.\\n\\nЩоб додати пристрої, виберіть `rws -> setDevices` в розділі `Developer/Extrinsic`. Потім натисніть кнопку `Додати елемент` та виберіть недавно створений обліковий запис без токенів:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nНадішліть транзакцію. Тепер ви можете перевірити список пристроїв у розділі `Chain state` за допомогою `rws -> devices`. Там ви побачите адресу вашого облікового запису без токенів. Виберіть обліковий запис, який придбав підписку, та натисніть `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nТепер ви можете спробувати [надіслати запуск](/docs/subscription-launch) екстрику за допомогою підписки.\"}},{\"node\":{\"id\":\"38badab8432945ba5c7357a828226cfb\",\"title\":\"Встановлення та встановлення програмного забезпечення Gaka-Chu\",\"path\":\"/docs/uk/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**У цій статті ми розглянемо кілька кроків встановлення та запуску для налаштування робота-художника. Вимоги:**\\n- KUKA KR6 R900 sixx з KRC4 та SmartPad;\\n- Intel NUC з встановленою [ROS melodic](http://wiki.ros.org/melodic/Встановитиation/Ubuntu);\\n- Стіл, фарба, пензель, вода.\\n\\n## Встановлення програмного забезпечення на KRC4\\nДля цього потрібний інтерфейс EKI як на KRC4, так і на NUC. Детальна інформація про те, як його налаштувати на KRC4, наведена [тут](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Запустіть його на контролері робота.\\n\\n## Встановлення програмного забезпечення на NUC\\nСтворіть робочий простір catkin:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nЗавантажте пакети ROS. Усі скрипти зберігаються [тут](https://github.com/airalab/robot_painter/tree/test_branch). Клонуйте репозиторій:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nМожливо, вам знадобляться деякі заголовкові файли та бібліотеки, щоб все працювало правильно. Завантажте їх:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nДодайте команду джерела до файлу `.bashrc`:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nНаразі ви повинні мати могу запускати скрипти. Якщо щось піде не так, спробуйте вирішити деякі [проблеми](https://github.com/airalab/robot_painter/issues)\\n\\n## Заповнення констант\\nПо-перше, роботу потрібно знати місцезнаходження та орієнтацію полотна, а також позицію бляшанки з фарбою. Все це вказано в `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Давайте подивимося на це.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nЦе константи рівняння площини, які вказують положення полотна в 3D-просторі. Вони мають бути отримані під час процесу калібрування, описаного нижче. Далі йде фарба.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nЦе координати бляшанки з фарбою. Вони також можуть бути вказані під час калібрування. Розмір полотна вказується в\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nКілька важливих констант зберігаються в `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nЇх назви говорять самі за себе, тому заповніть їх відповідно до ситуації.\\n\\n## Калібрування Gaka-Chu\\nСам процес калібрування досить простий.\\n\\n1) Запустіть інтерфейс EKI на KRC4:\\n\\nУвійдіть в режим 'AUT', увімкніть драйвери та запустіть скрипт `eki_hw_interface`\\n\\n2) Запустіть інтерфейс EKI на NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nВін повинен виводити безкінечні журнали.\\n\\n3) Запустіть RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nВи повинні побачити наступне:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nСпробуйте перемістити кінцевий ефектор та натиснути 'Plan and Execute'. Робот повинен рухатися. На SmartPad перейдіть до **Display -> Actual position** та спостерігайте координати кінцевого ефектора. Покладіть полотно горизонтально до основи робота. Увімкніть пензель у тримач пензля та обережно перемістіть його, поки він ледь торкається полотна. У цьому положенні збережіть координати кінцевого ефектора. Повторіть це 12-15 разів. Також збережіть координати центру полотна та бляшанки з фрбою.\\nКоли у вас є набір координат, використовуйте [ці](https://github.com/nakata5321/Matlab_scripts_gaka-chu) скрипти Matlab, щоб вирішити відсутні константи та кватерніон. Вставте їх. Перебудуйте свій робочий простір з\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Тестування калібрування Gaka-Chu\\nПісля калібрування Gaka-Chu потрібно протестувати, намалювавши межі полотна. Щоб це зробити, виконайте кожен з них в новому терміналі:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nПісля цього ви повинні побачити контур полотна в RViz:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nУ терміналі натисніть \\\"S\\\", щоб виконати тестування. Кінцевий ефектор робота повинен рухатися праворуч над межами полотна, а пензель повинен м'яко торкатися полотна протягом усього руху. Якщо цього не відбувається, спробуйте повторно калібрувати. Якщо модель полотна обертається неправильно, ви можете обернути її, змінивши кватрніон в Matlab.\\n\\n## Створення мистецтва\\nДля того, щоб все працювало, вам потрібно 6 основних модулів:\\n- Інтерфейс EKI;\\n- MOVEit + RViz;\\n- Трансляція середовища кадрів;\\n- Сервіс конвертації зображень;\\n- Модуль малювання траєкторій;\\n- Початковий тригер.\\n\\nДавайте запустимо їх по одному.\\n\\n### Інтерфейс Eki\\nНа KRC4 запустіть `eki_hw_interface`, на NUC у новому терміналі виконайте:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz та MOVEit\\nВам потрібен планувальник та симуляція. Запустіть їх з\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Середовище\\nСкажіть роботу, де знаходяться бляшанка з фарбою та полотно. Зверніть увагу, що не обов'язково запускати вузол `draw workspace`, `tf_broadcaster` ділиться розміром полотна. Він просто не показує його в RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Обробник зображень\\nВсі вхідні зображення потрібно обробляти. Запустіть сервіс.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nКоли він отримує виклик, він обробляє зображення з фільтром HP і створює файл rosbag з траєкторіями.\\n\\n### Траєкторії малюнка\\nОсновний скрипт тут - сам малюнок траєкторій. Він чекає на зобаження, викликає сервіс TextConverter та малює картину.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Надішліть роботу зображення для малювання\\nРобот слухає конкретну ROS-тему, де вам потрібно передати шлях до бажаного зображення. Зображення повинно бути квадратним (ширина дорівнює висоті) і складатися з ліній. Надішліть шлях:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nПісля цього з'являються два вікна, на яких показані контури та треки. Закрийте їх і подивіться, як Гака-Чу малює. Будьте обережні і завжди будьте готові натиснути кнопку аварійної зупинки.\\nКоли Гака-Чу закінчує своє мистецтво, ви можете надіслати інший шлях до зображення, і художник повторює весь процес.\\n\"}},{\"node\":{\"id\":\"5833e29763f4afa038f1bef7df00b5d2\",\"title\":\"Підключення пристрою Amazon FreeRTOS до Robonomics через MQTT\",\"path\":\"/docs/uk/freertos-mqtt/\",\"content\":\"\\nОсь демонстрація того, як мікроконтролер, що працює на [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/), може бути підключений до мережі Robonomics через MQTT. Будь ласка, перевірте [цей репозиторій](http://github.com/khssnv/freertos_mqtt_robonomics_example) для отримання вихідного коду проекту.\\n\\nМи використовуємо [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) з дистрибутивом FreeRTOS та реалізацією MQTT, наданою [Espressif IoT Development Framework](https://github.com/espressif/esp-idf), який є виробником використовуваного мікроконтролера.\\n\\nТакож є датчик [PMS-3003](http://www.plantower.com/en/content/?107.html)  для демонстраційних цілей. Датчик вимірює наявність частинок у повітрі, і його можна використовувати для оцінки якості повітря.\\n\\nЯкість повітря не є темою статті, ви можете дізнатися більше про це на веб-сайті ВООЗ: [Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). Метою системи є публікація вимірювань датчика в мережі Robonomics Airalab.\\n\\n## Налаштування апаратного забезпечення\\n\\nМи підключаємо PMS3003 TXD PIN5 до ESP32 DevKitC IO17 для передачі вимірювань за допомогою UART.\\nТакож обидва пристрої потребують живлення та спільного заземлення.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Потік даних\\n\\nДля передачі вимірювань датчика в мережу Robonomics на рівні прошивки нашою метою є отримання даних з датчика за допомогою вбудованого комунікаційного протоколу, який він підтримує (UART у нашому випадку) і передача його до екземпляра AIRA за допомогою MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nУ нашому прикладі ми використовуємо хмарне розгортання AIRA, доступне за публічною IP-адресою та призначеною доменною назвою.\\nНа екземплярі AIRA ми налаштовуємо брокер MQTT `mosquitto` та підписуємося на тему `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`, щоб отримувати повідомлення з MQTT.\\n\\nПотім ми передаємо повідомлення до письменника `robonomics io` через канал.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nТепер дані доступні в мережі Robonomics, і ми можемо знову прочитати їх за допомогою `robonomics io`.\\n\\n## Прошивка\\n\\nМи використовуємо зразок застосунку [ESP-MQTT sample application with TCP transport](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) як основу.\\n\\nМи лише змінюємо `main/app_main.c` для підключення до датчика через UART, синхронізації часу SNTP та періодичного видавця MQTT.\\n\\nЯкщо ви намагаєтеся повторити проект і це ваш перший проект на основі ESP IDF, спочатку ознайомтеся з посібником з програмування [Espressif's ESP-IDF](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step), щоб ознайомитися з операціями прошивки, такими як налаштування, збірка та завантаження за допомогою інструменту `idf.py`.\\n\\n### Налаштування Wi-Fi\\n\\nДля зв'язку з екземпляром AIRA, розгорнутим у хмарі, нашому мікроконтролеру потрібне підключення до Інтернету.\\nМи використовуємо Wi-Fi ESP32 для цього.\\nEspressif надає утиліти для налаштування вбудованого Wi-Fi.\\nУ нашому прикладі ми використовуємо середовище розробки з Ubuntu 20.04 GNU / Linux.\\nЩоб налаштувати Wi-Fi, ми переходимо до папки прокту та запускаємо інструмент налаштування SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nПотім ми встановлюємо SSID точки доступу Wi-Fi та пароль в розділі `Example Підключитисяion Конфігурація`.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### Налаштування кінцевої точки MQTT\\n\\nЄ дві речі, які потрібно налаштувати для MQTT.\\nПерше - це адреса брокера MQTT.\\nЦе налаштовується за допомогою інструменту налаштування SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nВстановіть `URL брокера` в розділі `Example Налаштування`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nДруга річ - це тема MQTT.\\nМи встановлюємо її в прошивці з префіксом назви проекту, за яким слідує MAC-адреса нашого ESP32.\\nЦе дає нам `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` для нашого конкретного мікросхеми.\\n\\n## Від MQTT до Robonomics\\n\\nСпочатку перевіримо, чи отримуємо дані за допомогою MQTT.\\nМи можемо підписатися на тему брокера MQTT Mosquitto, на яку пристрій публікує.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nТут ми додаємо пакет `mosquitto` до нашого середовища, щоб використовувати утиліту `mosquitto_sub`.\\nПотім ми підписуємося на тему, встановлену в прошивці.\\nМи отримали наші вимірювання, що значає, що AIRA правильно отримує дані через MQTT.\\nТепер давайте направимо ці повідомлення до мережі Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nТут ми використовуємо утиліту `robonomics` для публікації повідомлень у каналі pubsub `/freertos_mqtt_robonomics_example`.\\nМи вказуємо `bootnodes`, щоб забезпечити, що буде встановлено принаймні одне з'єднання.\\n\\nТепер ми читаємо ці повідомлення з того ж каналу pubsub.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Використані початкові ресурси\\n\\n* ESP32 DevKitC pinout з блогу GoJimmy https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* Структура даних та декодер PSM3003 з проекту OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Дякуємо всім!**\\n\"}},{\"node\":{\"id\":\"459389531f2077d20be8558502620383\",\"title\":\"Як редагувати Wiki\",\"path\":\"/docs/uk/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki є відкритим джерелом. Ласка, вносьте корективи: виправлення помилок, орфографічних помилок, деякої незрозумілої або застарілої інформації, переклад на будь-яку мову. Вам понадобиться [GitHub](https://github.com/) акаунт.**\\n\\n\\n## Як редагувати\\n\\nЯкщо вам потрібно редагувати документи Robonomics Wiki, будь ласка, дотримуйтесь цих кроків\\n\\nПереконайтеся, що у вас є [Node.js](https://nodejs.org/en/download/package-manager/) та [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) встановлені.\\n\\n### 1. Клонуйте репозиторій\\n\\nСпочатку вам потрібно склонувати репозиторій вікі:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nПерейдіть до каталогу репозиторію та виконайте наступні команди:\\n\\n`за допомогою npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`за допомогою yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Локальне обслуговування (develop, develop-m1)\\n\\nПотім розгорніть проект локально: \\n\\n```\\ngridsome develop\\n```\\n\\n> Якщо ви отримали помилку `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`, виконайте наступну команду:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Створити PR\\n\\n[Створити запит на злиття](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) до [репозиторію вікі](https://github.com/airalab/robonomics-wiki)\\n\\n## Компоненти\\n\\n### Asciinema\\nRobonomics Wiki підтримує Asciinema. Щоб вставити Asciinema, будь ласка, дотримуйтесь цих інструкцій:\\n* Імпортуйте компонент після блоку frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* Вставте як окремий абзац `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, де vid - це ID конкретного asciicast\\n\\n> Ви можете отримати скрипт віджета для певного asciicast, натиснувши на посилання «Embed» на сторінці asciicast.\\n> Він виглядає так:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Документація Asciinema](https://asciinema.org/docs/embedding)\\n\\nУ вищезазначеному прикладі vid дорівнює 14.\\n\\n### Код\\n\\nYou can add helpful extras to your code: \\n\\n`код з кнопкою копіювання`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nабо `код із додатковим рядком`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Властивості для code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nДокументи в Robonomics Wiki містять блок frontmatter. Він повинен бути у верхній частині файлу Markdown і повинен мати форму дійсного YAML, розташованого між потрійними рисками. Між потрійними рисками ви можете встановити або редагувати наступні параметри:\\n\\n```YAML\\n---\\ntitle: How to contribute # Заголовок сторінки, вам не потрібно дублювати його в тексті\\ncontributors: [positivecrash] # Основні учасники (хто активно курує цю сторінку). Потрібен нікнейм GitHub, без будь-яких додаткових символів\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Встановитиation\\n    # Інструменти, які використовувалися для тестування технології\\n---\\n```\\n\\n### Grid \\nДопомагає додати сіткову компоновку до елементів:\\n\\n- Спочатку використовуйте компонент обгортки сітки: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- А потім використовуйте стільки компонентів елементів сітки, скільки вам потрібно всередині обгортки:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Шлюз</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Властивості для robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Зображення\\n\\n#### Як завантажити \\nЗавантажте зображення в папку `/docs/images/url-of-your-doc`\\n* Якщо зображення потрібно локалізувати, вставте їх всі в одну папку\\n* Використовуйте додаток локалізації в назві зображень, якщо воно локалізоване, наприклад, `image_en.jpg`\\n* Переконайтеся, що ваше зображення оптимізоване для вебу і водночас виглядає добре\\n\\n#### Як вставити \\n\\nЄ два способи вставити зображення в ваші документи:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nРекомендується вставляти зображення з вбудованим тегом `<robo-wiki-picture>`, але ви також можете використовувати стандартний спосіб для файлів Markdown.\\n\\n</robo-wiki-note>\\n\\n`з підписом`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`або без підпису` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`або просте зображення` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`або просте зображення з підписом`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`зображення з альтернативним текстом`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Властивості для robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Примітки та попередження\\nВи можете додавати примітки та надавати їм певні типи:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`примітка з заголовком`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`примітка з вмістом`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`примітка з заголовком та вмістом`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Властивості для robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nВи можете додавати вкладки до документа:\\n\\n- Використовуйте компонент обгортки вкладок: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- А потім використовуйте стільки компонентів елементів вкладок, скільки вам потрібно всередині обгортки:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`горизонтальні вкладки`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`вертикальні вкладки`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`елемент вкладки з межею`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Властивості для robo-wiki-tabs (обгортка)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Властивості для robo-wiki-tab (елемент)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Заголовок з якорями\\nВи можете створювати власні заголовки з якорями та надавати їм певне значення\\n\\n`заголовок з якорем`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nабо\\n\\n`заголовок без прив'язки`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Властивості для robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Відео\\n\\nЄ два способи вставити відео в ваші документи:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nРекомендується вставляти відео з вбудованим тегом `<robo-wiki-video>`, але ви також можете використовувати стандартний спосіб для файлів Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nВам потрібно вказати формат відео\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Властивості\\n\\n- Якщо ви додаєте файл розміром більше <span style=\\\"color:#af1c1c\\\">10MB</span>, будь ласка, завантажте його на сервер, а не в репо.\\n\\n- Ви можете використовувати будь-які властивості для [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Припустимі формати - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nВи можете вставити будь-яке відео з YouTube в документ, вставивши посилання на спільний доступ як окремий абзац без будь-яких додаткових лапок або тегів, наприклад: `https://youtu.be/kQaSwNYHJQ8`\\n\\nОднак, якщо вам потрібен автовідтворення, ви повинні використовувати спеціальний компонент:\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Властивості для robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Як редагувати бічну навігацію\\n\\nЯкщо вам потрібно відредагувати бічну навігацію Robonomics Wiki, будь ласка, дотримуйтесь цих кроків:\\n\\n* Редагуйте файл `/data/sidebar_docs.yaml`.\\n\\n* Вирішіть, куди помістити свій документ\\n\\n* Використовуйте правильний YAML для `/data/sidebar_docs.yaml` та спирайтеся на існуючу структуру файлу\\n\\n* **ВАЖЛИВА ЗАМІТКА:** якщо ви використовуєте той самий документ у різних розділах/підрозділах, наприклад: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Попередньо встановлене зображення для Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nПЕРЕКОНАЙТЕСЯ, ЩО ДОДАЛИ ПАРАМЕТР `topic` ТАКОЮ ОСЬ ФОРМОЮ: \\n\\n(для правильної роботи навігації)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## Як додати спеціальну навігацію для документів\\n\\n* Відредагуйте файл `/data/sidebar_docs.yaml`.\\n\\n* Знайдіть потрібний документ і додайте параметри `prev` і `next` так:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Якщо ви хочете повністю видалити навігацію, додайте параметр `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Якщо ви хочете видалити лише навігацію `попередня сторінка` або `наступна сторінка`, додайте параметр `withoutPrev` або `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nабо\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"e1a624a02d1b651c30182f01531c52ed\",\"title\":\"Отримуйте сповіщення, коли двері відкриті\",\"path\":\"/docs/uk/door-notification/\",\"content\":\"\\nУ цій статті ви встановите інтеграцію з ботом Telegram та налаштуєте автоматизацію, яка буде надсилати вам сповіщення на ваш обліковий запис Telegram, коли двері відкриті.\\n\\n## Сповіщення від бота Telegram\\n\\nСпочатку вам потрібно створити особистого бота Telegram. Для цього перейдіть на [спеціального бота Telegram @BotFather](https://t.me/botfather) та слідуйте інструкціям. \\nЗбережіть свій токен для доступу до HTTP API.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nЗберігайте свій токен **безпечно** і зберігайте його **надійно**, його може використовувати будь-хто для керування вашим ботом \\n\\n</robo-wiki-note>\\n\\nНаступним кроком є знаходження вашого ***User Chat ID***. Для цього використовуйте наступне [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nТепер давайте встановимо інтеграцію \\\"Telegram broadcast\\\". Ця інтеграція буде надсилати повідомлення на ваш Telegram.\\n\\nДля попередньо встановленого зображення Robonomics, Docker Home Assistant або Home Assistant Core вам потрібно відредагувати `configuration.yaml`. Підключіться до Raspberry Pi через `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nВставте наступні рядки в кінець файлу. Вставте ваш **bot API key** та **your User Chat ID**. Також створіть назву для вашого сервісу повідомлень:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Збережіть конфігурацію та перезавантажте Home Assistant.**\\n\\n\\nВ результаті в сервісі Home Assistant буде створено сервіс, який буде надсилати будь-яке повідомлення в чат Telegram з вами. \\nВи можете перевірити це в меню Інструменти розробника на веб-інтерфейсі Home Assistant. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Сповіщення про відкриття дверей\\n\\nТепер час створити автоматизацію. Спочатку імпортуйте шаблон до вашого Home Assistant з цього посилання:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nІ створіть автоматизацію:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nТепер ви будете отримувати повідомлення від бота Telegram кожного разу, коли двері відкриті.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nВи можете використовувати цю автоматизацію з будь-якими дверима/вікнами у вашому домі.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"fbab20f10db6c97d6135668fa6a5dc0f\",\"title\":\"Цифрові двійники\",\"path\":\"/docs/uk/digital-twins/\",\"content\":\"  \\n**Уявіть собі складний пристрій або систему, яка має кілька модулів для підтримки і вимагає кількох облікових записів для використання. Щоб тримати всіх їх в однму місці або кодувати деяку функціональність з окремими обліковими записами або, наприклад, встановлювати різні джерела даних для різних потоків інформації, використовується модуль Цифрової Двійника.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Будь ласка, зверніть увагу, що ці та наступні посібники демонструються на локальному екземплярі вузла Robonomics. Налаштуйте свій за допомогою [цієї інструкції](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Огляд теорії\\nБудь-який обліковий запис може створювати та керувати Цифровим Двійником. Двійник можна уявити як своєрідну таблицю з таким вмістом:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nДе:\\n* **DT id** є непідписаним цілим числом унікальний індекс Цифрового Двійника.\\n* **Topic name** є шістнадцятковим `H256` або ASCII-даними довжиною 32 байти, таким самим, як [`Запуск`](/docs/launch) зовнішній параметр. \\nНаприклад: `0x1234....FF` або `hello.parachain.robonomics.world`.\\n* **Source** - є деякою адресою облікового запису.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Як вже обговорювалося раніше в огляді зовнішніх витягів запуску, `H256` може бути представлений у вигляді закодованого IPFS CID (див.\\n  [Python-інструмент](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) для цього).\\n  Тому теми також можут використовуватися як засоби зберігання даних, наприклад, опис модуля Twin.\\n\\n</robo-wiki-note>\\n\\n\\n## Створити цифровий близнюк\\n\\n### 1. Перейдіть до РDeveloper -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Виберіть digitalTwin -> create зі списку можливих витягів\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nНадішліть транзакцію. Тут не потрібні параметри для створення Twin. Зараз власник Цифрового близняка зможе додавати/змінювати теми близняка.\\n\\nІдентифікатор Twin можна знайти на сторінці огляду Досліджуватиr.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Додати тему\\n\\n### Виберіть digitalTwin -> setSource зі списку можливих витягів\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID, отриманий на сторінці Explorer.\\n* `topic` - раніше обговорюване ім'я теми `H256`. На цьому зображенні це рядок з 32 символами.\\n* `source` - адреса облікового запису, яка буде пов'язана з темою.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Зверніть увагу, що тему можна перезаписати іншою джерелом адреси, якщо потрібно.\\n\\n</robo-wiki-note>\\n\\nПідпишіть та надішліть витяг.\\n\\n## Explore\\n\\nВи можете знайти всю інформацію про існуючі Цифрові близнюки в сховищі модуля `digitalTwin` в розділі `Developer -> Chain state`\\n\\n- Загальна кількість близнюків - `total()`;\\n- Власник Цифрового близняка - `owner(u32)`;\\n- Інформація про теми Цифрового близняка - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"9cc4ccfbdac3e3a0fc141c76ec6fb3fd\",\"title\":\"Створити цифровий ідентифікатор, керований Ethereum\",\"path\":\"/docs/uk/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nОдин з сервісів Robonomics - [Реєстрація цифрового паспорта](https://dapp.robonomics.network/#/passport/) для довільних даних. Сервіс дозволяє створити цифровий ідентифікатор, зберігаючи хеші данних у публічному блокчейні та присвоюючи унікальну адресу.\\n\\nВи можете знайти сервіс \\\"Реєстрація цифрового паспорта\\\" у [Robonomics DApp](https://dapp.robonomics.network/) в розділі \\\"Сервіси\\\" або просто перейдіть за цим [посиланням](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Відео-інструкція\\n\\nУ наступному відео показано процес реєстрації білету Robonomics:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Крок за кроком на зображеннях\\n\\n### 1. Відкрийте сервіс\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Додайте необхідну інформацію та файли\\n\\nЗверніть увагу, що можна додати кілька зображень.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Підпишіть запит\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Схваліть токени\\n\\nСервіс стягує невелику комісію. Але спочатку вам потрібно схвалити необхідну кількість токенів, які будуть витрачені з вашого рахунку.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Прийміть пропозицію та знову підпишіть повідомлення\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Подивіться на створений паспорт\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nПроцес реєстрації займає певний час. В кінці ви побачите посилання на створений ідентифікатор.\\n\"}},{\"node\":{\"id\":\"a2e6977a63ecdfa2d66b774d3b2a83af\",\"title\":\"Даталог\",\"path\":\"/docs/uk/datalog/\",\"content\":\"\\n**Тепер, коли у вас є деякі кошти на вашому рахунку, ви можете надсилати екстрикси. Спробуйте спочатку Datalog. Він дозволяє зберігати дані в блокчейні постійно. Уявіть собі розподілене т криптозахищене сховище для ваших даних, і ось воно!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nБудь ласка, зверніть увагу, що ці та наступні посібники демонструються на локальному екземплярі вузла Robonomics. Налаштуйте свій за допомогою [цієї інструкції](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Перейдіть до  Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Виберіть datalog -> record зі списку можливих екстриксів\\n\\nТакож виберіть обліковий запис, з яким ви хочете відправити екстрикс. Заповніть поле запису.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Даталог підтримує рядок з максимальною довжиною 512 байтів. Для зберігання великої кількості даних можна використовувати [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Відправити транзакцію\\n\\nПідпишіть та відправте транзакцію з обліковим записом, створеним раніше за допомогою розширення або DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  Ви також можете видалити **ВСІ** ваші записи за допомогою *datalog -> erase* виклику.\\n\\n</robo-wiki-note>\\n\\n## 4. Перегляньте свій даталог у сховищі\\n\\nДля цього перейдіть до *Developer -> Chain state*, виберіть *datalog -> datalogIndex*, вкажіть свій обліковий запис та натисніть кнопку \\n\\\"+\\\" щоб отримати індекси записів вашого облікового запису, а потім досліджуйте потрібний з них за допомогою *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Досліджуватиr\\\">\\n\\n  Всі події, включаючи записи даталогу, можна побачити в потоці подій у *Explorer*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"1b52148e7d272fe94d0d2d0be5b249fb\",\"title\":\"Create Account for Robonomics Parachaв\",\"path\":\"/docs/uk/create-account-in-dapp/\",\"content\":\"\\n**Для взаємодії та роботи з Robonomics Parachain розробникам та користувачам потрібно створити обліковий запис на порталі Polkadot / Substrate. Обліковий запс виконує основні функції для мережі: ваша публічна адреса мережі (публічний ключ), контроль доступу до адреси та коштів (приватний ключ), відправка транзакцій в мережу, відображення ваших токенів та їх кількості і т.д. Нижче наведено два основних способи створення облікового запису для Robonomics Parachain.**\\n\\n## 1. Використання розширення Polkadot{.js} Browser\\n\\nРозширення Polkadot надає механізм для генерації облікового запису та взаємодії з усіма проектами Polkadot / Kusama, включаючи Robonomics Parachain. Це не найбезпечніший спосіб керування вашим обліковим записом, але він найзручніший з точки зору балансу безпеки / зручності.\\n\\n## 1.1. Встановлення розширення браузера\\n\\nРозширення браузера доступне для [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) and [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (плюс браузери на основі Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Відкриття додатку Robonomics Parachain\\n\\nПерейдіть до [Додаток Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) на порталі Polkadot / Substrate. Якщо це ваш перший вхід на портал, він запросить доступ до розширення браузера, тому дозвольте доступ. \\n\\nПісля відкриття додатку подивіться в верхньому лівому куті. Там відображаються назва мережі, її значок та номер останнього блоку. Клацнувши на цю область, ви відкриєте список усіх мереж Polkadot / Kusama, включаючи тестові мережі та локальні вузли. Ви можете перемикатися між мережами, вибравши потрібну та натиснувши кнопку `Switch` **Переконайтеся, що ви підключені до Robonomics Parachain зараз**. \\n\\n![Додаток Robonomics Parachain](../images/creating-an-account/1.2-robonomics-app.png \\\"Додаток Robonomics Parachain\\\")\\n\\n## 1.3. Оновлення метаданих розширення\\n\\nДуже ймовірно, що додаток попросить вас оновити метадані розширення, щоб відображати правильну інформацію про підключену вами мережу. Перейдіть до натисніть кнопку **Settings -> Metadata**, а потім у спливаючому вікні дозвольте розширенню це зробити. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Створення облікового запису в розширенні  \\n\\nВідкрийте розширення браузера Polkadot{.js}. Клацніть велику кнопку плюс або виберіть `Create new account` з маленької кнопки плюс у верхньому правому куті. Ви повинні побачити наступне меню зі згенерованим мнемонічним насінням у вигляді дванадцяти слів та адресою. `Create new account` Насіння - це ваш ключ до облікового запису. Знання насіння дозволяє вам (або будь-кому, хто знає насіння) отримати контроль над цим обліковим записом і навіть перестворити його, якщо ви забудете пароль. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nДуже важливо зберігати його в надійному місці **найкраще на папері або іншому недігітальному пристрої, а не в цифровому сховищі або на комп'ютері**, Збережіть насіння та натисніть. \\n\\nЗбережіть насіння та натисніть `Next step`. Ви повинні побачити наступне меню.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* дозволяє вам вибрати, для якої мережі цей обліковий запис буде використовуватися виключно. Ви можете використвувати одну й ту саму адресу на кількох мережах, проте з міркувань конфіденційності рекомендується створити нову адресу для кожної мережі, яку ви використовуєте. \\nВиберіть мережу Robonomics зі списку. Якщо ви не знайшли мережу Robonomics, то, ймовірно, ви не оновили метадані, поверніться назад і зробіть це.\\n\\n    - Ви помітите, що формат адреси та піктограми облікового запису зміняться - це нормально. Різні формати мережі є лише іншими представленнями одного й того ж публічного ключа. \\n\\n- *Name* - це лише ім'я облікового запису, яке використовується виключно вами. Воно не зберігається в блокчейні і не буде видно іншим користувачам. \\n\\n- *Password* використовується для шифрування інформації вашого облікового запису. Вам потрібно буде ввести його повторно при підписанні транзакцій на порталі. Створіть його і запам'ятайте.\\n\\nВ результаті після створення облікового запису ви побачите його в списку облікових записів у розширенні Polkadot{.js}. Натиснувши на три крапки, ви можете перейменувати обліковий запис, експортувати його, видалити його з розширення та змінити мережу, яка використовується для облікового запису. \\n\\nAlso, the account will з'явиться в the **Accounts -> Accounts** menu on the portal, wтут it will be noted that it was injected за допомогою the extension.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n## 2. Прямо на додатку Robonomics Parachain\\n\\nВи можете використовувати користувацький інтерфейс на порталі Polkadot / Substrate для створення облікового запису. Його можна використовувати для розробки та тестування. \\n\\n## 2.1. Відкрийте додаток Robonomics Parachain\\n\\nПерейдіть до [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) на порталі Polkadot / Substrate. **Перевірте вгорі лівому куті, що ви підключені до Robonomics Parachain**.  \\n\\nПерейдіть до **Accounts -> Accounts** та натисніть `Add account` Переконайтеся, що ви підключені до Robonomics Parachain зараз \\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Створення облікового запису\\n\\nВи повинні побачити наступне спливаюче меню з насінним фразом облікового запису. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nВін має дві форми: *Mnemonic* (зручна для читання) і *Raw* (послідовність цифр і літер). Збережіть фразу-сід безпечно і натисніть `Next`.\\n\\n> Також ви можете змінити тип криптовалюти для створення облікового запису, для цього відкрийте `Advanced creation options` і виберіть тип (`ed25519` на зображенні).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nУ наступному меню потрібно встановити ім'я облікового запису та пароль, аналогічно до інструкцій розширення, описаних вище.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nНатискання на кнопку `Next` перенесе вас до останнього вікна. Натисніть `Save` щоб завершити створення облікового запису. Він також згенерує резервні JSON-файли, які ви повинні безпечно зберігати. Ви можете використовувати цей файл пізніше, щоб відновити свій обліковий запис, якщо ви пам'ятаєте пароль.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Додати обліковий запис ed25519 до розширення Polkadot\\n\\nМожливо, вам знадобиться додати створений обліковий запис до розширення Polkadot.js (для облікового запису ed25519 ви можете зробити це лише з резервним JSON-файлом). Для цього вам потрібно створити резервну копію облікового запису. Натисніть на три крапки на своєму обліковому записі та виберіть `Create a backup file for this account` і введіть свій пароль.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nПотім відкрийте розширення та натисніть кнопку `+` в правому верхньому куті, потім виберіть `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nУ відкритому вікні перетягніть збережений файл, введіть пароль і натисніть `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Обліковий запис успішно створено \\n\\nТепер ви можете повністю користуватися своїм свіжоствореним обліковим записом. Надсилайте та отримуйте токени, повідомлення, пишіть даталог та багато іншого. Вільно досліджуйте всі можливості додатку. Щоб скопіювати адресу свого облікового запису, просто натисніть на його значок, адреса буде скопійована в буфер обміну. \\n\\nЯкщо ви бажаєте дізнатися більше про облікові записи Polkadot / Kusama та додаткові способи їх створення, додаткову інформацію можна знайти [тут](https://wiki.polkadot.network/docs/learn-accounts) i [тут](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"de667d280ec021a5380c3205654321eb\",\"title\":\"Як сприяти ресурсам Robonomics\",\"path\":\"/docs/uk/contributing/\",\"content\":\"\\nRobonomics Network – це проект із відкритим вихідним кодом, який ми хочемо полегшити для будь-кого, хто може зробити свій внесок. Ви можете створювати статті, пропонувати зміни, покращувати документацію чи запускати тести. Якщо ви хочете внести свій внесок, будь ласка, відкрийте нову проблему або створіть запит на отримання в тому ж репозиторії.\\n\\n## Основні репозиторії Robonomics \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Основний проект вікі\\n- [Robonomics Maв](https://github.com/airalab/robonomics.network) — Офіційний maв сайт Robonomics Network\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Домашня сторінка для веб-сервісів Robonomics\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Офіційний додаток\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Офіційний веб-сайт Robonomics Academy\\n\\n### Правила для звітування\\n\\nПри відкритті нової проблеми не забудьте про кілька основних правил для звітування:\\n\\n1. Виберіть точний репозиторій, до якого ви хочете подати проблему.\\n\\n2. Якщо ви повідомляєте про помилку, переконайтеся, що цю помилку ще не повідомили.\\n\\n3. Обов'язково вкажіть заголовок і чіткий опис, а також якомога більше відповідної інформації.\\n\\n4. Будь ласка, попередьте свою проблему одним з наступних префіксів: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## ЗЗапити на витягування\\n\\nБудь-яке сховище Robonomics може бути предметом запитів на отримання або змін від учасників, якщо ви вважаєте, що маєте щось цінне, щоб додати або змінити. Будь ласка, не забувайте про основні правила для дописувачів.\\n\\n### Правила для сприяння\\n\\n1. Запити на злиття бажані перед проблемами, якщо у вас є якісь виправлення, особливо для невеликих змін, таких як помилки друку.\\n\\n2. Переконайтеся, що опис запиту на злиття чітко описує проблему і рішення. Вкажіть номер відповідної проблеми, якщо це можливо.\\n\\n3. Будь ласка, не виправляйте пробіли, форматуйте код або робіть чисто косметичні патчі.\\n\\n4. Будь ласка, намагайтеся дотримуватися переважного стилю, мови та макету Markdown.\\n\\n\\n\"}},{\"node\":{\"id\":\"5b7c465daf9b5f492518edf25c2c7be1\",\"title\":\"Сервіси резервного копіювання\",\"path\":\"/docs/uk/backup-services/\",\"content\":\"\\n**У цій статті ви дізнаєтеся, як створити резервні копії конфігурації вашого Home Assistant та відновити її за потреби. Для створення резервних копій виклиається служба, яка генерує захищений архів з файлами конфігурації. Також служба додає конфігурацію Mosquitto brocker та Zigbee2MQTT до резервної копії, якщо вона існує. Потім цей архів додається до IPFS та отриманий CID зберігається в Robonomics Digital Twв.**\\n## Створення резервної копії конфігурації Home Assistant\\n\\nСтворення резервної копії дозволяє легко відновити конфігурацію Home Assistant у разі виникнення неполадок.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warnвg\\\" title=\\\"ПОПЕРЕДЖЕННЯ\\\">\\n\\nДля резервного копіювання та відновлення конфігурації необхідно використовувати **власний IPFS-шлюз** такий як Pinata. Без нього ваша резервна копія буде зберігатися лише на вашому локальному вузлі IPFS, що може запобігти відновленню конфігурації Home Assistant у разі відмови локального вузла.\\n\\n</robo-wiki-note>\\n\\n1. У веб-інтерфейсі Home Assistant перейдіть до `Developer Tools` -> `Services`. Пошук `Robonomics: Save Backup to Robonomics` та натисніть `CALL SERVICE`.\\n\\n2. Зачекайте, поки з'явиться повідомлення `Backup was updated in Robonomics` з'явиться в `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ПОПЕРЕДЖЕННЯ\\\">\\n\\nНе намагайтеся створити резервну копію або відновити конфігурацію безпосередньо після завантаження Home Assistant та Robonomics Integration. Будь ласка, **зачекайте приблизно 5 хвилин** щоб завершити початкову настройку.\\n\\n</robo-wiki-note>\\n\\nАргументи служби:\\n- **Повна резервна копія**  (default: False) - додає базу даних до резервної копії, тому історія станів сутностей також буде збережена.\\n- **Шлях до файлу паролю mosquitto** (default: `/etc/mosquitto`) - Якщо ви використовували методи установки Home Assistant Core або Docker і не маєте типового шляху до Mosquitto brocker, вам слід змінити цей параметр. *Не потрібно для Home Assistant OS або Superviser*.\\n\\n## Відновлення конфігурації Home Assistant з резервної копії\\n\\nДля відновлення конфігурації вам потрібно мати встановлений Home Assistant та Robonomics Integration. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ПОПЕРЕДЖЕННЯ\\\">\\n\\nЩоб успішно відновити конфігурацію в методах установки Home Assistant Core та Docker, вам потрібно виконати додаткові кроки налаштування, як описано в кінці сторінки.\\n\\n</robo-wiki-note>\\n\\n1. Встановіть Home Assisntant з Robonomics Integration (якщо він ще не встановлений), дотримуючись кроків з статті для [бажаного методу установки](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-тут-your-smart-home).\\n\\n2. [Налаштування інтеграції Robonomics](https://wiki.robonomics.network/docs/robonomics-hass-integration) за допомогою **тех же насіння** яке ви використовували в попередній конфігурації Robonomics. Якщо ваша підписка закінчилася, [переактивуйте її](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. У веб-інтерфейсі Home Assistant перейдіть до `Developer Tools` -> `Services`. Пошук `Robonomics: Restore from the Backup in Robonomics` і а потім у спливаючому вікні дозвольте розширенню це зробити. `CALL SERVICE`. Перейдіть на `Overview` сторінку, щоб перевірити стан вашого резервного копіювання.\\n\\n4. Після відновлення Home Assistant автоматично перезавантажиться. Якщо з якоїсь причини Home Assistant не перезавантажується, ви можете перевірити стан відновлення, спостерігаючи за станом сутності `robonomics.backup` . Якщо статус `restored` ви повинні вручну перезапустити Home Assistant, перейшовши до `Settings` > `System` і натиснувши на кнопку `RESTART`, розташовану в правому верхньому куті.\\n\\n5. Якщо ваше резервне копіювання включає конфігурацію Zigbee2MQTT або Mosquitto, вам потрібно перезапустити ці служби, щоб увімкнути нову конфігурацію. Ви можете зробити це вручну, перезапустивши служби окремо, або просто перезапустивши комп'ютер Home Assistant, щоб перезапустити всі служби.\\n\\nАргументи служби:\\n- **Шлях до файлу паролю mosquitto** (default: `/etc/mosquitto`) - Якщо ви використовували етоди встановлення Home Assistant Core або Docker і не маєте типового шляху до брокера Mosquitto, вам слід змінити цей параметр. *Не потрібно для Home Assistant OS або Superviser*.\\n- **Шлях до конфігурації Zigbee2MQTT**  (default: `/opt/zigbee2mqtt`) - Якщо ви використовували методи встановлення Home Assistant Core або Docker і не маєте типового шляху до Zigbee2MQTT, вам слід змінити цей параметр. *Не потрібно для Home Assistant OS або Superviser*.\\n\\n## Відновлення конфігурації Mosquitto та Zigbee2MQTT для методу встановлення Home Assistant Core\\n\\nЯкщо резервна копія містить конфігурацію Mosquitto або Zigbee2MQTT, під час процесу відновлення вони будуть розміщені в типовому шляху або в шляху, вказаному в аргументах. Однак, якщо ви встановили інтеграцію Robonomics в існуючий Home Assistant Core *(не з попередньо встановленого зображення Robonomics)*, the `homeassistant` користувач може не мати доступу до цього шляху.\\n\\nТому для відновлення конфігурації Mosquitto та Zigbee2MQTT вам потрібно надати необхідні права на читання користувачу `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Резервне копіювання конфігурації Mosquitto та Zigbee2MQTT для методу встановлення Home Assistant Docker\\n\\nЩоб зробити резервну копію конфігурацій Mosquitto та Zigbee2MQTT з контейнера Docker, вам потрібно створити томи для їх відповідних конфігурацій. Це можна зробити, запустивши контейнер Home Assistant з додатковими аргументами:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nабо внесіть зміни у ваш `compose.yaml` файл:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nЗверніть увагу, що типові шляхи для конфігурацій Mosquitto та Zigbee2MQTT - `/etc/mosquitto` і `/opt/zigbee2mqtt`, відповідно. Однак ці шляхи можуть варіюватися залежно від вашої конкретної настройки.\\n\\n</robo-wiki-note>\\n\\n## Кнопки резервного копіювання\\n\\nКрім використання служб для роботи з резервними копіями, ви можете спростити процес, використовуючи `Переконайтеся, що ви підключені до Robonomics Parachain заразcreate_backup` і `Переконайтеся, що ви підключені до Robonomics Parachain заразrestore_from_backup` кнопки з інтеграції Robonomics. Ці кнопки викликають відповідні служби з типовими параметрами (кнопка резервного копіювання створює резервну копію без історії).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nЩоб додати кнопки на вашу панель інструментів, виконайте наступні кроки:\\n\\n1. Натисніть на три крапки в правому верхньому куті панелі інструментів.\\n2. Виберіть `Edit Dashboard`.\\n3. Натисніть на кнопку `Add Card` в правому нижньому куті.\\n4. Choose the `Entities` картку.\\n5. У полі `Entities` знайдіть сутності Переконайтеся, що ви підключені до Robonomics Parachain заразcreate_backup та button.restore_from_backup.\\n6. Натисніть `Save` для додавання сутностей на картку.\\n7. Завершіть редагування, натиснувши кнопку `Done` в правому верхньому куті.\"}},{\"node\":{\"id\":\"39eab252efbbc718b2cb5b8505fab728\",\"title\":\"Підключити датчик\",\"path\":\"/docs/uk/carbon-footprint-sensor/\",\"content\":\"\\nПриклад роботи є у відео:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Вимоги\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (або один з [підтримуваних](https://www.zigbee2mqtt.io/вformation/підтримуваних_adapters.html))\\n\\nService is runnвg on Raspberry Pi і contact the smart plug via zigbee protocol.\\n\\n## Zigbee-приймач\\n\\nЯкщо у вас є JetHome USB JetStick Z2, він вже має необхідне прошивання, тому вам не потрібно його перепрошивати. Але якщо у вас є інший адаптер, спочатку вам потрібно перепрошитати його за допомогою програмного забезпечення zigbee2MQTT. Інструкції для вашого пристрою ви можете знайти [тут](https://www.zigbee2mqtt.io/вformation/підтримуваних_adapters.html).\\n\\nПідключіть адаптер та перевірте адресу адаптера (вона також може бути `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nМожливо, спочатку потрібно отримати доступ до порту USB. Додайте свого користувача до `dialout` групою (це працює для Ubuntu, але назва групи може бути іншою в інших ОС).\\nДля Ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nДля Arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nПотім вийдіть з системи та увійдіть знову або перезавантажте комп'ютер.\\n\\n## Установка\\n\\nКлонуйте репозиторій:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Конфігурація\\n\\nПерейдіть до `data/configuration.yaml` та встановіть `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nТакож ви можете заповнити поля `server` і `port` з відповідною інформацією. У полі `server` використовуйте IP-адресу `docker0` моста для встановлення з'єднання: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nТут ваша адреса - `172.17.0.1`.\\n\\nПотім створіть файл config/config.yaml з наступною інформацією та встановіть своє місцезнаходження (ви можете переглянути його на https://countrycode.org/ за 3-літерним ISO-кодом):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Підключіть розетку\\n\\nПерший запуск:\\n\\n```\\ndocker-compose up     \\n```\\n\\nЩоб переключитися в режим сполучення на розетці довго а потім у спливаючому вікні дозвольте розширенню це зробити кнопку живлення протягом кількох секунд, доки індикатор не почне швидко блимати синім.\\n\\nУ журналах ви повинні побачити, що ваш плагін почав публікувати в mqtt.\\n\\n## Після парування\\n\\nЯкщо ви не хочете дозволяти іншим пристроям паруватися з вашим приймачем, зараз вам слід перейти до `data/configuration.yaml` та встановіть `permit_join: false`. Restart service (use 'Ctrl+C' і \\n\\n```bash\\ndocker-compose up     \\n```\\nще раз, щоб зберегти зміни).\\n\\n## Запуск\\nПри першому запуску буде створено обліковий запис для розетки. \\n> If you already have an account you should add its seed to `config.config.yaml` file in `device_seed` section:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nПісля створення облікового запису ви побачите адресу в журналах (seed буде додано до `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nВам потрібно перекласти деякі токени на цей обліковий запис для комісій за транзакції, ви можете зробити це на [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nСервіс побачить, що у вас достатньо токенів, в журналах ви побачите:\\n```\\nplug               | Balance is OK\\n```\\nСервіс буде бачити mqtt-повідомлення від розетки та забезпечувати безпечне використання електроенергії. Кожну годину (ви можете змінити таймаут у розділі `config/config.yaml` in `sending_timeout` секундах) він створюватиме журнал даних з наступною інформацією:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"55fc01c98f2a3015912a0f6b3f19e644\",\"title\":\"Послуга взаємозаліку\",\"path\":\"/docs/uk/carbon-footprint-service/\",\"content\":\"\\nПриклад роботи є у відео:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nСервіс компенсації викидів CO2 шляхом спалювання токенів в мережі Statemвe. \\nВироблений CO2 розраховується наступним чином: дані з пристрою в Вт помножити на коефіцієнти, залежні від регіону. 1 тонна СО2 компенсується споживанням 1 токена. [Ось](/docs/carbon-footprвt-sensor) інструкції для підключення пристрою.\\n\\n## Сценарій\\n\\n1. Зареєструйте новий пристрій у Digital Twin у мережі Robonomics\\n2. Один раз в інтервалі отримання останніх даних з усіх пристроїв і помножте на коефіцієнт залежно від регіону\\n3. Підсумувати дані і перетворити їх на тонни СО2\\n4. Відняти загальну кількість спалених токенів від поточних даних \\n5. Спалити ціле число токенів в мережі Statemine \\n6. Зберегти загальну кількість спалених токенів у локальній базі даних та Даталог \\n\\n\\n## Встановлення\\n\\nКлонувати репозиторій та редагувати файл конфігурації.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Конфігурація description\\n\\nНе редагувати `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network wтут Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nКоефіцієнти для невідновлюваної енергії були взяті з [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) та збережені в `utils/coefficients.py`. \\n\\n## Запуск\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"bc7452a5a4c0ccc5a6279b8bdb9c2df0\",\"title\":\"Додавання коштів на ваш рахунок на порталі Robonomics\",\"path\":\"/docs/uk/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Після успішного створення облікових записів на порталі Robonomics, настав час поповнити їх коштами, щоб ви могли ініціювати транзакції.**\\n\\n<robo-wiki-note type=\\\"warnвg\\\" title=\\\"Dev Node\\\">\\n\\nЗверніть увагу, що ці та наступні посібники демоструються на локальному екземплярі вузла Robonomics. Налаштуйте свій за допомогою [цієї інструкції.](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Перейдіть до розділу Облікові записи на порталі Robonomics \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Виберіть обліковий запис, з якого ви хочете переказати кошти\\n\\nУ режимі розробки існує кілька облікових записів, кожен з яких має 10000 одиниць коштів, які можуть бути використані для переказу коштів на інші облікові записи, створені в розробницькій мережі. Ці облікові записи позначені ключами гайки <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> поруч з ними.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Клацніть на кнопку \\\"надіслати\\\" облікового запису, з якого ви хочете переказати кошти, наприклад BOB\\n\\n## 3. Виберіть обліковий запис, на який ви хочете переказати кошти\\nПісля натискання на кнопку \\\"надіслати\\\", ви побачите вікно \\\"надіслати кошти\\\". У цьому вікні:\\n\\n- Зі сиску доступних облікових записів виберіть обліковий запис, на який ви хочете надіслати кошти.\\n- Введіть кількість одиниць, які ви хочете надіслати.\\n- Натисніть \\\"здійснити переказ\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Підтвердіть транзакцію\\n\\nПісля натискання \\\"здійснити переказ\\\" на попередньому етапі, ви побачите вікно \\\"підтвердити транзакцію\\\".<br/>\\nПерегляньте деталі транзакції і, нарешті, клацніть кнопку \\\"підписати та надіслати\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nУ цьому прикладі ми переказали 500 одиниць коштів з \\\"BOB\\\" на \\\"EMPLOYER\\\". Ви можете побачити, що на рахунку EMPLOYER, який спочатку не мав жодних коштів, тепер є 500 одиниць коштів.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Переконайтеся, що у вас є достатньо коштів на рахунках, які ви хочете використовувати в ігровому майданчику.**\"}},{\"node\":{\"id\":\"d99b169074abc7f994657ef4d4ad0d2e\",\"title\":\"Адаптер Zigbee с Zigbee2MQTT для предустановленного образа\",\"path\":\"/docs/ru/zigbee-to-mqtt-image/\",\"content\":\"\\n**В этой статье вы будете сопрягать умные устройства.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nОткройте веб-браузер и перейдите по адресу `http://%RASPBERRY_IP_ADDRESS%:8099`. Вы можете найти IP-адрес Raspberry Pi, используя [мобильное приложение Fing](https://www.fing.com/products) или [инструмент командной строки nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nВы увидите веб-интерфейс Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nПришло время подключить ваше умное устройство. \\nСначала нажмите кнопку `Permit join (All)` в верхней части веб-интерфейса Zigbee2MQTT. \\n\\nЗатем начните сопрягать устройства. Самый распространенный способ перевести устройство в режим подключения - удерживать его кнопку питания или включать/выключать его 5 раз. Убедитесь, что Zigbee2MQTT работает.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nКогда устройство подключится, вы увидите их в веб-интерфейсе:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nТеперь вы должны увидеть этот датчик в вашем веб-интерфейсе Home Assistant. Перейдите в `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nПосле добавления всех датчиков вы можете закрыть веб-интерфейс Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"653cfe3e804d77e003753e00803ba26a\",\"title\":\"Substrate Cumulus Parachain Testsuite для межцепочечной передачи сообщений\",\"path\":\"/docs/ru/xcm-robobank/\",\"content\":\"\\n\\nОсновная цель этого проекта - упрощение разработки времени выполнения парачейна при использовании межцепочечных сообщений. \\nОн позволяет разрабатывать код времени выполнения с интеграционными тестами с высокой степенью повторяемости и простым использованием.\\nОн автоматизирует построение, создание предварительно заданной конфигурации сети (т.е. 1 ретрансляционная цепочка + 2 парачейна), настройку каналов передачи сообщений между парачейнами и запуск тестов передачи сообщений, отправку сообщений с использованием вызова времени выполнения, все это создано и составлено на языке Python.\\n\\nXCM Testsuite используется для тестирования производственного цикла Robobank - набора палеток Substrate, которые позволяют роботам регистрироваться на внешних парачейнах, получать предоплаченные заказы, выполнять их и получать платежи с использованием внешних токенов. Это позволяет роботам работать внутри сети Robonomics со всей необходимой инфраструктурой, но в то же время предлагать свои услуги на любом другом парачейне.\\n\\nПример видео доступен на [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nОсновные шаги в демонстрационном сценарии:\\n- запуск ретрансляционной цепочки и двух парачейнов в пакете из 6 процессов\\n- настройка каналов передачи сообщений XCM между парачейнами\\n- регистрация робота в обоих парачейнах\\n- создание заказа для этого робота в клиентском парачейне (резервирование платежа для завершения заказа)\\n- отправка сообщения XCM на парачейн Robonomics\\n- создание \\\"зеркальной\\\" записи заказа на парачейне Robonomics\\n- робот принимает заказ на парачейне Robonomics\\n- отправка сообщения XCM о принятии заказа обратно на клиентский парачейн\\n- принятие заказа на клиентском парачейне (резервирование штрафного сбора за невыполнение заказа до срока)\\n- робот завершает заказ на парачейне Robonomics\\n- отправка сообщения XCM о завершении заказа на клиентский парачейн\\n- расчет всех платежей (платеж клиента передается роботу, а также неиспользованный штрафной сбор)\\n- закрытие заказа1\\n\\n\\n## Верхний поток\\nЭтот проект является форком\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nОн содержит код палеток времени выполнения, которые тестируются.\\nКак и в исходном коде узла, код парачейнов находится в каталогах \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nОтличия от исходного \\\"substrate-node-template\\\":\\n- этот временной код имеет модуль обработчика HRMP и может обрабатывать сообщения от соседних парачейнов\\n- готовый к использованию тестовый временной код для внутренних тестов XCM\\n\\n## Сборка и запуск\\nРекомендуется (очень) настройка: \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[ПРИМЕЧАНИЕ] Первая сборка может занять много времени, до нескольких часов на неоптимальных машинах.\\n\\n[ПРИМЕЧАНИЕ] Скрипт работает с ФИКСИРОВАННЫМИ версиями (хэшами коммитов) Polkadot(Rococo) в ретрансляционной цепочке и парачейнах.\\n\\n[ПРИМЕЧАНИЕ] По умолчанию скрипт каждый раз создает одну и ту же среду при запуске, удаляя все предыдущие состояния. Это поведение можно изменить в \\\"config.sh\\\", используя параметр \\\"PERSISTENT\\\".\\n\\n\\nЗапустите сборку и настройку скрипта.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nОсновные действия скрипта \\\"init.sh\\\":\\n - чтение конфигурации (файл \\\"config.sh\\\" с номером ревизии, начальными ключами и идентификаторами узлов, параметром сохранения цепных данных и т.д.)\\n - настройка пакетов ОС, Rust и Python\\n - создание отдельных двоичных файлов для ретрансляционной цепочки и также для обоих парачейнов\\n    - бинарные файлы будут сгенерированы в подкаталоге ./bin. \\n - (необязательно) удаление всех предыдущих цепных данных для всех цепей\\n    - отключается, если \\\"PERSISTENT=1\\\" установлено в \\\"config.sh\\\"\\n - запуск в виде отдельных процессов (с отдельными PID и каналами ввода-вывода):\\n    - валидаторы ретрансляционной цепочки (т.е. 4 валидатора, работающих на стабильной ревизии Rococo)\\n    - коллаторы для парачейна-100 (т.е. один коллатор для первого парачейна, который вы разрабатываете)\\n    - коллаторы для парачейна-200 (т.е. один коллатор для второго парачейна, который вы разрабатываете)\\n - печать всех конечных точек, портов в консоль, позволяющая изучать любую цепь с помощью приложений фронтенда (обозреватель, DApp)\\n - продолжайте печатать все выходные данные всех цепей в консоль\\n\\n[ПРЕДУПРЕЖДЕНИЕ] После запуска дождитесь, пока сеть будет работать, убедитесь, что финализация блока началась и что парачейны зарегистрированы. Эти процессы должны занимать примерно 5 минут (50 блоков x 6 секунд).\\n\\n## Проверка работы начальной настройки \\n\\nИспользуйте стандартный фронтенд Polkdot и сгенерированные конечные точки \\\"--ws-port\\\" для подключения к каждому узлу.\\nОткройте [приложение Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) для мониторинга цепей. \\n\\n### Пример:\\nLocalhost, 4 валидатора ретрансляционной цепочки, один коллатор парачейна-100, один коллатор парачейна-200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nЕсли все работает, и согласование началось, мы можем перейти к запуску наших тестовых случаев (в новом терминале).\\n\\n### Тестирование передачи сообщений UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nОн создает сообщение `Balance.transfer` в `парачейн-100` и передает его на цепочку реле.\\nКогда цепочка реле получает сообщение, она переводит 15 токенов со счета `пара 100` на счет Чарли.\\n\\n\\n### Тестирование передачи сообщений HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nОн создает сообщение `Balance.transfer` в `парачейн-100` и передает его в `соседний 200`.\\nДо этого он наделяет счет `субл 100` 1000 токенами и устанавливает коммуникационный канал между парачейнами.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nСледующие сообщения могут быть отправлены, запустив подкоманду `hrmpm`. Он не создает канал, поэтому работает быстрее.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Дополнительные параметры\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Локальная тестовая сеть\\n\\n### Создание настраиваемой спецификации цепи\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nОтредактируйте файл rococo_local.json, заменив параметры балансов и авторитетов на свои.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nАдрес Polkadot для //Alice//stash (криптография sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nКлюч сессии Polkadot grandpa для //Alice (криптография ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nАдрес Polkadot для //Alice (криптография sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nПреобразование rococo_local.json в необработанный формат.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nЧтобы использовать новую спецификацию цепи, замените файл rococo.json в каталоге ./config/ на этот новый и перезапустите цепь.\\n```bash\\n./scripts/init.sh run\\n```\\nВы можете свободно редактировать код. Вышеуказанная команда перестроит проект и обновит узел коллатора перед запуском.\\nCumulus - это предварительная версия программного обеспечения, которое все еще находится в активной разработке.\\nWe are using a specific commit of polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nВы можете использовать более новые версии программного обеспечения. Для этого измените POLKADOT_COMMIT в ./scipt/config.sh\\nна последний коммит ветки `rococo-v1`, удалите ./bin/polkadot и запустите \\n```bash\\n./scripts/init.sh run\\n```\\n\\nОбновление зависимостей проекта коллатора \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nНекоторые зависимости, вероятно, требуют новых функций инструментальной цепи Rust. Этот проект основан на Rust `nightly-2021-01-26`\\nОбновите версию инструментальной цепи Rust в ./scripts/config.sh перед сборкой.\\n\\n## Взлом парачейна\\n[Добавление внешнего паллета](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - возможно, это должно быть в разделе \\\"Узнать больше\\\"?\\n## Learn More\\n\\nСсылка на оригинальный [Шаблон узла разработчика Substrate](https://github.com/substrate-developer-hub/substrate-node-template), чтобы узнать больше о структуре этого проекта, его возможностях и способе их реализации. Вы можете узнать больше о [Пути блока парачейна](https://polkadot.network/the-path-of-a-parachain-block/) на официальном блоге Polkadot. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"269f4ed37af1a24897790f0a2a706e89\",\"title\":\"Активировать подписку\",\"path\":\"/docs/ru/sub-activate/\",\"content\":\"\\nВ этой статье вы создадите учетные записи Robonomics parachain и купите подписку на IoT. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nДля управления Home Assistant с помощью Robonomics вам понадобятся 2 учетные записи на Robonomics parachain. Для одной из учетных записей (`sub_owner`) вы купите подписку Robonomics. Вторая учетная запись (`sub_controller`) будет контролировать все процессы Home Assistant (например, телеметрию) и предоставлять доступ другим пользователям. Эти учетные записи обеспечат безопасность вашего Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nОбе учетные записи должны быть созданы с использованием шифрования **ed25519**. По этой причине вам необходимо создать учетную запись с помощью пользовательского интерфейса Polkadot-JS и выбрать необходимое шифрование.\\n\\nЭта функция отключена по умолчанию в пользовательском интерфейсе Polkadot-JS. Чтобы включить ее, перейдите в `Settings` -> `General` -> `account options` и выберите `Allow local in-browser account storage` в раскрывающемся меню `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Создание учетных записей владельцев и контролеров\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Перейдите на [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) на портале Polkadot / Substrate. **Проверьте верхний левый угол, чтобы убедиться, что вы подключены к Robonomics Parachain.**\\n\\n2. Перейдите в `Accounts` -> `Accounts` и нажмите кнопку `Add account`. Вы увидите всплывающее меню с семенем учетной записи. Оно имеет две формы: *Мнемоника* (читаемая человеком) и *Сырой* (последовательность цифр и букв). \\n\\n3. Откройте `Advanced creation options`, измените тип криптографии создаваемой учетной записи на `Edwards - ed25519` и нажмите `Next`.\\n\\n\\n4. Безопасно сохраните мнемоническую фразу-семя и нажмите `Next`.\\n\\n5. В следующем меню вам нужно задать имя учетной записи и пароль. Дайте ей имя `sub_owner` для удобства. Нажмите `Next`.\\n\\n6. В последнем окне нажмите `Save`, чтобы завершить создание учетной записи. Он также сгенерирует резервные файлы JSON, которые вы должны сохранить в надежном месте. Вы можете позже использовать этот файл для восстановления вашей учетной записи, если вы помните пароль.\\n\\n7. Повторите эти шаги для учетной записи с именем `sub_controller`.\\n\\n\\n## Добавление учетных записей в Polkadot.js\\n\\nДля удобства вы должны использовать [расширение Polkadot.js](https://polkadot.js.org/extension/) и добавить в него эти новые созданные учетные записи. Для учетной записи ed25519 вы можете сделать это только с помощью резервного файла JSON. Вы можете использовать файлы, сохраненные при создании учетных записей.\\n\\nВы можете получить эти файлы снова, создав резервную копию учетной записи. Нажмите на три точки рядом с вашей учетной записью, выберите `Create a backup file for this account` и введите пароль.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Откройте расширение и нажмите кнопку `+` в правом верхнем углу, затем выберите `Restore account from backup JSON file`.\\n\\n2. В открывшемся окне загрузите JSON-файл, введите пароль и нажмите `Restore`.\\n\\n3. Убедитесь, что для учетных записей в расширении Polkadot.js выбрана сеть Robonomics. На портале Polkadot / Substrate перейдите в `Setting` -> `Metadata` и нажмите кнопку `Update metadata`.\\n\\n4. Подтвердите обновление метаданных во всплывающем окне. Теперь расширение будет показывать метку сети, для которой используется адрес.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Активация подписки Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nДля этого шага вам должно быть достаточно токенов XRT (минимум 2-3 XRT) на вашей учетной записи `sub_owner`.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Перейдите на страницу подписки Robonomics в [dapp.robonomics.network/#/subscription](https://dapp.robonomics.network/#/subscription) и нажмите кнопку `Подключить учетную запись` в правой боковой панели.\\n\\n2. Во всплывающем меню подключите расширение Polkadot.js. Вы увидите адрес вашей учетной записи с балансом.\\n\\n3. Перед покупкой проверьте, что вы выбрали учетную запись `sub_owner`. Нажмите на иконку профиля адреса, вы должны увидеть учетную запись `sub_owner` в поле `Check owner account`.\\n\\n4. Наконец, нажмите кнопку `SUBMIT` и введите пароль для вашей учетной записи. После этого дождитесь завершения процесса активации. Через некоторое время вы увидите состояние вашей подписки.\\n\\n\\n## Добавление учетных записей в подписку\\n\\nТеперь вам нужно добавить учетную запись `sub_controller` в **список доступа**.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Откройте расширение и нажмите на значок рядом с именем учетной записи. Он скопирует адрес учетной записи.\\n\\n\\n2. Вставьте этот адрес в поле `Robonomics parachain address` в разделе **Управление доступом**. Дайте ему имя и нажмите кнопку `+`. \\n\\n3. Повторите шаги 1 и 2 для учетной записи `sub_owner`.\\n\\n4. Нажмите `Save`. Введите пароль вашей учетной записи `sub_owner` во всплывающем окне и дождитесь завершения процесса активации.\\n\"}},{\"node\":{\"id\":\"36388e7f175464eb1c585289e943bf90\",\"title\":\"Как отправить запуск с подпиской\",\"path\":\"/docs/ru/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Обратите внимание, что в этом руководстве показано использование подписки на паракейн Robonomics Kusama. Вы также можете выполнить все те же шаги на своем [локальном узле](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nЕсли у вашего адреса есть активная подписка, то любые устройства, настроенные с использованием секретного ключа этой учетной записи, могут отправлять экстриксы без комиссии. \\nДавайте попробуем отправить команду `launch`.\\n\\nПерейдите на страницу `Developer/Extrinsics`, затем выберите свою учетную запись (те, что есть в списке устройств) и выберите `rws -> call(subscriptionId, call)`. Затем в поле `subscriptionId` вставьте адрес владельца подписки (того, кто сделал ставку на аукционе), а в следующем поле выберите `launch -> launch(robot, param)`. В поле `robot` введите адрес, на который вы хотите отправить транзакцию `launch`, и вставьте команду (для описания команды запуска см. [здесь](/docs/launch)). Затем отправьте транзакцию: \\nТеперь перейдите на страницу `Network/Исследуйтеr`, и в области `Recent Events` вы увидите два события, которые вы создали: `rws.NewCall` и `launch.NewЗапуск`:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\nТеперь перейдите на страницу `Network/Исследуйтеr` и в разделе `Recent Events` вы увидите два события, которые вы создали: `rws.NewCall` и `launch.NewЗапуск`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"e8d99b71cc3679ded22ebe4a938e1e08\",\"title\":\"Как использовать чертежи\",\"path\":\"/docs/ru/use-blueprints/\",\"content\":\"\\nВ этой статье вы узнаете, как добавить автоматические чертежи в свой Home Assistant и настроить их.\\n\\n## Автоматизация чертежей\\n\\nНекоторые чертежи уже установлены. Автоматизации, основанные на таких чертежах, нужно только настроить. В веб-интерфейсе вы можете найти предустановленные чертежи в `Settings/Automations & Scenes`. Откройте `Blueprints` и найдите нужный вам чертеж. В этом примере будет использоваться `Motion-activated Light`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nНажмите на `Create Automation`, чтобы открыть редактор автоматизации. Дайте имя, выберите чертеж для использования (`Motion-activated Light` в нашем случае). После этого вам нужно выбрать датчик движения и лампу. Когда конфигурация завершена, нажмите `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Настройка\\\" />\\n\\nЕсли вы хотите внести изменения, вы можете найти их, перейдя в `Settings/Automations & Scenes`, а затем `Automations`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Импорт чертежей\\n\\nHome Assistant может импортировать чертежи из  Home Assistant, GitHub и GitHub gists. Список всех чертежей находится на [Бирже чертежей](https://community.home-assistant.io/c/blueprints-exchange/53). После выбора перейдите в `Settings/Automations & Scenes` и откройте `Blueprints`. Нажмите на `Import Blueprint` и вставьте URL выбранного чертежа. Затем нажмите `PREVIEW BLUEPRINT`. В этом случае мы будем использовать [Обнаружение и уведомление о низком уровне заряда батареи для всех батарейных датчиков](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nЭто загрузит чертеж и покажет предварительный просмотр в диалоговом окне импорта. Вы можете изменить имя и завершить импорт. Нажмите на `Create Automation`, чтобы открыть редактор автоматизации. Здесь вы можете настроить параметры автоматизации и добавить действия для получения уведомлений.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"a524c96f5b4de08ce3e4b1c27af3179a\",\"title\":\"Получение телеметрии умного дома\",\"path\":\"/docs/ru/smart-home-telemetry/\",\"content\":\"\\n**В этой статье вы будете использовать сервис Robonomics, который запрашивает телеметрию устройств умного дома.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Перейдите на dapp и выберите сервис [SmartHome Telemetry](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. В поле контроллера введите адрес `SUB_CONTROLLER`. Вставьте секретную фразу для шифрования данных.\\n\\n3. В блоке `Get telemetry` выберите временную метку из выпадающего списка и нажмите кнопку `DOWNLOAD TELEMETRY`.\\n\\n4. Загрузка телеметрии может занять некоторое время. После завершения вы увидите информацию с ваших устройств и датчиков.\\n\\n\\n<!---\\n## Lançamento devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Запуск\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nЗапуск command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"29444daad497f3f59a7399b85ac5e48e\",\"title\":\"Robonomics SLS Шлюз\",\"path\":\"/docs/ru/sls-gateway/\",\"content\":\"\\n**В этой статье вы настроите Robonomics SLS Шлюз. Вы установите необходимое программное обеспечение для шлюза, настроите его и подключите к Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Прошивка\\n\\nСначала вам нужно установить прошивку микроконтроллера шлюза. Подготовьте шлюз, установив переключатели `1` и `3` в нижней части SLS Шлюза в положение `ON`, остальные должны быть в положении `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nПодключение ateway to your Raspberry Pi via USB type-C port on the gateway.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nКлонируйте репозиторий с прошивкой на Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nПерейдите в `robonomics-hass-utils/esp_firmware/linux`. Чтобы прошить SLS шлюз, вам нужно запустить скрипты `Clear` и `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Устранение неполадок\\n\\nЕсли у вас возникли проблемы с обновлением прошивки шлюза, вам нужно выполнить дополнительные действия:\\n\\n1. Убедитесь, что у вас установлен модуль pySerial:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Предоставьте своему пользователю права доступа к USB-порту и перезагрузите компьютер:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. В некоторых случаях необходимо изменить настройку пропускной способности в скрипте для обновления прошивки. Откройте скрипт `Flash_16mb.sh` с помощью редактора `nano` и измените параметр baud с `921600` на меньшее значение (например, `115200`).\\n\\n## Настройка\\n\\n1. Отсоедините SLS Шлюз от компьютера. Установите переключатели на задней части шлюза в правильное положение. Переключатели `5` (RX Zigbee to ESP) и `6` (TX Zigbee to ESP) должны быть в положении `ON`, остальные должны быть в положении `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Подключите кабель питания типа C. Индикаторный свет в центре должен загореться зеленым.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. При первом запуске шлюз начнет передавать Wi-Fi с SSID `zgw****`. Подключитесь к этой сети. Имейте в виду, что сигнал может быть довольно слабым, поэтому лучше держать SLS шлюз ближе к вашему компьютеру. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Если подключение прошло успешно, откроется веб-интерфейс (или вы можете найти его по адресу 192.168.1.1). \\n\\n5. Вы увидите страницу `Wi-Fi Settings`. Выберите свою Wi-Fi и введите пароль. Нажмите кнопку `Apply`. Шлюз перезагрузится и подключится к вашей Wi-Fi сети. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Найдите локальный IP-адрес SLS шлюза для доступа к веб-интерфейсу. Чтобы найти его, вы можете использовать [мобильное приложение Fing](https://www.fing.com/products) или [инструмент командной строки nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Имя шлюза должно выглядеть так: `zgw****`. Откройте веб-интерфейс шлюза, вставив IP-адрес шлюза в браузер.\\n\\n7. Перейдите в `Setting` -> `Hardware` и убедитесь, что настройки выглядят так, как на изображении. Исправьте настройки при необходимости и нажмите кнопку `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nТаблица с необходимыми значениями:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Затем перезагрузите шлюз. Выберите  `Actions` -> `Reboot system` в правом верхнем углу.\\n\\n9. Убедитесь, что шлюз работает должным образом в окне информации о Zigbee. Состояние устройства должно быть `OK`.\\n\\n10. Настройте автоматическое добавление устройств в Home Assistant. Перейдите в `Zigbee` -> `Config`, затем выберите `Home Assistant MQTT Discovery` и `Clear States`. Сохраните изменения и снова **перезагрузите** SLS шлюз.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nЕсли у вас уже есть активный SLS шлюз в вашем доме, и вы сейчас настраиваете еще один, то они будут конфликтовать друг с другом. Чтобы решить эту проблему, вам нужно изменить канал на новом устройстве. Для этого перейдите в `Zigbee` -> `Config` и измените канал на другой (например, канал 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Сопряжение SLS с MQTT\\n\\nПосле настройки SLS Шлюза вам нужно подключить SLS Шлюз к Home Assistant. Откройте веб-интерфейс SLS Шлюза и перейдите в `Settings/Link` -> `MQTT Setup`:\\n\\n\\nДобавьте адрес вашего брокера (адрес Raspberry Pi с Home Assistant в локальной сети, вы можете найти его с помощью [мобильного приложения Fing](https://www.fing.com/products) или [инструмента командной строки nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), порт (по умолчанию `1883`), имя пользователя и пароль брокера (которые вы создали ранее) и имя темы (вы можете выбрать любое). Также IP-адрес Raspberry Pi должен быть статическим. Нажмите `Enable` и `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nСохраните изменения. Теперь устройства будут автоматически отображаться в Home Assistant.\\n\\n## Подключение устройств\\n\\nПодключите ваши устройства, перейдя в раздел `Zigbee` -> `Join`. Поместите ваши сенсоры в режим сопряжения, наиболее распространенным способом переключения устройства в режим подключения является удержание его кнопки питания или переключение их вкл/выкл 5 раз. Нажмите кнопку `Enable Join`, чтобы начать поиск устройств Zigbee. Вы увидите активные сенсоры.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nТеперь вы можете перейти в раздел [**Подписка на IoT**](/docs/sub-activate) и начать активацию подписки Robonomics.\\n\"}},{\"node\":{\"id\":\"9b43a71f4bfbefd35c30e791b1327a1d\",\"title\":\"Децентрализованная сеть датчиков\",\"path\":\"/docs/ru/sensors-network-introduction/\",\"content\":\"\\nСтатьи о децентрализованной сети датчиков были перенесены в Robonomics Academy: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"cd202774c4f705bee7e9cda2fca0cec0\",\"title\":\"Безопасное подключение облачного искусственного интеллекта к производственному процессу\",\"path\":\"/docs/ru/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nТехнологии Robonomics уже могут решать проблемы, с которыми сталкивается Индустрия 4.0, и они уже применяются в реальных сценариях в промышленной среде.\\n\\nБольшое количество компаний по искусственному интеллекту создают решения для оптимизации процессов на производственном участке, позволяя заводам производить больше с меньшими затратами. Однако большинство заводов неохотно подключают свою инфраструктуру к облаку напрямую, так как это приводит к потенциальным кибербезопасностным рискам, которые могут привести к миллионным потерям и даже потере человеческой жизни.\\n\\n[MerkleBot](https://merklebot.com) использовал [Robonomics Network](https://robonomics.network), чтобы создать решение для промышленных клиентов, позволяющее безопасно подключать их завод к облачному искусственному интеллекту.\\n\\nЭта статья написана в результате эксперимента, который мы провели вместе с [Veracity Protocol](https://www.veracityprotocol.org/), использующим алгоритмы для создания неинвазивной защиты любого физического предмета на основе фотографий с мобильного устройства.\\n\\nЭтот пример использования показывает процесс сканирования промышленных деталей с помощью роботизированной руки.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Пошаговый процесс\\n\\n### DApp в качестве пользовательского интерфейса\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp действует в качестве пользовательского интерфейса для оператора. Он используется для запроса запуска робота для сбора фотографий, и его целью является обеспечение безопасной связи между производственной средой и облачным искусственным интеллектом.\\n\\n### Запуск робота\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nОператор запускает роботическое сканирование, подписывая транзакцию в DApp. Этот шаг гарантирует, что процесс на производственном участке может начаться только на основе транзакции в публичном блокчейне.\\n\\nРобот получает команду от блокчейна через Robonomics Network и начинает сканирование. Технологии Robonomics Network позволяют сократить разрыв между бизнес-целью и операцией робототехники.\\n\\n### Сбор данных и отправка в облачный искусственный интеллект\\n\\nВ DApp оператор видит подтверждение, и робот начинает сканировать предметы, размещенные на столе, как в этом примере использования, или непосредственно на производственной линии, если это необходимо.\\n\\n<!-- ![](../images/Veracity_Protocol_Запуск.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Запуск.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Запуск.gif\\\" />\\n\\n\\nКогда робот собирает данные, он сохраняет их локально и делает их доступными для облачного искусственного интеллекта через протокол IPFS. Шифруя данные и организуя обмен данными через блокчейн-транзакцию, мы можем авторизовать доступ к облачному искусственному интеллекту, убедившись, что данные остаются безопасными и на своем месте.\\n\\nМеханизм безопасности, встроенный в Robonomics на основе общей безопасности публичных блокчейнов, позволяет достичь уровня безопасности, который является непозволительно дорогим для большинства заводов, чтобы организовать его самостоятельно.\\n\\n### Создание цифрового паспорта\\n\\nКогда облачный искусственный интеллект анализирует данные, журнал и рекомендации записываются автоматически в виде [цифрового паспорта](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/). Каждая операция и сканирование могут быть прослежены, так как блокчейн-запись содержит хэш для всех этих файлов через протокол IPFS.\\n\\n## Комментарии к примеру использования\\n\\nВ этом примере использования была использована промышленная рука Universal Robot UR3. Но благодаря поддержке Robonomics для ROS, большинство основных промышленных манипуляторов могут быть использованы и подключены к облачному искусственному интеллекту безопасно, включая KUKA, Fanuc и Yaskawa.\\n\\nЕсли вас интересует узнать больше о развертывании и интеграции облачных инструментов искусственного интеллекта безопасно, пожалуйста, [свяжитесь](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"abe395d737d0af9e76cec3d2d4594a9e\",\"title\":\"Как добавить датчик SDS011 в Home Assistant\",\"path\":\"/docs/ru/sds-sensor-hass/\",\"content\":\"\\nВ этой статье объясняется, как подключить датчик качества воздуха SDS с помощью прошивки [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) и [Robonomics](https://github.com/airalab/sensors-software) к Home Assistant.\\n\\n## Установка \\nДоступны два варианта установки:\\n\\n### Вариант 1: HACS\\n\\nСамый простой способ добавить локальный датчик Luftdaten - это через HACS. [Здесь](https://hacs.xyz/docs/setup/download/) вы можете найти краткое объяснение о том, как настроить HACS.\\n\\nПосле установки HACS перейдите в HACS -> Интеграции и найдите интеграцию `Local Luftdaten Sensor`. Нажмите кнопку загрузки и перезапустите Home Assistant после загрузки интеграции.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Вариант 2: Ручная установка\\n\\nПод пользователем homeassistant склонируйте репозиторий проекта:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nЕсли у вас уже есть какие-либо пользовательские интеграции, скопируйте `custom_components/local_luftdaten/` в вашу директорию `custom_components`. Например:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nЕсли у вас нет пользовательских интеграций, скопируйте всю директорию `custom_components` в директорию конфигурации вашего Home Assistant. Например:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Настройка\\n\\nСоздайте новую запись датчика в вашем `configuration.yaml` и настройте имя хоста или IP-адрес. Чтобы найти локальный IP-адрес вашего датчика, вы можете использовать [мобильное приложение Fing](https://www.fing.com/products) или [инструмент командной строки nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Имя может быть любым.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> Список всех поддерживаемых датчиков можно найти в [репозитории](https://github.com/lichtteil/local_luftdaten).\\n\\nПерезапустите Home Assistant.\\nПосле этого вы можете добавить датчик на вашу панель инструментов. Имя сущности будет таким же, как имя, которое вы добавили в `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"33f6ce478a05ef2102a6aa57c8f9c877\",\"title\":\"Как подключить датчик SDS011\",\"path\":\"/docs/ru/sds-sensor-connect/\",\"content\":\"\\n** Вот пошаговое руководство о том, как подключить ваш датчик к сети датчиков Robonomics. Наши датчики используют прошивку Robonomics, которая является улучшенной версией прошивки sensor.community. Она включает дополнительные датчики и имеет измененный механизм отправки данных. **\\n\\n1. Подключите датчик к розетке для его питания.\\n2. Плата создаст Wi-Fi сеть с именем `RobonomicsSensor-xxxxxxxxx`. Подключитесь к ней с вашего телефона или компьютера: вы увидите окно авторизации (если нет, откройте браузер и перейдите по адресу `192.168.4.1`).\\n3. Выберите свою Wi-Fi сеть из списка (или введите ее вручную, если она отсутствует в списке) и заполните поле пароля.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nДатчик можно подключить только к сети Wi-Fi 2,4 ГГц. \\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Укажите координаты места, где будет установлен датчик. Вы можете получить их с любых карт или получить их из адреса, используя [эту ссылку.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nКоординаты датчика будут отображаться на общедоступной карте. Если вы не хотите показывать свою личную информацию, укажите близкие, но не точные координаты.\\n</robo-wiki-note> \\n5. Нажмите на `Save configuration and restart`. Плата перезагрузится и подключится к указанной Wi-Fi сети.\\n6. Откройте [карту датчиков Robonomics](https://sensors.robonomics.network/#/) и найдите место, где вы установили датчик. Через несколько минут вы сможете увидеть ваш датчик с данными на карте.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"cb705241a367d1beed029f56e0dd9cbe\",\"title\":\"Как запустить узел разработки Robonomics\",\"path\":\"/docs/ru/run-dev-node/\",\"content\":\"\\n**Для тестирования ваших приложений на Robonomics вы можете запустить его в режиме разработки. В этой статье показаны пошаговые\\nинструкции о том, как получить собственный локальный тестовый экземпляр Robonomics.**\\n\\n\\n## Получить двоичный файл узла\\n\\n1. Сначала вам понадобится двоичный файл, загрузите архив с ним из последнего [релиза](https://github.com/airalab/robonomics/releases).\\n\\n2. Перейдите в папку с архивом, распакуйте двоичный файл и измените разрешения:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Запустить\\n\\nЗапустите узел с помощью команды:\\n\\n```bash\\n./robonomics --dev\\n```\\nВы увидите следующий вывод:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Если вы хотите очистить существующие блоки, вы можете сделать это, удалив RocksDB в `/tmp/substrate******/chains/dev/db/full`.\\n  Замените `******` на соответствующий идентификатор, отображаемый в журналах при запуске.\\n\\n  Если вы хотите каждый раз запускать узел с нуля, используйте флаг `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Подключение\\n\\nТеперь вы можете подключиться к локальному узлу через [Портал Polkadot](https://polkadot.js.org/apps/#/explorer).\\n\\nИзмените сеть на `Local Node` в верхнем левом углу и нажмите `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nДобро пожаловать в локальный экземпляр Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"54eacd6cb84cfb602bf873906a20ad85\",\"title\":\"Robonomics Video Service\",\"path\":\"/docs/ru/robonomics-video/\",\"content\":\"\\nВ этой статье показано, как добавить IP-камеру в Home Assistant и отправить видео на Robonomics Web Service.\\n\\nЧтобы подключить камеру к Home Assistant, вам нужно знать ее IP-адрес и создать локальную учетную запись камеры для подключения к потоку RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nПоскольку это делается по-разному для каждой камеры, этот процесс не рассматривается в данной статье.\\n</robo-wiki-note>\\n\\nТребования:\\n- IP-камера\\n- Настроенная локальная учетная запись камеры\\n- IP-адрес камеры\\n- Настроенный Home Assistant\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nВ этой статье предполагается, что у вас есть обычная IP-камера без опций RTZ (поворот, наклон, масштабирование). \\nЕсли у вас есть камера RTZ, проверьте статью [\\\"Камера RTZ\\\"](/docs/ptz-camera). А затем вернитесь ко второму шагу здесь.\\n\\n</robo-wiki-note>\\n\\n## Подключите камеру\\n\\nFirst, you need to find out the URL for the RTSP stream of the camera. \\nДля этого попробуйте ввести следующий запрос в Интернете: \\\"<ИМЯ_КАМЕРЫ> RTSP-поток\\\".\\nURL потока должен начинаться с `rtsp://<IP_Адрес>...`. \\n\\nВ этой статье используется камера \\\"Tapo\\\", а путь потока - `rtsp://<IP_Адрес>/stream1`.\\n\\nОткройте Home Assistant и перейдите в \\\"Settings\\\"-> \\\"Devices & Services\\\". Нажмите кнопку \\\"ADD INTEGRATION\\\"  и\\nначните вводить \\\"Generic Camera\\\". Выберите его.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nВ окне конфигурации предоставьте следующую информацию:\\n- Stream Source URL - URL потока RTSP камеры\\n- Username - введите имя пользователя вашей локальной учетной записи камеры\\n- Password - введите пароль для вашей локальной учетной записи камеры\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nПрокрутите вниз настройки и нажмите кнопку \\\"Submit\\\".\\n\\nВ окне предварительного просмотра активируйте флажок \\\"This image looks good.\\\" и нажмите кнопку \\\"Submit\\\". Затем - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Добавьте на панель управления\\n\\nКроме того, вы можете добавить поток на свою панель управления. Для этого перейдите на панель управления и создайте новую карту \\n\\\"Picture Glance\\\". Дальнейшие шаги:\\n- введите желаемый \\\"Title\\\"\\n- удалите данные из \\\"Image Path\\\"\\n- выберите камеру в \\\"Camera Entity\\\"\\n- в \\\"Camera View\\\" выберите \\\"live\\\", чтобы уменьшить задержку\\n\\nИ сохраните его.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Проверьте папку медиафайлов\\n\\nПрежде чем отправить видео на Robonomics Video Service, видео должно быть сохранено в папке, и Home Assistant должен иметь доступ к этой папке. \\nСамый простой вариант в этом случае - использовать медиапак, в котором Home Assistant хранит все медиафайлы.\\n\\n- Если вы используете HAOS или предустановленное изображение, ваш Home Assistant **уже имеет папку Media**.\\n- Если вы используете Core Home Assistant, вам следует перейти в папку `.homeassistant` и создать в ней папку `media`.\\n- Если вы используете Home Assistant Docker, добавьте строку ` -v /ПУТЬ_К_ВАШИМ_МЕДИА:/media \\\\` в команду Docker.\\n\\nЧтобы проверить, что все настроено правильно, перейдите на вкладку “Media” -> “local media” в вашем Home Assistant. \\nВы должны увидеть пустую папку (без ошибок):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Вызов сервиса\\n\\nЧтобы отправить видео на Robonomics, вы должны вызвать специальный сервис в Home Assistant. \\nВ этой статье это делается вручную, но вы можете создать автоматизацию для этого.\\n\\nДля этого зайдите в `Developer tools` -> «Services» и найдите \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nВ \\\"Targets\\\" выберите сущность вашей камеры.\\nВ \\\"Path to save the recording\\\" вы должны указать абсолютный путь к папке,\\nгде Home Assistant может сохранить видео:\\n- Для предустановленного изображения - `/home/homeassistant/.homeassistant/media`;\\n- Для HA OS или Home Assistant Docker- `/media`;\\n- Для Home Assistant Core - Путь к ранее созданной папке с медиафайлами.\\n\\nКроме того, вы можете выбрать продолжительность записи. \\n\\nЗаполните данные и вызовите сервис с помощью кнопки \\\"CALL SERVICE\\\".\\n\\n## DAPP\\n\\nЧтобы просмотреть полученное видео, перейдите на [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nВставьте адрес вашего контроллера и нажмите кнопку ниже. Дождитесь процесса \\\"Search for Twins\\\". \\nВ результате вы получите IPFS CID со всеми записанными видео.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nЗатем выберите учетную запись контроллера (или любую другую) из выпадающего списка и подпишите сообщение для авторизации в\\nвеб-портале Web3 IPFS, чтобы загрузить все видео. В результате вы получите все видео, записанные вашим умным домом.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nПоскольку все видео в папке зашифрованы с помощью ключа контроллера, вам нужно вставить его для расшифровки видео.\\nПосле этого кнопка воспроизведения видео активируется. Нажмите на нее, чтобы скачать видео.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"71dd6bffd00af67f278789bee4d55e3d\",\"title\":\"Обзор Robonomics Smart Home\",\"path\":\"/docs/ru/robonomics-smart-home-overview/\",\"content\":\"\\n## Безопасный IoT с использованием блокчейна \\n\\nДля вашего умного дома современный рынок IoT предлагает широкий спектр решений. Но вы обычно привязаны к централизованным облачным провайдерам или дорогостоящим собственным шлюзам. В результате вы, как пользователь, всегда зависите от поставщика оборудования и инфраструктуры для работы вашей умной системы. В то же время ваш умный дом не может быть по-настоящему умным без облачной статистики и аналитики.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Мы видим две основные проблемы с существующими умными домами:**\\n\\n1. У вас нет контроля над теми данными, которые вы делитесь с поставщиком или третьей стороной.\\n2. Ваш умный дом уязвим для отключения централизованных облачных серверов. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nЧтобы решить обе проблемы, мы предлагаем вам попробовать Robonomics - нашу **безопасную**, **безсерверную** и **футуристическую** децентрализованную облачную платформу.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Шаги к облачной платформе без корпораций\\n\\nВот несколько простых шагов для создания доступного умного дома с использованием Home Assistant в качестве приложения для обмена данными устройств и Robonomics в качестве безкорпоративной децентрализованной облачной платформы. Robonomics использует современные и безопасные технологии Web3, обеспечивая повышенную безопасность на протяжении всего процесса.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Начните здесь свой умный дом\\n\\nМы подготовили подробные руководства по настройке умного дома на Robonomics. Шаги могут варьироваться в зависимости от вашей конкретной ситуации: у вас уже есть работающий Home Assistant с подключенными устройствами или вы начинаете с нуля, чтобы создать свой умный дом.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ru/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ru/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"7e865494bb6a151103643b9968791e02\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/ru/robonomics-prometheus-grafana/\",\"content\":\"\\n**Следующая инструкция предоставлена [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**Оригинальная статья находится [здесь](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Введение\\nДля более эффективного мониторинга и поддержки узлов Robonomics рекомендуется настроить мониторинг на основе сервера Prometheus и Grafana. В этом документе будет показано, как настроить каждый из них для полного мониторинга вашего узла.\\n\\n##  Предварительные требования\\n* [Server Setup with Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Установленный коллатор Robonomics parachain](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Убедитесь, что на вашем компьютере работает robonomics.service и порт 9615 доступен \\n\\n## Шаг 1 - Создание учетных записей службы\\n\\nВ целях безопасности мы начнем с создания двух новых учетных записей пользователей: prometheus и node_exporter. Создайте эти две учетные записи и используйте параметры _--no-create-home_ и _--shell /bin/false_, чтобы эти пользователи не могли войти на сервер.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nПрежде чем мы загрузим двоичные файлы Prometheus, создайте необходимые каталоги для хранения файлов и данных Prometheus. Следуя стандартным соглашениям Linux, мы создадим каталог в _/etc_ для файлов конфигурации Prometheus и каталог в _/var/lib_ для его данных.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nТеперь установите владельца пользователя и группы на новые каталоги для пользователя prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Шаг 2 - Загрузка Prometheus\\n\\nСначала загрузите и распакуйте текущую стабильную версию Prometheus в ваш домашний каталог. Последние двоичные файлы можно найти на [странице загрузки Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nТеперь распакуйте загруженный архив.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nЭто создаст каталог с именем prometheus-2.21.0.linux-amd64, содержащий два двоичных файла (prometheus и promtool), каталоги _consoles_ и _console_libraries_ с файлами интерфейса веб-страницы, лицензией, уведомлением и несколькими примерами файлов.\\n\\nСкопируйте два двоичных файла в каталог _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nУстановите владельца пользователя и группы на двоичные файлы для пользователя prometheus, созданного на шаге 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nСкопируйте каталоги consoles и _console_libraries_ в _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nУстановите владельца пользователя и группы на каталоги для пользователя prometheus. Использование флага -R гарантирует, что владение будет установлено и для файлов внутри каталога.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nТеперь, когда Prometheus установлен, мы создадим его файлы конфигурации и службы в предварительной подготовке к его первому запуску.\\n\\n## Шаг 3 - Настройка Prometheus\\n\\nВ каталоге _/etc/prometheus_ используйте nano или ваш текстовый редактор, чтобы создать файл конфигурации с именем _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nВ глобальных настройках определите интервал по умолчанию для сбора метрик. Обратите внимание, что Prometheus будет применять эти настройки ко всем экспортерам, если настройки самих экспортеров не переопределяют глобальные настройки.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nЭто значение scrape_interval говорит Prometheus собирать метрики от своих экспортеров каждые 15 секунд, что достаточно для большинства экспортеров.\\nТеперь добавьте сам Prometheus в список экспортеров для сбора с помощью следующей директивы scrape_configs:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus использует _job_name_ для маркировки экспортеров в запросах и на графиках, поэтому выберите что-то описательное здесь.\\n\\nИ, поскольку Prometheus экспортирует важные данные о себе, которые можно использовать для мониторинга производительности и отладки, мы переопределили глобальную директиву scrape_interval с 15 секунд до 5 секунд для более частых обновлений.\\n\\nНаконец, Prometheus использует директивы _static_configs_ и _targets_ для определения места работы экспортеров. Поскольку этот экспортер работает на том же сервере, что и сам Prometheus, мы можем использовать localhost вместо IP-адреса вместе с портом по умолчанию, 9090.\\n\\nВаш файл конфигурации должен выглядеть так:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nСохраните файл и закройте текстовый редактор.\\n\\nТеперь установите владельца пользователя и группы на файл конфигурации для пользователя prometheus, созданного на шаге 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nС завершением настройки мы готовы протестировать Prometheus, запустив его в первый раз.\\n\\n## Step 4 — Запуск Prometheus\\n\\nЗапустите Prometheus от имени пользователя _prometheus_, указав путь к файлу конфигурации и каталогу данных.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nВывод содержит информацию о прогрессе загрузки Prometheus, файле конфигурации и связанных службах. Он также подтверждает, что Prometheus слушает порт _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nЕсли вы получаете сообщение об ошибке, убедитесь, что вы использовали синтаксис YAML в файле конфигурации, а затем следуйте инструкциям на экране для устранения проблемы.\\n\\nТеперь остановите Prometheus, нажав _CTRL+C_, а затем откройте новый файл службы _systemd_.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nФайл службы указывает _systemd_ запустить Prometheus от имени пользователя prometheus, с файлом конфигурации, расположенным в каталоге _/etc/prometheus/prometheus.yml_, и сохранить данные в каталоге _/var/lib/prometheus_. Скопируйте следующее содержимое в файл:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nНаконец, сохраните файл и закройте текстовый редактор. Чтобы использовать только что созданную службу, перезагрузите systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nТеперь вы можете запустить Prometheus с помощью следующей команды:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nЧтобы убедиться, что Prometheus работает, проверьте статус службы.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nВывод показывает статус Prometheus, идентификатор основного процесса (PID), использование памяти и многое другое.\\n\\nЕсли статус службы неактивен, следуйте инструкциям на экране и повторите предыдущие шаг для устранения проблемы перед продолжением обучения.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nКогда вы будете готовы продолжить, нажмите _Q_ для выхода из команды статуса. Наконец, включите службу для запуска при загрузке.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nТеперь, когда Prometheus работает, мы можем установить дополнительный экспортер для генерации метрик о ресурсах нашего сервера.\\n\\n## Шаг 5 — Загрузка Node Exporter\\n\\nЧтобы расширить Prometheus за пределы метрик только о себе, мы установим дополнительный экспортер под названием Node Exporter. Node Exporter предоставляет подробную информацию о системе, включая использование ЦП, диска и памяти. Загрузите текущую стабильную версию Node Exporter в ваш домашний каталог. Последние бинарные файлы можно найти на [странице загрузки Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nТеперь распакуйте скачанный архив.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nЭто создаст каталог с именем _node_exporter-1.0.1.linux-amd64_, содержащий двоичный файл с именем _node_exporter_, лицензию и уведомление.\\n\\nСкопируйте двоичный файл в каталог _/usr/local/bin_ и установите владельца пользователя и группы на пользователя node_exporter, созданного на Шаге 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nТеперь, когда вы установили Node Exporter, давайте проверим его работу, запустив его перед созданием файла службы, чтобы он запускался при загрузке.\\n\\n## Step 6 — Запуск Node Exporter\\n\\nШаги для запуска Node Exporter аналогичны шагам для запуска самого Prometheus. Начните с создания файла службы Systemd для Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nСкопируйте следующее содержимое в файл службы:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nСохраните файл и закройте текстовый редактор. Наконец, перезагрузите systemd, чтобы использовать только что созданную службу.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nТеперь вы можете запустить Node Exporter с помощью следующей команды:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nПроверка that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nКак и раньше, этот вывод показывает статус Node Exporter, идентификатор основного процесса (PID), использование памяти и многое другое. Если статус службы неактивен, следуйте инструкциям на экране и повторите предыдущие шаги для устранения проблемы перед продолжением.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nНаконец, включите Node Exporter для запуска при загрузке.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nПосле полной настройки и успешного запуска Node Exporter мы скажем Prometheus начать сбор новых метрик.\\n\\n## Шаг 7 — Настройка Prometheus для сбора метрик Node Exporter\\n\\nПоскольку Prometheus собирает только экспортеры, которые определены в разделе scrape_configs его файла конфигурации, нам нужно добавить запись для Node Exporter, так же, как мы сделали для самого Prometheus. Откройте файл конфигурации.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nВ конце блока scrape_configs добавьте новую запись с именем node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nПоскольку этот экспортер также работает на том же сервере, что и сам Prometheus, мы можем использовать localhost вместо IP-адреса, а также порт по умолчанию Node Exporter, 9100. Весь ваш файл конфигурации должен выглядеть так:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nСохраните файл и закройте текстовый редактор, когда будете готовы продолжить. Наконец, перезапустите Prometheus, чтобы изменения вступили в силу.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nЕще раз убедитесь, что все работает правильно с помощью команды статуса.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nЕсли статус службы не установлен как активный, следуйте инструкциям на экране и повторите предыдущие шаги перед продолжением.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nТеперь у нас установлен, настроен и работает Prometheus и Node Exporter.\\n\\n## Шаг 8 - Добавление встроенного в Robonomic node_exporter\\n\\nПосле успешной установки Prometheus и node_exporter нам придется использовать встроенный экспортер Prometheus в каждом проекте подложки. Чтобы это произошло, нам нужно добавить дополнительную запись в _/etc/prometheus/prometheus.yml_.\\nОткройте файл конфигурации.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nВ конце блока scrape_configs добавьте новую запись с именем robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nСохраните файл и закройте текстовый редактор. Весь ваш файл конфигурации должен выглядеть так:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nНаконец, перезапустите Prometheus, чтобы изменения вступили в силу.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nЕще раз убедитесь, что все работает правильно, с помощью команды status.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nУ нас теперь установлены, настроены и работают _Prometheus_, _Node Exporter_ и _Robonomic Exporter_. Теперь перейдите к Grafana\\n\\n## Шаг 9 - Настройка Grafana\\n\\nПоследний шаг - подключить Prometheus в качестве источника данных в Grafana. В этом руководстве мы будем использовать бесплатную облачную версию Grafana, которая позволяет иметь до 5 панелей мониторинга, а также отдельную [панель Robonomics](https://grafana.com/grafana/dashboards/13015). Просто перейдите на [grafana.com](https://grafana.com/), создайте новую учетную запись и войдите в свою новую учетную запись Grafana.\\n\\nСначала мы должны добавить в Grafana новый _**источник данных**_, который в нашем случае будет сервером Prometheus.\\nПерейдите в раздел Источник данных:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nЗатем нажмите **_Добавить источник данных_**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nЗатем выберите _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nНа новом экране введите **_IP-адрес вашего сервера Prometheus с портом 9090_**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nПосле этого нажмите _**Сохранить и проверить**_, если вы выполнили все шаги, то должны увидеть зеленую галочку и быть готовыми к импорту панели мониторинга. На главной странице нажмите **+**, а затем **Импорт**, как показано на рисунке ниже:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nЗатем вы увидите страницу импорта:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nВ поле _URL или ID панели Grafana.com_ напишите _**13015**_ (так как это ID панели Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nПосле загрузки внешней панели мониторинга вы увидите этот экран:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nПоследний шаг - выбрать ранее созданный **_источник данных_** и нажать _**Импорт**_\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nВот и все! На этом этапе вы должны увидеть импортированную панель мониторинга. \\n\\n\\n## Ссылки\\n\\n* [Как установить Prometheus на Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Создание панели мониторинга с помощью Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Поддержка Grafana для Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Мониторинг метрик хоста Linux с помощью node exporter](https://prometheus.io/docs/guides/node-exporter/)\\n* [Запросы в Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Визуализация метрик узла](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Метрики узла Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [Панель мониторинга Node Exporter для Prometheus](https://grafana.com/grafana/dashboards/11074)\\n* [Метрики ROBONOMICS (XRT) в Grafana](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"b8c4e6eee23d18cbacc3e7afbdeb57a7\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/ru/robonomics-opengov/\",\"content\":\"\\n## Введение \\n\\nRobonomics перешел к модели управления parachain на основе сложного механизма OpenGov Polkadot, который позволяет цепочке развиваться со временем, в конечном итоге подчиняясь держателям токенов.\\nПереход Robonomics к OpenGov гарантирует, что DAO держателей токенов, контролирующих большую часть доли, всегда может управлять направлением Robonomics parachain, внедряя любые изменения в сеть, которые они считают подходящими.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov применим только к Robonomics Parachain, который является цепочкой на основе Substrate, подключенной к Kusama Relay Chain. OpenGov не применим к реализации Robonomics Ethereum, так как Ethereum mainnet в настоящее время не поддерживает сложные системы управления, такие как OpenGov.\\n</robo-wiki-note>\\n\\nOpenGov изменяет способ осуществления повседневных операций и принятия решений на parachain. Он обеспечивает большую ясность в отношении объема референдумов и имеет потенциал для значительного увеличения пропускной способности принимаемых на parachain решений.\\n\\nOpenGov уже несколько месяцев работает на релецепторной цепи Kusama на момент написания и доказал, что он значительно увеличивает количество решений (индивидуальных и дискретных референдумов), которые может предложить, проголосовать и, через голосование, в конечном итоге контролировать DAO держателей токенов.\\n\\n**Следующий контент, содержащийся в этом разделе вики, рассмотрит основные принципы OpenGov на Robonomics parachain и поможет вам лучше понять концепции, лежащие в основе OpenGov.**\\n\\n*Важно отметить, что управление - это постоянно развивающийся механизм в протоколе, особенно на ранних этапах внедрения.*\\n\\nДля тех, кто интересуется только параметрами Robonomics OpenGov Track, см. [здесь](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## О референдумах\\n\\nРеферендумы - это простые, всеобъемлющие и стейковые схемы голосования. Каждому референдуму соответствует конкретное предложение, которое принимает форму привилегированного вызова функции во время выполнения цепочек. Это также может включать самый мощный вызов `set_code``, который имеет возможность отключать весь код среды выполнения цепочек – это уникально для цепочек на основе Substrate и устраняет необходимость «хард-форка» цепочки при обновлении бизнес-логики цепочек ( время выполнения).\\n\\nРеферендумы - это отдельные события, у которых есть фиксированный период голосования (более подробно о различных периодах в жизненном цикле референдума позже). Каждый держатель токенов может голосовать по референдуму одним из трех способов - ЗА (согласен/да), ПРОТИВ (не согласен/нет) или ВОЗДЕРЖИВАТЬСЯ от голосования вообще.\\n\\nУ всех референдумов есть задержка вступления в силу. Это период между окончанием референдума и, предполагая, что референдум был одобрен, внедрением изменений в сеть. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Для каждого типа Origin установлено **Минимальное** период вступления в силу, но инициатор конкретного референдума может установить задачи этого конкретного референдума на выполнение через множество блоков в будущем\\n\\n</robo-wiki-note>\\n\\nРеферендумы считаются \\\"запеченными\\\", если они закрыты и подсчитаны голоса. Предполагая, что референдум был одобрен, он будет запланирован для вступления в силу (в планировщике цепочек). Референдумы считаются \\\"незапеченными\\\", если результат ожидается - например, если референдум все еще находится на голосовании.\\n\\nС добавлением OpenGov любой может начать референдум в любое время и может делать это столько раз, сколько пожелает. OpenGov устраняет ограничение только 1 референдума, который может быть обработан за раз (обратите внимание, что в Gov v1 можно голосовать только за 1 референдум за раз. Единственное исключение - это дополнительный экстренный референдум технического комитета, который также может одновременно быть подвергнут голосованию сообществом).\\n\\nOpenGov вводит несколько новых функций / концепций, известных как Origins и Tracks, и они вводятся для помощи в потоке и обработке референдумов в протоколе.\\n\\nКаждый Origin связан с одним классом референдума, и каждый класс связан с треком. Трек описывает жизненный цикл референдума и является специфичным для этого конкретного Origin, от которого исходит референдум. Наличие треков с их собственными специфическими параметрами позволяет сети динамически изменять жизненный цикл референдумов на основе их уровня привилегий (вы можете представить уровень привилегий как то, насколько мощным может быть референдум / какие типы изменений он может вносить в протокол).\\n\\n*Подумайте о Origins как о власти, связанной с референдумом, и подумайте о Tracks как о параметрах голосования, связанных с референдумом, таких как продолжительность его периодов и критерии одобрения и поддержки.*\\n\\nНапример, обновление времени выполнения не имеет таких же последствий для протокола, как небольшой совет по казне, и поэтому требуются разные источники, в которых будут предопределены разные результаты, одобрения, депозиты и периоды вступления в силу (Tracks) в палитрах цепочек.\\n\\n## Предложение референдума и жизненного цикла референдума\\n\\n### Период подготовки\\n\\nВ OpenGov, когда референдум впервые создается, его можно сразу же проголосовать сообществом держателей токенов. Однако он не находится немедленно в состоянии, когда он может завершиться или иначе быть учтенным, одобренным и немедленно введенным в действие. Вместо этого референдумы должны соответствовать ряду критериев, прежде чем они будут перемещены в период принятия решений. До тех пор, пока референдумы не войдут в период принятия решений, они останутся нерешенными и в конечном итоге истечут после общего периода жизненного цикла, указанного в отдельном треке.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nКритерии для входа референдума в период принятия решений следующие:\\n1. Период подготовки, который определяет время, которое должно пройти, прежде чем начнется период принятия решений. Этот период подготовки помогает снизить возможность \\\"снайпинга решений\\\", когда злоумышленник, контролирующий значительное количество голосов, может попытаться использовать свою большую долю, чтобы референдум был принят сразу после предложения, обойдя возможность для других участников DAO держателей токенов иметь достаточно времени для рассмотрения референдума и участия в голосовании. Вот почему у источников с более высокими привилегиями значительно более длительные периоды подготовки.\\n\\n2. Должно быть место для принятия решения. Каждый трек имеет свои ограничения на количество референдумов, которые могут быть приняты одновременно (max_deciding). Треки с более высокими привилегиями будут иметь более низкие ограничения. Например, источник на уровне Root будет иметь значительно меньшее количество референдумов, которые могут быть приняты одновременно, по сравнению с источниками на более низком уровне привилегий, такими как источник Small Tipper.\\n\\n3. Должен быть представлен депозит принятия решения. Создание референдума изначально довольно дешево, и стоимость депозита подачи (зарезервированного при создании референдума) довольно низкая и в основном состоит из стоимости хранения на цепочке, связанного с референдумом. Депозиты принятия решений значительно выше, что требуется для борьбы со спамом и влияет на экономическую игру, которую предлагает OpenGov, о которой мы расскажем позже.\\n\\nКогда все три вышеуказанных критерия будут выполнены, референдум перейдет в период принятия решений. Затем голоса по референдуму будут учтены для определения результата.\\n\\n### Период принятия решений\\n\\n*Для быстрого видеодемонстрации периода принятия решений см. [это видео](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nКогда референдум соответствует всем критериям, описанным в предыдущем разделе, он переходит в период принятия решений.\\n\\nПериод принятия решений основан на двух основных концепциях: одобрение и поддержка. \\n\\nОдобрение определяется как доля веса голосования за одобрение (ЗА против ПРОТИВ) по сравнению с общим весом голосования (все голоса ЗА и ПРОТИВ в совокупности). Убеждение каждого голоса учитывается в общем весе голосов ЗА/ПРОТИВ (подробнее о голосовании с убеждением / добровольной блокировке в следующем разделе).\\n\\nПоддержка - это общее количество голосов (токенов), которые приняли участие в референдуме (и не корректируются на основе убеждения) по сравнению с общим возможным количеством голосов, которые могут быть отданы в системе (подумайте об этом как о общем выпуске XRT на парачейне - примечательно, что общее количество обращающихся в обороте XRT здесь не является главным фактором, поскольку некоторая часть этого числа существует на Ethereum в виде токенов ERC-20).\\n\\n**Голоса, которые относятся к НЕТ, не вносят вклад в критерии одобрения, но включаются / учитываются в критерии поддержки**\\n\\nРеферендум должен соответствовать критериям поддержки И одобрения в период принятия решений, чтобы продвинуться в период подтверждения.\\n\\nДля получения подробной информации о критериях поддержки и одобрения для каждого трека см. эту [таблицу](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Период подтверждения\\n\\nУ каждого трека есть свой собственный определенный срок для его периода подтверждения. Треки с более высокими привилегиями (например, Root) имеют значительно более длительные периоды подтверждения, чем те, у которых привилегии ниже (например, Small Tipper).\\n\\nРеферендумы должны продолжать соответствовать критериям поддержки и одобрения на протяжении всего периода подтверждения, в противном случае они снова вернутся в период принятия решений (примечание: период принятия решений не приостанавливается во время периода подтверждения, поэтому вполне возможно, что период принятия решений может истечь во время периода подтверждения, что означает, что если референдум выходит из периода подтверждения из-за того, что он больше не соответствует критериям поддержки и одобрения, он будет считаться неудачным референдумом и не будет введен в действие).\\n\\n**Возможно настроить критерии поддержки и одобрения для отдельных треков через референдум с привилегиями Root Origin.**\\n\\nОригины с более низкими уровнями привилегий имеют значительно более простые критерии одобрения и поддержки (установленные треком), чем те, у которых уровень привилегий выше. Аналогично, оригины с более высокими уровнями привилегий имеют менее крутые кривые, чем те, у которых меньше привилегий (как определено в треке), чтобы гарантировать, что DAO держателей токенов действительно одобряет референдум и избежать саботажа референдума с высоким уровнем привилегий.\\n\\nВ OpenGov референдумы, которые не одобрены после истечения периода принятия решения, считаются отклоненными по умолчанию, и как вклады подачи, так и решения возвращаются их инициаторам (примечание: вклад в решение может быть размещен кем-то, отличным от инициатора референдума).\\n\\nЕсли референдум продолжает соответствовать критериям одобрения и поддержки на протяжении всего периода подтверждения, он считается одобренным и будет запланирован для выполнения из предложенного источника, но референдум будет выполнен только после истечения минимального периода вступления в силу.\\n\\n### Период вступления в силу\\n\\nПериод вступления в силу указывается инициатором при предложении референдума, но он подчиняется минимальному периоду вступления в силу, указанному в каждом треке. Более мощные источники имеют гораздо более высокий минимальный период вступления в силу, чем те, у которых меньше привилегий. Это гарантирует, что сеть имеет достаточно времени для подготовки к любым изменениям, которые может внести мощный референдум.\\n\\n## Добровольная блокировка / голосование по убеждению\\n\\nRobonomics использует концепцию, известную как добровольная блокировка или голосование по убеждению. Это позволяет держателям токенов увеличивать свою избирательную силу, решая, насколько долго они готовы заблокировать свои токены для конкретного референдума. Этот механизм влияет только на критерии одобрения для каждого референдума, и голосование по убеждению не влияет на критерии поддержки.\\n\\nГолосование по убеждению можно рассчитать с помощью следующей формулы:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nВ этой таблице показано, как каждый уровень увеличения периода блокировки умножает ваш голос по критериям одобрения:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nМаксимальное количество убеждения, которое может использовать держатель токенов, составляет 6x убеждение. Вы можете установить убеждение только в соответствии с таблицей выше, и вы не можете, например, использовать 5,5x убеждение.\\n\\nПока токен заблокирован из-за голосования, его все равно можно использовать для голосования в других референдумах, однако он не будет являться частью вашего передаваемого баланса (вы не можете отправить его на другой счет), и баланс станет передаваемым снова только после истечения всего периода блокировки.\\n\\n## Делегирование голосов\\n\\nВ OpenGov был добавлен механизм, позволяющий держателям токенов, у которых, возможно, нет достаточно времени для рассмотрения каждого референдума, все равно использовать свои токены в качестве части системы управления, это известно как делегирование голосов.\\n\\nДержатели токенов могут выбрать делегировать свою избирательную силу другому голосующему в системе (другому аккаунту). Голосующие могут указать, чтобы их избирательная сила была делегирована в гибком режиме, позволяющем им назначать свою избирательную силу другому аккаунту для каждого отдельного источника. Голосующие также могут установить разное количество избирательной силы для каждого источника (количество токенов и уровень убеждения).\\n\\nЭта функция делегирования имеет одну цель - увеличить явку избирателей и помочь обеспечить выполнение критериев одобрения и поддержки.\\n\\nЧтобы делегировать свою избирательную силу, вы можете использовать функцию \\\"Delegate\\\", которую вы можете найти в разделе Governance -> Referendum [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). Кроме того, пользователи могут отправить экструзию convictionVoting(Delegate), используя раздел Developer -> Extrinsics Robonomics Portal, однако использование функции \\\"Delegate\\\" раздела референдума портала намного проще.\\n\\n## Отмена / уничтожение референдума и экономическая игра управления\\n\\nВ OpenGov есть источники, которые посвящены отклонению текущих референдумов, независимо от их статуса. Это известно как треки Governance Canceller и Governance Killer.\\n\\nЭти источники вмешиваются в референдум, который уже был проголосован. Если референдум, исходящий от них, одобрен, он немедленно отклоняет текущий референдум, независимо от его статуса. \\n\\nОтмена сама по себе является типом референдума, который должен быть проголосован держателями токенов для выполнения. Отмена имеет свой собственный источник и трек, у которых меньше времени на принятие решения (период принятия решения и т. Д.) и кривые одобрения и поддержки с более крутыми/резкими кривыми (что означает, что их критерии гораздо легче выполнить со временем), чем у других источников. Это связано с тем, что отмена референдума обычно сопровождается чувством срочности.\\n\\nGovernance Canceller стремится мгновенно отклонить уже идущий референдум. Когда референдум отменяется этим источником, как податели, так и инициаторы референдума получают обратно свои депозиты по решению. Примером отмены референдума может быть случай, когда инициатор допустил человеческую ошибку в содержании своего референдума и не обязательно предпринимал злонамеренные действия.\\n\\nGovernance Killer стремится мгновенно отклонить уже идущий референдум. Здесь вступает в игру экономическая игра управления. Источники с высоким уровнем привилегий, такие как Root, имеют депозит по решению, который требует большого количества капитала (токенов XRT), чтобы быть размещенным, чтобы референдум мог войти в период принятия решения. \\n\\nЕсли злонамеренный актор представляет референдум, например, референдум с корневыми источниками, который стремится `set_code` времени выполнения цепи на что-то, что остановит цепь в производстве блоков, то DAO держателей токенов может поднять контрольный референдум Governance Killer для наказания этого действия. Если злонамеренный референдум отклонен через источник Governance Killer, то и подача, и решение депозитов сокращаются, что означает, что инициатор (аккаунт(ы), разместившие эти депозиты) потеряют эти средства. \\n\\nЭто означает, что для злонамеренных акторов существуют серьезные экономические последствия при попытке поднять референдум, который может иметь серьезные негативные последствия для цепи, что в теории остановит любого злонамеренного актора от попытки сделать это.\\n\\nДепозит по решению для самого трека Governance Killer довольно высокий, это сделано для того, чтобы остановить равно злонамеренных акторов от попыток сократить депозиты в противном случае хорошего референдума. **Существующий референдум Governance Killer может быть уничтожен последующим референдумом Governance Killer.**\\n\\n## Технический комитет Robonomics и источник из белого списка\\n\\nЭта группа - самоуправляемый экспертный орган, целью которого является представление людей, воплощающих и обладающих техническими знаниями сетевого протокола Robonomics. \\n\\nЭта группа (и только эта группа) может инициировать референдумы из палитры Whitelist. Эта палитра делает одну вещь: она позволяет одному источнику повысить уровень привилегий другого источника для определенной операции. \\n\\nЭта группа может авторизовать референдум от источника, известного как Whitelisted-Root, и эти референдумы могут выполняться с привилегиями Root, но эти референдумы будут успешно работать только с определенными уполномоченными командами, утвержденными группой. Палитра Whitelist проверяет две вещи:\\n1. Источник действительно является Whitelisted-Root (т.е. что референдум прошел через этот трек источника).\\n2. Предложение действительно было включено в белый список группой.\\n\\nЕсли оба условия верны, то операция будет выполняться с привилегиями Root.\\n\\nЭта система позволяет создать новый параллельный трек (источник Whitelisted-Root), параметры которого позволяют сократить время голосования (критерии утверждения и поддержки немного проще, чем у Root). Этот открытый и прозрачный процесс позволяет этой группе экспертов по протоколу сети Robonomics предлагать референдумы, которые они считают безопасными и критическими по времени.\\n\\nСледует отметить, что критерии поддержки для референдума, инициированного с источника Whitelisted-Root, не стремятся к 0, как многие другие источники/треки. Это гарантирует, что эта группа не имеет де-факто контроля над всем протоколом сети Robonomics и требует минимального уровня поддержки (явки избирателей) от общего DAO держателей токенов.\\n\\n\\n## Referendum Durations \\n\\nВажно понимать, что продолжительность каждого отдельного референдума не является конкретной вещью, она не установлена в камне. Некоторые периоды в жизненном цикле референдума, такие как минимальный период принятия решения, действительно имеют конкретную продолжительность, однако другие, включая период принятия решения, этого не имеют. Например, нельзя точно сложить максимальные продолжительности периодов Подготовки, Принятия решения, Подтверждения и Минимального периода принятия решения и заявить, что \\\"каждый референдум займет X количество дней\\\", это намного более гибко.\\n\\nДавайте рассмотрим это с точки зрения нескольких отдельных референдумов, все из которых исходят из одного источника, в данном случае, корневого источника. \\n\\nУ корневого источника есть свой собственный трек, где установлены продолжительности каждого периода, а также кривые утверждения и поддержки.\\n\\nВажно помнить, что референдумы будут продвигаться на следующий этап своего жизненного цикла только в том случае, если будут выполнены определенные условия. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nВы должны предполагать на следующих изображениях, что для того, чтобы референдум перешел на следующий этап своего жизненного цикла, должны быть выполнены условия, описанные на предыдущем изображении (если не указано иное).\\n\\n\\n### Максимально возможная продолжительность с очень низкой явкой избирателей\\n\\nНиже приведено изображение, представляющее максимально возможный график для референдума, можно считать, что это референдум, который:\\n1. Имеет размещенный депозит по решению и, следовательно, перешел в период принятия решения.\\n2. Имеет один голос, например, 1 XRT, в сторону AYE - это означает, что она будет соответствовать требуемой поддержке (явка избирателей) только в самом конце периода принятия решения (поскольку общая поддержка крайне низкая), но имеет 100% одобрение, поэтому в конечном итоге будет соответствовать требованиям для входа в период подтверждения.\\n3. Продолжает соответствовать вышеуказанным критериям во время периода подтверждения.\\n4. Предложение, поднятое референдумом, будет введено точно на том же блоке, что и окончание минимального периода введения в действие - технически инициатор референдума может установить изменения в сети, подробно описанные в референдуме, чтобы ввести в действие множество блоков в будущем, поэтому реальный жизненный цикл отдельного референдума может охватывать много дней, недель, месяцев или лет.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nМы видим, что в этом примере жизненный цикл референдума составит (приблизительно) 17 дней.\\n\\n\\n### Duration with a lot of voter turnout (with a high amount of AYE votes)\\n\\nТеперь давайте посмотрим на референдум, в котором держатели токенов XRT проявили большой интерес. В этом примере мы предположим, что общая явка избирателей составила около 248 771 XRT, и все избиратели голосуют в сторону AYE (примечание: технически на этом этапе корневого референдума, согласно треку, только 60% голосов должны быть в сторону AYE, чтобы референдум соответствовал критериям одобрения).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Всегда обращайтесь к самой актуальной информации о треке для точной информации о каждом треке, дополнительную информацию можно найти в этой [таблице](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nВ этом примере:\\n1. Решение о депозите было опубликовано во время периода подготовки, и поэтому оно смогло перейти в период принятия решения в конце периода подготовки.\\n2. Многие избиратели проголосовали по этому референдуму - получив явку избирателей около 248 771 XRT за относительно короткое время.\\n3. Голоса были преимущественно в сторону AYE (более 60% AYE).\\n4. Референдум продолжительное время соответствует критериям периода подтверждения (Примечание: Если референдум перестает соответствовать критериям периода подтверждения, то он возвращается в период принятия решения).\\n5. Предложение, поднятое референдумом, будет введено точно на том же блоке, на котором заканчивается минимальный период введения в действие.\\n\\nИз-за того, что явка избирателей составила около 248 771 XRT, референдум будет соответствовать критериям для входа в период подтверждения через примерно 168 часов (7 дней).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nМы видим, что в этом втором примере из-за того, что было много явки избирателей, период принятия решения фактически закончился на полпути к его максимально допустимому времени. В результате получается референдум, который может быть введен в действие через примерно 10 дней.\\n\\n\\n### Продолжительность, когда решение о депозите никогда не опубликовано\\n\\nТеперь давайте посмотрим на референдум, который был инициирован, но никогда не имел опубликованного решения о депозите. Такие референдумы находятся в своего рода \\\"лимбе\\\", где их период подготовки закончился, но поскольку решение о депозите не было опубликовано, референдум остается в состоянии \\\"подготовки\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nМы видим, что в этом третьем примере из-за того, что решение о депозите никогда не было опубликовано, референдум фактически никогда не войдет в период принятия решения, вместо этого он остается в состоянии \\\"подготовки\\\". Это означает, что в конечном итоге, если решение о депозите никогда не будет опубликовано, референдум завершится по истечении времени, указанного в константе timeOut палета.\\n\\nЭто уже случалось на Kusama, когда референдум был опубликован с корневыми источниками, но из-за высоких требований к капиталу для опубликования решения о депозите референдум никогда не вошел в последующие этапы своего жизненного цикла. Такие референдумы завершаются с флагом \\\"истек срок\\\".\\n\\n\\n### Продолжительность, когда решение о депозите опубликовано поздно\\n\\nНаконец, давайте рассмотрим пример, когда решение о депозите было опубликовано довольно поздно после того, как референдум был инициирован. Это уже случалось на Kusama, когда референдум был опубликован с корневым источником, но инициатору потребовалось время, чтобы найти кого-то с большим количеством капитала, чтобы опубликовать решение о депозите от его имени.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nВ этом последнем примере из-за того, что решение о депозите было опубликовано после окончания периода подготовки, но до истечения срока референдума, жизненный цикл референдума на самом деле гораздо длиннее обычного, поскольку он входит в период принятия решения после более длительного времени.\\n\\nВажно отметить, что держатель токенов DAO может голосовать ЗА/ПРОТИВ по референдумам, находящимся в периоде подготовки или застрявшим в состоянии \\\"подготовки\\\".\\n\"}},{\"node\":{\"id\":\"c1e33869b7564da2b1be1093d8370b97\",\"title\":\"Настройка интеграции Robonomics\",\"path\":\"/docs/ru/robonomics-hass-integration/\",\"content\":\"\\n**В этой статье вы добавите Robonomics в Home Assistant. Это позволяет Home Assistant записывать журналы данных с зашифрованными данными в Robonomics Parachain и прослушивать команды запуска от парачейна для управления умными устройствами. Интеграция использует IPFS для хранения данных и отправки хэшей IPFS в функции журнала данных или запуска.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. В веб-интерфейсе Home Assistant перейдите в `Settings` -> `Device & Services` и нажмите `ADD INTEGRATION`. Найдите `Robonomics`.\\n\\n2. Нажмите на Robonomics и заполните конфигурацию: \\n\\n- Добавьте seed из аккаунта `SUB_CONTROLLER` в seed аккаунта контроллера.\\n- Добавьте публичный адрес аккаунта `SUB_OWNER` в адрес владельца подписки.\\n- Установите интервал отправки данных (по умолчанию 10 минут).\\n- (По желанию) Вы можете добавить учетные данные для сервиса пиннинга Pinata или другого пользовательского шлюза, чтобы распространить свои данные шире по сети IPFS.\\n\\n3. Нажмите `Отправить` после завершения конфигурации. Если вы заполнили все правильно, вы увидите окно успешного завершения.\\n\\nВот и все! Вы полностью настроили Интеграцию Робономики в Home Assistant. Теперь вы можете использовать все\\nвеб-сервисы Robonomics. Чтобы узнать больше о них, перейдите в раздел [\\\"Использование\\\".](/docs/global-administration)\\n\"}},{\"node\":{\"id\":\"e0e58c471d663b89fbb2715cdcdf808d\",\"title\":\"Python-интерфейс и Robonomics IO\",\"path\":\"/docs/ru/rinterface/\",\"content\":\"\\n**Некоторые экстрансики, реализованные в палетах Robonomics, сложно отправить из приложения Polkadot. Более того, есть \\nнеобходимость взаимодействия с этой функциональностью с использованием языков программирования. Для этой цели был разработан простой инструмент на Python\\nназываемый [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface). Это обертка над поддерживаемым polkascan \\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). Ниже приведено краткое описание этого пакета\\nи некоторые полезные ссылки и примеры. Также обсуждаются инструменты командной строки.**\\n\\n## robonomics-interface\\n\\nДоступно на [PyPi](https://pypi.org/project/robonomics-interface/) готовый пакет для загрузки и установки.\\nТакже имеется подробная сгенерированная из docstring [документация](https://multi-agent-io.github.io/robonomics-interface/).\\n\\nВ целом, это инструмент для разработчиков, которые хотят взаимодействовать с блокчейном Robonomics с помощью программных инструментов. Почти \\nвсе проекты на Python команды Robonomics, которые взаимодействуют с парачейном, используют этот интерфейс.\\n\\n### Установка\\n\\nПроцесс установки требует наличия у пользователя установленного Python 3.8 или выше. Ни `x86`, ни `arm7`, ни `arm8`\\nархитектуры не требуют процесса компиляции. Все пакеты собраны и опубликованы разработчиками зависимостей.\\n\\nВ качестве инструмента установки используется `pip`:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Пример использования\\n\\nОсновная идея заключается в создании экземпляра `Account` и использовании его для создания экземпляров, связанных с палетами.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  Также возможно использование пользовательских конечных точек (например, локального узла для тестирования):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nТакже возможно отправлять экстрансики:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Как уже было сказано, больше примеров доступно на странице [документации](https://multi-agent-io.github.io/robonomics-interface/).\\n\\n</robo-wiki-note>\\n\\n## Инструмент командной строки\\n\\n`robonomics-interface` также содержит инструменты командной строки Python `click`, которые можно использовать для прототипирования и быстрых тестов. Он устанавливается\\nвместе с пакетом и доступен в терминале:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nВы можете попробовать использовать его с локальным узлом. Принят философия конвейера.\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"8dbd51b178ad292634e065ea93b2da41\",\"title\":\"Robonomics на Ethereum\",\"path\":\"/docs/ru/robonomics-ethereum/\",\"content\":\"\\nВся информация о Robonomics на Ethereum переехала в репозиторий GitHub. Вся необходимая информация может быть найдена [здесь.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"a43d90e7199ef7700edfd7b53c3c2e69\",\"title\":\"Управление PTZ-камерой в Home Assistant\",\"path\":\"/docs/ru/ptz-camera/\",\"content\":\"\\nВ этой статье рассматривается процесс настройки PTZ-камеры в Home Assistant. \\nБудет использоваться протокол ONVIF. Для этого требуется локальная учетная запись камеры.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nПроцесс настройки локальной учетной записи камеры не рассматривается в этой статье.\\n</robo-wiki-note>\\n\\nТребования:\\n- PTZ-камера\\n- Локальная учетная запись камеры\\n- IP-адрес камеры\\n- Настроенный Home Assistant\\n\\n## Интеграция ONVIF\\n\\nДавайте начнем с установки **интеграции ONVIF**. \\n\\nПерейдите в раздел \\\"Devices & Services\\\" в \\\"Settings\\\" и нажмите кнопку \\\"ADD INTEGRATION\\\".\\nВведите \\\"ONVIF\\\" и выберите интеграцию. Вы увидите следующее окно.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nНажмите кнопку \\\"Submit\\\". Она попытается автоматически найти вашу камеру. Если успешно, \\nвыберите свою камеру из списка и заполните пустые поля. \\nВ противном случае вам придется заполнить все поля вручную. Вы увидите следующее окно.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nЗаполните пробелы:\\n- Name - дайте имя вашей камере\\n- Host - укажите IP-адрес вашей камеры\\n- Port - обычно это 2020 год, но ваш поставщик камеры может изменить его\\n- Username - напишите имя пользователя вашей локальной учетной записи камеры\\n- Password - напишите пароль для вашей локальной учетной записи камеры\\n\\nи нажмите \\\"Submit\\\". Выберите область для вашей камеры и нажмите \\\"Завершить\\\".\\n\\n## Добавьте управление камерой на панель инструментов\\n\\nТеперь, когда вы полностью настроили камеру, вы можете добавить ее поток и кнопки управления на панель инструментов.\\n\\nПерейдите на панель инструментов и начните с создания новой карты. Выберите \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nЗаполните данные:\\n- Title - выберите заголовок изображения камеры\\n- Camera Entity - выберите сущность камеры из выпадающего списка\\n- Camera View - выберите \\\"live\\\", чтобы получить меньшую задержку\\n\\nЗатем переключитесь в режим \\\"Code Editor\\\", нажав кнопку в левом нижнем углу. Вы увидите следующий код:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nЗамените содержимое `entities: []` в соответствии с примером ниже (`<YOUR_CAMERA_ENTITY>` такой же, как параметр `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nВот и все. Теперь вы должны увидеть карту PTZ-камеры на панели инструментов вместе с кнопками управления.\\n\\n## Устранение неполадок\\nЕсли вы используете Ядро Home Assistant и не видите поток с камеры, вам следует установить интеграции `stream` и `FFMPEG`. \\nДля этого вам нужно добавить строки `stream: ` и `ffmpeg: ` в конец configuration.yaml.\"}},{\"node\":{\"id\":\"4fbab2ab5e451f7167496c7f2855ca67\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/ru/notifications/\",\"content\":\"\\nВы можете получать уведомления на свой смартфон с помощью [notify](https://notify.events/). Сначала зарегистрируйтесь там и на `Control Panel` создайте новый канал:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nДобавьте заголовок и нажмите `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nЗатем нажмите `Add Source` и выберите `Home Assistant` во вкладке `IoT and Smart Home` tab:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nНапишите заголовок и нажмите `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nТам вы увидите токен, который вам нужно добавить в файл конфигурации для Home Assistant. Сохраните его где-нибудь и нажмите `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nзатем нажмите `Subscribe`, чтобы добавить подписчиков:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nВыберите любого подписчика, которого вы хотите, и следуйте инструкциям.\\n\\nТеперь вам нужно отредактировать конфигурацию на вашем компьютере с помощью Home Assistant. Откройте файл `configuration.yaml` под пользователем `homeassistant`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nИ добавьте эти строки:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nТакже добавьте новую автоматизацию после строки `automation:`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nЭта автоматизация будет отправлять сообщение `Door was changed to on/off` после изменения состояния датчика с идентификатором сущности `binary_sensor.contact_sensor_contact` с `off` на `on`.\\n\\nИ перезапустите Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"87cbbb4087aa49ec1fb5f29b522ca88e\",\"title\":\"Liability\",\"path\":\"/docs/ru/liability/\",\"content\":\"\\n**Чтобы превратить роботов в экономические агенты, нужен инструмент контракта. Знакомьтесь с Liability - паллет Robonomics, реализующий\\nконтракты между учетными записями parachain!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Обратите внимание, что этот учебник демонстрируется на локальном экземпляре Robonomics Node. Настройте свой с помощью [этих инструкций](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Обзор теории\\n\\nНа Ethereum была довольно сложная структура взаимодействия с ответственностью. Вы можете ознакомиться с ней \\n[здесь](/docs/robonomics-how-it-works). В наши дни с Kusama все немного проще!\\n\\n### Переговоры\\n\\nДля подписания контракта стороны должны сначала провести переговоры. Это может быть сделано несколькими способами, включая \\n[IPFS PubSub](https://blog.ipfs.tech/25-pubsub/) или Robonomics PubSub. Пример кода на Python с использованием Robonomics PubSub \\nпредставлен [здесь](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub). \\n\\nПредложение и спрос - это сообщения, содержащие две основные характеристики контракта: **описание работы** и **цена**. Формат сообщения\\nдолжен быть разработан пользователем для каждого конкретного приложения. Важно не соблюдать строгое правило формата в процессе переговоров.\\nВозможный ход представлен на рисунке ниже.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Обратите внимание, что PubSub - это открытый протокол, поэтому нельзя передавать конфиденциальные данные. Для этого следует использовать другие протоколы.\\n\\n</robo-wiki-note>\\n\\n\\n### Signatures\\n\\nКогда переговоры успешно завершены, каждая сторона должна подписать свое так называемое соглашение, названное подписью. Это \\nсообщение, содержащее описание работы и цену **в определенном формате**, подписанное с помощью закрытого ключа учетной записи. Для этого есть \\n[инструмент на Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability).\\n - Описание работы называется **техника**. Это строка длиной 32 байта, похожая на запуск, которая может быть закодирована в IPFS CID.\\n - Цена называется **экономика**. Это десятичное число XRT - Вейнер. 1 Вейнер = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Вы можете получить [IPFS](https://ipfs.tech/) CID, отформатированный правильно, с помощью [библиотеки на Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  При использовании функции `sign_liability` нет необходимости преобразовывать хеш, это будет сделано автоматически.\\n\\n</robo-wiki-note>\\n\\nСледуя примеру с кофе:\\n\\n1. Задача - это JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Его IPFS CID - `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Таким образом, **техника** (преобразованный CID) - `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **Экономика** составляет `1.5 XRT`.\\n\\nКогда подписано, пришло время создать обязательство! Это может быть сделано одной из сторон (либо обещающей стороной, либо обещателем), либо \\n3-ей стороной, так называемым поставщиком.\\n\\n## Создать обязательство\\n\\n### Подготовка\\n\\nКак уже упоминалось ранее, в процессе участвуют как минимум две стороны. В этом примере давайте используем три и создадим\\nотдельного поставщика для этого. Предположим, что переговоры уже состоялись каким-то образом.\\n\\n### 1. Создайте три аккаунта и добавьте на них средства\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nЗдесь мы предоставили поставщику 100 XRT для подписи внешних обязательств, обещающей стороне было предоставлено 2 XRT для оплаты работы.\\nОбещатель не получил никаких средств (за исключением существенного депозита не менее 1 мXRT).\\n\\n### 1. Перейдите в Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Выберите liability -> create из выпадающего списка возможных внешних обязательств\\n\\nТакже выберите аккаунт, с которым вы хотите отправить extrinsic. Заполните все параметры.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  Поскольку здесь используется поставщик, нет необходимости знать семена участников. Необходимы только их подписи.\\n\\n</robo-wiki-note>\\n\\n### 3. Отправьте транзакцию\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Просмотрите свое обязательство в событиях\\n\\nДля этого перейдите в `Network -> Explorer`  и найдите список событий справа. Нажмите на треугольник, чтобы развернуть его.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  Хэш может быть преобразован в IPFS CID с тем же \\n  [Python tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Исследование хранения\\n\\nВы также можете изучить некоторые характеристики обязательств в модуле хранения `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  Функция хранения `Next Index` показывает последний индекс обязательства +1, поэтому, даже если это `1`, обязательство `0` исследуется.\\n\\n</robo-wiki-note>\\n\\n## Отчеты\\n\\nПредставьте себе, что кофе был приготовлен, и теперь кофеварке нужно somehow сообщить об этом. Вот где появляются отчеты об обязательствах\\n. В качестве доказательства труда аккаунт добавляет еще один IPFS CID в качестве содержимого отчета при завершении существующего\\nобязательства. Для этого также требуется подпись обещателя.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  Подписанное сообщение содержит существующий индекс обязательства и IPFS CID отчета, закодированный в 32-байтовом представлении. Опять же,\\n  [инструмент Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) может помочь подписать отчет.\\n\\n</robo-wiki-note>\\n\\nПродолжая пример с кофеваркой:\\n\\n1. Отчет - это JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Его IPFS CID - `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. Таким образом, **payload** (преобразованный CID) — это `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2` \\n4. **Индекс** - `0`, это существующий индекс обязательства.\\n\\n### 1. Перейдите к extrinsics, liability -> finalize(report)\\n\\nЗаполните параметры и отправьте внешнее обязательство. Опять же, это может быть сделано 3-ей стороной. \\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Обратите внимание, что учетная запись обещателя не должна быть \\\"мертвой\\\" - у нее должен быть существенный депозит не менее 1 мXRT.\\n\\n</robo-wiki-note>\\n\\nПодпишите и отправьте отчет. После выполнения вы можете изучить его в событиях.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Исследуйте reports\\n\\nВы также можете наблюдать отчет в хранилище. Перейдите в `Developer -> Storage` и выберите `liability` из выпадающего списка.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Проверьте балансы\\n\\nНа картинке показано, что теперь обещатель получил \\\"зарплату\\\". Произошли экономические отношения!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Проверка\\\">\\n\\n  На данный момент нет способа проверить, выполнена ли работа, поэтому как только обещатель сообщает, токены переводятся на его счет.\\n  Функция проверки будет добавлена в будущем.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"73b43206cf9e614648cdf93a21d55888\",\"title\":\"Запуск\",\"path\":\"/docs/ru/launch/\",\"content\":\"\\n**Еще одна основная функция Robonomics parachain - это паллет Launch. Он позволяет отправлять команды на учетные записи/любые сущности, стоящие за ними. Эти команды включают параметр, определяющий задачу, которую нужно выполнить.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Обратите внимание, что эти и следующие учебники демонстрируются на локальном экземпляре узла Robonomics. Настройте свой с помощью [этих инструкций](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Перейдите в Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Выберите launch -> launch из выпадающего списка возможных экстрансиксов\\n\\nТакже выберите учетную запись, с которой вы хотите отправить экстрансикс. Заполните поле целевого адреса и параметров.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Launch поддерживает команды длиной 32 байта в виде строк ([источник](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)),\\n  поэтому здесь есть место для импровизации:\\n  - Для базовых команд, таких как переключение, вы можете использовать \\\"0x0000000000000000000000000000000000000000000000000000000000000001\\\" или\\n  \\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\".\\n  - Для расширенных команд, включая json-подобные, вы можете использовать [IPFS](https://ipfs.tech/) CID, отформатированный в \\n  [правильном формате](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Отправьте транзакцию\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Просмотрите свой запуск в событиях\\n\\nДля этого перейдите в *Сеть -> Проводник* и справа найдите список событий. Нажмите значок треугольника, чтобы развернуть его.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"8f088856820b34852c5b233b590a7c2c\",\"title\":\"Как обновить версию узла Robonomics Collator\",\"path\":\"/docs/ru/how-to-update-collator-node-version/\",\"content\":\"\\nРекомендуется прочитать следующие статьи перед прочтением этого поста: [\\\"Как построить узел Collator\\\"](/docs/how-to-build-collator-node) и [\\\"Как запустить Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nВ этой статье приведены команды, необходимые для обновления узла Robonomics collator (работающего на Ubuntu), а также приведен пример после этого.\\n\\n## **Необходимые команды**\\n\\n0. Прежде чем начать, рекомендуется войти в систему под учетной записью `root`, если нет, то рекомендуется использовать:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Остановите службу Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Удалите предыдущую версию Robonomics (убедитесь, что вы находитесь в правильном каталоге):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Получите [последний релиз](https://github.com/airalab/robonomics/releases) версии Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Извлеките файл:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Переместите файл:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nВам нужно переместить этот файл в правильный каталог, в который вы установили узел Robonomics)\\n\\n</robo-wiki-note>\\n\\n6. Запустите Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nПример обновления узла коллатора до Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Изменение базы данных Kusama Relay Chain без установленного базового пути**\\n\\nИногда определенные снимки Kusama Relay Chain вызывают ошибки в вашем узле. Это часто приводит к остановке работы вашего узла. Пример ошибки, вызванной поврежденной базой данных Relay Chain:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nЧтобы исправить эту ошибку, вы должны удалить существующую базу данных Kusama Relay Chain (скорее всего RocksDb) и заменить ее другой базой данных, такой как ParityDb. Выполните следующие команды:\\n\\n1. Найдите каталог узла Robonomics и проверьте файлы:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Убедитесь, что вы видите каталог polkadot, а затем перейдите в каталог chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Удалите каталог `ksmcc3`:\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Создайте новый каталог `ksmcc3`:\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Теперь вам нужно загрузить новый снимок. В этом примере используется сильно усеченный снимок ретрансляционной цепи, но вы можете заменить его на любой предпочитаемый снимок.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Пока снимок загружается, откройте новую сессию и отредактируйте ваш сервисный файл:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nИзмените строки в сервисном файле, относящиеся к базе данных и усечению:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nИспользуйте `Ctrl + S`, а затем `Ctrl + X`, чтобы сохранить и выйти из сервисного файла.\\n\\n7. Теперь вам нужно перезагрузить ваш демон.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. К этому времени, в вашей другой сессии, надеюсь, новая база данных загрузилась, поэтому извлеките файл:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. После завершения распаковки выполните следующее:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Теперь вы можете запустить сервис, отслеживать возможные ошибки и проверить, что он соединяется как с ретрансляционной цепью, так и с парачейном.\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"ecca4bfed90a3196e6796d133d28379d\",\"title\":\"Обновите вашу Home Assistant OS\",\"path\":\"/docs/ru/hass-os-upgrade/\",\"content\":\"\\n**Эта статья содержит инструкции по обновлению вашей существующей Home Assistant OS с интеграцией Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Установка IPFS Add-on\\n\\n\\nИнтеграция Робономики хранит данные с помощью локального демона IPFS, поэтому его необходимо сначала установить.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. Для Home Assistant существует [дополнение IPFS](https://github.com/airalab/ipfs-addon). Чтобы установить его, перейдите в  `Settings` -> `Add-ons` и нажмите кнопку `ADD-ON STORE` в правом нижнем углу.\\n\\n2. Нажмите на три точки в правом верхнем углу и выберите `Repositories`. Добавьте туда следующую ссылку:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Нажмите кнопку `ADD`.\\n\\n4. Закройте менеджер репозиториев и обновите страницу. Теперь в конце страницы вы увидите дополнение IPFS Daemon.\\n\\n5. Откройте дополнение и нажмите `INSTALL`. После установки нажмите `START`.\\n\\n## Установите HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) позволяет устанавливать пользовательские интеграции.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Прежде чем начать, вам нужно установить дополнение для подключения к устройству Home Assistant с помощью SSH. В магазине дополнений найдите `ssh`. Мы рекомендуем установить дополнение `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Если дополнение SSH не найдено, попробуйте включить режим расширенного режима в настройках вашего профиля пользователя. Для этого нажмите на значок профиля в левом нижнем углу и найдите опцию Расширенный режим.\\n\\n</robo-wiki-note>\\n\\n2. Выберите дополнение и нажмите `INSTALL`. После завершения установки перейдите на вкладку `Configuration` и добавьте `password` или `authorized_keys`. Не забудьте сохранить эту часть конфигурации.\\n\\n3. На вкладке `Info` нажмите `START`. Если вы хотите видеть дополнение в боковой панели, не забудьте включить `Показывать в боковой панели`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Откройте SSH Add-on и выполните следующую команду:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Перезагрузите Home Assistant (вы можете сделать это в `Settings`->`System`). \\n\\n6. Теперь интеграция HACS будет доступна для добавления в меню `Integrations`. Перейдите в `Settings`->`Devices & Services`, нажмите `Add Integration` и найдите HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Для использования HACS вам понадобится учетная запись Github.\\n\\n</robo-wiki-note>\\n\\n7. Нажмите на нее и следуйте инструкциям по установке. \\n\\n## Установите интеграцию Robonomics\\n\\nТеперь вы можете установить интеграцию Robonomics с помощью HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nОткройте HACS в меню боковой панели и перейдите к  `Integrations`. Нажмите `Explore & Download Repositories`, затем найдите `Robonomics` и нажмите кнопку `Download`, расположенную в правом нижнем углу. После завершения загрузки перезапустите Home Assistant.\"}},{\"node\":{\"id\":\"820531e1d4d216256374522bbb098579\",\"title\":\"Как запустить коллатор Robonomics\",\"path\":\"/docs/ru/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  В видео и скриншотах этой статьи мы использовали версию 1.4.0 Robonomics. Вам нужно использовать те же команды, но заменить версию Robonomics на текущую.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nВ настоящее время сеть Robonomics в основном поддерживается начальными разработчиками, но любой может поддержать проект. Каждый дополнительный полный узел блокчейна помогает ему стать более устойчивым и устойчивым к сбоям. Бинарные файлы узла Robonomics доступны в [релизе](https://github.com/airalab/robonomics/releases) или их можно [собрать из исходного кода](/docs/how-to-build-collator-node/).\\n\\n## Что такое коллатор\\n\\nКоллатор является частью парачейна Robonomics. Этот тип узла создает новые блоки для цепи Robonomics.\\n\\n>Коллаторы поддерживают парачейны, собирая транзакции парачейна от пользователей и создавая доказательства перехода состояния для валидаторов цепи ретрансляции. Другими словами, коллаторы поддерживают парачейны, агрегируя транзакции парачейна в кандидаты на блоки парачейна и создавая доказательства перехода состояния для валидаторов на основе этих блоков.\\n\\nВы можете узнать больше о коллаторах на связанной [странице вики Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nВ парачейне Robonomics каждый коллатор получает вознаграждение (**0.001598184 XRT**) за каждый блок, который коллатор строит (вознаграждения происходят при запечатывании блоков в цепь). \\nТакже коллатор, который строит блок, получает **50% комиссии за транзакции**, содержащиеся в созданном им блоке.\\n\\n## Требования\\n\\nРекомендуется запускать коллатор с использованием **стандартных аппаратных требований** для [валидаторов Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ совместимый с x86-64.\\n+ Intel Ice Lake или новее (Xeon или Core серии); AMD Zen3 или новее (EPYC или Ryzen).\\n+ 4 физических ядра @ 3.4GHz.\\n+ Одновременная многопоточность отключена (Hyper-Threading на Intel, SMT на AMD).\\n+ Хранение - NVMe SSD объемом 1 ТБ (так как он должен быть разумного размера для работы с ростом блокчейна).\\n+ Память - 32 ГБ DDR4 ECC\\n\\n\\nВ этой статье мы используем следующие спецификации:\\n+ 4 vCPU\\n+ 700 ГБ пространства NVMe для баз данных коллатора. Требуется возможность расширения этого дискового пространства.\\n+ 8 ГБ ОЗУ\\n\\n\\n## Важная информация\\n1. Мы используем некоторые переменные в этих инструкциях, и вам нужно будет заменить значения на свои во всех командах:\\n    + **%NODE_NAME%** это имя узла. Пример: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** это путь к примонтированному тому. Пример: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** это адрес учетной записи в экосистеме Polkadot в формате SS58. Пример: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Обратите внимание, что в запуске службы коллатора необходимо включить *--state-cache-size=0*. Этот параметр важен для стабильности коллатора.\\nВы можете увидеть больше информации в связанной [проблеме](https://github.com/airalab/robonomics/issues/234) на github.\\n\\n## Первый раз легко запустить Robonomics коллатор\\n\\nВы можете легко запустить коллатор напрямую в командной строке, чтобы проверить наличие ошибок.\\nПосле этого настоятельно рекомендуется запустить Robonomics коллатор как сервис (смотрите следующий шаг).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Запустите Robonomics коллатор как сервис\\n\\n1. Создайте пользователя для сервиса с домашним каталогом\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Скачайте, извлеките и переместите бинарный файл Robonomics в каталог */usr/local/bin/*. В командах в этом разделе необходимо заменить *$ROBONOMICS_VERSION* на текущую версию Robonomics. Вы можете найти текущую версию на [странице релизов репозитория Robonomics на github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Создайте файл службы systemd с именем *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    And add the following lines in the service file:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Сохраните этот файл, затем включите и запустите службу:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nURL телеметрии: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nЖурналы коллаторов можно отслеживать с помощью: `journalctl -u robonomics.service -f` \\n\\nПосле запуска Robonomics коллатора он начнет синхронизацию с Kusama Relay Chain, это может занять значительное время в зависимости от скорости вашей сети и системных характеристик, поэтому рекомендуется загрузить снимок Kusama. \\n\\n\\n## Ускорение процесса синхронизации с использованием снимка Kusama\\n\\nМы рекомендуем сделать это сразу после создания и запуска службы Robonomics. Более подробную информацию о снимках и инструкции по использованию вы можете найти на следующей странице: https://ksm-rocksdb.polkashots.io/\\n\\nИнструкции:\\n\\n1. Остановите службу Robonomics и удалите текущий каталог базы данных Kusama:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Скачайте актуальный снимок и извлеките его:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    You can remove the downloaded archive after succesful unpacking:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Установите правильную собственность для папки базы данных:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Запустите службу Robonomics снова:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Проверьте журналы службы:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Устранение неполадок\\n### Ошибка: \\\"State Database error: Too many sibling blocks inserted\\\"\\nFor fix this error you can just launch your collator in archive mode: \\n\\n1) First, need to stop the Robonomics service: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Затем добавьте параметр `--state-pruning=archive` к части службы parachain. Пример отредактированного файла службы:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Перезагрузите конфигурацию менеджера systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Удалите существующую базу данных parachain:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Запустите службу robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    After that need to wait for the synchronization of the parahain database.\\n\\n### Ошибка: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nЭта ошибка связана с параметрами виртуализации. Необходимо использовать тип эмулируемого процессора \\\"host-model\\\". Вы можете настроить это на хосте виртуализации.\\n\\nНо, если вы заметили эту ошибку на каком-либо хостинге, вам нужно только обратиться с этой проблемой в техподдержку.\\n\"}},{\"node\":{\"id\":\"295a63f5015fe69f7d9ce73f554ac8bb\",\"title\":\"Как построить узел коллатора из исходного кода\",\"path\":\"/docs/ru/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  В видео и скриншотах этой статьи мы использовали версию 1.4.0 Robonomics. Вам нужно использовать те же команды, но заменить версию Robonomics на текущую.\\n</robo-wiki-note>\\n\\n## Что такое коллатор\\n\\nКоллатор является частью парачейна Robonomics. Этот тип узла создает новые блоки для цепи.\\n\\n>Коллаторы поддерживают парачейны, собирая транзакции парачейна от пользователей и создавая доказательства перехода состояния для валидаторов цепи ретрансляции. Другими словами, коллаторы поддерживают парачейны, агрегируя транзакции парачейна в кандидаты на блоки парачейна и создавая доказательства перехода состояния для валидаторов на основе этих блоков.\\n\\nВы можете узнать больше о коллаторе на связанной [странице вики Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nВ парачейне Robonomics каждый коллатор получает вознаграждение (**0.000380520 XRT**) за каждый построенный блок, если этот блок был запечатан в цепь. \\nТакже коллатор получает **50% комиссии за транзакции** с этого блока.\\n\\n## Процесс сборки\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nУбедитесь, что у вас установлен Rust и необходимое программное обеспечение. Установщик Rust спросит вас о текущих параметрах установки, вы должны выбрать опцию `1) Продолжить установку (по умолчанию)`.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Установка Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nУстановите необходимую ночную цепочку и цель wasm.\\nСледующие команды актуальны для Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nВам также потребуется установить следующие пакеты:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nТеперь вы можете установить узел robonomics из исходного кода git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nПосле этой команды скомпилированный двоичный файл robonomics будет находиться в каталоге `~/.cargo/bin`.\\n\\nСледующий шаг - это запуск узла коллатора. Вы можете прочитать об этом в статье [\\\"Как запустить коллатор Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"9eba74a9b56932750c1db87b4752efe5\",\"title\":\"Инициализация Home Assistant\",\"path\":\"/docs/ru/hass-init/\",\"content\":\"\\n**После установки Home Assistant необходимо его инициализировать.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nВы начинаете с создания учетной записи владельца Home Assistant. Эта учетная запись является администратором и может вносить любые изменения. Откройте веб-браузер и перейдите по адресу `http://%RASPBERRY_IP_ADDRESS%:8123`. Вы можете найти IP-адрес Raspberry Pi, используя [мобильное приложение Fing](https://www.fing.com/products) или [инструмент командной строки nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">Адрес Raspberry Pi может меняться со временем из-за настроек маршрутизатора.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. На первой странице введите имя, имя пользователя, пароль и нажмите кнопку `CREATE ACCOUNT`.\\n\\n2. На следующем экране введите имя для вашего дома, установите ваше местоположение и систему единиц. Нажмите `DETECT для поиска вашего местоположения и установки вашего часового пояса и системы единиц на основе этого местоположения. Если вы не хотите отправлять свое местоположение, вы можете установить эти значения вручную.\\n\\n3. После этого Home Assistant покажет все устройства, которые он обнаружил в вашей сети. Не беспокойтесь, если вы видите меньше элементов, чем показано ниже; вы всегда можете вручную добавить устройства позже. Пока просто нажмите `FINISH`, и вы окажетесь на главном экране Home Assistant.\\n\\n4. Наконец, вы увидите веб-интерфейс Home Assistant, на котором будут отображены все ваши устройства. \\n\\n\\n## Устранение неполадок\\n\\n1. Если вы забыли свой логин или пароль для локального пользователя, [проверьте эту статью](https://www.home-assistant.io/docs/locked_out/), чтобы восстановить ваши учетные данные.\\n\"}},{\"node\":{\"id\":\"e0e2c850c1c91f8a19611af6204004bd\",\"title\":\"Обновите ядро Home Assistant\",\"path\":\"/docs/ru/hass-core-upgrade/\",\"content\":\"\\n**В этой статье содержатся инструкции по обновлению вашего существующего ядра Home Assistant с интеграцией Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Предполагается, что установка вашего ядра Home Assistant была завершена в соответствии с [официальными инструкциями](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) и у вас есть пользователь <u>homeassistant</u> и среда `venv`. Если это не так, следуйте инструкциям ниже, **но отредактируйте скрипт соответствующим образом**.\\n  2. IPFS будет установлен и запущен как служба <u>systemd</u> на хост-машине.\\n  3. Предполагается, что у вас установлен [Python3.10](https://www.python.org/downloads/) или более новая версия.\\n\\n</robo-wiki-note>\\n\\n## Установка\\n\\nСкачайте установочный скрипт и запустите его в терминале:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nВы увидите следующий вывод:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nВ процессе установки вам будет предложено подтвердить перезапуск нескольких служб. Навигируйте с помощью клавиши `tab` и выберите опцию `yes`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Возможно, вы увидите ошибку вроде `mkdir: can't create directory 'custom_components': File exists`. Это означает, что у вас уже есть этот каталог с некоторыми установленными пользовательскими компонентами. Просто игнорируйте это сообщение.\\n\\n</robo-wiki-note>\\n  \\nПосле завершения перезагрузите Home Assistant.\\n\\n## Проверка\\n\\nПроверьте, что служба IPFS работает:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nВы увидите следующий вывод:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"94be9e74c78adde0c8055fef08334ac8\",\"title\":\"Предустановленный образ для Raspberry Pi\",\"path\":\"/docs/ru/hass-image-install/\",\"content\":\"\\n**Добро пожаловать в руководство по установке Home Assistant с интеграцией Robonomics на Raspberry Pi. Home Assistant - это система умного дома с открытым исходным кодом, которая предоставляет централизованную платформу для управления умными устройствами в вашей домашней сети. Интегрируясь с Robonomics, децентрализованной облачной службой, вы можете улучшить функциональность и безопасность вашего умного дома. В этой статье мы предоставим пошаговые инструкции по установке Home Assistant с Robonomics на Raspberry Pi, что позволит вам автоматизировать и контролировать различные аспекты вашего дома с использованием безопасного и децентрализованного решения. Давайте начнем!**\\n\\n## Оборудование, необходимое для установки\\n\\nЕсли вы еще не включили Home Assistant в свою систему умного дома, важно знать, какое оборудование вам понадобится для создания полной системы умного дома с нуля.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Скачайте предустановленный образ Robonomics\\n\\nПредустановленный образ Robonomics содержит:\\n- Ядро Home Assistant\\n- IPFS\\n- MQTT-брокер и интеграцию\\n- Zigbee2MQTT\\n- Интеграцию Robonomics\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nВы можете проверить исходный код и скачать последнюю версию образа на [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Настройте образ\\n\\nУстановка [Raspberry Pi Imager](https://www.raspberrypi.com/software/) на твоем компьютере. Затем вставьте SD-карту.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nЗапустите программу Raspberry Pi Imager. Выберите требуемый образ в качестве операционной системы и убедитесь, что выбрана ваша SD-карта из выпадающего меню хранения. \\nВ настройках:\\n- Установите имя пользователя и пароль (сохраните имя пользователя по умолчанию \\\"pi\\\", чтобы было легко запомнить),  \\n- укажите имя и пароль Wi-Fi, \\n- выберите свою страну из выпадающего списка\\nа затем нажмите `Write` для записи образа. \\n                   \\n<robo-wiki-note type=\\\"note\\\">Внимательно сохраните имя пользователя и пароль, поскольку эти учетные данные потребуются в случае устранения неполадок.</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nКоды стран можно найти [здесь](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. Первая загрузка\\n\\n**Безопасно извлеките SD-карту**, вставьте ее в Raspberry Pi. Затем **вставьте адаптер Zigbee** в Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">Важно вставить адаптер Zigbee перед первым запуском Raspberry Pi! \\nЭто необходимо для автоматической настройки сети Zigbee.</robo-wiki-note>\\n\\n**Если у вас есть [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (который имеет все необходимое программное обеспечение), вы можете просто продолжить выполнение этих инструкций. Однако, если у вас есть другой адаптер, первое, что ва нужно сделать, это прошить его программным обеспечением Zigbee2MQTT. Инструкции для вашего устройства можно найти [здесь](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nЗатем подключите кабель питания к вашему устройству. Оно должно подключиться к вашей сети Wi-Fi. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nКогда ваш Raspberry Pi подключен, красный светодиод загорится, а зеленый светодиод будет мигать некоторое время. Подождите до 5 минут, чтобы Raspberry Pi загрузился и зарегистрировался в сети. \\n\\nТеперь найдите IP-адрес Raspberry Pi. Чтобы найти его, вы можете использовать [мобильное приложение Fing](https://www.fing.com/products) или \\n[инструмент командной строки nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Найдите `robots-home` (необязательное имя может быть `Home(homeassistant)`) \\nимя хост-машины в списке IP. \\n\\nВ этом примере адрес - `192.168.43.56`. \\n\\nЧтобы проверить, что все работает, откройте веб-браузер и перейдите на веб-страницу `http://%RASPBERRY_IP_ADDRESS%:8123`. В этом примере это будет `192.168.43.56:8123`.\\nЕсли все в порядке, вы увидите веб-интерфейс Home Assistant. Если веб-страница не открывается, подождите до 5 минут, чтобы Raspberry Pi загрузился и попробуйте снова. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Устранение неполадок\\n\\n1. Чтобы позже изменить настройки Wi-Fi, вы должны войти в Raspberry Pi через команду `ssh`. Для этого откройте терминал на вашем компьютере\\nи введите команду ssh с вашим именем пользователя, которое вы создали на шаге \\\"Настройка образа\\\" (по умолчанию - \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\nа затем используйте команду `sudo raspi-config`. Найдие больше информации об этой команде на [официальном сайте.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"07c305e94622361cb1089f05f1c216a3\",\"title\":\"Substrate Cumulus Parachain Testsuite para mensajería entre cadenas\",\"path\":\"/docs/es/xcm-robobank/\",\"content\":\"\\n\\nEl objetivo principal de este proyecto es simplificar el desarrollo de tiempo de ejecución de parachain cuando se utilizan mensajes entre cadenas. \\nPermite el desarrollo de código de tiempo de ejecución con pruebas de integración con un alto grado de repetibilidad y uso sencillo.\\nAutomatiza la construcción, la construcción de una configuración de red predefinida (es decir, 1 cadena de relé + 2 parachains), la configuración de canales de envío de mensajes entre parachains y la ejecución de pruebas de mensajería, el envío de mensajes, utilizando llamadas al tiempo de ejecución, todo construido y compuesto en Python.\\n\\nXCM Testsuite se utiliza para probar el ciclo de producción de Robobank, el conjunto de paletas de Substrate que permiten a los robots registrarse en parachains externos, recibir pedidos prepagos, ejecutarlos y recibir pagos utilizando tokens externos. Esto permite que los robots operen dentro de la red Robonomics con toda la infraestructura requerida, pero al mismo tiempo, ofrezcan sus servicios en cualquier otra parachain.\\n\\nUn ejemplo de video está disponible en [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nLos principales pasos en el escenario de demostración son:\\n- lanzar la cadena de relé y dos parachains en un paquete de 6 procesos\\n- configurar canales de mensajes XCM entre parachains\\n- registrar un robot en ambos parachains\\n- crear un pedido para este robot en el parachain del cliente (reservando el pago para la finalización del pedido)\\n- enviar un mensaje XCM al parachain de Robonomics\\n- crear el registro de pedido \\\"reflejado\\\" en el parachain de Robonomics\\n- el robot acepta el pedido en el parachain de Robonomics\\n- enviar un mensaje XCM sobre la aceptación del pedido de vuelta al parachain del cliente\\n- aceptar el pedido en el parachain del cliente (reservando una tarifa de penalización por falta de finalización del pedido hasta la fecha límite del pedido)\\n- el robot completa el pedido en el parachain de Robonomics\\n- enviar un mensaje XCM sobre la finalización del pedido al parachain del cliente\\n- liquidar todos los pagos (el pago del cliente se transfiere al robot, así como la tarifa de penalización no utilizada)\\n- cerrar el pedido1\\n\\n\\n## Corriente ascendente\\nEste proyecto es un fork de\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nContiene el código de las paletas de tiempo de ejecución que se están probando.\\nAl igual que en el código de nodo original, los parachains se encuentran en los catálogos \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nDiferencias con el \\\"substrate-node-template\\\" original:\\n- este tiempo de ejecución del recolector tiene un módulo de controlador HRMP y puede manejar mensajes de parachains hermanos\\n- tiempo de ejecución de prueba simulado listo para pruebas internas de XCM\\n\\n## Construir y ejecutar\\nConfiguración recomendada (altamente): \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[NOTA] La primera compilación puede llevar mucho tiempo, hasta varias horas en máquinas subóptimas.\\n\\n[NOTA] El script funciona con las versiones FIJAS (hashes de confirmación) de Polkadot (Rococo) en la cadena de relé y parachains.\\n\\n[NOTA] Por defecto, el script recrea el mismo entorno en cada lanzamiento, eliminando todos los estados anteriores. Este comportamiento se puede cambiar en \\\"config.sh\\\" utilizando el parámetro \\\"PERSISTENT\\\".\\n\\n\\nEjecutar script de compilación y configuración.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nAcciones básicas del script \\\"init.sh\\\":\\n - leer la configuración (archivo \\\"config.sh\\\" con número de revisión, claves e identificadores de nodo iniciales, parámetro de persistencia de datos de cadena, etc.)\\n - configurar paquetes del sistema operativo, Rust y Python\\n - generar binarios separados para la cadena de relé y también para ambos parachains\\n    - los binarios se generarán en el subdirectorio ./bin. \\n - (opcional) eliminar todos los datos de cadena anteriores para todas las cadenas\\n    - desactivado si \\\"PERSISTENT=1\\\" está configurado en \\\"config.sh\\\"\\n - se ejecuta como procesos separados (con PID y tuberías de E/S separadas):\\n    - validadores de la cadena de relé (es decir, 4 validadores de una revisión estable de Rococo en ejecución)\\n    - recolectores para parachain-100 (es decir, un solo recolector para el primer parachain que estás desarrollando)\\n    - recolectores para parachain-200 (es decir, un solo recolector para el segundo parachain que estás desarrollando)\\n - imprime todos los puntos finales, puertos en la consola, lo que te permite estudiar cualquier cadena utilizando aplicaciones frontend (explorador, DApp)\\n - sigue imprimiendo todos los datos de salida de todas las cadenas en la consola\\n\\n[ADVERTENCIA] Después de iniciar, espera hasta que la red esté activa, asegúrate de que la finalización del bloque haya comenzado y de que los parachains estén registrados. Estos procesos deberían tardar aproximadamente 5 minutos (50 bloques x 6 segundos).\\n\\n## Comprobando que la configuración inicial funciona \\n\\nUtiliza el frontend estándar de Polkdot y los puntos finales generados \\\"--ws-port\\\" para conectarte con cada nodo.\\nAbre [Polkadot application](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) para monitorear las cadenas. \\n\\n### Ejemplo:\\nLocalhost, 4 validadores de cadena de relé, un recolector de parachain-100, un recolector de parachain-200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nSi todo funciona y el consenso comienza, podemos proceder a ejecutar nuestros casos de prueba (en una nueva terminal).\\n\\n### Prueba de paso de mensajes UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nCrea un mensaje `Balance.transfer` en `parachain-100` y lo pasa a la cadena de relé.\\nCuando la cadena de relé recibe el mensaje, transferirá 15 tokens de la cuenta `para 100` a la cuenta de Charlie.\\n\\n\\n### Prueba de paso de mensajes HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nCrea un mensaje `Balance.transfer` en `parachain-100` y lo pasa al `sibling 200`.\\nAntes de eso, dota a la cuenta `subl 100` con 1000 tokens y establece un canal de comunicación entre las parachains.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nLos mensajes siguientes se pueden enviar ejecutando el subcomando `hrmpm`. No crea un canal y, por lo tanto, se ejecuta más rápido.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Más opciones\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Testnet local\\n\\n### Crear especificación de cadena personalizada\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nEditar rococo_local.json, reemplazar los parámetros de saldos y autoridades con los tuyos.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nDirección de Polkadot para //Alice//stash (criptografía sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nClave de sesión de Polkadot grandpa para //Alice (criptografía ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nDirección de Polkadot para //Alice (criptografía sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nConvertir rococo_local.json al formato sin procesar.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nPara usar una nueva especificación de cadena, reemplaza el archivo rococo.json en el directorio ./config/ con este nuevo y vuelve a ejecutar la cadena.\\n```bash\\n./scripts/init.sh run\\n```\\nPuedes editar libremente el código. El comando anterior reconstruirá el proyecto y actualizará el nodo del colador antes de comenzar.\\nCumulus es un software de prelanzamiento que aún está en desarrollo intenso.\\nEstamos utilizando un compromiso específico de polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15 18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nPuedes usar versiones más recientes del software. Para hacer esto, cambia POLKADOT_COMMIT en ./scipt/config.sh\\nal último compromiso de la rama `rococo-v1`, elimina ./bin/polkadot y ejecuta \\n```bash\\n./scripts/init.sh run\\n```\\n\\nActualizar dependencias del proyecto del colador \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nEs probable que algunas dependencias requieran nuevas características de la cadena de herramientas de Rust. Este proyecto se basa en Rust `nightly-2021-01-26`\\nActualiza la versión de la cadena de herramientas de Rust en ./scripts/config.sh antes de compilar.\\n\\n## Hackear parachain\\n[Agregar paleta externa](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - ¿debería estar probablemente en \\\"más información\\\"?\\n## Learn More\\n\\nConsulta la [Plantilla de Nodo del Hub de Desarrolladores de Substrate](https://github.com/substrate-developer-hub/substrate-node-template) para obtener más información sobre la estructura de este proyecto, las capacidades que encapsula y la forma en que se implementan esas capacidades. Puedes obtener más información sobre [El camino de un bloque de parachain](https://polkadot.network/the-path-of-a-parachain-block/) en el blog oficial de Polkadot. [Taller de Paridad Cumulus](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"0e00b81abe56ec93b4674a4e11cf0baa\",\"title\":\"Glossary\",\"path\":\"/docs/ru/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\nсоединение общественно-частного ключевой пары, общая часть которой является общедоступным адресом пользователя, а частная часть - секретным ключом для доступа к управлению этим адресом.\\n\\n\\n### Auction (of Parachains)\\nмеханизм аренды слотов для парачейн в экосистемах Polkadot и Kusama; парачейн должен выиграть аукцион, чтобы получить слот.\\n\\n### Autonomous Agent\\nвычислительная система, которая получает сенсорные данные из окружающей среды и принимает решение о том, как реагировать на внешние стимулы, чтобы достичь своих целей.\\n\\n### AIRA\\nили Автономный Интеллектуальный Робот-Агент - программное обеспечение, разработанное командой Robonomics в 2015 году, которое реализует стандарт экономического взаимодействия человека и машины, а также машины и машины через интеллектуальный договор о ответственности.\\n\\n\\n## B\\n\\n### Blockchain\\nв широком смысле распределенная сеть, использующая криптографию, чтобы позволить группе участников безопасно достигать согласия о изменяющемся состоянии системы.\\n\\n### Blockchain Исследуйтеr\\nприложение, которое позволяет исследовать различные блоки, транзакции и адреса на блокчейне (например, Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\nзаранее созданная автоматизированная логика, которую можно легко добавить в экземпляр Home Assistant.\\n\\n### Bridge\\nтехнология и методы, с помощью которых две экономически суверенные и технологически разнообразные цепочки могут взаимодействовать друг с другом. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nили Cs - миллионная доля одного токена XRT, 1 XRT = 1 000 000 Cs; назван в честь Рональда Коуза, британского экономиста, одного из основателей институциональной экономики, лауреата Нобелевской премии по экономическим наукам. \\n\\n### Collator\\nузел, поддерживающий парачейн, собирая транзакции парачейн и создавая доказательства перехода состояния для валидаторов.\\n\\n### Consensus\\nпроцесс, в котором узлы сети блокчейна достигают согласия о текущем состоянии данных в сети (например, Proof-of-Work, Proof-of-Stake).\\n\\n### Crowdloan\\nкраудфандинговая кампания по сбору токенов для участия в аукционе слотов в экосистеме Polkadot / Kusama.\\n\\n### Cybernetics\\nизучение управления и коммуникации в животном и машине, согласно определению Н. Винера.\\n\\n### Cyber-Physical System\\nили CPS - сильное объединение и взаимная интеграция нескольких вычислительных, сетевых и физических процессов.\\n\\n\\n## D\\n\\n### DAO\\nколлективно владеемая организация, управляемая блокчейном, в которой управление ресурсами осуществляется в соответствии с предварительно согласованным и формализованным набором правил, соблюдение которых осуществляется автоматически.\\n\\n### Datalog (Function)\\nфункция парачейн Robonomics, которая хранит данные устройства в блокчейне.\\n\\n### Dapp\\nили децентрализованное приложение - приложение, которое работает в рамках распределенной сети и предоставляет доступ к своим функциям в удобном для пользователя виде.\\n\\n### Decentralized Cloud\\nоблачный вычислительный сервис на основе децентрализованной пиринговой сети, к которой пользователи могут присоединиться для использования услуг или предоставления своих ресурсов, таких как вычисления, сеть, хранение и т. д.\\n\\n### Digital Twin\\nцифровая версия реального оборудования, копирующая его технические характеристики и исторические данные.\\n\\n\\n## E\\n\\n### Edge-system\\nустройство Интернета вещей, которое действует как связующее звено между локально доступными встроенными системами и глобальной сетью, обычно поддерживая протоколы связи и передачу телеметрии и управляющих сигналов.\\n\\n### Embedded System\\nустройство Интернета вещей с ограниченными вычислительными и коммуникационными ресурсами, предоставляющее базовые функции (датчики, исполнительные механизмы, кнопки) на самом низком уровне, обычно без пользовательского интерфейса.\\n\\n### Ethereum\\nдецентрализованная открытая блокчейн-система, которая работает как платформа для множества других криптовалют, а также для выполнения децентрализованных смарт-контрактов.\\n\\n### Ethereum Upgrade\\nранее известный как Ethereum 2.0 или Eth2 - обновления протокола Ethereum, которые должны сделать сеть более масштабируемой, безопасной и устойчивой; для этого предлагается изменить консенсус на Proof-of-Stake и добавить механизм шардинга для увеличения пропускной способности сети.\\n\\n### Exodus\\nпроцесс передачи токенов XRT с сети Ethereum на парачейн Robonomics.\\n\\n### Extrinsic\\nфункция в сети Polkadot и Kusama, которая может вызывать переходы состояния сети извне состояния.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nили Gk - тысячная доля одного токена XRT, 1 XRT = 1 000 Gk; назван в честь Виктора Глушкова, советского математика, одного из основателей информационных технологий и кибернетики в Советском Союзе.\\n\\n\\n## H\\n\\n### Home Assistant\\nили Hass - программное обеспечение системы управления с открытым исходным кодом, предназначенное для центрального хаба для умных устройств. \\n\\n### HRMP\\nили горизонтальная ретрансляция маршрутизированных сообщений - безопасная передача сообщений между парачейн, которая хранит все сообщения в хранилище Relay Chain перед отправкой их в парачейн. \\n\\n### HMI\\nили Интерфейс Человек-Машина - пользовательский интерфейс или панель управления, которая соединяет пользователя с машиной, системой или устройством.\\n\\n\\n## I\\n\\n### Industry 4.0\\nили Четвертая промышленная революция - непрерывная автоматизация традиционного производства и промышленных практик с использованием современных интеллектуальных технологий.\\n\\n### IPFS\\nили межпланетная файловая система - пиринговое программное обеспечение для хранения и обмена данными в распределенной файловой системе.\\n\\n### IoT\\nили Интернет вещей - подключение к глобальной сети миллиардов устройств, способных собирать данные и интегрироваться в окружающую среду.\\n\\n### IoT Gateway\\nкраевая система, которая агрегирует и передает данные от устройств Интернета вещей в сеть и наоборот; часто эти устройства являются более сложной версией WiFi-маршрутизатора.\\n\\n### IoT Provider\\nвнешний сервис, который предоставляет пользователям Интернета вещей удаленный доступ к данным и аналитике, а также управление умными устройствами через Интернет.\\n\\n### IoT Subscription\\nФункция парачейна Robonomics, которая позволяет использовать все функции парачейна в течение определенного периода без комиссии.\\n\\n\\n## K\\n\\n### KSM\\nнативный токен для сети Kusama.\\n\\n### Kusama\\n«канареечная сеть» для Polkadot, состоящая из версии программного обеспечения Polkadot, выпущенной раньше срока и не прошедшей проверку.\\n\\n\\n## L\\n\\n### Запуск (Function)\\nфункция парачейна Robonomics, которая запускает или останавливает устройство, отправляя команду через блокчейн.\\n\\n### Lease Period\\nпродолжительность времени, в течение которой парачейн может подключаться к Реле-цепи.\\n\\n### Libp2p\\nбиблиотека с открытым исходным кодом для создания зашифрованных пиринговых сетей.\\n\\n### Lights-out Factory\\nили Смарт-фабрика — полностью автоматизированная фабрика, не требующая присутствия человека на месте.\\n\\n### Lighthouse\\nумный контракт, в концепции роботической экономики, который выполняет транзакцию, когда Провайдер устанавливает рыночное согласование между Обещающим и Обещающим.\\n\\n### Liability\\nумный контракт, заключенный между кибер-физическими системами друг с другом ии с людьми, для выполнения задачи за плату.\\n\\n### Liability Market\\nплатформа, в концепции роботической экономики, отвечающая за сопоставление предложений и спроса среди узлов системы.\\n\\n\\n## M\\n\\n### MQTT\\nили Протокол передачи телеметрии через сообщения — протокол публикации-подписки, разработанный для низкоскоростных, высоколатентных, ненадежных сетей для обработки большого объема сообщений устройств Интернета вещей.\\n\\n### MQTT Broker\\nсервис, который получает все сообщения от клиентов MQTT, а затем маршрутизирует сообщения соответствующим подписчикам.\\n\\n\\n## N\\n\\n### NFT\\nили Токен непереставаемости — токен, который нельзя заменить и отличить от других токенов, что позволяет токенизацию уникальных предметов и обеспечивает исключительное владение этими токенами.\\n\\n### Node (of Robonomics)\\nмодуль блокчейна на основе Substrate или Ethereum с расширениями Robonomics для подключения к сети Robonomics.\\n\\n\\n## O\\n\\n### On-chain Governance\\nпроцесс определения допустимых изменений в сети, таких как изменения кода или перемещение средств, который существует в самой сети и может непосредственно изменять ее.\\n\\n\\n## P\\n\\n### Pallet\\nмодуль Substrate, написанный на Rust, который объединяет конкретную логику или алгоритм для работы времени выполнения блокчейна на основе Substrate. \\n\\n### Parachain\\nпользовательский, специфичный для приложения структура данных (обычно блокчейн), интегрированный в Реле-цепь и может быть проверен валидаторами.\\n\\n### Parathread\\nпарачейн без слота, который может временно участвовать (на блок-по-блоковой основе с комиссией) в безопасности Реле-цепи.\\n\\n### Polkadot\\nгетерогенная, многоцепочечная сеть, позволяющая различным блокчейнам с различными характеристиками выполнять произвольное межцепное взаимодействие при общей безопасности.\\n\\n### Polkadot/Substrate Portal\\nбазовый пользовательский интерфейс Substrate для взаимодействия с сетью Polkadot, Kusama и другими сетями Substrate.\\n\\n### Proposal (on Polkadot / Kusama)\\nпотенциальный вызов функции, над которым будет проводиться голосование в референдуме Polkadot, Kusama или парачейнов. \\n\\n### Proof-of-Work\\nмеханизм консенсуса, при котором для достижения согласия участникам сети требуется выполнение вычислительной работы.\\n\\n### Proof-of-Stake\\nмеханизм консенсуса, при котором для достижения согласия участникам сети требуется залог капитала связанной криптовалюты, который выступает в качестве залога.\\n\\n### Promisee\\nузел, который размещает заказ на выполнение задачи в концепции роботической экономики.\\n\\n### Promisor\\nузел, который соглашается выполнить задачу за плату в концепции роботической экономики.\\n\\n### Provider (Robonomics)\\nузел, в концепции роботической экономики, который отслеживает сообщения Рынка ответственности и сопоставляет предложение и спрос за небольшую плату. \\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\nчасть управления на цепи, голосует, следует ли принять предложение пользователям сети или нет. \\n\\n### Relay Chain\\nосновная цепь, координирующая консенсус Polkadot / Kusama и коммуникацию между парачейнами.\\n\\n### Robofirm\\nорганизация, в которой весь бизнес-процесс полностью автоматизирован и не требует участия человека.\\n\\n### Rococo\\nтестовая сеть для тестирования парачейнов на Kusama\\n\\n### robonomics-interface\\nбиблиотека на языке Python, специализирующаяся на взаимодействии с Robonomics для удобного программирования.\\n\\n### Robonomics на Ethereum\\nверсия Robonomics Network, работающая поверх Ethereum, выпущенная в 2018 году.\\n\\n### Robot Economy\\nэкономическая система, в которой устройства действуют как независимые агенты, способные выполнять ключевые экономические действия, ранее уникальные для людей.\\n\\n### Robot-as-a-Service\\nили RaaS — бизнес-модель, при которой компании сдают в аренду свое робототехническое оборудование клиентам на короткий или длительный срок.\\n\\n### ROS\\nили Robot Operating System — фреймворк для разработки программного обеспечения роботов, который предоставляет сервисы, разработанные для гетерогенного компьютерного кластера, такие как абстракция аппаратного обеспечения, управление устройствами низкого уровня, реализация широко используемой функциональности, передача сообщений между процессами и управление пакетами.\\n\\n### ROS 2\\nобновленная и перестроенная версия Robot Operating System с новыми функциями, такими как поддержка множества роботов и малых встроенных систем, а также интеграция с реальным временем.\\n\\n### ROS 2 Middleware\\nили RMW — протокол, который предоставляет стандартные функции ROS 2, такие как обнаружение, сериализация и передача; ROS 2 поддерживает несколько реализаций промежуточного программного обеспечения, которые можно выбрать в соответствии с требованиями проекта.\\n\\n### RWS\\nили Robonomics Web Services — децентрализованные инфраструктурные сервисы для робототехники и Интернета вещей, которые позволяют легко подключать устройства и взаимодействовать с пользовательскими приложениями, облачными сервисами и другими устройствами в безопасном режиме; у него есть собственный токен, также называемый RWS, который дает пожизненную подписку на IoT в парачейне Robonomics.\\n\\n### Запуститьtime\\nфункция перехода состояния блокчейна, которая определяет допустимый алгоритм для определения состояния следующего блока на основе предыдущего состояния.\\n\\n\\n## S\\n\\n### Seed Phrase\\nчеловекочитаемый приватный ключ, созданный в виде последовательности случайных слов и необходимый для доступа к адресу блокчейна и его токенам.\\n\\n### Shared Security\\nмодель безопасности Polkadot / Kusama, при которой все цепочки одинаково защищены путем размещения доказательств о валидности блоков парачейна в Реле-цепи таким образом, что потенциальному злоумышленнику потребуется атаковать всю систему.\\n\\n### SLS Gateway\\nоткрытый исходный код шлюза IoT для устройств Zigbee на основе микроконтроллера ESP32, разработанный Smart Logic System.\\n\\n### Slot (of Parachain)\\nредкий ресурс в экосистеме Polkadot / Kusama, который позволяет подключать парачейн к Реле-цепи без оплаты за каждый блок.\\n\\n### Smart Leasing\\nвариант модели Robot-as-a-Service, в котором оплата производится не за время, а за конкретные операции и их количество.\\n\\n### Smart Contract\\nпрограмма или алгоритм, хранящийся в блокчейне, который автоматически выполняется, когда выполняются заранее определенные условия.\\n\\n### SSH\\nили Secure Shell — сетевой протокол для безопасной работы сетевых служб через небезопасную сеть, который использует криптографию с открытым ключом для аутентификации удаленного компьютера. \\n\\n### Staking\\nчасть консенсуса Proof-of-Stake, акт залога токенов путем их депонирования в качестве залога для возможности создания действительного блока и получения вознаграждения.\\n\\n### Substrate\\nмодульная платформа для создания блокчейнов, подобных Polkadot и Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nфонд, собранный из части вознаграждений за производство блоков, комиссий за транзакции, стейкинга и т. д., который может быть потрачен путем представления предложения о расходовании; если Казначейство завершает период расходования без расходования всех своих средств, оно подвергается сжиганию определенного процента средств.\\n\\n### Transaction Costs\\nстоимость сбора и обработки информации из-за ограниченной рациональности экономических агентов и сложности процессов.\\n\\n\\n## V\\n\\n### Validator\\nузел, обеспечивающий безопасность Реле-цепи путем залога своих токенов, проверки доказательств от коллаторов на парачейнах и голосования за консенсус вместе с другими валидаторами.\\n\\n\\n## W\\n\\n### Web3\\nидея новой итерации Веба, которая включает в себя концепции децентрализации, блокчейн-технологий и экономики на основе токенов.\\n\\n### Wiener (XRT)\\nили Wn — миллиардная доля одного токена XRT, 1 XRT = 1 000 000 000 Wn; назван в честь Норберта Винера, американского математика, одного из основателей кибернетики и теории искусственного интеллекта.\\n\\n\\n## X\\n\\n### XCM\\nили Cross-Consensus Message Format — формат обмена сообщениями между различными блокчейн-системами в Polkadot / Kusama.\\n\\n\\n### XRT\\nвнутренний токен для сети Robonomics, существующий независимо на сетях Ethereum и Kusama.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nреализация оверлейной сети полностью зашифрованной маршрутизации для сетей сетчатого типа.\\n\\n\\n## Z\\n\\n### Zigbee\\nбеспроводной протокол связи, широко используемый для подключения умных устройств из-за низкого энергопотребления, простоты настройки и гибкости конфигурации, а также поддержки самоорганизующейся и самовосстанавливающейся топологии сети.\\n\\n### Zigbee Adapter\\nустройство, которое передает данные между сетью Zigbee и другой сетью (например, Wi-Fi) для управления устройствами Zigbee.\\n\\n### Zigbee2MQTT\\nпрограммное обеспечение, которое позволяет подключать Zigbee к сетям MQTT путем перевода сообщений из одной сети в другую. \"}},{\"node\":{\"id\":\"14235968e440c4b0863ce0ca1da3f780\",\"title\":\"Обновите свой Home Assistant Docker для Unix-подобных ОС\",\"path\":\"/docs/ru/hass-docker-upgrade/\",\"content\":\"\\n**В этой статье содержатся инструкции по обновлению вашего существующего Home Assistant Docker (на Unix-подобной ОС) с интеграцией Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Предполагается, что используются стандартные образы Docker и контейнер Home Assistant с именем <u>homeassistant</u>.\\n  2. IPFS будет установлен и запущен как служба <u>systemd</u> на хост-машине.\\n  3. Предполагается, что у вас установлена [Python3.9](https://www.python.org/downloads/) или более новая версия.\\n\\n</robo-wiki-note>\\n\\n## Установка\\n\\nСкачайте установочный скрипт и запустите его в терминале:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nВы увидите следующий вывод:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Возможно, вы увидите ошибку вроде `mkdir: can't create directory 'custom_components': File exists`. Это означает, что у вас уже есть этот каталог с некоторыми установленными пользовательскими компонентами. Просто игнорируйте это сообщение.\\n\\n</robo-wiki-note>\\n\\nПерезапустите контейнер:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Проверка\\n\\nПроверьте, что служба IPFS работает:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nВы увидите следующий вывод:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"2412f765e5ec9f151ce1b81f8b82a157\",\"title\":\"Начало работы\",\"path\":\"/docs/ru/getting-started/\",\"content\":\"\\n## Что такое Robonomics\\n\\nПлатформа Robonomics предоставляет инструменты для работы с сетью роботической экономики. Robonomics позволяет разработчикам умных городов и зон промышленности 4.0 создавать доверие среди [автономных роботов-сервисов](/docs/glossary#cyber-physical-system), предоставлять [прямой доступ пользователей через dapp](/docs/glossary#dapp) для заказа продуктов из автономных фабрик и услуг городских сетей датчиков. Это, в свою очередь, позволит нам создать децентрализованную систему, которая глобально отслеживает деятельность киберфизических систем.\\n\\nНа следующей диаграмме показано, какое место занимает Robonomics в сценарии:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nУзнайте больше в [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Быстрый старт в сети Robonomics\\n**Для удобства новичков разработчики ядра Robonomics придумали [6-ти урочную кривую обучения](/docs/wschool2021-intro/)!**\\n\\nВы изучите серверную архитектуру IoT! Robonomics Web Services (RWS) - это основная инфраструктурная служба для робототехники и IoT на основе Polkadot && IPFS.\\n\\nВыпускники курса могут запустить локальную ретрансляционную цепь и управлять устройством, совместимым с ROS, через межцепные транзакции.\\n\\n**[Присоединяйтесь к Discord разработчиков Robonomics](https://discord.gg/jTxqGeF5Qy), чтобы связаться с сообществом и получить техническую поддержку.**\\n\\n### Преимущества для выпускников Robonomics Academy\\n- Стажировка для лучших студентов   Станьте участником команды Robonomics и внесите свой вклад в развитие выбранного продукта.\\n- Активное сообщество и регулярные мероприятия   Станьте чатью сообщества учащихся, обсуждайте свои сценарии использования с экспертами отрасли. Объединяйтесь и участвуйте в хакатонах!\\n- Сертификат о завершении   Добавьте сертификат о завершении курса по созданию DAPPs для IoT в свое портфолио.\\n- Помощь в поступлении в университет ИТМО. Независимо от того, являетесь ли вы бакалавром или магистром, вы получите помощь в поступлении в университет.\\n- Возможности финансирования и ускорения: 1) Подайте заявку на получение гранта Academia в размере до 50 000 долларов США; 2) Участвуйте в программе ускорения Robonomics builders, поддерживаемой Web3 Foundation; 3) Разверните свое автономное приложение на основе Robonomics; 4) Монетизируйте его и получайте маркетинговую поддержку от команды Robonomics.\\n\\n\\n## Что содержит документация\\n\\n### Я разработчик Dapp\\n\\n- [Robonomics-js на GitHub](https://github.com/airalab/robonomics-js) - простой Javascript SDK для разработчиков сети Robonomics dApp.\\n- [Шаблон dApp](https://github.com/airalab/vue-dapp-robonomics-template) - использует Vue.js\\n- [Документация вики](/docs/robonomics-js/)\\n\\n### Я инженер робототехники\\n\\nОзнакомьтесь с разделом [cases](/docs/iot-sensors-connectivity/) и начните разработку по [примерам](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"1f66d633f2f8c1ecfb44f33b28873d56\",\"title\":\"Как купить подписку\",\"path\":\"/docs/ru/get-subscription/\",\"content\":\"\\n**Платить комиссии за транзакции в блокчейне - неприятно. Представьте себе устройство IoT, которое отправляет телеметрию каждые 5-10 минут. Это заставит вас заплатить довольно много в течение месяца. Одной из ключевых особенностей сети Robonomics является подписка на Robonomics Web Service (RWS). Платите ежемесячно и забудьте о стоимости транзакций! Для теоретической базы см. [эту](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) статью.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Обратите внимание, что этот учебник демонстрирует покупку подписки на параплан Robonomics Kusama. Вы также можете выполнить все те же шаги на своем [локальном узле](/docs/run-dev-node).\\n\\n  Еще одна вещь перед началом. Это \\\"сложный\\\" способ покупки подписки. Существует обычный способ сделать это через [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Сделайте ставку на аукцион\\n\\nПодписки в Robonomics продаются по модели аукциона. Чтобы получить одну, вам нужно сделать ставку на аукцион и выиграть его (не волнуйтесь, это быстро).\\n\\nВ `Developer/Chain state` вы можете увидеть доступные аукционы. \\nВыберите `rws` и `auctionQueue` и нажмите кнопку `+`, вы увидите идентификаторы доступных аукционов:\\n\\n![queue](../images/rws/queue.png)\\n\\nВы можете увидеть информацию о любой подписке с помощью `rws` `auction` и идентификатора аукциона (идентификатор аукциона на картинке - 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nВ информации об аукционе вы можете увидеть поле `winner`, на данный момент оно равно `null`, поэтому у никого нет этой подписки, и вы можете ее получить. Для этого перейдите в `Developer/Extrinsic`, выберите свою учетную запись и `rws -> bid`. Также установите идентификатор аукциона (79) и количество единиц для ставки (более 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nОтправьте транзакцию и проверьте информацию об аукционе с идентификатором 79 (в `Chain state` выберите `rws -> auction` и идентификатор 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nТеперь в поле `winner` вы увидите адрес вашей учетной записи, это означает, что у этой учетной записи есть подписка 79. Аукцион начинается с первой ставки и длится несколько блоков, поэтому если кто-то сделает больше токенов, чем вы в следующих нескольких блоках, он станет победителем и получит подписку.\\n\\nТеперь вы можете добавить устройства. Устройства - это учетные записи, которые могут использовать эту подписку и отправлять экстрансы без комиссии.\\nЧтобы протестировать это, создайте новую учетную запись без токенов и добавьте ее в устройства. \\n\\nЧтобы добавить устройства, выберите `rws -> setDevices` в `Developer/Extrinsic`. Затем нажмите кнопку `Add Item` и выберите недавно созданную учетную запись без токенов:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nОтправьте транзакцию. Теперь вы можете проверить список устройств в `Chain state` с помощью `rws -> devices`. Там вы увидите адрес вашей учетной записи без токенов. Выберите учетную запись, которая купила подписку, и нажмите `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nТеперь вы можете попробовать [отправить запуск](/docs/subscription-launch) экстранс с использованием подписки.\"}},{\"node\":{\"id\":\"57bff9b173a46c19da69c362882f4d7f\",\"title\":\"Подключение устройства Amazon FreeRTOS к Robonomics по протоколу MQTT\",\"path\":\"/docs/ru/freertos-mqtt/\",\"content\":\"\\nВот демонстрация того, как микроконтроллер, работающий на [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/), может быть подключен к сети Robonomics через MQTT. Пожалуйста, проверьте [этот репозиторий](http://github.com/khssnv/freertos_mqtt_robonomics_example) для получения исходного кода проекта.\\n\\nМы используем [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) с дистрибутивом FreeRTOS и реализацией MQTT, предоставленной [Espressif IoT Development Framework](https://github.com/espressif/esp-idf), при этом Espressif является производителем используемого микроконтроллера.\\n\\nТакже есть датчик [PMS-3003](http://www.plantower.com/en/content/?107.html) в качестве демонстрации. Датчик измеряет наличие частиц в воздухе, и его можно использовать для оценки качества воздуха.\\n\\nКачество воздуха не является темой статьи, вы можете узнать больше об этом на веб-сайте ВОЗ: [Атмосферное (уличное) загрязнение воздуха](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). Цель системы - публикация измерений датчика в сети Robonomics от Airalab.\\n\\n## Настройка оборудования\\n\\nМы подключаем PMS3003 TXD PIN5 к ESP32 DevKitC IO17 для передачи измерений по UART.\\nТакже оба устройства требуют питания и общего заземления.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Поток данных\\n\\nДля передачи измерений датчика в сеть Robonomics на уровне прошивки нашей целью является получение данных от датчика по встроенному протоколу связи, который он поддерживает (в нашем случае UART), и передача их в экземпляр AIRA по протоколу MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nВ нашем примере мы используем облачное развертывание AIRA, доступное по публичному IP-адресу и назначенному доменному имени.\\nНа экземпляре AIRA мы настраиваем MQTT-брокер `mosquitto` и подписываемся на тему `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`, чтобы получать сообщения от MQTT.\\n\\nЗатем мы передаем сообщения в писатель `robonomics io` через канал.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nТеперь данные доступны в сети Robonomics, и мы можем прочитать их с помощью `robonomics io`.\\n\\n## Прошивка\\n\\nМы используем [пример приложения ESP-MQTT с TCP-транспортом](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) в качестве основы.\\n\\nМы только модифицируем `main/app_main.c` для подключения по UART к датчику, синхронизации времени SNTP и периодической публикации MQTT.\\n\\nЕсли вы пытаетесь повторить проект и это ваш первый проект на базе ESP IDF, сначала ознакомьтесь с [Руководством по программированию ESP-IDF от Espressif](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step), чтобы ознакомиться с операциями прошивки, такими как настройка, сборка и загрузка с помощью инструмента `idf.py`.\\n\\n### Wi-Fi Конфигурация\\n\\nДля связи с экземпляром AIRA, развернутым в облаке, нашему микроконтроллеру требуется подключение к Интернету.\\nМы используем Wi-Fi ESP32 для этого.\\nEspressif предоставляет утилиты для настройки встроенного Wi-Fi.\\nВ нашем примере мы используем среду разработки с Ubuntu 20.04 GNU/Linux.\\nДля настройки Wi-Fi мы переходим в папку проекта и запускаем инструмент настройки SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nЗатем мы устанавливаем SSID и пароль точки доступа Wi-Fi в разделе «Пример конфигурации подключения».\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### Настройка конечной точки MQTT\\n\\nЕсть две вещи, которые нужно настроить для MQTT.\\nПервое - это адрес брокера MQTT.\\nОн настраивается с помощью инструмента настройки SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nУстановите `URL брокера` в разделе `Example Configuration`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nВторое - это тема MQTT.\\nМы устанавливаем ее в прошивке с префиксом имени проекта, за которым следует MAC-адрес нашего ESP32.\\nЭто дает нам `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` для нашей конкретной микросхемы.\\n\\n## От MQTT к Robonomics\\n\\nСначала давайте проверим, получаем ли мы данные по MQTT.\\nМы можем подписаться на тему брокера MQTT Mosquitto, на которую устройство публикует.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nЗдесь мы вводим пакет `mosquitto` в нашу среду, чтобы использовать утилиту `mosquitto_sub`.\\nЗатем мы подписываемся на тему, установленную в прошивке.\\nМы получили наши измерения, что означает, что AIRA правильно получает данные по MQTT.\\nТеперь давайте направим эти сообщения в сеть Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nЗдесь мы используем утилиту `robonomics` для публикации сообщений в канале pubsub `/freertos_mqtt_robonomics_example`.\\nМы указываем `bootnodes`, чтобы обеспечить установку хотя бы одного соединения.\\n\\nТеперь мы считываем эти сообщения из того же канала pubsub.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Использованные исходные ресурсы\\n\\n* Схема выводов ESP32 DevKitC от блога GoJimmy https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* Структура данных и декодер PSM3003 от OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Спасибо всем!**\\n\"}},{\"node\":{\"id\":\"50a7edd0757b7dcc4d2fb8fb7335eecd\",\"title\":\"Gaka-Chu setup and software Установка\",\"path\":\"/docs/ru/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**В этой статье мы рассмотрим некоторые этапы установки и запуска робота-художника. Требования:**\\n- KUKA KR6 R900 sixx с KRC4 и SmartPad;\\n- установленные Intel NUC с [ROS melodic](http://wiki.ros.org/melodic/Установка/Ubuntu);\\n- Стол, краска, кисть, вода.\\n\\n## Установка программного обеспечения на KRC4\\nТребуется интерфейс EKI как на KRC4, так и на NUC. Подробная информация о том, как его настроить на KRC4, представлена [здесь](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Запустите его на контроллере робота.\\n\\n## Установка программного обеспечения на NUC\\nСоздайте рабочее пространство catkin:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nЗагрузите пакеты ROS. Все скрипты хранятся [здесь](https://github.com/airalab/robot_painter/tree/test_branch). Клонировать репозиторий:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nВам может понадобиться некоторые заголовочные файлы и библиотеки, чтобы все работало правильно. Загрузите их:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nДобавьте команду source в файл `.bashrc`:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nНа данный момент вы должны иметь возможность запускать скрипты. Если что-то идет не так, попробуйте некоторые [решения проблем](https://github.com/airalab/robot_painter/issues)\\n\\n## Заполнение констант\\nПрежде всего, роботу необходимо знать местоположение и ориентацию холста, а также позицию банки с краской. Все это указывается в `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Давайте посмотрим на это.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nЭто константы уравнения плоскости, которые указывают положение холста в трехмерном пространстве. Они должны быть получены во время процесса калибровки, описанного ниже. Далее идет краска.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nЭто координаты банки с краской. Они также могут быть указаны при калибровке. Размер холста указывается в\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nЕще несколько важных констант хранятся в `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nИх названия говорят сами за себя, поэтому заполните их в соответствии с ситуацией.\\n\\n## Калибровка Gaka-Chu\\nСам процесс калибровки довольно прост.\\n\\n1) Запустите интерфейс EKI на KRC4:\\n\\nВойдите в режим 'AUT', включите драйверы и запустите скрипт `eki_hw_interface`\\n\\n2) Запустите интерфейс EKI на NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nОн должен выводить бесконечные журналы.\\n\\n3) Запустите RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nВы должны увидеть следующее:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nПопробуйте переместить рабочий орган и нажмите 'Plan and Execute'. Робот должен двигаться. На SmartPad перейдите к **Display -> Actual position** и наблюдайте координаты рабочего органа. Горизонтально расположите холст на базе робота. Вставьте кисть в держатель и аккуратно перемещайте ее, пока она едва касается холста. В этом положении сохраните координаты рабочего органа. Повторите 12-15 раз. Также сохраните координаты центра холста и банки с краской.\\nКогда у вас есть набор координат, используйте [эти](https://github.com/nakata5321/Matlab_scripts_gaka-chu) скрипты Matlab для определения недостающих констант и кватерниона. Вставьте их. Перестройте свое рабочее пространство с\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Тестирование калибровки Gaka-Chu\\nПосле калибровки Gaka-Chu необходимо протестировать, нарисовав границы холста. Чтобы сделать это, выполните каждую в новом терминале:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nПосле этого вы должны увидеть контур холста в RViz:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nВ терминале нажмите \\\"S\\\" для выполнения тестирования. Конечный эффектор робота должен двигаться прямо над границами холста, и кисть должна мягко касаться холста во время всего движения. Если это не так, попробуйте перекалибровать. Если модель холста повернута неправильно, вы можете повернуть ее, изменив кватернион в Matlab.\\n\\n## Создание искусства\\nДля работы вам понадобятся 6 основных модулей:\\n- Интерфейс EKI;\\n- MOVEit + RViz;\\n- Трансляция окружающих рамок;\\n- Сервис конвертации изображений;\\n- Модуль рисования траекторий;\\n- Триггер запуска.\\n\\nДавайте запустим их по одному.\\n\\n### Интерфейс EKI\\nПри запуске KRC4 запустите `eki_hw_interface`, на NUC в новом терминале выполните следующее:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz и MOVEit\\nВам понадобится планировщик и симуляция. Запустите их с помощью\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Окружение\\nСообщите роботу, где находятся банка с краской и холст. Обратите внимание, что нет необходимости запускать узел `draw workspace`, `tf_broadcaster` передает размер холста. Он просто не отображается в RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Обработчик изображений\\nВсе входящие изображения должны быть обработаны. Запустите сервис.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nКогда он получает вызов, он обрабатывает изображение с помощью фильтра HP и создает файл rosbag с траекториями.\\n\\n### Модуль рисования траекторий\\nОсновной скрипт здесь - это сам модуль рисования траекторий. Он ожидает изображение, вызывает сервис TextConverter и рисует картину.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Отправьте роботу изображение для рисования\\nРобот слушает определенную ROS-тему, где вам нужно передать путь к желаемому изображению. Изображение должно быть квадратным (ширина равна высоте) и состоять из линий. Отправьте путь:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nПосле этого появятся два окна, показывающие контуры и траектории. Закройте их и посмотрите, как рисует Gaka-Chu. Будьте внимательны к безопасности и всегда готовы нажать кнопку аварийной остановки.\\nКогда Gaka-Chu заканчивает свое искусство, вы можете отправить другой путь к изображению, и художник повторяет весь процесс.\\n\"}},{\"node\":{\"id\":\"f7b2d922a0cdf138a9c424b405a5b589\",\"title\":\"Как редактировать Wiki\",\"path\":\"/docs/ru/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki является открытым исходным кодом. Любые исправления приветствуются: исправление ошибок, опечаток, некоторой неясной или устаревшей информации, перевод на любой язык. Вам понадобится учетная запись [GitHub](https://github.com/).**\\n\\n\\n## Как редактировать\\n\\nЕсли вам нужно отредактировать документацию Robonomics Wiki, пожалуйста, следуйте этим шагам\\n\\nУбедитесь, что у вас установлены [Node.js](https://nodejs.org/en/download/package-manager/) и [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool).\\n\\n### 1. Клонировать репозиторий\\n\\nСначала вам нужно склонировать репозиторий вики:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nПерейдите в каталог репозитория и выполните следующие команды:\\n\\n`используя npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`используя yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Локальное развертывание (develop, develop-m1)\\n\\nЗатем разверните проект локально: \\n\\n```\\ngridsome develop\\n```\\n\\n> Если у вас возникла ошибка `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`, выполните следующую команду:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Создать запрос на включение изменений\\n\\n[Создайте запрос на включение изменений](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) в [репозиторий вики](https://github.com/airalab/robonomics-wiki)\\n\\n## Компоненты\\n\\n### Asciinema\\nRobonomics Wiki поддерживает Asciinema. Чтобы вставить Asciinema, пожалуйста, следуйте этим инструкциям:\\n* Импортируйте компонент после блока frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* Вставьте в отдельный параграф `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, где vid - это идентификатор конкретного asciicast\\n\\n> Вы можете получить скрипт виджета для конкретного asciicast, нажав на ссылку «Embed» на странице asciicast.\\n> Это выглядит так:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Asciinema docs](https://asciinema.org/docs/embedding)\\n\\nВ приведенном выше примере vid равно 14.\\n\\n### Код\\n\\nВы можете добавить полезные дополнения к своему коду: \\n\\n`код с кнопкой копирования`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nили `код с дополнительной строкой`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Свойства для code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nДокументация в Robonomics Wiki содержит блок frontmatter. Он должен находиться в верхней части файла Markdown и должен иметь форму допустимого YAML, заключенного между тремя черточками. Между тремя черточками вы можете установить или изменить следующие параметры:\\n\\n```YAML\\n---\\ntitle: How to contribute # Заголовок страницы, вам не нужно дублировать его в тексте\\ncontributors: [positivecrash] # Основные участники (кто активно курирует эту страницу). Требуется никнейм GitHub, без каких-либо дополнительных символов\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Установка\\n    # Инструменты, которые использовались для тестирования технологии\\n---\\n```\\n\\n### Grid \\nПомогает добавить сетку к элементам:\\n\\n- Сначала используйте обертку компонента сетки: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- А затем используйте внутри оболочки столько компонентов элементов сетки, сколько захотите:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Свойства для обертки robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Изображения\\n\\n#### Как загрузить \\nЗагрузите изображение в папку `/docs/images/url-of-your-doc`\\n* Если изображение должно быть локализовано, вставьте все изображения в одну папку\\n* Используйте локализационное приложение в имени изображений, если оно локализовано, например, `image_en.jpg`\\n* Убедитесь, что ваше изображение оптимизировано для веба и в то же время выглядит хорошо\\n\\n#### Как вставить \\n\\nЕсть два способа вставить изображения в ваши документы:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nРекомендуется вставлять изображения с помощью встроенного тега `<robo-wiki-picture>`, однако вы также можете использовать стандартный способ для файлов Markdown.\\n\\n</robo-wiki-note>\\n\\n`с подписью`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`или без подписи` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`или простое изображение` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`или простое изображение с подписью`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`изображение с альтернативным текстом`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Свойства для robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Примечания и предупреждения\\nВы можете добавлять примечания и указывать им определенные типы:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`примечание с заголовком`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`примечание с содержимым`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`примечание с заголовком и содержимым`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Свойства для robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nВы можете добавлять tabs в документ:\\n\\n- Используйте обертку компонента tabs: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- А затем используйте столько компонентов tab элементов, сколько вам нужно внутри обертки:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`горизонтальные tabs`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`вертикальные tabs`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`tab элемент с границей`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Свойства для robo-wiki-tabs (обертка)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Свойства для robo-wiki-tab (элемент)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Заголовок с якорями\\nВы можете создавать пользовательские заголовки с якорями и присваивать им определенное значение\\n\\n`заголовок с якорем`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nor\\n\\n`title without anchor`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Свойства для robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Видео\\n\\nЕсть два способа вставить видео в ваши документы:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nРекомендуется вставлять видео с помощью встроенного тега `<robo-wiki-video>`, однако вы также можете использовать стандартный способ для файлов Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Сервер\\nВам нужно указать формат видео\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Свойства\\n\\n- Если вы добавляете файл размером более <span style=\\\"color:#af1c1c\\\">10 МБ</span>, пожалуйста, загружайте его на сервер, а не в репозиторий.\\n\\n- Вы можете использовать любые свойства для [тега видео HTML5](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Допустимые форматы - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nВы можете вставить любое видео YouTube в документ, вставив ссылку на обмен в качестве отдельного абзаца без дополнительных кавычек или тегов, например: `https://youtu.be/kQaSwNYHJQ8`\\n\\nОднако, если вам нужно автоматическое воспроизведение, вам необходимо использовать специальный компонент: \\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Свойства для robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Как редактировать sidebar navigation\\n\\nЕсли вам нужно отредактировать боковую навигацию в Robonomics Wiki, пожалуйста, выполните следующие шаги:\\n\\n* Отредактируйте файл `/data/sidebar_docs.yaml`.\\n\\n* Решите, где разместить свой документ\\n\\n* Используйте допустимый YAML для `/data/sidebar_docs.yaml` и полагайтесь на существующую структуру файла\\n\\n* **ВАЖНОЕ ЗАМЕЧАНИЕ:** если вы используете один и тот же документ в разных разделах/подразделах, например: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Предустановленный образ для Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nУБЕДИТЕСЬ, ЧТО ДОБАВИЛИ ПАРАМЕТР `topic` ВОТ ТАК: \\n\\n(для правильной работы навигации) \\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## Как добавить пользовательскую навигацию для документов \\n\\n* Отредактируйте файл `/data/sidebar_docs.yaml`.\\n\\n* Найдите нужный документ и добавьте параметры `prev` и `next`, например:\\n\\n```\\n    - title_en: Как редактировать Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Если вы хотите полностью удалить навигацию, добавьте параметр `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Если вы хотите удалить только навигацию `previous page` или `next page`, добавьте параметр `withoutPrev` или `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nили\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"19f8cf3d5da341a8f1f074905b2b9779\",\"title\":\"Получайте уведомления, когда дверь открывается\",\"path\":\"/docs/ru/door-notification/\",\"content\":\"\\nВ этой статье вы установите интеграцию с ботом Telegram и настроите автоматизацию, которая будет отправлять уведомление на ваш аккаунт Telegram, когда дверь открывается.\\n\\n## Уведомления от бота Telegram\\n\\nДля начала вам необходимо создать личного бота в Telegram. Для этого зайдите к [специальному Telegram-боту @BotFather](https://t.me/botfather) и следуйте инструкциям.\\nСохраните свой токен для доступа к HTTP API.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nСохраняйте свой токен **безопасно** и храните его **надежно**, он может быть использован любым для управления вашим ботом. \\n\\n</robo-wiki-note>\\n\\nСледующий шаг - найти ваш ***User Chat ID***. Для этого используйте следующего [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nТеперь установим интеграцию \\\"Telegram broadcast\\\". Эта интеграция будет отправлять сообщения на ваш Telegram.\\n\\nДля предустановленного образа Robonomics, Docker Home Assistant или Ядро Home Assistant вам нужно отредактировать `configuration.yaml`. Подключитесь к Raspberry Pi через `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nВставьте следующие строки в конец файла. Вставьте свой **ключ API бота** и **ваш User Chat ID**. Также создайте имя для вашего сервиса уведомлений:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Сохраните конфигурацию и перезагрузите Home Assistant.**\\n\\n\\nВ результате в вашем сервисе Home Assistant будет создан сервис, который будет отправлять любое сообщение в чат Telegram с вами. \\nВы можете проверить это в меню Инструменты разработчика на веб-интерфейсе Home Assistant. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Уведомление об открытии двери\\n\\nТеперь пришло время создать автоматизацию. Сначала вы импортируете чертеж в свой Home Assistant по этой ссылке.\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nИ создайте автоматизацию.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nТеперь вы будете получать сообщение от Telegram бота каждый раз, когда дверь открывается.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nВы можете использовать эту автоматизацию с любыми дверями/окнами в вашем доме\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"993ecbb0ea7ea23d25951bc63eee693b\",\"title\":\"Цифровые двойники\",\"path\":\"/docs/ru/digital-twins/\",\"content\":\"  \\n**Представьте, что у вас есть сложное устройство или система, которая имеет несколько модулей для обслуживания и требует нескольких учетных записей для использования. Чтобы хранить все это в одном месте или кодировать некоторую функциональность с отдельными учетными записями или, например, устанавливать разные источники datalog для разных информационных потоков, используется модуль Digital Twin.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Обратите внимание, что эти и следующие учебники демонстрируются на локальном экземпляре узла Robonomics. Настройте свой с помощью [этих инструкций](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Обзор теории\\nЛюбая учетная запись может создавать и управлять Digital Twin. Twin можно представить как своего рода таблицу со следующим содержимым:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nГде:\\n* **DT id** - это беззнаковый целочисленный уникальный индекс Digital Twin.\\n* **Topic name** is a hex `H256` or ASCII data of 32 bytes length, same as [`Запуск`](/docs/launch) extrinsic parameter. \\nНапример: `0x1234....FF` или `hello.parachain.robonomics.world`.\\n* **Source** - это некоторый адрес учетной записи.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Как обсуждалось ранее во внешнем обзоре Запуска, `H256` может быть представлен как закодированный CID IPFS (см. [Инструмент Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) for that). для этого).\\n  Поэтому топики могут использоваться и как хранилище данных, например, описание модуля Twin.\\n\\n</robo-wiki-note>\\n\\n\\n## Создание Digital Twin\\n\\n### 1. Перейдите в Разработчик -> Экстрансики\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Выберите digitalTwin -> create из выпадающего списка возможных экстрансиков\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nОтправьте транзакцию. Здесь не требуются параметры для создания Twin. Теперь только владелец Digital Twin может добавлять/изменять темы Twin.\\n\\nID Twin можно найти на странице обзора Explorer.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Добавление темы\\n\\n### Выберите digitalTwin -> setSource из выпадающего списка возможных экстрансиков\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - ID Digital Twin, полученный на странице Explorer.\\n* `topic` - ранее обсуждаемое имя темы `H256`. На этой картинке это строка из 32 символов.\\n* `source` - адрес учетной записи, связанный с темой.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Обратите внимание, что тема может быть перезаписана другим адресом источника при необходимости.\\n\\n</robo-wiki-note>\\n\\nПодпишите и отправьте экстрансик.\\n\\n## Explore\\n\\nВы можете найти всю информацию о существующих Цифровые двойники в хранилище `Developer -> Chain state` модуля хранения `digitalTwin`.\\n\\n- Общее количество Twins - `total()`;\\n- Владелец Digital Twin - `owner(u32)`;\\n- Информация о темах Digital Twin - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"83bcf7c1175b6c1537358089a6a66a6f\",\"title\":\"Datalog\",\"path\":\"/docs/ru/datalog/\",\"content\":\"\\n**Теперь, когда у вас есть некоторые средства на вашем счету, вы можете отправлять экстрансики. Первым, что можно попробовать, является Datalog. Он позволяет сохранять данные в блокчейне постоянно. Представьте себе распределенное и крипто-защищенное хранилище для ваших данных, и это оно!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Обратите внимание, что эти и следующие учебники демонстрируются на локальном экземпляре Robonomics Node. Настройте свой с помощью [этих инструкций](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Перейдите в Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Выберите datalog -> record из выпадающего списка возможных экстрансиков\\n\\nТакже выберите учетную запись, с которой вы хотите отправить экстрансик. Заполните поле записи.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog поддерживает строку с максимальным размером 512 байт. Для хранения большого объема данных можно использовать [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Отправьте транзакцию\\n\\nПодпишите и отправьте транзакцию с учетной записью, созданной ранее с помощью расширения или DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  Вы также можете стереть **ВСЕ** ваши записи с помощью вызова *datalog -> erase*.\\n\\n</robo-wiki-note>\\n\\n## 4. Просмотрите свой datalog в хранилище\\n\\nДля этого перейдите в *Developer -> Chain state*,, выберите *datalog -> datalogIndex*, укажите вашу учетную запись и нажмите кнопку \\\"+\\\", чтобы получить индексы записей вашей учетной записи, а затем изучите нужную с помощью *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Исследуйтеr\\\">\\n\\n  Все события, включая запись datalog, можно увидеть в потоке событий в *Explorer*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"b716e6f613b1d1473641f96ebcb7662c\",\"title\":\"Создание цифровой идентичности, управляемой Ethereum\",\"path\":\"/docs/ru/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nОдин из сервисов Robonomics - [Регистрация цифрового паспорта](https://dapp.robonomics.network/#/passport/) для произвольных данных. Сервис позволяет создать цифровую идентичность, сохраняя хэши данных в общедоступном блокчейне и назначая уникальный адрес.\\n\\nВы можете найти сервис \\\"Digital passport registration\\\" в [Robonomics DApp](https://dapp.robonomics.network/) в разделе \\\"Services\\\" или просто перейти по этой [прямой ссылке](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Видеоинструкция\\n\\nВ следующем видео показан прогресс регистрации белой книги Robonomics:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Пошаговая инструкция с картинками\\n\\n### 1. Откройте сервис\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Добавьте необходимую информацию и файлы\\n\\nОбратите внимание, что можно добавить несколько изображений.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Подпишите запрос\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Утвердите токены\\n\\nСервис взимает небольшую плату. Но сначала вы должны утвердить необходимое количество токенов, которое будет потрачено с вашего счета.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Примите предложеие и снова подпишите сообщение\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Посмотрите созданный паспорт\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nПроцесс регистрации занимает некоторое время. В конце вы увидите ссылку на созданную идентичность.\\n\"}},{\"node\":{\"id\":\"b2ae5b9414ba424ca67c0b26c0b33342\",\"title\":\"Create Account for Robonomics Parachain\",\"path\":\"/docs/ru/create-account-in-dapp/\",\"content\":\"\\n**Для взаимодействия и работы с Robonomics Parachain разработчикам и пользователям необходимо создать учетную запись на портале Polkadot / Substrate. Учетная запись выполняет основные функции для сети: ваш общедоступный адрес сети (открытый ключ), контроль доступа к адресу и средствам (закрытый ключ), отправка транзакций в сеть, отображение ваших токенов и их количества и т. д. Ниже приведены два основных способа создания учетной записи для Robonomics Parachain.**\\n\\n## 1. Использование расширения браузера Polkadot{.js}\\n\\nРасширение Polkadot предоставляет механизм для создания учетной записи и взаимодействия со всеми проектами Polkadot / Kusama, включая Robonomics Parachain. Это не самый безопасный способ управления вашей учетной записью, но он наиболее удобен с точки зрения баланса безопасности и удобства.\\n\\n## 1.1. Установите расширение браузера\\n\\nРасширение браузера доступно для [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) и [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (а также для браузеров на основе Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Откройте приложение Robonomics Parachain\\n\\nПерейдите на [приложение Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) на портале Polkadot / Substrate. Если вы впервые входите в портал, он запросит доступ к расширению браузера, поэтому разрешите доступ. \\n\\nПосле открытия приложения обратите внимание на верхний левый угол. Там отображается название сети, ее значок и номер последнего блока. Нажав на эту область, вы откроете список всех сетей Polkadot / Kusama, включая тестовые сети и локальные узлы. Вы можете переключаться между сетями, выбрав нужную и нажав кнопку `Switch`. **Убедитесь, что вы подключены к Robonomics Parachain**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Обновите метаданные расширения\\n\\nОчень вероятно, что приложение попросит вас обновить метаданные для расширения, чтобы отобразить правильную информацию о подключенной вами цепочке. Перейдите в **Settings -> Metadata**, нажмите кнопку «Обновить метаданные», а затем во всплывающем окне разрешите расширению это сделать. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Создайте учетную запись в расширении\\n\\nОткройте расширение браузера Polkadot{.js}. Нажмите большую кнопку плюс или выберите `Create new account` из маленькой кнопки плюс в правом верхнем углу. Вы должны увидеть следующее меню с сгенерированным мнемоническим сидом в виде двенадцати слов и адресом. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nСид - это ваш ключ к учетной записи. Знание сида позволяет вам (или любому другому, кто знает сид) получить контроль над этой учетной записью и даже пересоздать ее, если вы забудете пароль. **Очень важно сохранить его где-то надежно**, предпочтительно на бумаге или другом недигитальном устройстве, а не в цифровом хранилище или на компьютере. \\n\\nСохраните сид и нажмите `Next step`. Вы должны увидеть следующее меню.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* позволяет выбрать, для каких сетей будет использоваться эта учетная запись исключительно. Вы можете использовать один и тот же адрес на нескольких сетях, однако из соображений конфиденциальности рекомендуется создавать новый адрес для каждой используемой сети. \\nВыберите сеть Robonomics из выпадающего списка. Если вы не смогли найти сеть Robonomics, скорее всего, вы не обновили метаданные, вернитесь и сделайте это.\\n\\n    - Вы заметите, что формат адреса и значок учетной записи изменятся - это нормально. Разные форматы сетей представляют собой просто другие представления одного и того же открытого ключа. \\n\\n- *Name* - это просто имя учетной записи, предназначенное только для вашего использования. Оно не хранится в блокчейне и не будет видно другим пользователям. \\n\\n- *Password* используется для шифрования информации вашей учетной записи. Вам потребуется ввести его заново при подписании транзакций на портале. Создайте его и запомните его.\\n\\nВ результате, после создания учетной записи, вы увидите ее в списке учетных записей в расширении Polkadot{.js}. Нажав на три точки, вы можете переименовать учетную запись, экспортировать ее, удалить ее из расширения и изменить используемую сеть для учетной записи. \\n\\nТакже учетная запись появится в меню **Accounts -> Accounts** на портале, где будет отмечено, что она была внедрена с использованием расширения.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Прямо на приложении Robonomics Parachain\\n\\nВы можете использовать пользовательский интерфейс на портале Polkadot / Substrate для создания учетной записи. Его можно использовать для разработки и тестирования. \\n\\n## 2.1. Откройте приложение Robonomics Parachain\\n\\nПерейдите на [приложение Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) на портале Polkadot / Substrate. **Проверьте в левом верхнем углу, что вы подключены к Robonomics Parachain**.  \\n\\nПерейдите в **Accounts -> Accounts** и нажмите кнопку `Добавить учетную запись`. \\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Создание учетной записи\\n\\nВы должны увидеть следующее всплывающее меню с семенем учетной записи. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nОно имеет две формы: *Мнемоническая* (читаемая человеком) и *Сырая* (последовательность цифр и букв). Сохраните фразу-семя надежно и нажмите `Далее`.\\n\\n> Также вы можете изменить тип криптографии создаваемой учетной записи, для этого откройте `Расширенные параметры создания` и выберите тип (`ed25519` на картинке).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nВ следующем меню вам нужно задать имя учетной записи и пароль, аналогично инструкциям расширения, описанным выше.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nНажатие кнопки `Next` перенесет вас в последнее окно. Нажмите `Save`, чтобы завершить создание учетной записи. Он также сгенерирует резервные файлы JSON, которые вы должны сохранить в надежном месте. Вы можете позже использовать этот файл для восстановления учетной записи, если помните пароль.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Добавление учетной записи ed25519 в расширение Polkadot\\n\\nВам может потребоваться добавить созданную учетную запись в расширение Polkadot.js (для учетной записи ed25519 вы можете сделать это только с помощью резервного файла JSON). Для этого вам нужно создать резервную копию учетной записи. Нажмите на три точки рядом с вашей учетной записью и выберите `Создать резервную копию файла для этой учетной записи` и введите пароль.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nЗатем откройте расширение и нажмите кнопку `+` в правом верхнем углу, затем выберите `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nВ открывшемся окне перетащите сохраненный файл, введите пароль и нажмите `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Учетная запись успешно создана \\n\\nТеперь вы можете полностью работать со своей только что созданной учетной записью. Отправляйте и получайте токены, сообщения, записывайте даталоги и многое другое. Не стесняйтесь исследовать все возможности приложения. Чтобы скопировать адрес вашей учетной записи, просто щелкните по ее значку, адрес будет скопирован в буфер обмена. \\n\\nЕсли вы хотите узнать больше о учетных записях Polkadot / Kusama и дополнительных способах их создания, дополнительную информацию можно найти [здесь](https://wiki.polkadot.network/docs/learn-accounts) и [здесь](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"9ea2fa080ea89f80e354315680cbdea8\",\"title\":\"Сервис компенсации выбросов\",\"path\":\"/docs/ru/carbon-footprint-service/\",\"content\":\"\\nПример работы есть в видео:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nСервис для компенсации выбросов CO2 путем сжигания токенов в сети Statemine.\\nРасчет произведенного CO2 производится следующим образом: данные с устройства в Вт умножаются на коэффициенты, зависящие от региона. 1 тонна CO2 компенсируется потреблением 1 токена. [Здесь](/docs/carbon-footprint-sensor) находятся инструкции по подключению устройства.\\n\\n## Сценарий\\n\\n1. Регистрация нового устройства в цифровом двойнике в сети Robonomics \\n2. Раз в интервал получение последних данных со всех устройств и их умножение на коэффициент, зависящий от региона\\n3. Суммирование данных и преобразование их в тонны CO2\\n4. Вычитание общего количества сгорающих токенов из текущих данных \\n5. Сжигание целого числа токенов в сети Statemine \\n6. Сохранение общего количества сгорающих токенов в локальной базе данных и Datalog \\n\\n\\n## Установка\\n\\nКлонирование репозитория и редактирование файла конфигурации.\\n\\n```\\ngir clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Конфигурация description\\n\\nНе редактируйте `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network where Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nКоэффициенты для нерегенеративной энергии были взяты из [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) и сохранены в `utils/coefficients.py`. \\n\\n## Запуск\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"4113122abf080efc4d2720d51b87056c\",\"title\":\"Как внести вклад в ресурсы Robonomics\",\"path\":\"/docs/ru/contributing/\",\"content\":\"\\nСеть Robonomics - это проект с открытым исходным кодом, и мы хотим сделать его доступным для всех желающих внести свой вклад. Вы можете создавать статьи, предлагать изменения, улучшать документацию или запускать тесты. Если вы хотите внести свой вклад, пожалуйста, откройте новую проблему или создайте запрос на включение изменений в том же репозитории.\\n\\n## Основные репозитории Robonomics \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) - Основной проект вики\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) - Официальный основной веб-сайт сети Robonomics \\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) - Домашняя страница для веб-сервисов Robonomics\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) - Официальное приложение\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) - Официальный веб-сайт Robonomics Academy\\n\\n### Правила для отчетности\\n\\nПри открытии новой проблемы не забудьте о нескольких основных правилах для отчетности:\\n\\n1. Выберите точный репозиторий, в котором вы хотите сообщить о проблеме.\\n\\n2. Если вы сообщаете о ошибке, убедитесь, что она еще не была сообщена.\\n\\n3. Обязательно укажите заголовок и четкое описание, а также максимально возможную информацию.\\n\\n4. Пожалуйста, добавьте префикс к вашей проблеме из следующих: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Запросы на слияние\\n\\nЛюбой репозиторий Robonomics может быть подвержен запросам на слияние или изменениям со стороны участников, если вы считаете, что у вас есть что-то ценное для добавления или изменения. Пожалуйста, не забывайте о базовых правилах для участников.\\n\\n### Правила для участия\\n\\n1. Запросы на слияние предпочтительнее проблем, если у вас есть какие-то исправления, особенно для небольших изменений, таких как опечатки.\\n\\n2. Убедитесь, что описание PR ясно описывает проблему и решение. Укажите соответствующий номер проблемы, если это применимо.\\n\\n3. Пожалуйста, не исправляйте пробелы, форматируйте код или делайте чисто косметические исправления.\\n\\n4. Пожалуйста, попытайтесь придерживаться преобладающего стиля, языка и макета Markdown.\\n\\n\\n\"}},{\"node\":{\"id\":\"913a55baa4b53921c2dff12ff4a46a1c\",\"title\":\"Подключите датчик\",\"path\":\"/docs/ru/carbon-footprint-sensor/\",\"content\":\"\\nПример работы есть в видео:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Требования\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Адаптер Zigbee [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (или один из [поддерживаемых](https://www.zigbee2mqtt.io/information/supported_adapters.html))\\n\\nСервис работает на Raspberry Pi и связывается со смарт-розеткой через протокол Zigbee.\\n\\n## Адаптер Zigbee\\n\\nЕсли у вас есть JetHome USB JetStick Z2, он уже имеет необходимое программное обеспечение, поэтому вам не нужно его прошивать. Но если у вас есть другой адаптер, сначала вам нужно прошить его с помощью программного обеспечения zigbee2MQTT. Инструкции для вашего устройства можно найти [здесь](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nПодключите адаптер и проверьте адрес адаптера (он также может быть `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nВозможно, вам потребуется получить доступ к USB-порту. Добавьте своего пользователя в группу `dialout` (это работает для Ubuntu, но имя группы может отличаться в других ОС).\\nДля Ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nДля Arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nЗатем выйдите из системы и войдите снова или перезагрузите компьютер.\\n\\n## Установка\\n\\nКлонируйте репозиторий:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Конфигурация\\n\\nПерейдите в `data/configuration.yaml` и установите `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nТакже вы можете заполнить поля `server` и `port` соответствующей информацией. В поле `server` используйте IP-адрес моста `docker0` для установления соединения: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nЗдесь ваш адрес - `172.17.0.1`.\\n\\nЗатем создайте файл config/config.yaml со следующей информацией и установите свое местоположение (вы можете посмотреть на https://countrycode.org/ для 3-буквенного ISO-кода):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Подключите розетку\\n\\nПервый запуск:\\n\\n```\\ndocker-compose up     \\n```\\n\\nЧтобы перейти в режим сопряжения с розеткой, удерживайте кнопку питания в течение нескольких секунд, пока не начнет быстро мигать синий свет. \\n\\nВ журналах вы должны увидеть, что ваша розетка начала публиковаться в mqtt. \\n\\n\\n## После сопряжения\\n\\nЕсли вы не хотите разрешить другим устройствам сопрягаться с вашим адаптером, теперь вы должны перейти в `data/configuration.yaml` и установить `permit_join: false`. Перезапустите сервис (используйте 'Ctrl+C' и \\n\\n```bash\\ndocker-compose up     \\n```\\nеще раз, чтобы применить изменения).\\n\\n## Запуск\\nПри первом запуске будет создан аккаунт для розетки. \\n> Если у вас уже есть аккаунт, вы должны добавить его сид в файл `config.config.yaml` в разделе `device_seed`:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nПосле создания аккаунта вы увидите адрес в журналах (сид будет добавлен в `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nВам нужно перевести некоторые токены на этот аккаунт для оплаты комиссии за транзакции, вы можете сделать это на [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nСервис увидит, что у вас достаточно токенов, в журналах вы увидите:\\n```\\nplug               | Balance is OK\\n```\\nСервис увидит mqtt-сообщения от розетки и обеспечит безопасное использование электроэнергии. Каждый час (вы можете изменить таймаут в `config/config.yaml` в разделе `sending_timeout`, таймаут указывается в секундах) будет создан журнал данных со следующей информацией:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"d786730453014ae485af64b97c6e2616\",\"title\":\"Резервные службы\",\"path\":\"/docs/ru/backup-services/\",\"content\":\"\\n**В этой статье вы узнаете, как создавать резервные копии конфигурации Home Assistant и восстанавливать ее при необходимости. Для создания резервных копий вызывается служба, которая генерирует защищенный архив с файлами конфигурации. Также служба добавляет конфигурацию Mosquitto brocker и Zigbee2MQTT в резервную копию, если они существуют. Затем эта служба добавляет архив в IPFS и сохраняет полученный CID в цифровом двойнике Robonomics.**\\n## Создание резервной копии конфигурации Home Assistant\\n\\nСоздание резервной копии позволяет легко восстановить конфигурацию Home Assistant в случае сбоя.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nДля резервного копирования и восстановления конфигурации необходимо использовать **пользовательский IPFS-шлюз**, такой как Pinata. Без него ваша резервная копия будет храниться только на вашем локальном узле IPFS, что может помешать восстановлению конфигурации Home Assistant в случае сбоя локального узла.\\n\\n</robo-wiki-note>\\n\\n1. В веб-интерфейсе Home Assistant перейдите в `Developer Tools` -> `Services`. Найдите `Robonomics: Save Backup to Robonomics` и нажмите `CALL SERVICE`.\\n\\n2. Дождитесь появления уведомления `Backup was updated in Robonomics` в разделе `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nНе пытайтесь создавать резервную копию или восстанавливать конфигурацию непосредственно после загрузки Home Assistant и интеграции Robonomics. Пожалуйста, **подождите примерно 5 минут**, чтобы завершить начальную настройку.\\n\\n</robo-wiki-note>\\n\\nАргументы службы:\\n- **Полная резервная копия** (по умолчанию: False) - добавляет базу данных в резервную копию, чтобы сохранялась история состояний сущностей.\\n- **Путь к файлу паролей mosquitto** (по умолчанию: `/etc/mosquitto`) - Если вы использовали методы установки Ядро Home Assistant или Docker и у вас нет стандартного пути к Mosquitto brocker, вы должны изменить этот параметр. *Не требуется для Home Assistant OS или Superviser*.\\n\\n## Восстановление конфигурации Home Assistant из резервной копии\\n\\nДля восстановления конфигурации вам понадобится установленный Home Assistant и интеграция Robonomics. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nЧтобы успешно восстановить конфигурацию в Home Assistant Core и методах установки Docker, вам необходимо выполнить дополнительные настройки, описанные в конце страницы.\\n\\n</robo-wiki-note>\\n\\n1. Установите Home Assisntant с интеграцией Robonomics (если еще не установлено), следуя шагам из статьи для [желаемого метода установки](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2. [Настройте интеграцию Robonomics](https://wiki.robonomics.network/docs/robonomics-hass-integration), используя **те же сиды**, которые вы использовали в предыдущей конфигурации Robonomics. Если ваша подписка закончилась, [возобновите ее](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. В веб-интерфейсе Home Assistant перейдите в `Develop2er To1ols` -> `Services`. Найдите `Robonomics: Restore from the Backup in Robonomics` и нажмите `CALL SERVICE`. Перейдите на страницу `Overview`, чтобы проверить состояние вашей резервной копии.\\n\\n4. После восстановления Home Assistant автоматически перезагрузится. Если по какой-либо причине Home Assistant не перезагружается, вы можете проверить статус восстановления, отслеживая состояние сущности `robonomics.backup`. Если статус - `restored`, вам нужно будет вручную перезапустить Home Assistant, перейдя в `Settings` > `System` и нажав кнопку `RESTART`, расположенную в правом верхнем углу.\\n\\n5. Если ваша резервная копия включает конфигурацию Zigbee2MQTT или Mosquitto, вам нужно перезапустить эти сервисы, чтобы включить новую конфигурацию. Вы можете сделать это вручную, перезапустив сервисы по отдельности, или просто перезапустив компьютер Home Assistant, чтобы убедиться, что все сервисы перезапущены.\\n\\nАргументы службы:\\n- **путь к файлу паролей mosquitto** (по умолчанию: `/etc/mosquitto`) - Если вы использовали методы установки Home Assistant Core или Docker и у вас нет пути по умолчанию к брокеру Mosquitto, вы должны изменить этот параметр. *Не требуется для Home Assistant OS или Superviser*.\\n- **Путь к конфигурации Zigbee2MQTT** (по умолчанию: `/opt/zigbee2mqtt`) - Если вы использовали методы установки Home Assistant Core или Docker и у вас нет пути по умолчанию к Zigbee2MQTT, вы должны изменить этот параметр. *Не требуется для Home Assistant OS или Superviser*.\\n\\n## Восстановление конфигурации Mosquitto и Zigbee2MQTT для метода установки Home Assistant Core\\n\\nЕсли резервная копия включает конфигурацию Mosquitto или Zigbee2MQTT, во время процесса восстановления они будут размещены в пути по умолчанию или в указанном в аргументах пути. Однако, если вы установили интеграцию Robonomics в существующий Home Assistant Core *(не из предустановленного образа Robonomics)*, пользователь `homeassistant` может не иметь доступа к этому пути.\\n\\nЧтобы восстановить конфигурацию Mosquitto и Zigbee2MQTT, вам нужно предоставить пользователю `homeassistant` необходимые права на чтение:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Резервное копирование конфигурации Mosquitto и Zigbee2MQTT для метода установки Home Assistant Docker\\n\\nЧтобы создать резервные копии конфигураций Mosquitto и Zigbee2MQTT из контейнера Docker, вам нужно создать тома для соответствующих конфигураций. Это можно сделать, запустив контейнер Home Assistant с дополнительными аргументами:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nили внести изменения в ваш файл `compose.yaml`:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nОбратите внимание, что пути по умолчанию для конфигураций Mosquitto и Zigbee2MQTT - `/etc/mosquitto` и `/opt/zigbee2mqtt` соответственно. Однако эти пути могут отличаться в зависимости от вашей конкретной настройки.\\n\\n</robo-wiki-note>\\n\\n## Кнопки резервного копирования\\n\\nПомимо использования сервисов для работы с резервными копиями, вы можете упростить процесс, используя кнопки `button.create_backup` и `button.restore_from_backup` из интеграции Robonomics. Эти кнопки вызывают соответствующие сервисы с параметрами по умолчанию (кнопка резервного копирования создает резервную копию без истории).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nЧтобы добавить кнопки на вашу панель управления, выполните следующие действия:\\n\\n1. Нажмите на три точки в правом верхнем углу панели управления.\\n2. Выберите `Edit Dashboard`.\\n3. Нажмите кнопку `Add Card` в правом нижнем углу.\\n4. Выберите карточку Entities`.\\n5. В поле Entities` найдите сущности button.create_backup и button.restore_from_backup.\\n6. Нажмите `Save`, чтобы добавить сущности на карточку.\\n7. Завершите редактирование, нажав кнопку `Done` в правом верхнем углу.\"}},{\"node\":{\"id\":\"0a8047a57192c7796dcbf415107506b9\",\"title\":\"Добавление средств на ваш счет в портале Robonomics\",\"path\":\"/docs/ru/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**После успешного создания учетных записей на портале Robonomics настало время пополнить их средствами, чтобы вы могли инициировать транзакции.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Обратите внимание, что эти и следующие учебники демонстрируются на локальном экземпляре узла Robonomics. Настройте свой с помощью [этих инструкций](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Перейдите в раздел «Аккаунты» на портале Робономики.\\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Выберите счет, с которого хотите перевести средства\\n\\nВ режиме разработки существует несколько счетов с 10000 единицами средств каждый, которые можно использовать для перевода средств на другие счета, созданные в сети разработки. Эти счета обозначены значками гаечного ключа <img alt=\\\"значок гаечного ключа\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> рядом с ними.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Нажмите на кнопку \\\"send\\\" счета, с которого хотите перевести средства, например BOB\\n\\n## 3. Выберите счет, на который хотите перевести средства\\nПосле нажатия на кнопку \\\"send\\\" вам будет предложено окно \\\"send funds window\\\". В предложенном окне:\\n\\n- Из списка доступных счетов выберите счет, на который хотите отправить средства.\\n- Введите количество единиц, которые вы хотите отправить.\\n- Нажмите \\\"make transfer\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Авторизуйте транзакцию\\n\\nПосле нажатия \\\"make transfer\\\" на предыдущем этапе вам будет предложено окно \\\"authorize transaction window\\\".<br/>\\nПроверьте детали транзакции и нажмите кнопку \\\"sign and submit\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nВ этом примере мы перевели 500 единиц средств с \\\"BOB\\\" на \\\"EMPLOYER\\\". Вы можете видеть, что на счету EMPLOYER, который изначально не имел средств, теперь есть 500 единиц средств.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Убедитесь, что у вас достаточно средств на счетах, которые вы хотите использовать в песочнице.**\"}},{\"node\":{\"id\":\"92ed01871577df0b438fa14f2d80b801\",\"title\":\"Adaptador Zigbee com Zigbee2MQTT para Imagem Pré-instalada\",\"path\":\"/docs/pt/zigbee-to-mqtt-image/\",\"content\":\"\\n**Neste artigo você irá parear dispositivos inteligentes.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nAbra um navegador da web e vá para `http://%RASPBERRY_IP_ADDRESS%:8099`. Você pode encontrar o endereço IP do Raspberry Pi usando o [aplicativo móvel Fing](https://www.fing.com/products) ou a [ferramenta de linha de comando nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nVocê verá a interface web do Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nÉ hora de conectar seu dispositivo inteligente. \\nPrimeiro, pressione o botão `Permit join (All)` no topo da interface web do Zigbee2MQTT. \\n\\nEm seguida, comece a parear os dispositivos. A maneira mais comum de colocar um dispositivo no modo de conexão é segurar seu botão de energia ou ligá-los/desligá-los 5 vezes. Certifique-se de que o Zigbee2MQTT esteja em execução.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nQuando o dispositivo se conectar, você os verá na interface web:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nAgora você deve ver este sensor em sua interface web do Home Assistant. Vá para `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nApós adicionar todos os sensores, você pode fechar a interface web do Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"5cb539cb43ea399e5b249905f21c5787\",\"title\":\"Substrate Cumulus Parachain Testsuite para mensagens entre cadeias cruzadas\",\"path\":\"/docs/pt/xcm-robobank/\",\"content\":\"\\n\\nO objetivo principal deste projeto é a simplificação do desenvolvimento de tempo de execução de parachain, quando mensagens entre cadeias cruzadas são usadas. \\nEle permite o desenvolvimento de código de tempo de execução com testes de integração com alto grau de repetibilidade e uso simples.\\nAutomatiza a construção, construção de configuração de rede pré-definida (ou seja, 1 cadeia de retransmissão + 2 parachains), configuração de canais de passagem de mensagens entre parachains e execução de testes de mensagens, envio de mensagens, usando chamada para tempo de execução, tudo construído e composto em Python.\\n\\nXCM Testsuite é usado para testar o ciclo de produção da Robobank - o conjunto de paletes Substrate, que permitem que robôs se registrem em parachains externos, recebam pedidos pré-pagos, executem-nos e recebam pagamentos usando tokens externos. Isso permite que os robôs operem dentro da rede Robonomics com toda a infraestrutura necessária, mas ao mesmo tempo, ofereçam seus serviços em qualquer outro parachain.\\n\\nUm exemplo de vídeo está disponível no [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nAs principais etapas no cenário de demonstração são:\\n- lançar cadeia de retransmissão e dois parachains em um pacote de 6 processos\\n- configurar canais de mensagens XCM entre parachains\\n- registrar um robô em ambos os parachains\\n- criar um pedido para este robô no parachain do cliente (reservando pagamento para a conclusão do pedido)\\n- enviar mensagem XCM para o parachain Robonomics\\n- criar o registro de pedido \\\"espelhado\\\" no parachain Robonomics\\n- robô aceita o pedido no parachain Robonomics\\n- enviar mensagem XCM sobre a aceitação do pedido de volta ao parachain do cliente\\n- aceitar o pedido no parachain do cliente (reservando uma taxa de penalidade por falta de conclusão do pedido até o prazo do pedido)\\n- robô conclui o pedido no parachain Robonomics\\n- enviar mensagem XCM sobre a conclusão do pedido para o parachain do cliente\\n- resolver todos os pagamentos (o pagamento do cliente é transferido para o robô, assim como a taxa de penalidade não utilizada)\\n- fechar o pedido1\\n\\n\\n## Upstream\\nEste projeto é um fork do\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nEle contém o código dos paletes de tempo de execução sendo testados.\\nComo no código original do nó, os parachains estão nos catálogos \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nDiferenças com o \\\"substrate-node-template\\\" original:\\n- este tempo de execução do coletor tem o módulo do manipulador HRMP e pode lidar com mensagens de parachains irmãos\\n- tempo de execução de teste simulado pronto para testes internos de XCM\\n\\n## Construir & Executar\\nConfiguração recomendada (altamente): \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[NOTA] A primeira compilação pode levar muito tempo, até várias horas em máquinas subótimas.\\n\\n[NOTA] O script funciona com as versões FIXAS (hashes de commit) do Polkadot (Rococo) na cadeia de retransmissão e nos parachains.\\n\\n[NOTA] Por padrão, o script recria o mesmo ambiente a cada inicialização, removendo todos os estados anteriores. Esse comportamento pode ser alterado em \\\"config.sh\\\" usando o parâmetro \\\"PERSISTENT\\\".\\n\\n\\nExecute o script de compilação e configuração.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nAções básicas do script \\\"init.sh\\\":\\n - ler configuração (arquivo \\\"config.sh\\\" com número de revisão, chaves e identificadores iniciais do nó, parâmetro de persistência de dados da cadeia, etc.)\\n - configurar pacotes do sistema operacional, Rust e Python\\n - gerar binários separados para a cadeia de retransmissão e também para ambos os parachains\\n    - os binários serão gerados no subdiretório ./bin. \\n - (opcional) remover todos os dados anteriores da cadeia para todas as cadeias\\n    - desativado se \\\"PERSISTENT=1\\\" estiver definido em \\\"config.sh\\\"\\n - executar como processos separados (com PIDs e pipes de E/S separados):\\n    - validadores da cadeia de retransmissão (ou seja, 4 validadores de execução de uma revisão estável do Rococo)\\n    - coletor para parachain-100 (ou seja, único coletor para o primeiro parachain que você está desenvolvendo)\\n    - coletor para parachain-200 (ou seja, único coletor para o segundo parachain que você está desenvolvendo)\\n - imprimir todos os endpoints, portas no console, permitindo que você estude qualquer cadeia usando aplicativos front-end (explorador, DApp)\\n - continuar imprimindo todos os dados de saída de todas as cadeias no console\\n\\n[AVISO] Após o lançamento, aguarde até que a rede esteja ativa, verifique se a finalização do bloco foi iniciada e se os parachains estão registrados. Esses processos devem levar aproximadamente 5 minutos (50 blocos x 6 segundos).\\n\\n## Verificando se a configuração inicial funciona \\n\\nUse a interface padrão do Polkdot e os endpoints gerados \\\"--ws-port\\\" para se conectar a cada nó.\\nAbra o [aplicativo Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) para monitorar as cadeias. \\n\\n### Exemplo:\\nLocalhost, 4 validadores de cadeia de retransmissão, um coletor parachain-100, um coletor parachain-200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nSe tudo funcionar e o consenso começar, podemos prosseguir para executar nossos casos de teste (em um novo terminal).\\n\\n### Teste de passagem de mensagem UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nEle cria uma mensagem `Balance.transfer` em `parachain-100` e a passa para a cadeia de relé.\\nQuando a cadeia de relé recebe a mensagem, ela transferirá 15 tokens da conta `para 100` para a conta Charlie.\\n\\n\\n### Teste de passagem de mensagem HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nEle cria uma mensagem `Balance.transfer` em `parachain-100` e a passa para o `sibling 200`.\\nAntes disso, ele endossa a conta `subl 100` com 1000 tokens e estabelece um canal de comunicação entre as parachains.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nAs próximas mensagens podem ser enviadas executando o subcomando `hrmpm`. Isso não cria um canal e, portanto, é executado mais rápido.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Mais opções\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Testnet Local\\n\\n### Criar especificação de cadeia personalizada\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nEdite o arquivo rococo_local.json, substitua os parâmetros de saldos e autoridades pelos seus.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nEndereço Polkadot para //Alice//stash (criptografia sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nChave de sessão Polkadot grandpa para //Alice (criptografia ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nEndereço Polkadot para //Alice (criptografia sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nConverter rococo_local.json para o formato bruto.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nPara usar a nova especificação de cadeia, substitua o arquivo rococo.json no diretório ./config/ por este novo e execute novamente a cadeia.\\n```bash\\n./scripts/init.sh run\\n```\\nVocê pode editar o código livremente. O comando acima reconstruirá o projeto e atualizará o nó do colator antes de iniciar.\\nCumulus é um software pré-lançamento que ainda está em desenvolvimento intenso.\\nEstamos usando um commit específico do polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15 18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nVocê pode usar versões mais recentes do software. Para fazer isso, altere POLKADOT_COMMIT em ./scipt/config.sh\\npara o commit mais recente do branch `rococo-v1`, exclua ./bin/polkadot e execute \\n```bash\\n./scripts/init.sh run\\n```\\n\\nAtualize as dependências do projeto do colator \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nAlgumas dependências provavelmente requerem novos recursos da ferramenta rust. Este projeto é baseado no rust `nightly-2021-01-26`\\nAtualize a versão da ferramenta rust em ./scripts/config.sh antes de compilar.\\n\\n## Hackeie a parachain\\n[Adicione um pallet externo](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - deve estar provavelmente em \\\"saiba mais\\\"?\\n## Learn More\\n\\nConsulte o [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template) upstream para saber mais sobre a estrutura deste projeto, as capacidades que ele encapsula e a maneira como essas capacidades são implementadas. Você pode saber mais sobre [O Caminho de um Bloco de Parachain](https://polkadot.network/the-path-of-a-parachain-block/) no blog oficial do Polkadot. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"3755163f6b9ff19b6060e100771eb71d\",\"title\":\"Como usar Blueprints\",\"path\":\"/docs/pt/use-blueprints/\",\"content\":\"\\nNeste artigo, você aprenderá como adicionar blueprints de automação ao seu Home Assistant e configurá-lo.\\n\\n## Blueprints de Automação\\n\\nAlguns blueprints já estão instalados. Automações baseadas nesses blueprints só precisam ser configuradas. Na interface web, você pode encontrar blueprints pré-instalados em `Settings/Automations & Scenes`. Abra `Blueprints` e encontre o blueprint que você deseja usar. Neste exemplo, será usado `Motion-activated Light`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nClique em `Create Automation` para abrir o editor de automação. Dê um nome, escolha um blueprint para usar (`Motion-activated Light` no nosso caso). Depois disso, você precisa escolher o sensor de movimento e a lâmpada. Quando a configuração estiver concluída, clique em `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Configuração\\\" />\\n\\nSe você quiser fazer alterações, pode encontrá-lo indo para `Settings/Automations & Scenes` e depois `Automations`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Importando Blueprints\\n\\nO Home Assistant pode importar blueprints dos fóruns do Home Assistant, GitHub e GitHub gists. A lista de todos os blueprints está localizada em [Blueprints Exchange](https://community.home-assistant.io/c/blueprints-exchange/53). Depois de escolher, vá para `Settings/Automations & Scenes` e abra `Blueprints`. Clique em `Import Blueprint` e insira a URL do blueprint escolhido. Em seguida, clique em `PREVIEW BLUEPRINT`. Neste caso, usaremos [Detecção e notificação de nível de bateria baixo para todos os sensores de bateria](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nIsso carregará o blueprint e mostrará uma visualização na caixa de diálogo de importação. Você pode alterar o nome e concluir a importação. Clique em `Create Automation` para abrir o editor de automação. Aqui você pode configurar os parâmetros da automação e adicionar ações para receber notificações.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"cd11b42e628c127941d1de1200b56085\",\"title\":\"Ativar Assinatura\",\"path\":\"/docs/pt/sub-activate/\",\"content\":\"\\nNeste artigo, você criará contas de parachain Robonomics e comprará uma assinatura IoT. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nPara controlar o Home Assistant com Robonomics, você precisa de 2 contas no parachain Robonomics. Para uma das contas (`sub_owner`), você comprará uma assinatura Robonomics. A segunda conta (`sub_controller`) controlará todos os processos do Home Assistant (como telemetria) e dará acesso a outros usuários. Essas contas fornecerão segurança para o seu Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nAmbas as contas devem ser criadas com criptografia **ed25519**. Por causa disso, você precisa criar uma conta usando a UI Polkadot-JS e selecionar a criptografia necessária.\\n\\nEssa funcionalidade está desativada por padrão na interface do Polkadot-JS UI. Para ativá-la, vá para `Settings` -> `General` -> `account options` e selecione `Allow local in-browser account storage` no menu suspenso`in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Criar contas de proprietário e controlador\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Acesse o [aplicativo Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) no Portal Polkadot / Substrate. **Verifique o canto superior esquerdo para garantir que você esteja conectado ao Robonomics Parachain.**\\n\\n2. Vá para `Accounts` -> `Accounts` e clique no botão `Add account`. Você verá o menu suspenso com a semente da conta. Ela tem duas formas: *Mnemonic* (legível por humanos) e *Raw* (uma sequência de dígitos e letras). \\n\\n3. Abra `Advanced creation options`, altere o tipo de criptografia da criação da conta para `Edwards - ed25519` e clique em `Next`.\\n\\n\\n4. Salve a frase-semente mnemônica com segurança e clique em `Next`.\\n\\n5. No próximo menu, você precisa definir o nome da conta e a senha. Dê a ele o nome `sub_owner` para conveniência. Clique em `Next`.\\n\\n6. Na última janela, clique em `Save` para concluir a criação da conta. Ele também gerará arquivos JSON de backup que você deve armazenar com segurança. Você pode usar este arquivo posteriormente para recuperar sua conta, se lembrar da senha.\\n\\n7. Repita essas etapas para uma conta com o nome `sub_controller`.\\n\\n\\n## Adicionar Contas ao Polkadot.js\\n\\nPara maior conveniência, você deve usar a [extensão Polkadot.js](https://polkadot.js.org/extension/) e adicionar essas contas recém-criadas a ela. Para uma conta ed25519, você só pode fazer isso com um arquivo JSON de backup. Você pode usar os arquivos salvos quando criou as contas.\\n\\nVocê pode obter esses arquivos novamente criando um arquivo de backup da conta. Clique nos três pontos em sua conta, escolha `Create a backup file for this account` e digite sua senha.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Abra uma extensão e clique no botão `+` no canto superior direito, em seguida, escolha `Restore account from backup JSON file`.\\n\\n2. Em uma janela aberta, faça o upload do arquivo JSON, insira a senha e clique em `Restore`.\\n\\n3. Verifique se a rede Robonomics está selecionada para as contas na extensão Polkadot.js. No Portal Polkadot / Substrate, vá para  `Setting` -> `Metadata` e clique no botão `Update metadata`.\\n\\n4. Confirme a atualização dos metadados na janela pop-up. Agora, a extensão mostrará o rótulo da rede para a qual o endereço é usado.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Ativar Assinatura Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nPara esta etapa, você deve ter uma quantidade suficiente de tokens XRT (mínimo de 2-3 XRTs) em sua conta `sub_owner`.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Acesse o dapp Robonomics na [página de assinatura](https://dapp.robonomics.network/#/subscription) e clique em conectar conta na barra lateral direita.\\n\\n2. No menu pop-up seguinte, conecte a extensão Polkadot.js. Você verá o endereço da sua conta com saldo.\\n\\n3. Antes de comprar, verifique se você escolheu a conta `sub_owner`. Clique no ícone do perfil do endereço, você deve ver a conta `sub_owner` abaixo do campo `Verificar conta proprietária`.\\n\\n4. Por fim, clique no botão `SUBMIT` e insira a senha da sua conta. Depois disso, aguarde até que o processo de ativação seja concluído. Você verá o estado da sua assinatura após algum tempo.\\n\\n\\n## Adicionar Contas à Assinatura\\n\\nAgora você precisa adicionar uma conta `sub_controller` à **lista de acesso**.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Abra a extensão e clique no ícone próximo ao nome da conta. Ele copiará o endereço da conta.\\n\\n\\n2. Cole este endereço no campo `Robonomics parachain address` na parte **Gerenciar acesso**. Dê um nome a ele e clique no botão `+`. \\n\\n3. Repita as etapas 1 e 2 para a conta `sub_owner`.\\n\\n4. Clique em `Save`. Insira a senha do seu `sub_owner` na janela pop-up e aguarde até que o processo de ativação seja concluído.\\n\"}},{\"node\":{\"id\":\"abb68a189fe24bbdcc548aa31813cc94\",\"title\":\"Como enviar um lançamento com assinatura\",\"path\":\"/docs/pt/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Preste atenção que este tutorial demonstra o uso de uma assinatura na parachain Robonomics Kusama. Você também pode realizar todos os mesmos passos em seu [nó local](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nSe o seu endereço tiver uma assinatura ativa, então qualquer dispositivo configurado com a chave secreta dessa conta pode enviar extrínsecos sem taxa. \\nVamos tentar enviar o comando `launch`.\\n\\nVá para a página `Developer/Extrinsics`, em seguida, escolha sua conta (aquela da lista de dispositivos) e selecione `rws -> call(subscriptionId, call)`. \\nEm seguida, no campo `subscriptionId`, cole o endereço do proprietário da assinatura (aquele que fez o lance no leilão) e no próximo campo escolha `launch -> launch(robot, param)`. No campo `robot`, digite o endereço para o qual você deseja enviar a transação `launch` e insira o comando (para a descrição do comando de lançamento, consulte [aqui](/docs/launch)). Em seguida, envie a transação:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\nAgora vá para a página `Network/Explorer` e na área `Recent Events` você verá dois eventos que você criou; `rws.NewCall` e `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"42bf1a81eddf0e6aa4e8ea6afe2dfb6b\",\"title\":\"Obtenha Telemetria de Casa Inteligente\",\"path\":\"/docs/pt/smart-home-telemetry/\",\"content\":\"\\n**Neste artigo, você usará o serviço Robonomics, que consulta a telemetria de dispositivos de casa inteligente.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Acesse o dapp e escolha o serviço [SmartHome Telemetry](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. No campo do controlador, insira o endereço `SUB_CONTROLLER`. Insira a frase de segurança para criptografar os dados.\\n\\n3. No bloco `Get telemetry`, escolha um carimbo de data/hora na lista suspensa e pressione o botão `DOWNLOAD TELEMETRY`.\\n\\n4. O download da telemetria pode levar algum tempo. Após a conclusão, você verá as informações de seus dispositivos e sensores.\\n\\n\\n<!---\\n## Lançamento devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Launch\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"e219fcf1435850d8a8f3dbd4acb0be91\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/pt/sls-gateway/\",\"content\":\"\\n**Neste artigo, você configurará o Robonomics SLS Gateway. Você instalará o software necessário para o gateway, o configurará e o conectará ao Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nPrimeiro, você precisa instalar o firmware do microcontrolador do gateway. Prepare o gateway configurando as chaves `1` e `3` na parte inferior do SLS Gateway para `ON`, as outras devem estar `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nConecte o gateway ao seu Raspberry Pi através da porta USB tipo-C no gateway.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nClone o repositório com o firmware para o seu Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nVá para `robonomics-hass-utils/esp_firmware/linux`. Para atualizar o gateway SLS, você precisa executar os scripts `Clear` e `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Solucionando Problemas\\n\\nSe você estiver enfrentando problemas ao atualizar o firmware do gateway, você precisa seguir etapas adicionais:\\n\\n1. Certifique-se de ter o módulo pySerial instalado:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Dê ao seu usuário direitos de acesso à porta USB e reinicie o computador:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. Em alguns casos, é necessário alterar a configuração de largura de banda no script para atualizar o firmware. Abra o script `Flash_16mb.sh` com o editor `nano` e altere o parâmetro de velocidade de transmissão de `921600` para um valor menor (por exemplo, `115200`).\\n\\n## Configuração\\n\\n1. Desconecte o SLS Gateway do computador. Configure as chaves na parte de trás do gateway para a posição correta. As chaves `5` (RX Zigbee para ESP) e `6` (TX Zigbee para ESP) devem estar na posição `ON`, as outras devem estar `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Conecte o cabo de alimentação tipo-C. A luz indicadora no centro deve ficar verde.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. Na primeira inicialização, o gateway começará a compartilhar Wi-Fi com o SSID `zgw****`. Conecte-se a esta rede. Tenha em mente que o sinal pode ser fraco, então é melhor manter o gateway SLS mais próximo do seu computador. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Se a conexão for bem-sucedida, a interface web será aberta (ou você pode encontrá-la no endereço 192.168.1.1). \\n\\n5. Você verá a página `Wi-Fi Settings`. Selecione sua rede Wi-Fi e insira a senha. Pressione o botão `Apply`. O gateway reiniciará e se conectará à sua rede Wi-Fi. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Encontre o IP local do gateway SLS para acessar a interface web. Para encontrá-lo, você pode usar o [aplicativo móvel Fing](https://www.fing.com/products) ou a [ferramenta de linha de comando nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). O nome do gateway deve ser parecido com este: `zgw****`. Abra a interface web do gateway colando o IP do gateway em um navegador.\\n\\n7. Vá para `Setting` -> `Hardware` e verifique se as configurações estão iguais à imagem. Corrija as configurações, se necessário, e clique no botão `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nA tabela com os valores necessários:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Em seguida, reinicie o gateway. Escolha `Actions` -> `Reboot system` no canto superior direito.\\n\\n9. Verifique se o gateway está funcionando corretamente na janela de informações do Zigbee. O DeviceState deve ser `OK`.\\n\\n10. Configure a adição automática de dispositivos ao Home Assistant. Vá para  `Zigbee` -> `Config` e escolha `Home Assistant MQTT Discovery` e `Clear States`. Salve as alterações e **reinicie** o gateway SLS.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSe você já tiver um gateway SLS ativo em sua casa e estiver configurando outro, eles entrarão em conflito. Para resolver esse problema, você precisa alterar o canal no novo dispositivo. Para fazer isso, vá para `Zigbee` -> `Config` e altere o canal para outro (por exemplo, canal 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Emparelhando o SLS com o MQTT\\n\\nApós configurar o SLS Gateway, você precisa conectar o SLS Gateway ao Home Assistant. Abra a interface web do SLS Gateway e vá para `Settings/Link` -> `MQTT Setup`:\\n\\n\\nAdicione o endereço do seu broker (endereço do Raspberry Pi com o Home Assistant na rede local, você pode encontrá-lo com o [aplicativo móvel Fing](https://www.fing.com/products) ou a [ferramenta de linha de comando nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), porta (padrão é `1883`), nome de usuário e senha do seu broker (que você criou anteriormente) e o nome do tópico (você pode escolher qualquer um). Além disso, o endereço IP do Raspberry Pi deve ser estático. Clique em `Enable` e `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nSalve as alterações. Agora, os dispositivos serão mostrados automaticamente no Home Assistant.\\n\\n## Conectar Dispositivos\\n\\nConecte seus dispositivos indo para `Zigbee` -> `Join`. Coloque seus sensores no modo de emparelhamento, a maneira mais comum de alternar um dispositivo para o modo de conexão é segurar seu botão de energia ou ligá-los/desligá-los 5 vezes. Pressione o botão `Enable Join` para iniciar a busca por dispositivos Zigbee. Você verá sensores ativos.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nAgora você pode ir para a seção [**Assinatura IoT**](/docs/sub-activate) e começar a ativar a assinatura Robonomics.\\n\"}},{\"node\":{\"id\":\"2e4b16b59f3e949317d9d66a414a3cdf\",\"title\":\"Rede de Sensores Descentralizada\",\"path\":\"/docs/pt/sensors-network-introduction/\",\"content\":\"\\nOs artigos sobre a Rede de Sensores Descentralizada foram transferidos para a Robonomics Academy: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"f964b5fb9c789cf79258c2796ca35e1d\",\"title\":\"Conecte com segurança a IA em nuvem ao chão de fábrica\",\"path\":\"/docs/pt/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nAs tecnologias Robonomics já podem resolver os desafios enfrentados pela Indústria 4.0 e já estão sendo aplicadas em cenários do mundo real no ambiente industrial.\\n\\nUm grande número de empresas de IA está construindo soluções para otimizar os processos no cho de fábrica, permitindo que as plantas produzam mais com menos custo. No entanto, a maioria das plantas reluta em conectar sua infraestrutura à nuvem diretamente, pois isso resulta em riscos potenciais de segurança cibernética, que podem levar a perdas de milhões de dólares e até mesmo à perda de vidas humanas.\\n\\n[MerkleBot](https://merklebot.com) usou [Robonomics Network](https://robonomics.network) para construir uma solução para clientes industriais conectarem sua fábrica à IA baseada em nuvem de forma segura.\\n\\nEste artigo é escrito após um experimento que conduzimos com o [Veracity Protocol](https://www.veracityprotocol.org/) que usa algoritmos para criar proteção não invasiva de qualquer item físico com base nas fotografias de um dispositivo móvel.\\n\\nEste caso de uso mostra o processo de digitalização das peças industriais usando um braço robótico.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Processo passo a passo\\n\\n### DApp como interface do usuário\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp atua como uma interface do usuário para o operador. É usado para solicitar o lançamento do robô para coletar as fotografias e seu objetivo é permitir a comunicação segura entre o ambiente da fábrica e a IA baseada em nuvem.\\n\\n### Lançando o robô\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nO operador inicia a digitalização robótica assinando a transação no DApp. Esta etapa garante que o processo no chão de fábrica só possa começar com base na transação no blockchain público.\\n\\nO robô recebe um comando do blockchain através da Robonomics Network e inicia a digitalização. As tecnologias da Robonomics Network nos permitem fechar a lacuna entre o objetivo comercial e a operação robótica.\\n\\n### Coleta de dados e envio para IA baseada em nuvem\\n\\nNo DApp, o operador vê a confirmação e o robô começa a digitalizar os itens colocados na mesa, como neste caso de uso, ou diretamente na linha de produção da fábrica, se necessário.\\n\\n<!-- ![](../images/Veracity_Protocol_Launch.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nQuando o robô coleta os dados, ele os armazena localmente e os disponibiliza para a IA baseada em nuvem através do protocolo IPFS. Ao criptografar os dados e organizar a troca de dados por meio de uma transação blockchain, podemos autorizar o acesso à IA baseada em nuvem, garantindo que os dados permaneçam seguros e no local.\\n\\nO mecanismo de segurança incorporado à Robonomics, com base na segurança compartilhada de blockchains públicos, permite obter o nível de segurança que é proibitivamente caro para a maioria das fábricas organizarem por conta própria.\\n\\n### Criação de passaporte digital\\n\\nQuando a IA baseada em nuvem analisa os dados, o arquivo de log e as recomendações são registrados automaticamente como um [Passaporte Digital](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/). Cada operação e digitalização podem ser rastreadas, pois o registro blockchain possui o hash de todos esses arquivos através do protocolo IPFS.\\n\\n## Comentários sobre o caso de uso\\n\\nNeste caso de uso, foi utilizado o braço industrial Universal Robot UR3. Mas, graças ao suporte da Robonomics para ROS, a maioria dos principais manipuladores industriais pode ser usada e conectada à IA baseada em nuvem de forma segura, incluindo KUKA, Fanuc e Yaskawa.\\n\\nSe você estiver interessado em saber mais sobre a implantação e integração de instrumentos de IA baseados em nuvem de forma segura, entre em contato pelo [e-mail](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"b9398f5506d009df643af93265411533\",\"title\":\"Como adicionar o sensor SDS011 ao Home Assistant\",\"path\":\"/docs/pt/sds-sensor-hass/\",\"content\":\"\\nEste artigo explica como conectar o sensor de qualidade do ar SDS com o Firmware [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) & [Robonomics](https://github.com/airalab/sensors-software) ao Home Assistant.\\n\\n## Instalação \\nExistem duas opções de instalação disponíveis:\\n\\n### Opção 1: HACS\\n\\nA maneira mais fácil de adicionar um Sensor Local Luftdaten é através do HACS. [Aqui](https://hacs.xyz/docs/setup/download/) você pode encontrar uma breve explicação sobre como configurar o HACS.\\n\\nDepois de instalar o HACS, vá para HACS -> Integrações e procure pela integração `Local Luftdaten Sensor`. Clique no botão de download e reinicie o Home Assistant assim que a integração for baixada.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Opção 2: Instalação Manual\\n\\nCom o usuário homeassistant, clone o repositório do projeto:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nSe você já tiver alguma integração personalizada, copie a pasta `custom_components/local_luftdaten/` para o diretório `custom_components`, por exemplo:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nSe você não tiver nenhuma integração personalizada, copie todo o diretório `custom_components` para o diretório de configuração do Home Assistant, por exemplo:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Configuração\\n\\nCrie uma nova entrada de sensor no seu `configuration.yaml` e ajuste o nome do host ou o endereço IP. Para encontrar o endereço IP local do seu sensor, você pode usar o [aplicativo móvel Fing](https://www.fing.com/products) ou a [ferramenta de linha de comando nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). O nome pode ser qualquer um.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> A lista de todos os sensores suportados pode ser encontrada no [repositório](https://github.com/lichtteil/local_luftdaten).\\n\\nReinicie o Home Assistant.\\nDepois disso, você pode adicionar o sensor ao seu painel. O nome da entidade será o nome que você adicionou ao `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"bdd006d8e1a6f0531d3bf081fea440f9\",\"title\":\"How to Conect SDS011 Sensor\",\"path\":\"/docs/pt/sds-sensor-connect/\",\"content\":\"\\n** Aqui está um guia passo a passo sobre como conectar seu sensor à Rede de Sensores Robonomics. Nossos sensores utilizam o firmware Robonomics, que é uma versão aprimorada do firmware sensor.community. Ele inclui sensores adicionais e possui um mecanismo de envio de dados modificado. **\\n\\n1. Conecte o sensor na tomada para alimentá-lo.\\n2. A placa criará uma rede Wi-Fi chamada `RobonomicsSensor-xxxxxxxxx`. Conecte-se a ela pelo seu telefone ou computador: você verá a janela de autorização (se não aparecer, abra o navegador e vá para `192.168.4.1`).\\n3. Selecione sua rede Wi-Fi na lista (ou escreva manualmente se ela não estiver na lista) e preencha o campo de senha.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nO sensor só pode ser conectado a uma rede Wi-Fi de 2,4 GHz.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Escreva as coordenadas do local onde o sensor será instalado. Você pode obtê-las de qualquer mapa ou obtê-las a partir do endereço usando [este link.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nAs coordenadas do sensor serão exibidas em um mapa publicamente disponível. Se você não quiser mostrar suas informações privadas, escreva próximo, mas não exato.\\n</robo-wiki-note> \\n5. Clique em `Save configuration and restart`. A placa será reiniciada e conectada à rede Wi-Fi especificada.\\n6. Abra [Mapa de sensores Robonomics](https://sensors.robonomics.network/#/) e encontre o local onde você instalou o sensor. Em alguns minutos, você poderá ver seu sensor com dados no mapa.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"019259a53e1a030b145c188a9d1f99f9\",\"title\":\"Visão geral da Casa Inteligente Robonomics\",\"path\":\"/docs/pt/robonomics-smart-home-overview/\",\"content\":\"\\n## IoT seguro com Blockchain \\n\\nPara a sua casa inteligente, o mercado moderno de IoT oferece uma ampla gama de soluções. Mas você geralmente está preso a provedores de nuvem centralizados ou gateways proprietários caros. Como resultado, você, como usuário, está sempre dependente do fornecedor de hardware e infraestrutura para executar seu sistema inteligente. Ao mesmo tempo, sua casa inteligente não pode ser verdadeiramente inteligente sem estatísticas e análises em nuvem.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Vemos dois problemas principais com as casas inteligentes atuais:**\\n\\n1. Você não tem controle sobre quais dados compartilha com o fornecedor ou terceiros.\\n2. Sua casa inteligente está vulnerável a desligamentos de servidores de nuvem centralizados. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nPara resolver ambos os problemas, sugerimos que você experimente o Robonomics, nossa nuvem **segura**, **sem servidor** e **futurista**.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Passos para uma nuvem livre de corporações\\n\\nAqui estão alguns passos simples para criar uma casa inteligente acessível usando o Home Assistant como aplicativo de comunicação de dispositivos e o Robonomics como uma plataforma de nuvem descentralizada e livre de corporações. O Robonomics utiliza tecnologias Web3 modernas e seguras, garantindo segurança aprimorada durante todo o processo.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Comece aqui a sua casa inteligente\\n\\nPreparamos guias detalhados sobre como configurar uma casa inteligente no Robonomics. Os passos podem variar dependendo da sua situação específica: se você já possui um Home Assistant operacional com dispositivos emparelhados, ou se está começando do zero para estabelecer sua casa inteligente.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/pt/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/pt/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"0434fc8e1cde1332476d59a7ae74d445\",\"title\":\"Serviço de Vídeo Robonomics\",\"path\":\"/docs/pt/robonomics-video/\",\"content\":\"\\nEste artigo mostra como adicionar uma câmera IP ao Home Assistant e enviar vídeos para o Serviço Web Robonomics.\\n\\nPara conectar uma câmera ao Home Assistant, você precisa saber o seu endereço IP e criar uma conta de câmera local para se conectar ao fluxo RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nComo isso é feito de forma diferente para cada câmera, esse processo não é considerado neste artigo.\\n</robo-wiki-note>\\n\\nRequisitos:\\n- Câmera IP\\n- Conta de câmera local configurada\\n- Endereço IP da câmera\\n- Home Assistant configurado\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nEste artigo pressupõe que você tenha uma câmera IP geral sem opções de rotação, inclinação e zoom (RTZ). \\nSe você tiver uma câmera RTZ, verifique o artigo \\\"Câmera RTZ\\\" (/docs/ptz-camera). E então volte para a segunda etapa aqui.\\n\\n</robo-wiki-note>\\n\\n## Conecte a Câmera\\n\\nPrimeiro, você precisa descobrir o URL do fluxo RTSP da câmera. \\nPara fazer isso, tente inserir a seguinte consulta na Internet: \\\"<NOME_DA_CÂMERA> fluxo RTSP\\\".\\nA URL do fluxo deve começar com `rtsp://<ENDEREÇO_IP>...`. \\n\\nEste artigo usa uma câmera \\\"Tapo\\\" e o caminho do fluxo é `rtsp://<ENDEREÇO_IP>/stream1`.\\n\\nAbra o Home Assistant e vá para \\\"Settings\\\"-> \\\"Devices & Services\\\". Pressione o botão \\\"ADD INTEGRATION\\\" e\\ncomece a digitar \\\"Generic Camera\\\". Escolha-a.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nNa janela de configuração, forneça as seguintes informações:\\n- Stream Source URL - A URL do fluxo RTSP da câmera\\n- Username - escreva o nome de usuário da sua conta de câmera local\\n- Password - escreva uma senha para sua conta de câmera local\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nRole para baixo nas configurações e pressione o botão \\\"Submit\\\".\\n\\nNa janela de visualização, ative a caixa de seleção \\\"This image looks good.\\\" e pressione o botão \\\"Submit\\\". Em seguida, - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Adicionar ao Painel\\n\\nAlém disso, você pode adicionar o fluxo ao seu painel. Para fazer isso, vá para o painel e crie um novo cartão \\n\\\"Picture Glance\\\". Etapas adicionais:\\n- insira o \\\"Títle\\\" desejado\\n- exclua os dados do \\\"Image Path\\\"\\n- selecione a câmera em \\\"Camera Entity\\\"\\n- na \\\"Camera View\\\", selecione \\\"live\\\" para que haja menos atraso\\n\\nE salve.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Verifique a pasta de mídia\\n\\nAntes de ser enviado ao Robonomics Video Service, o vídeo deve ser salvo em uma pasta, e o Home Assistant deve ter acesso a esta pasta.\\nA opção mais fácil nesse caso é usar um pacote de mídia, no qual o Home Assistant armazena todas as mídias.\\n\\n- Se você estiver usando HAOS ou uma Imagem Pré-instalada, seu Home Assistant **já possui uma pasta de mídia**.\\n- Se você estiver usando o Home Assistant Core, você deve ir para a pasta `.homeassistant` e criar a pasta `media` dentro dela.\\n- Se você estiver usando o Home Assistant Docker, adicione a linha ` -v /CAMINHO_PARA_SUA_MÍDIA:/media \\\\` ao comando Docker.\\n\\nPara verificar se tudo foi configurado corretamente, vá para a guia “Media” -> “local media” no seu Home Assistant. \\nVocê deve ver uma pasta vazia (sem erros):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Chamada de Serviço\\n\\nPara enviar um vídeo para a Robonomics, você deve chamar um serviço dedicado no Home Assistant. \\nNeste artigo, isso é feito manualmente, mas você pode criar uma automação para isso.\\n\\nPara fazer isso, vá para \\\"Developer tools\\\" -> \\\"Services\\\" e encontre \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nEm \\\"Targets\\\", escolha a entidade da sua câmera.\\nEm \\\"Path to save the recording\\\", você deve fornecer um caminho absoluto para a pasta,\\nonde o Home Assistant pode salvar o vídeo:\\n- Para Imagem Pré-instalada - `/home/homeassistant/.homeassistant/media`;\\n- Para HA OS ou Home Assistant Docker- `/media`;\\n- Para Home Assistant Core - Caminho para a pasta de mídia criada anteriormente.\\n\\nAlém disso, você pode escolher a Duração da gravação. \\n\\nPreencha os dados e chame o serviço com o botão\\\"CALL SERVICE\\\".\\n\\n## DAPP\\n\\nPara visualizar o vídeo resultante, vá para [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nCole o endereço da sua conta do controlador e clique no botão abaixo. Aguarde o processo de \\\"\\\"Search for Twins\\\".\\nComo resultado, você obterá um CID do IPFS com todos os vídeos gravados.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nEm seguida, selecione a conta do controlador (ou qualquer outra) na lista suspensa e assine uma mensagem para autorização no\\ngateway Web3 IPFS para baixar todos os vídeos. Como resultado, você obterá todos os vídeos gravados pela sua casa inteligente.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nComo todos os vídeos na pasta esto criptografados com a chave do controlador, você precisa inseri-la para descriptografar os vídeos.\\nDepois disso, o botão de reprodução do vídeo é ativado. Clique nele para baixar o vídeo.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"750f9ff4b6339fbbb964dca712994041\",\"title\":\"Como executar o nó de desenvolvimento do Robonomics\",\"path\":\"/docs/pt/run-dev-node/\",\"content\":\"\\n**Para testar suas aplicações no Robonomics, você pode querer executá-lo no modo de desenvolvimento. Este artigo mostra passo a passo\\ninstruções sobre como obter sua própria instância de teste local do Robonomics.**\\n\\n\\n## Obtenha o binário do nó\\n\\n1. Primeiro, você precisa de um arquivo binário, faça o download do arquivo compactado mais recente [release](https://github.com/airalab/robonomics/releases).\\n\\n2. Navegue até a pasta do arquivo compactado, descompacte o binário e altere as permissões:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Executar\\n\\nExecute o nó com:\\n\\n```bash\\n./robonomics --dev\\n```\\nVocê verá a seguinte saída:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Se você quiser limpar os blocos existentes, pode fazer isso removendo o RocksDB em `/tmp/substrate******/chains/dev/db/full`.\\n  Substitua `******` pelo identificador correspondente exibido nos logs ao iniciar.\\n\\n  Se você quiser iniciar o nó do zero toda vez, use a opção `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Conectar\\n\\nAgora você pode se conectar ao seu nó local através do [Polkadot Portal](https://polkadot.js.org/apps/#/explorer).\\n\\nAltere a rede para `Local Node` no canto superior esquerdo e pressione `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nBem-vindo à instância local do Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"d3c49f5153e6914dfd6a8776e18850b9\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/pt/robonomics-prometheus-grafana/\",\"content\":\"\\n**A seguinte instrução é fornecida por [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**O artigo original está localizado [aqui](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Introdução\\nPara monitorar e manter melhor o(s) nó(s) do Robonomics, é bom configurar um monitoramento baseado no Prometheus Server e Grafana. Este documento mostrará como configurar cada um deles para monitorar completamente o seu nó.\\n\\n##  Pré-requisitos\\n* [Configuração do servidor com Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Collator parachain do Robonomics instalado](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Certifique-se de que o robonomics.service esteja funcionando em sua máquina e a porta 9615 esteja acessível \\n\\n## Passo 1 - Criando Usuários de Serviço\\n\\nPor motivos de segurança, começaremos criando duas novas contas de usuário, prometheus e node_exporter. Crie esses dois usuários e use as opções _--no-create-home_ e _--shell /bin/false_ para que esses usuários não possam fazer login no servidor.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nAntes de baixarmos os binários do Prometheus, crie os diretórios necessários para armazenar os arquivos e dados do Prometheus. Seguindo as convenções padrão do Linux, criaremos um diretório em _/etc_ para os arquivos de configuração do Prometheus e um diretório em _/var/lib_ para seus dados.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nAgora, defina a propriedade do usuário e do grupo nos novos diretórios para o usuário prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Passo 2 - Baixando o Prometheus\\n\\nPrimeiro, baixe e descompacte a versão estável atual do Prometheus em seu diretório pessoal. Você pode encontrar os binários mais recentes na [página de download do Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nAgora, descompacte o arquivo baixado.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nIsso criará um diretório chamado prometheus-2.21.0.linux-amd64 contendo dois arquivos binários (prometheus e promtool), diretórios _consoles_ e _console_libraries_ contendo os arquivos da interface da web, uma licença, um aviso e vários arquivos de exemplo.\\n\\nCopie os dois binários para o diretório _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nDefina a propriedade do usuário e do grupo nos binários para o usuário prometheus criado no Passo 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nCopie os diretórios consoles e _console_libraries_ para _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nDefina a propriedade do usuário e do grupo nos diretórios para o usuário prometheus. Usar a opção -R garantirá que a propriedade seja definida nos arquivos dentro do diretório também.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nAgora que o Prometheus está instalado, criaremos seus arquivos de configuração e serviço em preparação para sua primeira execução.\\n\\n## Passo 3 - Configurando o Prometheus\\n\\nNo diretório _/etc/prometheus_, use o nano ou o seu editor de texto favorito para criar um arquivo de configuração chamado _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nNas configurações globais, defina o intervalo padrão para coletar métricas. Observe que o Prometheus aplicará essas configurações a todos os exportadores, a menos que as configurações próprias de um exportador individual substituam as globais.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nEsse valor de scrape_interval diz ao Prometheus para coletar métricas de seus exportadores a cada 15 segundos, o que é tempo suficiente para a maioria dos exportadores.\\nAgora, adicione o próprio Prometheus à lista de exportadores a serem coletados com a seguinte diretiva scrape_configs:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nO Prometheus usa o _job_name_ para rotular exportadores em consultas e gráficos, portanto, certifique-se de escolher algo descritivo aqui.\\n\\nE, como o Prometheus exporta dados importantes sobre si mesmo que você pode usar para monitorar o desempenho e depurar, substituímos a diretiva global scrape_interval de 15 segundos para 5 segundos para atualizações mais frequentes.\\n\\nPor fim, o Prometheus usa as diretivas _static_configs_ e _targets_ para determinar onde os exportadores estão sendo executados. Como esse exportador específico está sendo executado no mesmo servidor que o próprio Prometheus, podemos usar localhost em vez de um endereço IP junto com a porta padrão, 9090.\\n\\nSeu arquivo de configuração deve ficar assim:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nSalve o arquivo e saia do editor de texto.\\n\\nAgora, defina a propriedade do usuário e do grupo no arquivo de configuração para o usuário prometheus criado no Passo 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nCom a configuração concluída, estamos prontos para testar o Prometheus executando-o pela primeira vez.\\n\\n## Passo 4 - Executando o Prometheus\\n\\nInicie o Prometheus como usuário _prometheus_, fornecendo o caminho tanto para o arquivo de configuração quanto para o diretório de dados.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nA saída contém informações sobre o progresso de carregamento do Prometheus, arquivo de configuração e serviços relacionados. Ele também confirma que o Prometheus está ouvindo na porta _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nSe você receber uma mensagem de erro, verifique se você usou a sintaxe YAML em seu arquivo de configuração e siga as instruções na tela para resolver o problema.\\n\\nAgora, pare o Prometheus pressionando _CTRL+C_ e abra um novo arquivo de serviço _systemd_.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nO arquivo de serviço informa ao _systemd_ para executar o Prometheus como usuário prometheus, com o arquivo de configuração localizado no diretório _/etc/prometheus/prometheus.yml_ e para armazenar seus dados no diretório _/var/lib/prometheus_. Copie o seguinte conteúdo para o arquivo:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nPor fim, salve o arquivo e feche o editor de texto. Para usar o serviço recém-criado, recarregue o systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nAgora você pode iniciar o Prometheus usando o seguinte comando:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nPara garantir que o Prometheus esteja em execução, verifique o status do serviço.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nA saída informa o status do Prometheus, o identificador do processo principal (PID), o uso de memória e muito mais.\\n\\nSe o status do serviço não estiver ativo, siga as instruções na tela e refaça os passos anteriores para resolver o problema antes de continuar o tutorial.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nQuando estiver pronto para prosseguir, pressione _Q_ para sair do comando de status. Por último, habilite o serviço para iniciar na inicialização.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nAgora que o Prometheus está em execução, podemos instalar um exportador adicional para gerar métricas sobre os recursos do nosso servidor.\\n\\n## Passo 5 — Baixando o Node Exporter\\n\\nPara expandir o Prometheus além das métricas apenas sobre si mesmo, vamos instalar um exportador adicional chamado Node Exporter. O Node Exporter fornece informações detalhadas sobre o sistema, incluindo uso de CPU, disco e memória. Baixe a versão estável atual do Node Exporter para o seu diretório pessoal. Você pode encontrar os binários mais recentes na [página de download do Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nAgora, descompacte o arquivo baixado.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nIsso criará um diretório chamado _node_exporter-1.0.1.linux-amd64_ contendo um arquivo binário chamado _node_exporter_, uma licença e um aviso.\\n\\nCopie o binário para o diretório _/usr/local/bin_ e defina a propriedade de usuário e grupo para o usuário node_exporter que você criou no Passo 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nAgora que você instalou o Node Exporter, vamos testá-lo executando-o antes de criar um arquivo de serviço para que ele seja iniciado na inicialização.\\n\\n## Passo 6 — Executando o Node Exporter\\n\\nOs passos para executar o Node Exporter são semelhantes aos passos para executar o próprio Prometheus. Comece criando o arquivo de serviço Systemd para o Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nCopie o seguinte conteúdo para o arquivo de serviço:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nSalve o arquivo e feche o editor de texto. Por fim, recarregue o systemd para usar o serviço recém-criado.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nAgora você pode executar o Node Exporter usando o seguinte comando:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nVerificar that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nComo antes, esta saída informa o status do Node Exporter, o identificador do processo principal (PID), o uso de memória e muito mais. Se o status do serviço não estiver ativo, siga as mensagens na tela e refaça os passos anteriores para resolver o problema antes de continuar.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nPor último, habilite o Node Exporter para iniciar na inicialização.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nCom o Node Exporter totalmente configurado e em execução conforme o esperado, vamos informar ao Prometheus para começar a coletar as novas métricas.\\n\\n## Passo 7 — Configurando o Prometheus para coletar o Node Exporter\\n\\nComo o Prometheus só coleta exportadores que estão definidos na parte scrape_configs de seu arquivo de configuração, precisaremos adicionar uma entrada para o Node Exporter, assim como fizemos para o próprio Prometheus. Abra o arquivo de configuração.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nNo final do bloco scrape_configs, adicione uma nova entrada chamada node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nComo este exportador também está sendo executado no mesmo servidor que o próprio Prometheus, podemos usar localhost novamente junto com a porta padrão do Node Exporter, 9100. Seu arquivo de configuração completo deve ficar assim:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nSalve o arquivo e saia do editor de texto quando estiver pronto para continuar. Por fim, reinicie o Prometheus para que as alterações entrem em vigor.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nMais uma vez, verifique se tudo está sendo executado corretamente com o comando de status.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nSe o status do serviço não estiver definido como ativo, siga as instruções na tela e refaça os passos anteriores antes de prosseguir.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nAgora temos o Prometheus e o Node Exporter instalados, configurados e em execução.\\n\\n## Passo 8 - Adicionando o build in node_exporter do Robonomic\\n\\nDepois de instalar com sucesso o Prometheus e o node_exporter, teremos que usar o exportador do Prometheus integrado em cada projeto do substrato. Para fazer isso, precisamos adicionar uma entrada adicional em _/etc/prometheus/prometheus.yml_. \\nAbra o arquivo de configuração.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nNo final do bloco scrape_configs, adicione uma nova entrada chamada robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nSalve o arquivo e saia do seu editor de texto. Seu arquivo de configuração completo deve ficar assim:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nPor fim, reinicie o Prometheus para que as alterações entrem em vigor.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nMais uma vez, verifique se tudo está sendo executado corretamente com o comando de status.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nAgora temos o _Prometheus_, o _Node Exporter_ e o _Robonomic Exporter_ instalados, configurados e em execução. Agora siga para o Grafana.\\n\\n## Passo 9 - Configurando o Grafana\\n\\nO último passo é conectar o Prometheus como uma Fonte de Dados no Grafana. Para este tutorial, usaremos o grafana baseado em nuvem gratuito, que permite ter até 5 painéis, além do [painel dedicado do Robonomics](https://grafana.com/grafana/dashboards/13015). Basta ir para [grafana.com](https://grafana.com/), criar uma nova conta e fazer login na sua instância recém-criada do grafana.\\n\\nNo início, devemos adicionar ao Grafana uma nova _**Fonte de Dados**_, que neste caso será o servidor Prometheus.\\nAcesse Fonte de Dados:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nEm seguida, clique em **_Adicionar fonte de dados_**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext selecione _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nNa nova tela, insira o **_endereço IP do servidor Prometheus com a porta 9090_**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nDepois disso, _**Salve e teste**_ se você seguiu todos os passos, você deve ver a cor verde e estar pronto para importar o painel. No site principal, clique em **+** e depois em **Importar**, como mostrado na imagem abaixo:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nEm seguida, você verá a página de importação:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nNo campo _URL ou ID do painel do Grafana.com_, escreva _**13015**_ (pois este é o ID do painel do Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nAo carregar o painel externo, você verá esta tela:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nO último passo é escolher a **_Fonte de Dados_** previamente criada e clicar em _**Importar**_\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nPRONTO! Neste ponto, você deverá ver o painel importado. \\n\\n\\n## Referências\\n\\n* [Como instalar o Prometheus no Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Criando um painel de monitoramento com Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Suporte do Grafana para Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Monitorando métricas de host Linux com o node exporter](https://prometheus.io/docs/guides/node-exporter/)\\n* [Consultando o Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Visualizando métricas de nó](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Exportador do Prometheus para Substrate](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Métricas do nó Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [Painel do Exportador de Nó para Prometheus](https://grafana.com/grafana/dashboards/11074)\\n* [Métricas do ROBONOMICS (XRT) do Grafana](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"d964d5d4fffff7e3eeffdf0c58753787\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/pt/robonomics-opengov/\",\"content\":\"\\n## Introdução\\n\\nRobonomics mudou o modelo de governança da parachain para o sofisticado mecanismo OpenGov da Polkadot, que permite que a cadeia evolua ao longo do tempo, sob o comando dos detentores de tokens.\\nA transição do Robonomics para o OpenGov garante que o DAO detentor de tokens, que controla a maioria das participações, possa sempre comandar a direção da parachain do Robonomics, promovendo qualquer mudança na rede que considerem adequada.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  O OpenGov se aplica apenas à Robonomics Parachain, que é uma cadeia baseada em Substrate conectada à Kusama Relay Chain. O OpenGov não se aplica à implementação Ethereum do Robonomics, pois a mainnet Ethereum atualmente não suporta sistemas de governança sofisticados como o OpenGov.\\n</robo-wiki-note>\\n\\nO OpenGov muda a forma como as operações diárias e a tomada de decisões são realizadas na parachain. Ele fornece maior clareza quanto ao escopo dos referendos e tem o potencial de aumentar drasticamente a velocidade das decisões tomadas na parachain.\\n\\nO OpenGov está em funcionamento na Kusama relay chain há alguns meses no momento da escrita, e provou que aumenta drasticamente o número de decisões (referendos individuais e discretos) que o DAO detentor de tokens pode propor, votar e, por meio da votação, controlar a direção do protocolo.\\n\\n**O conteúdo a seguir contido nesta seção da wiki abordará os princípios fundamentais do OpenGov na parachain do Robonomics e tem como objetivo ajudá-lo a entender melhor os conceitos por trás do OpenGov.**\\n\\n*É importante observar que a governança é um mecanismo em constante evolução no protocolo, especialmente nas fases iniciais de implementação.*\\n\\nPara aqueles interessados apenas nos parâmetros da Trilha Robonomics OpenGov, consulte [aqui](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## Sobre Referendos\\n\\nReferendos são esquemas de votação simples, inclusivos e baseados em participação. Cada referendo tem uma proposta específica associada a ele, que assume a forma de uma chamada de função privilegiada no tempo de execução das cadeias. Isso também pode incluir a chamada mais poderosa `set_code`, que tem a capacidade de trocar todo o código do tempo de execução das cadeias - isso é exclusivo para cadeias baseadas em Substrate e remove a necessidade de um \\\"hard fork\\\" da cadeia ao atualizar a lógica de negócios das cadeias ( tempo de execução).\\n\\nReferendos são eventos discretos que têm um período de votação fixo (mais sobre os diferentes períodos durante o ciclo de vida de um referendo posteriormente). Os detentores individuais de tokens podem votar de três maneiras em referendos - AYE (concordar/sim), NAY (discordar/não) ou ABSTAIN (abster-se) de votar completamente.\\n\\nTodos os referendos têm um atraso de promulgação associado a eles. Este é o período entre o término do referendo e, assumindo que o referendo foi aprovado, as mudanças sendo promulgadas na rede. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Existe um Período de Promulgação **Mínimo** especificamente definido para cada tipo diferente de Origem, mas o originador de um referendo específico pode definir as tarefas específicas desse referendo para serem executadas muitos blocos no futuro\\n\\n</robo-wiki-note>\\n\\nOs referendos são considerados \\\"assados\\\" se estiverem encerrados e os votos forem contabilizados. Supondo que o referendo tenha sido aprovado, ele será agendado para promulgação (no agendador das cadeias). Os referendos são considerados \\\"não assados\\\" se o resultado estiver pendente - como se o referendo ainda estivesse sendo votado.\\n\\nCom a adição do OpenGov, qualquer pessoa pode iniciar um referendo a qualquer momento e pode fazê-lo quantas vezes desejar. O OpenGov remove a limitação de apenas 1 referendo poder ser processado de cada vez (observe que, no Gov v1, apenas 1 referendo pode ser votado de cada vez. A única exceção é um referendo de emergência adicional pelo Comitê Técnico acelerado, que também pode ser votado simultaneamente pela comunidade).\\n\\nO OpenGov introduz várias novas funcionalidades / conceitos conhecidos como Origens e Trilhas, e estes são introduzidos para ajudar no fluxo e processamento de referendos no protocolo.\\n\\nCada Origem está associada a uma única classe de referendo, e cada classe está associada a uma trilha. A trilha descreve o ciclo de vida do referendo e é específica para aquela Origem particular de onde o referendo se origina. Ter trilhas com parâmetros específicos permite que a rede modifique dinamicamente o ciclo de vida dos referendos com base em seu nível de privilégio (você pode pensar no nível de privilégio como sendo o quão poderoso um referendo pode ser / quais tipos de mudanças ele pode fazer no protocolo).\\n\\n*Pense nas Origens como o poder associado a um referendo e pense nas Trilhas como os parâmetros de votação associados a um referendo, como a duração de seus períodos e os critérios de aprovação e suporte.*\\n\\nPor exemplo, uma atualização de tempo de execução não tem as mesmas implicações para o protocolo do que uma pequena dica do tesouro, e, portanto, são necessárias origens diferentes nas quais diferentes participações, aprovações, depósitos e períodos de promulgação (Trilhas) serão predefinidos no pallet das cadeias.\\n\\n## Propondo um Referendo e Ciclo de Vida do Referendo \\n\\n### Período de Preparação\\n\\nNo OpenGov, quando um referendo é criado inicialmente, ele pode ser imediatamente votado pela comunidade detentora de tokens. No entanto, ele não está imediatamente em um estado em que possa ser encerrado, ou ter seus votos contados, aprovados e promulgados sumariamente. Em vez disso, os referendos devem cumprir uma série de critérios antes de serem movidos para o Período de Decisão. Até que os referendos entrem no Período de Decisão, eles permanecerão indefinidos - e eventualmente expirarão após o período de ciclo de vida geral especificado na trilha individual.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nOs critérios para um referendo entrar no Período de Decisão são os seguintes:\\n1. Um Período de Preparação que estabelece a quantidade de tempo que deve decorrer antes que o Período de Decisão possa começar. Este Período de Preparação ajuda a mitigar a possibilidade de \\\"ataque de decisão\\\" em que um atacante que controla uma quantidade substancial de poder de voto pode tentar usar sua grande participação para aprovar imediatamente um referendo após a proposta, contornando a possibilidade de os outros membros do token holder DAO terem tempo adequado para considerar o referendo e participar da votação. Por isso, as Origens com níveis de privilégio mais altos têm Períodos de Preparação significativamente mais longos.\\n\\n2. Deve haver espaço para a decisão. Cada trilha tem seus próprios limites para a quantidade de referendos que podem ser decididos simultaneamente (max_deciding). Trilhas que possuem níveis de privilégio mais poderosos terão limites mais baixos. Por exemplo, a origem de nível Root terá uma quantidade significativamente menor de referendos que podem ser decididos simultaneamente em comparação com origens de nível de privilégio mais baixo, como a origem Small Tipper.\\n\\n3. O Depósito de Decisão deve ser enviado. Inicialmente, criar um referendo é bastante barato, e o valor do Depósito de Submissão (reservado quando o referendo é criado inicialmente) é bastante baixo, e é composto principalmente pelo valor que custa para o armazenamento on-chain associado ao referendo. Os Depósitos de Decisão são significativamente mais altos, o que é necessário para combater o spam e faz parte do jogo econômico que o OpenGov traz, que veremos mais adiante.\\n\\nUma vez que todos esses três critérios acima tenham sido atendidos, o referendo passará para o Período de Decisão. Os votos no referendo serão então contados para o resultado.\\n\\n### Período de Decisão\\n\\n*Para uma demonstração rápida em vídeo do Período de Decisão, veja [este vídeo](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nUma vez que um referendo atenda a todos os critérios detalhados na seção acima, ele entrará no Período de Decisão.\\n\\nO Período de Decisão gira em torno de dois conceitos principais, sendo eles os critérios de Aprovação e Suporte. \\n\\nA Aprovação é definida como a parcela do peso do voto de aprovação (SIMs vs NÃOs) em comparação com o peso total do voto (todos os votos SIM e NÃO combinados). A convicção de cada voto conta para o peso geral dos votos SIM/NÃO (mais sobre votação por convicção / bloqueio voluntário em uma seção posterior).\\n\\nO Suporte é o número total de votos (tokens) que participaram do referendo (e não é ajustado pela convicção) em comparação com o total de votos possíveis que podem ser feitos no sistema (pense nisso como a emissão total de XRT na parachain - notavelmente, o fornecimento circulante total de XRT não é o principal fator aqui, devido ao fato de que alguma parte desse número existe no Ethereum como tokens ERC-20).\\n\\n**Votos que estão na direção de ABSTENÇÃO NÃO contribuem para os critérios de Aprovação, mas são incluídos / contam para os critérios de Suporte**\\n\\nUm referendo deve atender aos critérios de Suporte E Aprovação durante o Período de Decisão para progredir para o Período de Confirmação.\\n\\nPara detalhes dos critérios individuais de Suporte e Aprovação para cada trilha, consulte esta [planilha](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Período de Confirmação\\n\\nCada trilha tem sua própria duração específica para o Período de Confirmação. Trilhas que possuem níveis de privilégio maiores (como Root) têm Períodos de Confirmação significativamente mais longos do que aqueles com níveis de privilégio mais baixos (como Small Tipper).\\n\\nOs referendos devem continuar atendendo aos critérios de Aprovação e Suporte durante toda a duração do Período de Confirmação, caso contrário, eles voltarão para o Período de Decisão (observe: o Período de Decisão não é pausado durante o Período de Confirmação, portanto, é totalmente possível que um Período de Decisão expire durante o Período de Confirmação, o que significa que se um referendo for removido do Período de Confirmação por não atender mais aos critérios de Aprovação e Suporte, ele será considerado como um referendo fracassado e não promulgado).\\n\\n**É possível ajustar os critérios de aprovação e suporte para faixas individuais por meio de um referendo com privilégios de Origem Raiz.**\\n\\nOrigens com níveis de privilégio mais baixos têm critérios de aprovação e suporte significativamente mais fáceis (definidos pela faixa) do que aqueles com níveis de privilégio mais altos. Da mesma forma, origens com níveis de privilégio mais altos têm curvas menos íngremes do que aquelas com menos privilégios (conforme definido na faixa), a fim de garantir que o DAO detentor do token realmente aprove o referendo e evitar o sniping de referendos de origem de alto privilégio.\\n\\nNo OpenGov, referendos que não são aprovados após o período de decisão expirar são considerados rejeitados por padrão, e tanto os depósitos de submissão quanto de decisão são reembolsados aos seus originadores (observação: o depósito de decisão pode ser feito por alguém que não seja o originador do referendo).\\n\\nSe um referendo conseguir atender continuamente aos critérios de aprovação e suporte durante todo o Período de Confirmação, então ele é considerado aprovado e será agendado para ser executado a partir da origem proposta, mas o referendo só será executado após o período mínimo de promulgação ter decorrido.\\n\\n### Período de Promulgação\\n\\nO Período de Promulgação é especificado pelo originador quando o referendo é proposto, mas está sujeito ao Período Mínimo de Promulgação, que é especificado em cada faixa. Origens mais poderosas têm um período mínimo de promulgação muito maior do que aquelas com menos privilégios. Isso garante que a rede tenha tempo suficiente para se preparar para quaisquer mudanças que um referendo poderoso possa impor.\\n\\n## Bloqueio Voluntário / Convicção\\n\\nRobonomics usa um conceito conhecido como bloqueio voluntário, ou votação por convicção. Isso permite que os detentores de tokens aumentem seu poder de voto decidindo por quanto tempo estão dispostos a bloquear seus tokens para um referendo específico. Esse mecanismo afeta apenas o critério de aprovação para cada referendo, e a votação por convicção não afeta o critério de suporte.\\n\\nA votação por convicção pode ser calculada usando esta fórmula:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nEsta tabela mostra como cada nível crescente de período de bloqueio multiplica seu voto para o critério de aprovação:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nA quantidade máxima de convicção que um detentor de token pode usar é de 6x convicção. Você só pode definir a convicção de acordo com a tabela acima e não pode, por exemplo, usar 5,5x convicção.\\n\\nEnquanto um token está bloqueado devido à votação, ele ainda pode ser usado para votar em outros referendos, no entanto, ele não fará parte do seu saldo transferível (você não pode enviá-lo para outra conta) - e o saldo só se tornará transferível novamente quando todo o período de bloqueio expirar.\\n\\n## Delegação de Voto\\n\\nNo OpenGov, um mecanismo foi adicionado para permitir que os detentores de tokens que não têm tempo suficiente para revisar cada referendo ainda tenham seus tokens usados como parte do sistema de governança, isso é conhecido como delegação de voto.\\n\\nOs detentores de tokens podem optar por delegar seu poder de voto a outro eleitor no sistema (outra conta). Os eleitores podem especificar a delegação de seu poder de voto de forma ágil, permitindo que atribuam seu poder de voto a uma conta diferente para cada Origem individual. Os eleitores também podem definir para atribuir uma quantidade diferente de poder de voto para cada Origem (número de tokens e nível de convicção).\\n\\nEssa função de delegação tem um objetivo, aumentar a participação dos eleitores e ajudar a garantir que as participações necessárias para atender aos critérios de aprovação e suporte sejam alcançadas.\\n\\nPara delegar seu poder de voto, você pode usar a função \\\"Delegate\\\" que pode ser encontrada na seção Governança -> Referendo do [Portal Robonomics](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). Alternativamente, os usuários podem enviar a extrínseca convictionVoting(Delegate) usando a seção Desenvolvedor -> Extrínsecas do Portal Robonomics, no entanto, usar a função \\\"Delegate\\\" da seção de referendo do portal é muito mais fácil.\\n\\n## Cancelamento / Anulação de Referendo e o Jogo Econômico de Governança\\n\\nNo OpenGov, existem Origens dedicadas a rejeitar referendos em andamento, independentemente de seu status. Essas são conhecidas como faixas de Cancelador de Governança e Assassino de Governança.\\n\\nEssas Origens intervêm em um referendo que já foi votado. Essas Origens, se o referendo originado por elas for aprovado, rejeitarão imediatamente um referendo em andamento, independentemente de seu status. \\n\\nO cancelamento em si é um tipo de referendo que deve ser votado pelos detentores de tokens para ser executado. O cancelamento possui sua própria origem e faixa que têm um tempo de liderança menor (Período de Decisão, etc.) e têm curvas de aprovação e suporte com uma curva mais íngreme (o que significa que seus critérios são muito mais fáceis de serem atendidos ao longo do tempo) do que outras Origens. Isso ocorre devido ao fato de que o cancelamento de um referendo geralmente vem com um senso de urgência.\\n\\nO Cancelador de Governança tem como objetivo rejeitar imediatamente um referendo em andamento. Quando um referendo é cancelado por essa origem, tanto o Depósito de Submissão quanto o Depósito de Decisão são reembolsados aos seus originadores. Um exemplo de quando um referendo pode ser considerado cancelado é se o originador cometeu algum erro humano no conteúdo de seu referendo e não necessariamente tentou fazer algo malicioso.\\n\\nO Assassino de Governança tem como objetivo rejeitar imediatamente um referendo em andamento. É aí que o jogo econômico de governança entra em jogo. Origens com altos níveis de privilégio, como Root, têm um Depósito de Decisão que requer uma grande quantidade de capital (tokens XRT) para ser postado para que o referendo entre no Período de Decisão. \\n\\nSe um ator malicioso enviar um referendo, como um referendo com origens Root que visa `set_code` do tempo de execução da cadeia para algo que interromperá a produção de blocos da cadeia, então o DAO detentor de tokens pode levantar um referendo contrário ao Assassino de Governança para punir essa ação. Se o referendo malicioso for rejeitado pela origem Assassino de Governança, tanto o Depósito de Submissão quanto o Depósito de Decisão serão cortados, o que significa que o originador (as contas que postaram esses depósitos) perderão esses fundos. \\n\\nIsso significa que há uma consequência econômica severa para atores maliciosos que tentam levantar referendos que teriam impactos negativos graves para a cadeia, o que teoricamente impedirá qualquer ator malicioso de tentar fazer isso.\\n\\nO Depósito de Decisão para a própria faixa de Governança Assassina é bastante alto, isso é para impedir que atores igualmente maliciosos tentem reduzir os depósitos de referendos que, de outra forma, seriam bons. **Um referendo existente de Governança Assassina pode ser anulado por um referendo subsequente de Governança Assassina.**\\n\\n## Comitê Técnico Robonomics e Origem na Lista Branca\\n\\nEste grupo é um órgão de especialistas autônomos que tem como objetivo principal representar humanos que incorporam e possuem o conhecimento técnico do protocolo de rede Robonomics. \\n\\nEste grupo (e somente este grupo) é capaz de originar referendos a partir do pallet Whitelist. Este pallet faz uma coisa, ele permite que uma Origem aumente o nível de privilégio de outra Origem para uma determinada operação. \\n\\nEste grupo pode autorizar referendos de uma origem conhecida como Whitelisted-Root, e estes referendos podem ser executados com privilégios de nível Root, mas estes referendos só funcionarão com comandos específicos autorizados pelo grupo. O pallet Whitelist verifica duas coisas:\\n1. A Origem realmente é a Whitelisted-Root (ou seja, que o referendo passou por esta faixa de Origem).\\n2. A proposta realmente foi incluída na lista branca pelo grupo.\\n\\nSe ambas as condições forem verdadeiras, então a operação será executada com privilégios de nível Root.\\n\\nEste sistema permite a capacidade de ter uma nova faixa paralela (Origem Whitelisted-Root), cujos parâmetros permitem um tempo de resposta de votação mais curto (os critérios de Aprovação e Suporte são um pouco mais fáceis de serem atendidos do que o Root). Este processo aberto e transparente permite que este grupo de especialistas do Protocolo de Rede Robonomics proponha referendos que eles determinaram serem seguros e urgentes.\\n\\nDeve-se observar que os Critérios de Suporte para referendos iniciados com a origem Whitelisted-Root não tendem a zero como muitas outras origens/faixas. Isso garante que este grupo não tenha controle de fato sobre todo o Protocolo de Rede Robonomics e requer um nível mínimo de Suporte (participação dos votantes) do detentor geral de tokens.\\n\\n\\n## Durações de Referendos \\n\\nÉ importante entender que a duração de cada referendo individual não é algo concreto, não é fixo. Alguns períodos dentro do ciclo de vida do referendo, como o período mínimo de promulgação, de fato têm uma duração concreta, no entanto, outros, incluindo o período de decisão, não têm. Por exemplo, não é preciso somar as durações máximas dos períodos de Preparação, Decisão, Confirmação e Promulgação Mínima e afirmar que \\\"cada referendo levará X dias\\\", é muito mais fluido do que isso.\\n\\nVamos analisar isso através da perspectiva de alguns referendos separados, todos originados da mesma Origem, neste caso, a origem Root. \\n\\nA Origem Root tem sua própria faixa, onde as durações de cada período são definidas, assim como as curvas de Aprovação e Suporte.\\n\\nÉ importante lembrar que os referendos só avançarão para a próxima etapa de seu ciclo de vida se certas condições forem atendidas. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nVocê deve assumir nas imagens a seguir que, para um referendo avançar para a próxima etapa de seu ciclo de vida, as condições descritas na imagem acima teriam que ter sido atendidas (a menos que seja declarado o contrário).\\n\\n\\n### Duração máxima possível com muito pouca participação dos votantes\\n\\nA imagem abaixo é uma representação do cronograma máximo possível para um referendo, pense nisso como um referendo que:\\n1. Teve seu Depósito de Decisão publicado e, portanto, entrou no Período de Decisão.\\n2. Tem um único voto, por exemplo, 1 XRT, na direção AYE - isso significa que ele só atenderá o Suporte necessário (participação dos votantes) no final do Período de Decisão (já que o Suporte geral é extremamente baixo), mas tem 100% de Aprovação, então eventualmente atenderá aos requisitos para entrar no Período de Confirmação.\\n3. Continua atendendo aos critérios mencionados durante o Período de Confirmação.\\n4. A proposta levantada pelo referendo será promulgada exatamente no mesmo bloco em que o Período Mínimo de Promulgação termina - tecnicamente, o originador do referendo pode definir as alterações na rede conforme detalhado no referendo para promulgar muitos blocos no futuro, então realisticamente o ciclo de vida real de um referendo individual pode durar vários dias, semanas, meses ou anos.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nPodemos ver que neste exemplo, o ciclo de vida do referendo seria (aproximadamente) de 17 dias.\\n\\n\\n### Duração com muita participação dos votantes (com uma grande quantidade de votos AYE)\\n\\nAgora vamos dar uma olhada em um referendo em que o DAO detentor do token XRT expressou muito interesse. Neste exemplo, vamos supor que ocorreu uma participação geral de aproximadamente 248.771 XRT e todos os eleitores estão votando na direção AYE (observação: tecnicamente, nesta fase de um referendo Root, de acordo com a trilha, apenas 60% dos votos devem estar na direção AYE para que um referendo atenda aos critérios de aprovação).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Sempre consulte as informações mais atualizadas da trilha para obter informações precisas sobre cada trilha, mais informações podem ser encontradas nesta [planilha](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nNeste exemplo:\\n1. O Depósito de Decisão foi publicado durante o Período de Preparação e, portanto, pôde fazer a transição para o Período de Decisão no final do Período de Preparação.\\n2. Muitos eleitores votaram neste referendo - obtendo uma participação de aproximadamente 248.771 XRT em um período relativamente curto de tempo.\\n3. Os votos foram majoritariamente na direção AYE (acima de 60% AYE).\\n4. O referendo atende continuamente aos critérios do Período de Confirmação durante todo o seu Período de Confirmação (Observação: se um referendo deixar de atender aos critérios do Período de Confirmação, ele voltará ao seu Período de Decisão).\\n5. A proposta levantada pelo referendo será promulgada exatamente no mesmo bloco em que o Período Mínimo de Promulgação termina.\\n\\nDevido ao fato de ter havido uma participação de aproximadamente 248.771 XRT, o referendo atenderá aos critérios para entrar em seu Período de Confirmação após cerca de 168 horas (7 dias).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nPodemos ver que neste segundo exemplo, devido ao fato de ter havido uma boa participação de eleitores, o Período de Decisão realmente terminou na metade do tempo máximo alocado. Resultando em um referendo que pode ser promulgado em cerca de 10 dias.\\n\\n\\n### Duração quando o Depósito de Decisão nunca é publicado\\n\\nAgora, vamos dar uma olhada em um referendo que foi originado, mas nunca teve seu Depósito de Decisão publicado. Tais referendos estão em uma espécie de estado de \\\"limbo\\\", onde seu Período de Preparação terminou, mas, como o Depósito de Decisão não foi publicado, o referendo permanece no \\\"Estado de Preparação\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nPodemos ver que neste terceiro exemplo, devido ao fato de o Depósito de Decisão nunca ter sido publicado, o referendo na verdade nunca entrará no Período de Decisão, em vez disso, permanecerá no \\\"Estado de Preparação\\\". Isso significa que, eventualmente, se nenhum Depósito de Decisão for publicado, o referendo expirará após a duração especificada na constante timeOut do pallet.\\n\\nIsso já aconteceu anteriormente no Kusama, em que um referendo foi publicado com origens Root, mas devido aos altos requisitos de capital para publicar o Depósito de Decisão, o referendo nunca entrou nas últimas etapas de seu ciclo de vida. Tais referendos são concluídos com a marca de \\\"expirado\\\".\\n\\n\\n### Duração quando o Depósito de Decisão é publicado tarde\\n\\nPor fim, vamos dar uma olhada em um exemplo em que o Depósito de Decisão não foi publicado por um tempo considerável após o referendo ter sido originado. Isso já aconteceu anteriormente no Kusama, onde um referendo foi publicado com a origem Root, mas o originador teve que gastar tempo para encontrar alguém com uma grande quantidade de capital para publicar o Depósito de Decisão em seu nome.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nNeste exemplo final, devido ao fato de o Depósito de Decisão ter sido publicado após o término do Período de Preparação, mas antes que o referendo tenha expirado - o ciclo de vida do referendo é realmente muito mais longo do que o normal, pois ele entra no Período de Decisão após um período de tempo mais longo.\\n\\nÉ importante observar que o DAO detentor do token é capaz de votar AYE/NAY em referendos que estão no Período de Preparação ou presos no \\\"Estado de Preparação\\\".\\n\"}},{\"node\":{\"id\":\"6e7594306e939caab5e35f82cda4b00b\",\"title\":\"Configuração de integração Robonomics\",\"path\":\"/docs/pt/robonomics-hass-integration/\",\"content\":\"\\n**Neste artigo, você adicionará Robonomics ao Home Assistant. Isso permite que o Home Assistant registre datalogs com dados criptografados para Robonomics Parachain e ouça comandos de lançamento do parachain para controlar dispositivos inteligentes. A integração usa IPFS para armazenar dados e enviar hashes IPFS para funções de datalog ou lançamento.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Na interface web do Home Assistant, vá para  `Settings` -> `Device & Services` e clique em `ADD INTEGRATION`. Procure por `Robonomics`.\\n\\n2. Clique em Robonomics e preencha a configuração: \\n\\n- Adicione a seed da conta `SUB_CONTROLLER` à seed da conta do controlador.\\n- Adicione o endereço público da conta `SUB_OWNER` ao endereço do proprietário da assinatura.\\n- Defina o intervalo de envio de dados (por padrão, são 10 minutos).\\n- (Opcional) Você pode adicionar credenciais para o serviço de pinagem Pinata ou outro gateway personalizado para espalhar seus dados mais amplamente pela rede IPFS.\\n\\n3. Clique em `SUBMIT` após terminar a configuração. Se você preencheu tudo corretamente, verá a janela de sucesso.\\n\\nIsso é tudo! Você configurou completamente a Integração Robonomics no Home Assistant. Agora você pode usar todos os \\nServiços Web Robonomics. Para saber mais sobre eles, vá para a seção [\\\"Uso\\\"](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"5262bdf265d2fd9f072481d3ec672c20\",\"title\":\"Robonomics no Ethereum\",\"path\":\"/docs/pt/robonomics-ethereum/\",\"content\":\"\\nTodas as informações sobre robonomics no Ethereum foram transferidas para o repositório do GitHub. Todas as informações necessárias podem ser encontradas [aqui.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"f7fd7392602783e4388543383800c80c\",\"title\":\"Interface Python e Robonomics IO\",\"path\":\"/docs/pt/rinterface/\",\"content\":\"\\n**Algumas extrínsecas implementadas em paletes Robonomics são difíceis de serem enviadas pelo aplicativo Polkadot. Além disso, \\nhá a necessidade de interagir com essa funcionalidade usando linguagens de programação. Para esse fim, uma ferramenta Python simples foi desenvolvida\\nchamado [interface robonomics](https://github.com/Multi-Agent-io/robonomics-interface). É um invólucro mantido pelo polkascan\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). Abaixo está uma breve descrição deste pacote\\ne alguns links e exemplos úteis. Além disso, as ferramentas CLI são discutidas.**\\n\\n## robonomics-interface\\n\\nDisponível no [PyPi](https://pypi.org/project/robonomics-interface/) o pacote está pronto para download e configuração.\\nHá também uma documentação detalhada gerada por docstring [documentação](https://multi-agent-io.github.io/robonomics-interface/) disponível.\\n\\nNo geral, esta é uma ferramenta para desenvolvedores que desejam interagir com a blockchain Robonomics por meio de ferramentas de programação. Quase \\ntodos os projetos Python da equipe Robonomics que interagem com a parachain usam esta interface.\\n\\n### Instalação\\n\\nO processo de instalação requer que o usuário tenha pelo menos o Python 3.8 instalado. Nem `x86`, nem `arm7`, nem `arm8`\\narquiteturas requerem processo de compilação. Todas as rodas são construídas e publicadas pelos mantenedores das dependências.\\n\\n`pip` é usado como ferramenta de instalação:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Uso de exemplo\\n\\nA ideia principal é criar uma instância de `Account` e depois usá-la para criar instâncias dedicadas a paletes.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  Também é possível usar pontos de extremidade personalizados (por exemplo, nó local para testes):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nAs extrínsecas também podem ser enviadas:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Como foi dito, mais exemplos estão disponíveis na página de [documentação](https://multi-agent-io.github.io/robonomics-interface/).\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` também contém ferramentas CLI Python `click` para uso em prototipagem e testes rápidos. Ele é instalado\\ncom o pacote e disponível no Terminal:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nVocê pode tentar usá-lo com um nó local. A filosofia de pipeline é adotada:\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"c5e89a651f935ac1cd7ea61cbf23a638\",\"title\":\"Controle de câmera PTZ no Home Assistant\",\"path\":\"/docs/pt/ptz-camera/\",\"content\":\"\\nEste artigo aborda um processo de configuração de uma câmera PTZ no Home Assistant. \\nSerá utilizado o protocolo ONVIF. Isso requer uma conta de câmera local.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nO processo de configuração da conta de câmera local não é abordado neste artigo.\\n</robo-wiki-note>\\n\\nRequisitos:\\n- Câmera PTZ\\n- Conta de câmera local\\n- Endereço IP da câmera\\n- Home Assistant configurado\\n\\n## Integração ONVIF\\n\\nVamos começar com a instalação da integração **ONVIF**. \\n\\nVá para \\\"Devices & Services\\\" em \\\"Settings\\\" e pressione o botão  \\\"ADD INTEGRATION\\\".\\nDigite \\\"ONVIF\\\" e escolha a integração. Você verá a próxima janela.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nPressione o botão \\\"Submit\\\". Ele tentará pesquisar automaticamente sua câmera. Se tiver sucesso, \\nescolha sua câmera na lista e preencha os campos vazios. \\nCaso contrário, você terá que preencher todos os campos manualmente. Você verá a seguinte janela.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nPreencha as lacunas:\\n- Name - dê um nome para sua câmera\\n- Host - forneça o endereço IP da sua câmera\\n- Port - geralmente é comum ser 2020, mas o fornecedor da sua câmera pode alterar\\n- Username - escreva o nome de usuário da sua conta local da câmera\\n  - Password - escreva uma senha para sua conta local da câmera\\n\\ne pressione \\\"Submit\\\". Escolha uma Área para sua câmera e clique em \\\"Finish\\\".\\n\\n## Adicione o controle da câmera ao painel\\n\\nAgora que você configurou completamente a câmera, você pode adicionar seu fluxo e botões de controle ao painel.\\n\\nVá para o painel e comece criando um novo cartão. Escolha o tipo \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nPreencha os dados:\\n- Title - escolha o título da imagem da câmera\\n- Camera Entity - escolha uma entidade de câmera na lista suspensa\\n- Camera View - escolha \\\"ao vivo\\\" para obter menos atraso\\n\\nEm seguida, mude para o modo \\\"Code Editor\\\" pressionando o botão no canto inferior esquerdo. Você verá o seguinte código:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nSubstitua o conteúdo de `entities: []` de acordo com o exemplo abaixo (`<SUA_ENTIDADE_DE_CÂMERA>` é o mesmo que o parâmetro `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nIsso é tudo. Agora você deverá ver o cartão da câmera PTZ no painel junto com os botões de controle.\\n\\n## Solucionando Problemas\\nSe você estiver usando o Home Assistant Core e não estiver vendo um fluxo da câmera, você deve instalar as integrações \\\"stream\\\" e \\\"FFMPEG\\\". \\nPara fazer isso, você deve adicionar as strings `stream: ` e `ffmpeg: ` ao final do configuration.yaml.\"}},{\"node\":{\"id\":\"dbbbb2cd015eb56a93838c678f02c419\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/pt/notifications/\",\"content\":\"\\nVocê pode receber notificações em seu smartphone com [notify](https://notify.events/). Primeiro, registre-se lá e no `Control Panel` crie um novo canal:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nAdicione um título e pressione `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nEm seguida, pressione `Add Source` e escolha `Home Assistant` na guia `IoT and Smart Home`:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nEscreva um título e pressione `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nLá você verá o token que você precisa adicionar ao seu arquivo de configuração para o Home Assistant. Salve-o em algum lugar e pressione `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nem seguida, pressione `Subscribe` para adicionar assinantes:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nEscolha qualquer assinante que você deseja e siga as instruções.\\n\\nAgora você precisa editar a configuração em seu computador com o Home Assistant. Sob o usuário `homeassistant`, abra o arquivo `configuration.yaml`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nE adicione estas linhas:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nTambém adicione uma nova automação após a linha `automação`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nEsta automação enviará a mensagem `Door was changed to on/off` após o sensor com o ID da entidade `binary_sensor.contact_sensor_contact` mudar de estado de `off` para `on`.\\n\\nE reinicie o Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"43b699c30faf104a3a131d4b79e37eb5\",\"title\":\"Lançamento\",\"path\":\"/docs/pt/launch/\",\"content\":\"\\n**Outra funcionalidade básica do parachain Robonomics é o pallet de Lançamento. Ele permite enviar comandos para as contas/entidades por trás delas. Esses comandos incluem parâmetros para especificar a tarefa a ser executada.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Por favor, preste atenção que este e os seguintes tutoriais são demonstrados em uma instância local do Robonomics Node. Configure o seu com [estas instruções](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navegue até Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Escolha launch -> launch na lista suspensa de extrínsecos possíveis\\n\\nTambém escolha uma conta na qual você deseja enviar o extrínseco. Preencha o campo de endereço de destino e o campo de parâmetro.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  - O Launch suporta strings de 32 bytes como comandos ([source](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)),\\n  então há espaço para improvisar aqui:\\n  - Para comandos básicos como alternar, você pode usar \\\"0x00000000000000000000000000000000000000000000000000000000001\\\" ou\\n  \\\"0x000000000000000000000000000000000000000000000000000000000\\\".\\n  - Para comandos avançados, incluindo json, você pode usar [IPFS](https://ipfs.tech/) CID formatado em um\\n  [maneira correta](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Envie a transação\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Revise seu lançamento nos eventos\\n\\nPara isso, navegue até *Network -> Explorer* e encontre uma lista de eventos à direita. Clique em um ícone de triângulo para expandir.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"54d8dfaf8f5c340051bb78ce1b3f3524\",\"title\":\"Responsabilidade\",\"path\":\"/docs/pt/liability/\",\"content\":\"\\n**Para transformar robôs em agentes econômicos, é necessário uma ferramenta de contrato para isso. Conheça a Responsabilidade - Robonomics pallet implementando contratos entre contas parachain!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Por favor, preste atenção que este tutorial é demonstrado em uma instância local do Robonomics Node. Configure o seu com [estas instruções](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Visão Geral da Teoria\\n\\nDe volta ao Ethereum, havia uma estrutura bastante complicada de interação de responsabilidade. Você pode se familiarizar com ela [aqui](/docs/robonomics-how-it-works). Hoje em dia as coisas estão um pouco mais fáceis com o Kusama!\\n\\n### Negociações\\n\\nPara assinar um contrato, os dois lados precisam primeiro negociar. Isso pode ser feito de várias maneiras, incluindo [IPFS PubSub](https://blog.ipfs.tech/25-pubsub/) ou Robonomics PubSub. Um exemplo de código Python usando Robonomics PubSub é apresentado [aqui](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub).\\n\\nOferta e demanda são mensagens contendo duas características principais de um contrato: **descrição do trabalho** e **preço**. O formato da mensagem deve ser projetado pelo usuário para cada aplicação específica. Não é tão importante no processo de negociação seguir uma regra de formato estrito. O fluxo possível é apresentado na imagem abaixo.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Observe que o PubSub é um protocolo aberto, portanto, nenhum dado sensível deve ser transferido. Para isso, você deve usar outros protocolos.\\n\\n</robo-wiki-note>\\n\\n\\n### Assinaturas\\n\\nQuando as negociações terminam com sucesso, cada lado precisa assinar o chamado acordo denominado assinatura. Esta é uma mensagem contendo descrição do trabalho e preço **em formato específico** assinado com uma chave privada da conta. Existe uma [ferramenta Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability) para isso também.\\n - A descrição do trabalho é chamada de **técnica**. Esta é uma string de 32 bytes de comprimento, semelhante a um lançamento, que pode ser um CID IPFS codificado.\\n - O preço é chamado de **economia**. Este é um decimal XRT - Weiner. 1 Weiner = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Você pode obter um [CID](https://ipfs.tech/) IPFS formatado de maneira adequada com a [biblioteca Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  Ao usar a função `sign_liability`, não é necessário transformar o hash, isso será feito automaticamente.\\n\\n</robo-wiki-note>\\n\\nSeguindo o exemplo do café:\\n\\n1. A tarefa é um JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Seu CID IPFS é `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Portanto, a **técnica** (CID transformado) é `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **Economia** é `1.5 XRT`.\\n\\nQuando assinado, é hora de criar uma responsabilidade! Isso pode ser feito por um dos lados (seja o promitente ou o promissor) ou por uma conta de terceiros de um chamado provedor.\\n\\n## Criar Responsabilidade\\n\\n### Preparativos\\n\\nComo mencionado anteriormente, pelo menos dois lados estão envolvidos no processo. Para este exemplo, vamos usar três e fazer um provedor separado para isso. Suponha que as negociações já tenham ocorrido de alguma forma.\\n\\n### 1. Crie três contas e adicione fundos a elas\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nAqui fornecemos ao provedor 100 XRT para assinar extrínsecos de responsabilidade, o promitente recebeu 2 XRT para pagar pelo trabalho.\\nO promissor não recebeu nenhum fundo (exceto por um depósito existencial de pelo menos 1 mXRT).\\n\\n### 1. Navegue até Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Escolha a liability -> create na lista suspensa de extrínsecos possíveis\\n\\nTambém escolha uma conta com a qual você deseja enviar o extrínseco. Preencha todos os parâmetros.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  Como o provedor é usado aqui, não é necessário conhecer as sementes dos participantes. Apenas suas assinaturas são necessárias.\\n\\n</robo-wiki-note>\\n\\n### 3. Envie a transação\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Revise sua responsabilidade nos eventos\\n\\nPara isso, navegue até `Network -> Explorer` e encontre uma lista de eventos à direita. Clique em um ícone de triângulo para expandir.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  O hash pode ser transformado em um CID IPFS com a mesma [ferramenta Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Explorando o armazenamento\\n\\nVocê também pode explorar algumas características das responsabilidades no módulo de armazenamento `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  A função de armazenamento `Next Index` mostra o último índice de responsabilidade +1, então mesmo que seja `1`, a responsabilidade `0` é explorada.\\n\\n</robo-wiki-note>\\n\\n## Relatórios\\n\\nImaginem que um café foi feito e agora a máquina de café precisa relatar de alguma forma. É aí que entram os relatórios de responsabilidade. Como prova de trabalho, a conta adiciona outro CID IPFS como conteúdo do relatório ao finalizar a responsabilidade existente. Isso novamente requer uma assinatura do promissor.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  A mensagem assinada contém o índice de responsabilidade existente e o CID IPFS do relatório codificado em uma representação de 32 bytes. Mais uma vez, a [ferramenta Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) pode ajudar a assinar o relatório.\\n\\n</robo-wiki-note>\\n\\nContinuando com o exemplo da máquina de café:\\n\\n1. O relatório é um JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Seu CID IPFS é `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. Portanto, a **carga útil** (CID transformado) é `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2`\\n4. **Índice** é `0`, é o índice de responsabilidade existente.\\n\\n### 1. Navegue até extrinsics, liability -> finalize(report)\\n\\nPreencha os parâmetros e envie extrínseco. Novamente, isso pode ser feito por uma conta de terceiros.\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Atenção para que a conta do promissor não esteja \\\"inativa\\\" - ela deve ter o depósito existencial de pelo menos 1 mXRT.\\n\\n</robo-wiki-note>\\n\\nAssine e envie o relatório. Quando terminar, você pode explorá-lo nos eventos.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Explore relatórios\\n\\nVocê também pode observar o relatório no armazenamento. Vá para  `Developer -> Storage` e escolha `liability` na lista suspensa.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Verifique os saldos\\n\\nNa imagem é mostrado que agora o promissor recebeu o \\\"salário\\\". A relação econômica aconteceu!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  Por enquanto, não há maneira de verificar se o trabalho foi concluído, portanto, assim que o promissor relatar, os tokens são transferidos para sua conta. \\n  O recurso de verificação será adicionado no futuro.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"9d136c80b74003474a3d0104e465a5d7\",\"title\":\"Como lançar o Robonomics collator\",\"path\":\"/docs/pt/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  No screencast e nas capturas de tela deste artigo, usamos a versão 1.4.0 do Robonomics. Você precisa usar os mesmos comandos, mas substituir a versão do Robonomics pela atual.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nAtualmente, a rede Robonomics é mantida principalmente pelos desenvolvedores iniciais, mas qualquer pessoa pode apoiar o projeto. Cada nó completo adicional da blockchain ajuda a torná-la mais sustentável e tolerante a falhas. Os binários do nó Robonomics estão disponíveis em [release](https://github.com/airalab/robonomics/releases) ou podem ser [construídos a partir do código-fonte](/docs/how-to-build-collator-node/).\\n\\n## O que é um colator\\n\\nUm Collator faz parte do parachain Robonomics. Esse tipo de nó cria novos blocos para a cadeia Robonomics.\\n\\n>Os colatores mantêm as parachains coletando transações de parachain dos usuários e produzindo provas de transição de estado para os validadores da Relay Chain. Em outras palavras, os colatores mantêm as parachains agregando transações de parachain em candidatos a blocos de parachain e produzindo provas de transição de estado para os validadores com base nesses blocos.\\n\\nVocê pode aprender mais sobre collators na página wiki relacionada do [Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nNo parachain Robonomics, cada agrupador recebe recompensas de (**0,001598184 XRT**) para cada bloco que o agrupador constrói (as recompensas ocorrem quando os blocos são selados à cadeia).\\nAlém disso, o collator que constrói o bloco recebe **50% das taxas de transação** contidas no bloco que eles criam.\\n\\n## Requisitos\\n\\nRecomenda-se lançar um collator usando os **requisitos de hardware padrão** para [validadores Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ Compatível com x86-64.\\n+ Intel Ice Lake, ou mais recente (Xeon ou série Core); AMD Zen3, ou mais recente (EPYC ou Ryzen).\\n+ 4 núcleos físicos @ 3.4GHz.\\n+ Multithreading simultâneo desativado (Hyper-Threading na Intel, SMT na AMD).\\n+ Armazenamento - Um SSD NVMe de 1 TB (Deve ter um tamanho razoável para lidar com o crescimento da blockchain).\\n+ Memória - 32 GB DDR4 ECC\\n\\n\\nNeste artigo, usamos as seguintes especificações:\\n+ 4 vCPU\\n+ 700 GB de espaço NVMe para bancos de dados do collator. A capacidade de expandir esse espaço em disco é necessária.\\n+ 8GB de RAM\\n\\n\\n## Informações importantes\\n1. Usamos algumas variáveis nessas instruções e você precisará substituir os valores pelos seus próprios em todos os comandos:\\n    + **%NODE_NAME%** é o nome do nó. Exemplo: *meu-robonomics-kusama-collator*\\n    + **%BASE_PATH%** é o caminho para o volume montado. Exemplo: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** é o endereço da conta no ecossistema Polkadot no formato SS58. Exemplo: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Observe que você precisa incluir *--state-cache-size=0* no lançamento do serviço do collator. Esse parâmetro é importante para a estabilidade do collator.\\nVocê pode ver mais informações no [issue](https://github.com/airalab/robonomics/issues/234) relacionado no github.\\n\\n## Lançar facilmente um Robonomics collator pela primeira vez\\n\\nVocê pode lançar facilmente um collator diretamente na linha de comando para verificar erros.\\nDepois de fazer isso, é altamente recomendável lançar o Robonomics collator como um serviço (veja o próximo passo).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Lançar o Robonomics collator como um serviço\\n\\n1. Crie o usuário para o serviço com diretório home\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Baixe, extraia e mova o binário do Robonomics para o diretório */usr/local/bin/*. Você precisa substituir *$ROBONOMICS_VERSION* pela versão atual do Robonomics nos comandos desta seção. Você pode encontrar a versão atual na [página de lançamentos do repositório Robonomics no github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Crie o arquivo de serviço systemd chamado *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    E adicione as seguintes linhas no arquivo de serviço:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Salve este arquivo, em seguida, habilite e inicie o serviço:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nURL de telemetria: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nOs logs dos agrupadores podem ser monitorados com: `journalctl -u robonomics.service -f` \\n\\nAssim que o coletor Robonomics for iniciado, ele começará a sincronizar com o Kusama Relay Chain. Isso pode levar um tempo considerável, dependendo da velocidade da rede e das especificações do sistema, por isso recomendamos baixar um instantâneo do Kusama.\\n\\n\\n## Acelerando o processo de sincronização usando um snapshot do Kusama\\n\\nRecomendamos fazer isso imediatamente após criar e iniciar o serviço Robonomics. Você pode encontrar mais informações sobre snapshots e instruções de uso na seguinte página: https://ksm-rocksdb.polkashots.io/\\n\\nInstruções:\\n\\n1. Pare o serviço Robonomics e remova o diretório do banco de dados atual do Kusama:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Baixe o snapshot atual e extraia-o:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    Você pode remover o arquivo baixado após descompactar com sucesso:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Definindo a propriedade correta para a pasta do banco de dados:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Inicie o serviço Robonomics novamente:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Verifique os logs do serviço:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Solucionando Problemas\\n### Erro: \\\"State Database error: Too many sibling blocks inserted\\\"\\nPara corrigir esse erro, você pode simplesmente iniciar seu agrupador no modo de arquivamento:\\n\\n1) Primeiro, pare o serviço Robonomics: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Em seguida, adicione o parâmetro `--state-pruning=archive` à parte da parachain do arquivo de serviço. Exemplo do arquivo de serviço editado:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Instalar]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Recarregue a configuração do gerenciador do systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Remova o banco de dados da parachain existente:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Inicie o serviço robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    Depois disso, é necessário aguardar a sincronização do banco de dados da parachain.\\n\\n### Erro: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nEsse erro está relacionado aos parâmetros de virtualização. É necessário usar o tipo de processador emulado \\\"host-model\\\". Você pode configurar isso no host de virtualização.\\n\\nNo entanto, se você encontrar esse erro em qualquer hospedagem, é necessário entrar em contato com o suporte técnico apenas sobre esse problema.\\n\"}},{\"node\":{\"id\":\"e8dea4f4be5a5e59cc91d1b42214c2a8\",\"title\":\"Como atualizar a versão do nó Robonomics Collator\",\"path\":\"/docs/pt/how-to-update-collator-node-version/\",\"content\":\"\\nRecomenda-se ler os seguintes artigos antes de ler esta postagem: [\\\"Como construir um nó Collator\\\"](/docs/how-to-build-collator-node) e [\\\"Como lançar o Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nEste artigo contém os comandos necessarios para atualizar um nó collator Robonomics (executando no Ubuntu) e também dá um exemplo posteriormente.\\n\\n## **Comandos necessários**\\n\\n0. Antes de começar, é recomendado que você esteja logado como `root`, caso contrário, recomendo que você use:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Pare o serviço Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Remova a versão anterior do Robonomics (certifique-se de estar no diretório correto):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Obtenha a [versão mais recente](https://github.com/airalab/robonomics/releases) do Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Extraia o arquivo:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Mova o arquivo:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nVocê precisa mover este arquivo para o diretório correto onde você instalou o nó Robonomics)\\n\\n</robo-wiki-note>\\n\\n6. Inicie o Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nExemplo de atualização do nó collator para Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Alterando o banco de dados da cadeia de retransmissão Kusama sem definir um caminho base**\\n\\nHá momentos em que certos instantâneos da cadeia de retransmissão Kusama causam erros no seu nó. Isso geralmente faz com que o nó pare de funcionar. Exemplo de erro causado por um banco de dados corrompido da cadeia de retransmissão:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nPara corrigir esse erro, você deve remover o banco de dados existente da cadeia de retransmissão Kusama (provavelmente RocksDb) e substituí-lo por outro banco de dados, como ParityDb. Execute os seguintes comandos:\\n\\n1. Encontre o diretório do nó Robonomics e verifique os arquivos:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Confirme que você vê o diretório polkadot e, em seguida, navegue até o diretório chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Exclua o diretório `ksmcc3`:\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Crie um novo diretório `ksmcc3`.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Agora você precisa baixar um novo instantâneo. Este exemplo usa um instantâneo da cadeia de retransmissão fortemente podado, mas você pode trocá-lo por qualquer instantâneo que preferir.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Enquanto o instantâneo está sendo baixado, abra uma nova sessão e edite seu arquivo de serviço:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nModifique as linhas dentro do arquivo de serviço que se referem ao banco de dados e poda:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nUse `Ctrl + S` e depois `Ctrl + X` para salvar e sair do arquivo de serviço.\\n\\n7. Agora você precisa recarregar seu daemon.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. Neste momento, em sua outra sessão, esperamos que o novo banco de dados tenha sido baixado, então extraia o arquivo:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. Após a descompactação ser concluída, execute o seguinte:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Agora você pode iniciar o serviço, monitorá-lo em busca de erros e verificar se ele está se conectando tanto à cadeia de retransmissão quanto à parachain.\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"d509ceb2cff79e5efa9f2f5749ada5e7\",\"title\":\"Como construir um nó de colator a partir do código-fonte\",\"path\":\"/docs/pt/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  No screencast e nas capturas de tela deste artigo, usamos a versão 1.4.0 do Robonomics. Você precisa usar os mesmos comandos, mas substituir a versão do Robonomics pela atual.\\n</robo-wiki-note>\\n\\n## O que é um colator\\n\\nColator é parte da parachain do Robonomics. Esse tipo de nó cria novos blocos para a cadeia..\\n\\n>Os colatores mantêm as parachains coletando transações de parachain dos usuários e produzindo provas de transição de estado para os validadores da Relay Chain. Em outras palavras, os colatores mantêm as parachains agregando transações de parachain em candidatos a blocos de parachain e produzindo provas de transição de estado para os validadores com base nesses blocos.\\n\\nVocê pode aprender mais sobre colator na página relacionada da [Polkadot wiki](https://wiki.polkadot.network/docs/learn-collator)\\n\\nNo parachain Robonomics, cada agrupador recebe recompensas (**0,000380520 XRT**) para cada bloco construído, se esse bloco tiver sido selado à cadeia.\\nAlém disso, o agrupador recebe **taxas de transação de 50%** deste bloco.\\n\\n## Processo de construção\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nCertifique-se de ter o Rust e o software de suporte instalados. O instalador do Rust irá perguntar sobre as opções de instalação atuais, você deve escolher a opção `1) Prosseguir com a instalação (padrão)`.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Instalar Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nInstalar the required nightly toolchain and wasm target.\\nOs comandos a seguir são válidos para o Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nVocê também precisará instalar os seguintes pacotes:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nAgora você pode instalar o nó do robonomics a partir da fonte git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nApós este comando, o binário compilado do robonomics estará no diretório `~/.cargo/bin`.\\n\\nO próximo passo é como iniciar o nó colator. Você pode ler sobre isso no artigo [\\\"Como iniciar o colator do Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"ff37db49c3d2811522f88ac0efd394fd\",\"title\":\"Atualize seu Home Assistant OS\",\"path\":\"/docs/pt/hass-os-upgrade/\",\"content\":\"\\n**Este artigo contém instruções para atualizar seu Home Assistant OS existente com integração Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Instalar IPFS Add-on\\n\\n\\nA integração Robonomics armazena os dados usando o daemon IPFS local, portanto, você precisa instalá-lo primeiro. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. Existe um [Add-on IPFS para Home Assistant](https://github.com/airalab/ipfs-addon). Para instalá-lo, vá para `Settings` -> `Add-ons` e pressione o botão `ADD-ON STORE` no canto inferior direito.\\n\\n2. Clique nos três pontos no canto superior direito e escolha `Repositories`. Adicione o seguinte link lá:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Pressione o botão `ADD`.\\n\\n4. Feche o gerenciador de repositórios e atualize a página. Agora, no final da página, você pode ver o Add-on IPFS Daemon.\\n\\n5. Abra o add-on e pressione `INSTALL`. Após a instalação, pressione `START`.\\n\\n## Instalar HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) permite que você instale integrações personalizadas.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Antes de começar, você precisa instalar um add-on para conectar-se ao dispositivo Home Assistant com SSH. Na Loja de Add-ons, pesquise por `ssh`. Recomendamos instalar o add-on `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Se o add-on SSH não for encontrado, tente habilitar o Modo Avançado nas configurações do seu perfil de usuário. Para fazer isso, clique no ícone de perfil no canto inferior esquerdo e encontre a opção Modo Avançado.\\n\\n</robo-wiki-note>\\n\\n2. Escolha o add-on e pressione `INSTALL`. Após a instalação ser concluída, vá para a guia `Configuração` e adicione `password` ou `authorized_keys`. Não se esqueça de salvar esta parte da configuração.\\n\\n3. Na guia `Info`, pressione `START`. Se você quiser ver o add-on na barra lateral, não se esqueça de habilitar `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Abra o Add-on SSH e execute o seguinte comando:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Reinicie o Home Assistant (você pode fazer isso em `Settings`->`System`). \\n\\n6. Agora a Integração HACS estará disponível para adicionar no menu  `Integrations`. Vá para `Settings`->`Devices & Services`, pressione  `Add Integration`  e encontre o HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Para usar o HACS, você precisa de uma conta no Github.\\n\\n</robo-wiki-note>\\n\\n7. Clique nele e siga as instruções de instalação. \\n\\n## Instale a Integração Robonomics\\n\\nAgora você pode instalar a Integração Robonomics usando o HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nAbra o HACS no menu da barra lateral e navegue até `Integrations`. Clique em `Explore & Download Repositories`, procure por `Robonomics` e clique no botão `Download` localizado no canto inferior direito. Assim que o download for concluído, reinicie o Home Assistant.\"}},{\"node\":{\"id\":\"9fe99a323b2aff3968a7c7702dff3bee\",\"title\":\"Inicialização do Home Assistant\",\"path\":\"/docs/pt/hass-init/\",\"content\":\"\\n**Após instalar o Home Assistant, ele precisa ser inicializado.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nVocê está começando com a criação da conta do proprietário do Home Assistant. Essa conta é um administrador e pode fazer qualquer alteração. Abra o navegador da web e vá para `http://%RASPBERRY_IP_ADDRESS%:8123`. Você pode encontrar o endereço IP do Raspberry Pi usando o [aplicativo móvel Fing](https://www.fing.com/products) ou a [ferramenta de linha de comando nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">O endereço do Raspberry Pi pode mudar com o tempo, devido às configurações do roteador.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. Na primeira página, digite um nome, nome de usuário, senha e clique no botão `CREATE ACCOUNT`.\\n\\n2. Na próxima tela, digite um nome para sua casa e defina sua localização e sistema de unidades. Clique em `DETECT` para encontrar sua localização e definir seu fuso horário e sistema de unidades com base nessa localização. Se você não quiser enviar sua localização, você pode definir esses valores manualmente.\\n\\n3. Depois disso, o Home Assistant mostrará quaisquer dispositivos que ele tenha descoberto em sua rede. Não se preocupe se você ver menos itens do que o mostrado abaixo; você sempre pode adicionar dispositivos manualmente posteriormente. Por enquanto, clique em `FINISH` e você estará na tela principal do Home Assistant.\\n\\n4. Por fim, você verá a interface web do Home Assistant, que mostrará todos os seus dispositivos. \\n\\n\\n## Solucionando Problemas\\n\\n1. Se você esquecer seu nome de usuário ou senha para o usuário local, [verifique este artigo](https://www.home-assistant.io/docs/locked_out/) para restaurar suas credenciais.\\n\"}},{\"node\":{\"id\":\"99bb4a7231b9a07fc526f92437b1e70b\",\"title\":\"Imagem pré-instalada para Raspberry Pi\",\"path\":\"/docs/pt/hass-image-install/\",\"content\":\"\\n**Bem-vindo ao guia de instalação do Home Assistant com integração Robonomics em um Raspberry Pi. O Home Assistant é um sistema de automação residencial de código aberto que fornece um hub centralizado para controlar dispositivos inteligentes em sua rede doméstica. Ao integrar-se ao Robonomics, um serviço em nuvem descentralizado, você pode aprimorar a funcionalidade e a segurança de sua casa inteligente. Neste artigo, forneceremos instruções passo a passo sobre como instalar o Home Assistant com Robonomics em um Raspberry Pi, dando a você a capacidade de automatizar e controlar vários aspectos de sua casa usando uma solução segura e descentralizada. Vamos começar!**\\n\\n## Hardware necessário para a instalação\\n\\nSe você ainda não incorporou o Home Assistant à sua configuração de casa inteligente, é importante estar ciente do equipamento necessário para estabelecer um sistema completo de casa inteligente desde o início.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Baixe a imagem pré-instalada do Robonomics\\n\\nA imagem pré-instalada do Robonomics contém:\\n- Home Assistant Core\\n- IPFS\\n- Broker MQTT e Integração\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nVocê pode verificar o código-fonte e baixar a versão mais recente da imagem no [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Configure a imagem\\n\\nInstale o [Raspberry Pi Imager](https://www.raspberrypi.com/software/) em seu computador. Em seguida, insira o cartão SD.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nExecute o programa Raspberry Pi Imager. Escolha a imagem necessária como sistema operacional e certifique-se de selecionar seu cartão SD no menu suspenso de armazenamento.\\nNas configurações:\\n- Defina o nome de usuário e a senha (salve o nome de usuário padrão \\\"pi\\\" para facilitar a lembrança),  \\n- forneça o nome e a senha do Wi-Fi, \\n- escolha seu país na lista suspensa\\ne então `Grave` a imagem. \\n                   \\n<robo-wiki-note type=\\\"note\\\">Guarde o nome de usuário e a senha com cuidado, pois essas credenciais serão necessárias em caso de solução de problemas</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nVocê pode encontrar códigos de país [aqui](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. Primeira inicialização\\n\\n**Ejete com segurança o cartão SD**, insira-o no Raspberry Pi. Em seguida, **insira o adaptador Zigbee** no Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">É importante inserir o adaptador Zigbee antes da primeira inicialização do Raspberry Pi! \\nÉ necessário para a autoconfiguração da rede Zigbee.</robo-wiki-note>\\n\\n**Se você tiver o [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (que possui todo o firmware necessário), você pode simplesmente seguir estas instruções. No entanto, se você tiver outro adaptador, a primeira coisa que você precisa fazer é gravá-lo com o software Zigbee2MQTT. Você pode encontrar instruções para o seu dispositivo [aqui](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nEm seguida, conecte o cabo de alimentação ao seu dispositivo. Ele deve se conectar à sua rede Wi-Fi. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nAssim que o Raspberry Pi estiver conectado, o LED vermelho acenderá e o LED verde piscará por algum tempo. Aguarde até 5 minutos para que o Raspberry Pi inicialize e se registre na rede.\\n\\nAgora encontre o endereço IP do Raspberry Pi. Para encontrá-lo, você pode usar o aplicativo móvel [Fing](https://www.fing.com/products) ou \\na ferramenta de linha de comando [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Encontre o `robots-home` (o nome opcional pode ser `Home(homeassistant)`) \\nnome da máquina host na lista de IPs. \\n\\nNeste exemplo, o endereço é `192.168.43.56`. \\n\\nPara verificar se tudo está funcionando, abra o navegador da web e acesse a página da web `http://%RASPBERRY_IP_ADDRESS%:8123`. Neste exemplo, será `192.168.43.56:8123`.\\nSe tudo estiver correto, você verá a interface web do Home Assistant. Se a página da web não abrir, aguarde até 5 minutos para que o Raspberry Pi seja inicializado e tente novamente. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Solucionando Problemas\\n\\n1. Para alterar as configurações do Wi-Fi posteriormente, você deve fazer login no Raspberry Pi via comando `ssh`. Para isso, abra o terminal em seu computador\\ne digite o comando ssh com seu nome de usuário, que você criou na etapa \\\"Configurando a imagem\\\" (o padrão é \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\ne então use o comando `sudo raspi-config`. Encontre mais informações sobre este comando no [site oficial.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"4dcc4570c105aa90a4a2b9ba1bbe1b65\",\"title\":\"Atualize seu Home Assistant Docker para sistemas operacionais semelhantes ao Unix\",\"path\":\"/docs/pt/hass-docker-upgrade/\",\"content\":\"\\n**Este artigo contém instruções para atualizar seu Home Assistant Docker existente (em um sistema operacional semelhante ao Unix) com a integração Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. É assumido que as imagens e o contêiner padrão do Docker do Home Assistant chamados <u>homeassistant</u> estão sendo usados.\\n  2. O IPFS será instalado e executado como um serviço <u>systemd</u> na máquina hospedeira.\\n  3. É assumido que você tem o [Python3.9](https://www.python.org/downloads/) ou uma versão superior instalada.\\n\\n</robo-wiki-note>\\n\\n## Instalar\\n\\nBaixe o script de instalação e execute-o no terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nVocê verá a seguinte saída:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Você pode ver um erro como `mkdir: can't create directory 'custom_components': File exists`. Isso significa que você já possui essa pasta com alguns componentes personalizados instalados. Apenas ignore esta mensagem.\\n\\n</robo-wiki-note>\\n\\nReinicie o contêiner:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Verificar\\n\\nVerifique se o serviço IPFS está em execução:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVocê verá a seguinte saída:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"4d7571919fb1ea34544348c37ac852fe\",\"title\":\"Glossary\",\"path\":\"/docs/pt/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\numa conjunção de um par de chaves público-privadas, em que a parte pública é o endereço público do usuário e a parte privada é a chave secreta para acessar o controle desse endereço.\\n\\n\\n### Auction (of Parachains)\\nmecanismo de locação de slots para parachains nos ecossistemas Polkadot e Kusama; um parachain deve vencer um leilão de vela para obter um slot.\\n\\n### Autonomous Agent\\num sistema computacional que recebe dados sensoriais de seu ambiente e decide como responder a estímulos externos para alcançar seus objetivos.\\n\\n### AIRA\\nou Agente Robô Inteligente Autônomo — um software, desenvolvido pela equipe Robonomics em 2015, que implementa o padrão de interação econômica humano-máquina e máquina-máquina por meio de um contrato de responsabilidade intelectual.\\n\\n\\n## B\\n\\n### Blockchain\\nem um sentido amplo, uma rede distribuída que usa criptografia para permitir que um grupo de participantes chegue a um consenso confiável sobre o estado em mudança de um sistema.\\n\\n### Blockchain Explorarr\\num aplicativo que permite explorar os diferentes blocos, transações e endereços em uma blockchain (por exemplo, Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\numa lógica de automação pré-fabricada que pode ser facilmente adicionada a uma instância do Home Assistant.\\n\\n### Bridge\\numa tecnologia e métodos pelos quais duas cadeias economicamente soberanas e tecnologicamente diversas podem se comunicar entre si. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nou Cs — uma milionésima parte de um token XRT, 1 XRT = 1 000 000 Cs; em homenagem a Ronald Coase, economista britânico, um dos fundadores da economia institucional, ganhador do Prêmio Nobel Memorial de Ciências Econômicas.\\n\\n### Collator\\num nó que mantém um parachain coletando transações de parachain e produzindo provas de transição de estado para os validadores.\\n\\n### Consensus\\num processo no qual os nós de uma rede blockchain chegam a um acordo sobre o estado atual dos dados na rede (por exemplo, Prova de Trabalho, Prova de Participação).\\n\\n### Crowdloan\\numa campanha de financiamento coletivo para coletar tokens para fazer um lance no leilão de slots no ecossistema Polkadot / Kusama.\\n\\n### Cybernetics\\no estudo do controle e comunicação no animal e na máquina, de acordo com a definição de N. Wiener.\\n\\n### Cyber-Physical System\\nou CPS — uma forte unificação e integração mútua de vários processos computacionais, de rede e físicos.\\n\\n\\n## D\\n\\n### DAO\\numa organização de propriedade coletiva e governada por blockchain, na qual a gestão de recursos é realizada de acordo com um conjunto de regras pré-acordadas e formalizadas, cuja aplicação é realizada automaticamente.\\n\\n### Datalog (Function)\\numa função de parachain Robonomics que armazena dados do dispositivo na blockchain.\\n\\n### Dapp\\nou aplicativo descentralizado — um aplicativo que é executado como parte de uma rede distribuída e fornece acesso às suas funções de maneira amigável ao usuário.\\n\\n### Decentralized Cloud\\num serviço de computação em nuvem baseado em uma rede descentralizada ponto a ponto, no qual os usuários podem se juntar para usar serviços ou fornecer seus recursos, como computação, rede, armazenamento, etc.\\n\\n### Digital Twin\\numa versão digital de um equipamento real que copia suas características técnicas e dados históricos.\\n\\n\\n## E\\n\\n### Edge-system\\num dispositivo IoT que atua como um link entre sistemas embarcados acessíveis localmente e a rede global, geralmente suportando protocolos de comunicação e transmitindo telemetria e sinais de controle.\\n\\n### Embedded System\\num dispositivo IoT com recursos limitados de computação e comunicação que fornece funções básicas (sensores, atuadores, botões) no nível mais baixo, geralmente sem interfaces de usuário.\\n\\n### Ethereum\\num sistema blockchain de código aberto e descentralizado que funciona como uma plataforma para numerosas outras criptomoedas, bem como para a execução de contratos inteligentes descentralizados.\\n\\n### Ethereum Upgrade\\nanteriormente conhecido como Ethereum 2.0 ou Eth2 — uma atualização do protocolo Ethereum que deve tornar a rede mais escalável, segura e sustentável; para esses fins, propõe-se mudar o consenso para Proof-of-Stake e adicionar um mecanismo de fragmentação para aumentar a capacidade da rede.\\n\\n### Exodus\\nprocesso de transferência de tokens XRT da rede Ethereum para a parachain Robonomics.\\n\\n### Extrinsic\\numa função na rede Polkadot e Kusama, que pode acionar transições de estado da rede de fora do estado.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nou Gk — um milésimo de um token XRT, 1 XRT = 1 000 Gk; nomeado em homenagem a Victor Glushkov, um matemático soviético, um dos fundadores da tecnologia da informação e cibernética na União Soviética.\\n\\n\\n## H\\n\\n### Home Assistant\\nou Hass — um software de sistema de controle de código aberto, projetado para ser um hub central para dispositivos inteligentes.\\n\\n### HRMP\\nou Passagem de mensagens roteadas por retransmissão horizontal - uma mensagem segura que passa entre parachains, que armazena todas as mensagens no armazenamento da cadeia de retransmissão antes de enviá-las para parachains.\\n\\n### HMI\\nou Interface Humano-Máquina — uma interface do usuário ou painel de controle que conecta o usuário a uma máquina, sistema ou dispositivo.\\n\\n\\n## I\\n\\n### Industry 4.0\\nou a Quarta Revolução Industrial — a automação contínua das práticas tradicionais de manufatura e industriais, usando tecnologia inteligente moderna.\\n\\n### IPFS\\nou Sistema de Arquivos Interplanetário — um software peer-to-peer para armazenar e compartilhar dados em um sistema de arquivos distribuído.\\n\\n### IoT\\nou Internet das Coisas — uma conexão a uma rede global de bilhões de dispositivos, capazes de coletar dados e integrados ao ambiente.\\n\\n### IoT Gateway\\num sistema de borda que agrega e transmite dados de dispositivos IoT para a rede e vice-versa; frequentemente, esses dispositivos são uma versão mais complexa do roteador WiFi.\\n\\n### IoT Provider\\num serviço externo que fornece aos usuários de IoT acesso remoto a dados e análises, bem como controle de dispositivos inteligentes pela Internet.\\n\\n### IoT Subscription\\nrecurso da parachain Robonomics que permite usar todas as funções da parachain por um determinado período sem taxa.\\n\\n\\n## K\\n\\n### KSM\\num token nativo para a rede Kusama.\\n\\n### Kusama\\na \\\"rede canária\\\" para o Polkadot, que consiste em uma versão de lançamento antecipado e não auditada do software Polkadot.\\n\\n\\n## L\\n\\n### Lançamento (Function)\\numa função de parachain Robonomics que inicia ou interrompe um dispositivo enviando um comando através da blockchain.\\n\\n### Lease Period\\num período de tempo em que um parachain pode se conectar à Relay Chain.\\n\\n### Libp2p\\numa biblioteca de código aberto para criar redes ponto a ponto criptografadas.\\n\\n### Lights-out Factory\\nou Fábrica Inteligente - uma fábrica totalmente automatizada que não requer presença humana no local.\\n\\n### Lighthouse\\num contrato inteligente, no conceito de economia de robôs, que realiza uma transação quando o Provedor estabelece uma correspondência de mercado entre o Prometente e o Promissário.\\n\\n### Responsabilidade\\num contrato inteligente, feito por sistemas ciberfísicos entre si ou com humanos, para executar uma tarefa em troca de pagamento.\\n\\n### Liability Market\\numa plataforma, no conceito de economia de robôs, responsável por combinar ofertas e demandas entre os nós do sistema.\\n\\n\\n## M\\n\\n### MQTT\\nou Message Queuing Telemetry Transport - um protocolo de publicação e assinatura projetado para redes de baixa largura de banda, alta latência e não confiáveis para operar volumes altos de mensagens de dispositivos IoT.\\n\\n### MQTT Broker\\num serviço que recebe todas as mensagens dos clientes MQTT e, em seguida, roteia as mensagens para os clientes assinantes apropriados.\\n\\n\\n## N\\n\\n### NFT\\nou Token Não Fungível - um token que não pode ser intercambiável e indistinguível de outros tokens que permitem a tokenização de itens únicos e fornecem propriedade exclusiva para esses tokens.\\n\\n### Node (of Robonomics)\\num módulo de blockchain baseado em Substrate ou Ethereum com extensões Robonomics para conexão com a Rede Robonomics.\\n\\n\\n## O\\n\\n### On-chain Governance\\num processo de determinar quais alterações na rede são permitidas, como modificações no código ou movimentação de fundos, que existe na própria rede e pode alterá-la diretamente.\\n\\n\\n## P\\n\\n### Pallet\\num módulo Substrate escrito em Rust que agrupa lógica ou algoritmo específico para tempo de execução de blockchain baseado em Substrate.\\n\\n### Parachain\\numa estrutura de dados personalizada e específica do aplicativo (geralmente, uma blockchain) que é integrada à Relay Chain e pode ser validada pelos validadores.\\n\\n### Parathread\\numa parachain sem um slot que pode participar temporariamente (em uma base de bloco por bloco com uma taxa) na segurança da Relay Chain.\\n\\n### Polkadot\\numa rede heterogênea e multi-chain que permite que várias blockchains de características diferentes realizem comunicação arbitrária entre cadeias sob segurança compartilhada.\\n\\n### Polkadot/Substrate Portal\\numa interface básica do Substrate para interagir com uma rede Substrate do Polkadot, Kusama e outras.\\n\\n### Proposal (on Polkadot / Kusama)\\na potential function call to be voted on in a Polkadot, Kusama or parachains referendum. \\n\\n### Proof-of-Work\\num mecanismo de consenso no qual, para chegar a um acordo, os participantes da rede são obrigados a realizar trabalho computacional.\\n\\n### Proof-of-Stake\\num mecanismo de consenso no qual, para chegar a um acordo, os participantes da rede são obrigados a apostar capital da criptomoeda associada que atua como garantia.\\n\\n### Promisee\\num nó que faz um pedido para execução de uma tarefa no conceito de economia de robôs.\\n\\n### Promisor\\num nó que concorda em executar uma tarefa em troca de pagamento no conceito de economia de robôs.\\n\\n### Provider (Robonomics)\\num nó, no conceito de economia robótica, que monitora as mensagens do Mercado de Passivos e combina uma oferta e uma demanda por uma pequena taxa.\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\ncomo parte da governança on-chain, votar se uma proposta deve ou não ser aceita pelos usuários da rede.\\n\\n### Relay Chain\\na cadeia principal que coordena o consenso do Polkadot / Kusama e a comunicação entre parachains.\\n\\n### Robofirm\\numa organização na qual todo o ciclo do processo de negócios é totalmente automatizado e não requer participação humana.\\n\\n### Rococo\\na testnet para testar parachains no Kusama\\n\\n### robonomics-interface\\numa biblioteca Python especializada em interface com Robonomics para programação conveniente.\\n\\n### Robonomics no Ethereum\\numa versão da Rede Robonomics executada em cima do Ethereum, lançada em 2018.\\n\\n### Robot Economy\\num sistema econômico no qual dispositivos atuam como agentes independentes capazes de realizar atividades econômicas-chave anteriormente exclusivas para humanos.\\n\\n### Robot-as-a-Service\\nou RaaS - um modelo de negócio no qual as empresas alugam seu equipamento robótico para clientes e usuários para uso a curto ou longo prazo.\\n\\n### ROS\\nou Robot Operating System - uma estrutura para desenvolvimento de software de robôs, que fornece serviços projetados para um cluster de computadores heterogêneo, como abstração de hardware, controle de dispositivo de baixo nível, implementação de funcionalidades comumente usadas, passagem de mensagens entre processos e gerenciamento de pacotes.\\n\\n### ROS 2\\numa versão atualizada e reconstruída do Robot Operating System com novos recursos, como suporte para sistemas multi-robô e pequenos sistemas embarcados, e integração com tempo real.\\n\\n### ROS 2 Middleware\\nou RMW - um protocolo que fornece recursos padrão do ROS 2, como descoberta, serialização e transporte; o ROS 2 suporta várias implementações de middleware que podem ser escolhidas para melhor atender aos requisitos do projeto.\\n\\n### RWS\\nou Robonomics Web Services - serviços de infraestrutura descentralizados para robótica e IoT que permitem conectar dispositivos facilmente e interagir com aplicativos do usuário, serviços em nuvem e outros dispositivos com segurança; ele tem seu próprio token também chamado RWS, que oferece assinatura vitalícia de IoT na parachain Robonomics.\\n\\n### Executartime\\numa função de transição de estado de uma blockchain que define um algoritmo válido para determinar o estado do próximo bloco dado o estado anterior.\\n\\n\\n## S\\n\\n### Seed Phrase\\numa chave privada legível por humanos criada como uma sequência de palavras aleatórias e necessária para obter acesso ao endereço da blockchain e seus tokens.\\n\\n### Shared Security\\no modelo de segurança do Polkadot / Kusama em que todas as cadeias são igualmente protegidas ao colocar provas da validade dos blocos da parachain na Relay Chain, de modo que um potencial atacante precisaria atacar todo o sistema.\\n\\n### SLS Gateway\\num gateway IoT de código aberto para dispositivos Zigbee baseado no microcontrolador ESP32 desenvolvido pela Smart Logic System.\\n\\n### Slot (of Parachain)\\num recurso escasso no ecossistema do Polkadot / Kusama, que permite que uma parachain seja conectada à Relay Chain sem taxa para cada bloco.\\n\\n### Smart Leasing\\numa variante do modelo Robot-as-a-Service, na qual o aluguel é pago não por tempo, mas por operações específicas e sua quantidade.\\n\\n### Smart Contract\\num programa ou algoritmo armazenado em uma blockchain que é executado automaticamente quando condições predeterminadas são atendidas.\\n\\n### SSH\\nou Secure Shell — um protocolo de rede para operar serviços de rede com segurança em uma rede não segura, que usa criptografia de chave pública para autenticar o computador remoto. \\n\\n### Staking\\na parte do consenso Proof-of-Stake, um ato de vincular tokens depositando-os como garantia para ter a chance de produzir um bloco válido e obter uma recompensa.\\n\\n### Substrate\\numa estrutura modular para construir blockchains como Polkadot e Kusama.\\n\\n\\n## T\\n\\n### Treasury\\num fundo de recursos coletados por meio de uma parte das recompensas de produção de blocos, taxas de transação, staking, etc., que podem ser gastos fazendo uma proposta de gastos; se o Tesouro encerrar um período de gastos sem gastar todos os seus fundos, ele sofre uma queima de uma porcentagem dos fundos.\\n\\n### Transaction Costs\\no custo de coletar e processar informações devido à racionalidade limitada dos agentes econômicos e à complexidade dos processos.\\n\\n\\n## V\\n\\n### Validator\\num nó que garante a Relay Chain ao apostar seus tokens, validando provas de colaboradores em parachains e votando no consenso juntamente com outros validadores.\\n\\n\\n## W\\n\\n### Web3\\numa ideia para uma nova iteração da Web que incorpora conceitos como descentralização, tecnologias blockchain e economia baseada em tokens.\\n\\n### Wiener (XRT)\\nou Wn — uma bilionésima parte de um token XRT, 1 XRT = 1 000 000 000 Wn; nomeado em homenagem a Norbert Wiener, um matemático americano, um dos fundadores da cibernética e da teoria da inteligência artificial.\\n\\n\\n## X\\n\\n### XCM\\nou Cross-Consensus Message Format — um formato de mensagens entre diferentes sistemas blockchain no Polkadot / Kusama.\\n\\n\\n### XRT\\num token nativo para a Rede Robonomics, que existe independentemente nas redes Ethereum e Kusama.\\n\\n\\n## Y\\n\\n### Yggdrasil\\numa implementação de rede sobreposta de um esquema de roteamento totalmente criptografado de ponta a ponta para redes mesh.\\n\\n\\n## Z\\n\\n### Zigbee\\num protocolo de comunicação sem fio, muito comumente usado para conectar dispositivos inteligentes devido ao baixo consumo de energia, facilidade de uso e flexibilidade de configuração, e suporte a topologia de rede auto-organizadora e autorrecuperadora.\\n\\n### Zigbee Adapter\\num dispositivo que transfere dados entre a rede Zigbee e outra rede (ou seja, Wi-Fi) para controlar dispositivos Zigbee.\\n\\n### Zigbee2MQTT\\num software que permite conectar Zigbee a redes MQTT traduzindo mensagens de uma rede para outra.\"}},{\"node\":{\"id\":\"a8bfa85cf1043f3de38f76bc1aa56c41\",\"title\":\"Atualize o seu Home Assistant Core\",\"path\":\"/docs/pt/hass-core-upgrade/\",\"content\":\"\\n**Este artigo contém instruções para atualizar o seu Home Assistant Core existente com a integração Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Pressupõe-se que a instalação do seu Home Assistant Core tenha sido concluída de acordo com as [instruções oficiais](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) e que exista um usuário <u>homeassistant</u> e o ambiente `venv`. Se não for o caso, siga as instruções abaixo, **mas edite o script de acordo**.\\n  2. O IPFS será instalado e executado como um serviço <u>systemd</u> na máquina hospedeira.\\n  3. Presume-se que você tenha o [Python3.9](https://www.python.org/downloads/) ou superior instalado.\\n\\n</robo-wiki-note>\\n\\n## Instalar\\n\\nBaixe o script de instalação e execute-o no terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nVocê verá a seguinte saída:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nDurante o processo, você será solicitado a confirmar a reinicialização de vários serviços. Navegue com `tab` e selecione a opção `yes`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Você pode ver um erro como `mkdir: can't create directory 'custom_components': File exists`. Isso significa que você já possui essa pasta com alguns componentes personalizados instalados. Apenas ignore esta mensagem.\\n\\n</robo-wiki-note>\\n  \\nApós a conclusão, reinicie o seu Home Assistant.\\n\\n## Verificar\\n\\nVerifique se o serviço IPFS está em execução:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVocê verá a seguinte saída:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"cc45f0cad7d7c209b9039b690c1d7d6e\",\"title\":\"Administração Global\",\"path\":\"/docs/pt/global-administration/\",\"content\":\"\\n**Este artigo mostrará como configurar um novo usuário para o seu Home Assistant.**\\n\\n## Adicionando Usuários à Assinatura\\n\\nVocê não pode usar contas criadas anteriormente porque `SUB_OWNER` e `SUB_CONTROLLER` fornecem segurança, e o primeiro usuário que você criou quando começou o Home Assistant não possui uma conta Robonomics Parachain.\\n\\n1. Crie uma conta na Robonomics parachain, como você fez no [artigo anterior](/docs/sub-activate/).\\n\\n2. Usando a conta `SUB_OWNER`, adicione uma nova conta de usuário à assinatura no [dapp](https://dapp.robonomics.network/#/subscription/devices). Agora deve haver três endereços na lista de acesso: `SUB_OWNER`, `SUB_CONTROLLER` e `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Concedendo Acesso ao Usuário\\n\\n1. Acesse o serviço dapp chamado [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Escolha a conta que você acabou de criar na barra lateral direita (verifique se você escolheu a conta desejada pressionando o ícone de perfil).\\n\\n2. Insira a seed `USER` no campo obrigatório. Adicione os endereços `SUB_OWNER` e `SUB_CONTROLLER` nos campos de créditos de administrador. Se tudo estiver correto, você verá o status de verificação `VERIFIED`.\\n\\n3. Crie uma senha para o novo usuário que você acabou de registrar e confirme a transação, que agora será sem taxa devido à assinatura. Mais tarde, você pode restaurar a senha na guia Restaurar.\\n\\n4. Após o processo de registro, faça login no Home Assistant com o endereço do seu usuário como login e a senha recém-criada.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nAgora você pode usar o dapp para controlar sua casa através do Robonomics, verifique o artigo [**\\\"Obter Telemetria de Casa Inteligente\\\"**](/docs/smart-home-telemetry/).\\n\\n## Solucionando Problemas\\n\\n1. Se você esquecer a senha do Home Assistant da sua conta Robonomics, [verifique o Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nVá para a parte \\\"Your Home Assistant password\\\" e escolha a guia \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"284da962652ee97da154c74bb908df9c\",\"title\":\"Como comprar uma assinatura\",\"path\":\"/docs/pt/get-subscription/\",\"content\":\"\\n**Pagar comissões por transações em blockchain é irritante. Imagine um dispositivo IoT que envia telemetria a cada 5-10 minutos. Isso fará com que você pague bastante durante o mês. Uma das principais características da Rede Robonomics é a assinatura do Serviço Web Robonomics (RWS). Pague mensalmente e esqueça o custo da transação! Para informações teóricas, consulte [este](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) artigo.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Preste atenção que este tutorial demonstra a compra de uma assinatura na parachain Robonomics Kusama. Você também pode realizar todos os mesmos passos em seu [nó local](/docs/run-dev-node).\\n\\n  Mais uma coisa antes de começar. Esta é uma forma \\\"difícil\\\" de comprar uma assinatura. Existe uma forma convencional de fazer isso através do [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Dar um lance em um leilão\\n\\nAs assinaturas na Robonomics são vendidas com um modelo de leilão. Para obter uma, você precisa dar um lance em um leilão e vencê-lo (não se preocupe, é rápido).\\n\\nEm `Developer/Chain state`, você pode ver os leilões disponíveis. \\nEscolha `rws` e `auctionQueue` e pressione o botão `+`, você verá os IDs dos leilões disponíveis:\\n\\n![queue](../images/rws/queue.png)\\n\\nVocê pode ver informações sobre qualquer assinatura com `rws` `auction` e o ID do leilão (o ID do leilão na imagem é 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nNas informações sobre o leilão, você pode ver o campo `winner`, no momento ele está `null`, então ninguém possui essa assinatura e você pode obtê-la. Para isso, vá para `Developer/Extrinsic`, escolha sua conta e `rws -> bid`. Também defina o ID do leilão (79) e a quantidade de unidades para dar um lance (mais de 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nEnvie a transação e verifique as informações sobre o leilão com o ID 79 (em `Chain state`, escolha `rws -> auction` e ID 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nAgora, no campo `winner`, você verá o endereço da sua conta, o que significa que essa conta possui a assinatura 79. Um leilão começa com o primeiro lance e dura alguns blocos, então se alguém der mais tokens do que você nos próximos blocos, essa pessoa será a vencedora e ficará com a assinatura.\\n\\nAgora você pode adicionar dispositivos. Dispositivos são contas que podem usar essa assinatura e enviar extrínsecos sem taxa.\\nPara testá-lo, crie uma nova conta sem tokens e adicione-a aos dispositivos. \\n\\nPara adicionar dispositivos, escolha `rws -> setDevices` em `Developer/Extrinsic`. Em seguida, pressione o botão `Add Item` e escolha a conta recentemente criada sem tokens:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nEnvie a transação. Agora você pode verificar a lista de dispositivos em `Chain state` com `rws -> devices`. Lá você verá o endereço da sua conta sem tokens. Escolha a conta que comprou a assinatura e pressione `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nAgora você pode tentar [enviar um lançamento](/docs/subscription-launch) extrínseco usando a assinatura.\"}},{\"node\":{\"id\":\"23bc67ff0712b966d135fb7b66a50ef8\",\"title\":\"Começando\",\"path\":\"/docs/pt/getting-started/\",\"content\":\"\\n## O que é Robonomics\\n\\nA plataforma Robonomics fornece ferramentas para trabalhar com a rede de economia de robôs. Robonomics permite que os designers de cidades inteligentes e zonas da indústria 4.0 construam confiança entre os [serviços de robôs autônomos](/docs/glossary#cyber-physical-system), forneçam [acesso direto do usuário via dapp](/docs/glossary#dapp) para encomendar produtos de fábricas autônomas e serviços de redes de sensores urbanos. Isso, por sua vez, nos permitirá implementar um sistema descentralizado que monitora globalmente as atividades de sistemas ciberfísicos.\\n\\nO gráfico a seguir descreve o lugar que o Robonomics ocupa no cenário:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nEncontre mais em [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Início rápido da Rede Robonomics\\n**Para a conveniência dos recém-chegados, os desenvolvedores principais do Robonomics criaram uma [curva de aprendizado de 6 lições](/docs/wschool2021-intro/)!**\\n\\nVocê explorará a arquitetura de IoT sem servidor! Robonomics Web Services (RWS) é o serviço infraestrutural básico para Robótica e IoT em cima de Polkadot && IPFS.\\n\\nOs graduados do curso podem lançar uma cadeia de relés local e controlar um dispositivo compatível com ROS por meio de transações entre cadeias.\\n\\n**[Junte-se ao Discord dos Desenvolvedores do Robonomics](https://discord.gg/jTxqGeF5Qy) para se conectar com a comunidade e obter suporte técnico.**\\n\\n### Benefícios para os graduados da Academia Robonomics\\n- Estágio para os melhores alunos   Torne-se um membro da equipe Robonomics e contribua para o desenvolvimento do produto escolhido.\\n- Comunidade ativa && eventos regulares   Faça parte da comunidade de aprendizes, discuta seus casos de uso com especialistas do setor. Junte-se e participe de hackathons!\\n- Certificado de conclusão   Adicione um certificado de conclusão do curso de construção de DAPPs para IoT ao seu portfólio.\\n- Assistência na admissão à universidade ITMO. Seja você um bacharel ou mestre, você receberá assistência em sua admissão na universidade.\\n- Oportunidades de financiamento && aceleração: 1)Candidate-se a uma bolsa de apoio acadêmico de até $50.000; 2)Participe do programa de aceleração Robonomics builders apoiado pela Web3 Foundation; 3)Implante seu DAPP independente em cima do Robonomics; 4)Monetize-o && obtenha suporte de marketing da equipe Robonomics.\\n\\n\\n## O que a documentação contém\\n\\n### Sou um desenvolvedor de Dapp\\n\\n- [Robonomics-js no GitHub](https://github.com/airalab/robonomics-js) - SDK simples em Javascript para desenvolvedores de dApps da Rede Robonomics.\\n- [Modelo de dApp](https://github.com/airalab/vue-dapp-robonomics-template) - usa Vue.js\\n- [Documentação Wiki](/docs/robonomics-js/)\\n\\n### Sou um engenheiro de robótica\\n\\nConfira a seção de [casos](/docs/iot-sensors-connectivity/) e comece a desenvolver por meio de [exemplos](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"d93f469113b6a9969411bc8aab48e001\",\"title\":\"Configuração e Instalação de Software Gaka-Chu\",\"path\":\"/docs/pt/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**Neste artigo, passaremos por algumas etapas de instalação e lançamento para configurar um robô pintor. Requisitos:**\\n- KUKA KR6 R900 sixx com KRC4 e um SmartPad;\\n- Intel NUC com [ROS melodic](http://wiki.ros.org/melodic/Instalaration/Ubuntu) instalado;\\n- Mesa, tinta, pincel, água.\\n\\n## Instalação de software no KRC4\\nA interface EKI é necessária tanto no KRC4 quanto no NUC. Informações detalhadas sobre como configurá-lo no KRC4 são apresentadas [aqui](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Inicie no controlador do robô.\\n\\n## Instalação de software no NUC\\nCrie um espaço de trabalho catkin:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nBaixe os pacotes ROS. Todos os scripts estão armazenados [aqui](https://github.com/airalab/robot_painter/tree/test_branch). Clone o repositório:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nVocê pode precisar de alguns arquivos de cabeçalho e bibliotecas para que tudo funcione corretamente. Baixe-os:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nAdicione o comando de origem ao arquivo `.bashrc`:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nAté agora. você deve ser capaz de lançar os scripts. Se algo der errado, tente algumas [soluções de problemas](https://github.com/airalab/robot_painter/issues)\\n\\n## Preenchendo constantes\\nEm primeiro lugar, o robô precisa saber a localização e orientação da tela, bem como a posição da lata de tinta. Tudo isso é especificado em `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Vamos dar uma olhada nisso.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nEssas são as constantes da equação do plano que especificam a posição da tela no espaço 3D. Elas devem ser obtidas durante um processo de calibração descrito abaixo. Em seguida, vem a tinta.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nEssas são as coordenadas da lata de tinta. Elas também podem ser especificadas durante a calibração. O tamanho da tela é especificado em\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nVárias outras constantes importantes são armazenadas em `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nSeus nomes dizem tudo, então preencha-os de acordo com a situação.\\n\\n## Calibrando Gaka-Chu\\nO próprio processo de calibração é bastante simples.\\n\\n1) Inicie a interface EKI no KRC4:\\n\\nFaça login no modo 'AUT', ligue os drivers e inicie o script `eki_hw_interface`\\n\\n2) Inicie a interface EKI no NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nDeve exibir logs infinitos.\\n\\n3) Inicie o RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nVocê deve ver o seguinte:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nTente mover o efetuador final e clicar em 'Planejar e Executar'. O robô deve se mover. No SmartPad, vá para **Display -> Actual position** e observe as coordenadas do efetuador final. Coloque uma tela horizontalmente na base do robô. Conecte um pincel no suporte do pincel e mova-o cuidadosamente até que ele toque levemente a tela. Nessa posição, salve as coordenadas do efetuador final. Repita 12-15 vezes. Além disso, salve as coordenadas do centro da tela e da lata de tinta.\\nQuando você tiver um conjunto de coordenadas, use [esses](https://github.com/nakata5321/Matlab_scripts_gaka-chu) scripts do Matlab para resolver as constantes e quaterniões ausentes. Cole-os. Reconstrua seu espaço de trabalho com\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Testando a calibração do Gaka-Chu\\nQuando calibrado, o Gaka-Chu precisa ser testado desenhando as bordas da tela. Para fazer isso, execute cada um em um novo terminal:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nDepois disso, você deve ver um contorno da tela no RViz:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nNo terminal, pressione \\\"S\\\" para realizar o teste. O efetuador final do robô deve se mover acima das bordas da tela e o pincel deve tocar suavemente a tela durante todo o movimento. Se não for assim, tente recalibrar. Se o modelo da tela estiver girado incorretamente, você pode girá-lo alterando o quaternião no Matlab.\\n\\n## Fazendo arte\\nVocê precisa de 6 módulos básicos para fazer tudo funcionar:\\n- Interface EKI;\\n- MOVEit + RViz;\\n- Transmissão de quadros de ambiente;\\n- Serviço de conversão de imagens;\\n- Módulo de desenho de trajetórias;\\n- Gatilho de início.\\n\\nVamos lançá-los um por um.\\n\\n### Interface Eki\\nNo KRC4, inicie `eki_hw_interface`, no NUC em um novo terminal faça:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz e MOVEit\\nVocê precisa de um planejador e uma simulação. Inicie-os com\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Ambiente\\nInforme ao robô onde está a lata de tinta e a tela. Observe que não é necessário iniciar o nó `draw workspace`, o `tf_broadcaster` compartilha o tamanho da tela. Ele apenas não o mostra no RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Processador de imagens\\nTodas as imagens recebidas precisam ser processadas. Inicie o serviço.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nQuando recebe a chamada, ele processa uma imagem com um filtro HP e cria um arquivo rosbag com trajetórias.\\n\\n### Trajetórias desenhadas\\nO script principal aqui é o próprio desenhador de trajetórias. Ele espera pela imagem, chama o serviço TextConverter e desenha a pintura.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Envie ao robô uma imagem para desenhar\\nO robô escuta um tópico específico do ROS onde você precisa passar o caminho para uma imagem desejada. A imagem deve ser quadrada (largura igual à altura) e feita de linhas. Envie o caminho:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nDepois disso, duas janelas aparecem mostrando os contornos e as trilhas. Feche-as e veja Gaka-Chu desenhando. Tome cuidado com a segurança e esteja sempre pronto para pressionar o botão de parada de emergência.\\nQuando Gaka-Chu termina sua arte, você pode enviar outro caminho para a imagem e o pintor repete todo o processo.\\n\"}},{\"node\":{\"id\":\"a68d83e11eda3b49adf552a8eec7f624\",\"title\":\"Conecte um dispositivo Amazon FreeRTOS ao Robonomics por MQTT\",\"path\":\"/docs/pt/freertos-mqtt/\",\"content\":\"\\nAqui está a demonstração de como um microcontrolador executando [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) pode ser conectado à Rede Robonomics via MQTT. Por favor, verifique [este repositório](http://github.com/khssnv/freertos_mqtt_robonomics_example) para o código-fonte do projeto.\\n\\nNós usamos [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) com distribuição FreeRTOS e implementação MQTT fornecida pelo [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) enquanto a Espressif é uma fornecedora do microcontrolador utilizado.\\n\\nTambém há um sensor [PMS-3003](http://www.plantower.com/en/content/?107.html) para fins de demonstração. O sensor mede a presença de material particulado no ar e pode ser usado para estimar a qualidade do ar.\\n\\nA qualidade do ar não é um tópico do artigo, você pode encontrar mais informações sobre isso no site da OMS: [Poluição do ar ambiente (ao ar livre)](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). O objetivo do sistema é publicar as medições do sensor na rede Robonomics da Airalab.\\n\\n## Configuração de Hardware\\n\\nConectamos o pino TXD do PMS3003 ao IO17 do ESP32 DevKitC para transferir as medições por UART.\\nAmbos os dispositivos também requerem energia e um terra comum.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Fluxo de Dados\\n\\nPara enviar as medições do sensor para a rede Robonomics, em nível de firmware, nosso objetivo é obter os dados de um sensor por meio do protocolo de comunicação embarcado que ele suporta (UART no nosso caso) e enviá-los para uma instância AIRA por MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nEm nosso exemplo, usamos a implantação em nuvem do AIRA disponível por meio de um endereço IP público e um nome de domínio atribuído.\\nNa instância AIRA, configuramos o broker MQTT `mosquitto` e nos inscrevemos no tópico `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` para receber mensagens do MQTT.\\n\\nEm seguida, passamos as mensagens para o escritor `robonomics io` por meio de um pipe.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nAgora os dados estão disponíveis na Rede Robonomics e podemos lê-los novamente com o `robonomics io`.\\n\\n## Firmware\\n\\nUsamos o [aplicativo de exemplo ESP-MQTT com transporte TCP](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) como base.\\n\\nApenas modificamos o arquivo `main/app_main.c` para a conexão UART com o sensor, sincronização de tempo SNTP e rotina periódica de publicação MQTT.\\n\\nSe você está tentando repetir o projeto e é o seu primeiro projeto baseado no ESP IDF, siga primeiro o guia de programação do [Espressif ESP-IDF](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) para se familiarizar com as operações de firmware, como configuração, compilação e upload com a ferramenta `idf.py`.\\n\\n### Configuração do Wi-Fi\\n\\nPara se comunicar com a instância AIRA implantada na nuvem, nosso microcontrolador requer uma conexão com a Internet.\\nUsamos o Wi-Fi do ESP32 para isso.\\nA Espressif fornece utilitários para configurar o Wi-Fi embarcado.\\nEm nosso exemplo, usamos um ambiente de desenvolvimento com Ubuntu 20.04 GNU/Linux.\\nPara configurar o Wi-Fi, vamos para a pasta do projeto e executamos a ferramenta de configuração do SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nEm seguida, definimos o SSID e a senha do ponto de acesso Wi-Fi na seção `Example Conectarion Configuração`.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### Configuração do Endpoint MQTT\\n\\nExistem duas coisas a serem configuradas para o MQTT.\\nA primeira é o endereço do broker MQTT.\\nIsso pode ser configurado com a ferramenta de configuração do SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nDefina a `URL do Broker` na seção `Example Configuração`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nA segunda coisa é o tópico MQTT.\\nDefinimos isso no firmware com o prefixo do nome do projeto seguido do endereço MAC do nosso ESP32.\\nIsso nos dá `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` para nosso microchip específico.\\n\\n## Do MQTT para o Robonomics\\n\\nPrimeiro, vamos verificar se recebemos dados por MQTT.\\nPodemos nos inscrever no tópico do broker MQTT Mosquitto para receber as mensagens do dispositivo.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nAqui trazemos o pacote `mosquitto` para o nosso ambiente para usar a utilidade `mosquitto_sub`.\\nEm seguida, nos inscrevemos no tópico definido no firmware.\\nObtemos nossas medições, o que significa que a AIRA recebe dados corretamente por MQTT.\\nAgora vamos encaminhar essas mensagens para a Rede Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nAqui usamos a utilidade `robonomics` para publicar mensagens no canal pubsub `/freertos_mqtt_robonomics_example`.\\nEspecificamos `bootnodes` para garantir pelo menos uma conexão estabelecida.\\n\\nAgora estamos lendo essas mensagens do mesmo canal pubsub.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Recursos originais utilizados\\n\\n* Pinout do ESP32 DevKitC do blog do GoJimmy https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* Estrutura de dados e decodificador PSM3003 do OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Obrigado a todos!**\\n\"}},{\"node\":{\"id\":\"cf3eb9fdd6b65ba5d8d816fb839ab41e\",\"title\":\"Como editar Wiki\",\"path\":\"/docs/pt/edit-wiki/\",\"content\":\"\\n**A Robonomics Wiki é de código aberto. Quaisquer correções são bem-vindas: corrigir erros, erros de digitação, informações não claras ou desatualizadas, tradução para qualquer idioma. Você precisará de uma [GitHub](https://github.com/) conta.**\\n\\n\\n## Como editar\\n\\nSe você precisar editar os documentos da Robonomics Wiki, siga estas etapas\\n\\nAssegure-se de ter [Node.js](https://nodejs.org/en/download/package-manager/) e [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) instalado.\\n\\n### 1. Clonar repositório\\n\\nPrimeiro, você precisa clonar o repositório da wiki:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nVá para o diretório do repositório e execute os seguintes comandos:\\n\\n`usando npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`usando yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Servir localmente (develop, develop-m1)\\n\\nEm seguida, implante o projeto localmente: \\n\\n```\\ngridsome develop\\n```\\n\\n> Se você tiver o erro `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`,, execute o seguinte comando:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Fazer PR\\n\\n[Fazer solicitação de pull](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) para [repositório da wiki](https://github.com/airalab/robonomics-wiki)\\n\\n## Componentes\\n\\n### Asciinema\\nA Robonomics Wiki tem suporte para Asciinema. Para inserir o Asciinema, siga estas instruções:\\n* Importe o componente após o bloco frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* Insira como parágrafo separado `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, onde vid é o ID do asciicast específico\\n\\n> Você pode obter o script do widget para um asciicast específico clicando no link “Embed” na página do asciicast.\\n> Parece assim:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Documentação do Asciinema](https://asciinema.org/docs/embedding)\\n\\nNo exemplo acima, vid é 14.\\n\\n### Código\\n\\nVocê pode adicionar extras úteis ao seu código: \\n\\n`código com botão de cópia`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nou `código com linha adicional`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Propriedades para code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nOs documentos na Robonomics Wiki contêm um bloco frontmatter. Ele deve estar no topo do arquivo Markdown e deve ter a forma de YAML válido entre linhas tracejadas triplas. Entre as linhas tracejadas triplas, você pode definir ou editar as seguintes opções:\\n\\n```YAML\\n---\\ntitle: How to contribute # Título da página, você não precisa duplicá-lo no texto\\ncontributors: [positivecrash] # Principais colaboradores (que cuidam ativamente desta página). Apelido do GitHub necessário, sem nenhum símbolo adicional\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Instalaration\\n    # Ferramentas que foram usadas para testes de tecnologia\\n---\\n```\\n\\n### Grid \\nAjuda a adicionar layout de grade aos elementos:\\n\\n- Use primeiro o componente de wrapper de grade: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- E então use quantos componentes de itens de grade você quiser dentro do wrapper:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Propriedades para robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Imagens\\n\\n#### Como fazer upload \\nFaça o upload da imagem na pasta `/docs/images/url-of-your-doc`\\n* Se a imagem precisar ser localizada, insira todas elas em uma única pasta\\n* Use um apêndice de localidade no nome das imagens se estiver localizado, por exemplo, `image_en.jpg`\\n* Certifique-se de que sua imagem esteja otimizada para a web e, ao mesmo tempo, tenha uma boa aparência\\n\\n#### Como inserir \\n\\nExistem duas maneiras de inserir imagens em seus documentos:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nÉ recomendado inserir imagens com a tag embutida `<robo-wiki-picture>`, no entanto, você também pode usar o modo padrão para arquivos Markdown.\\n\\n</robo-wiki-note>\\n\\n`com legenda`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`ou sem legenda` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`ou imagem simples` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`ou imagem simples com legenda`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`imagem com texto alternativo`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Propriedades para robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Notas e avisos\\nVocê pode adicionar notas e atribuir a elas tipos específicos:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`nota com título`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`nota com conteúdo`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`nota com título e conteúdo`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Propriedades para robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nVocê pode adicionar abas ao documento:\\n\\n- Use o componente de wrapper de abas: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- E então use quantos componentes de itens de aba você quiser dentro do wrapper:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`abas horizontais`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`abas verticais`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`item de aba com borda`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Propriedades para robo-wiki-tabs (wrapper)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Propriedades para robo-wiki-tab (item)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Título com âncoras\\nVocê pode criar títulos personalizados com âncoras e atribuir a eles um valor específico\\n\\n`título com âncora`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nou\\n\\n`título sem âncora`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Propriedades para robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Vídeos\\n\\nExistem duas maneiras de inserir vídeos em seus documentos:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nÉ recomendado inserir vídeos com a tag embutida `<robo-wiki-video>`, no entanto, você também pode usar o modo padrão para arquivos Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nVocê precisa especificar o formato do vídeo\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Propriedades\\n\\n- Se você estiver adicionando um arquivo com tamanho superior a <span style=\\\"color:#af1c1c\\\">10MB</span>, please, upload it on server, not in repo.\\n\\n- Você pode usar qualquer propriedade para [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Formatos aceitáveis - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nVocê pode incorporar qualquer vídeo do YouTube no documento inserindo o link de compartilhamento como um parágrafo separado, sem aspas ou tags adicionais, por exemplo: `https://youtu.be/kQaSwNYHJQ8`\\n\\nNo entanto, se você precisar de reprodução automática, deverá usar um componente especial:\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Propriedades para robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Como editar a navegação da barra lateral\\n\\nSe você precisar editar a navegação da barra lateral da Robonomics Wiki, siga estas etapas:\\n\\n* Editar arquivo `/data/sidebar_docs.yaml`.\\n\\n* Decidir onde colocar seu documento\\n\\n* Use YAML válido para `/data/sidebar_docs.yaml` e confie na estrutura de arquivo existente\\n\\n* **NOTA IMPORTANTE:** se você estiver usando o mesmo documento em diferentes seções/subseções, por exemplo: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Imagem pré-instalada para Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nVERIFIQUE SE ADICIONAR O PARÂMETRO `topic` COMO ESTE: \\n\\n(para que a navegação funcione corretamente)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Imagem pré-instalada para Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## Como adicionar navegação personalizada para documentos\\n\\n* Edite o arquivo `/data/sidebar_docs.yaml`.\\n\\n* Encontre o documento correto e adicione os parâmetros `prev` e `next` assim:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Se você deseja remover completamente a navegação, adicione o parâmetro `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Se você deseja remover apenas a navegação `página anterior` ou `próxima página`, adicione o parâmetro `withoutPrev` ou `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nou\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"efc763ffc7c61fe91a7ea7381846e2cc\",\"title\":\"Receba notificações quando a porta abrir\",\"path\":\"/docs/pt/door-notification/\",\"content\":\"\\nNeste artigo, você irá instalar a integração do bot do Telegram e configurar uma automação, que enviará uma notificação para sua conta do Telegram quando uma porta estiver aberta.\\n\\n## Notificações do Bot do Telegram\\n\\nPrimeiro, você precisa criar um bot pessoal do Telegram. Para isso, vá para o [bot especial do Telegram @BotFather](https://t.me/botfather) e siga as instruções. \\nSalve seu token para acessar a API HTTP.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nMantenha seu token **seguro** e armazene-o **em local seguro**, pois ele pode ser usado por qualquer pessoa para controlar seu bot \\n\\n</robo-wiki-note>\\n\\nO próximo passo é encontrar o seu ***User Chat ID***. Para isso, use o seguinte [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nAgora vamos instalar a integração de \\\"Telegram broadcast\\\". Essa integração enviará mensagens para o seu Telegram.\\n\\nPara a imagem pré-instalada do Robonomics, Docker do Home Assistant ou Home Assistant Core, você precisa editar o `configuration.yaml`. Conecte-se ao seu Raspberry Pi via `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nCole as seguintes linhas no final do arquivo. Insira o seu **bot API key** e **your User Chat ID**. Também crie um nome para o seu serviço de notificação:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Salve a configuração e recarregue o Home Assistant.**\\n\\n\\nComo resultado, no seu serviço do Home Assistant será criado um serviço, que enviará qualquer mensagem para o chat do Telegram com você. \\nVocê pode verificar isso no menu Ferramentas do Desenvolvedor na interface web do Home Assistant. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Notificação de Porta Aberta\\n\\nAgora é hora de criar uma automação. Primeiro, importe o modelo para o seu Home Assistant a partir deste link:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nE crie a automação:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nAgora você receberá uma mensagem do bot do Telegram sempre que a porta estiver aberta.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nVocê pode usar essa automação com qualquer porta/janela em sua casa.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"26c0b1cbbf6010d25ead4fa82837fa89\",\"title\":\"Gêmeos Digitais\",\"path\":\"/docs/pt/digital-twins/\",\"content\":\"  \\n**Imagine ter um dispositivo ou sistema complicado que possui vários módulos para manter e requer algumas contas para usar. Para mantê-los todos em um só lugar ou codificar alguma funcionalidade com contas separadas ou, por exemplo, definir diferentes fontes de dados para diferentes fluxos de informações, o módulo Gêmeo Digital deve ser usado.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Por favor, preste atenção que este e os seguintes tutoriais são demonstrados em uma instância local do Robonomics Node. Configure o seu com [estas instruções](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Visão geral da teoria\\nQualquer conta pode criar e gerenciar um Gêmeo Digital. O Gêmeo pode ser imaginado como uma espécie de tabela com o seguinte conteúdo:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nOnde:\\n* **DT id** é um índice de Gêmeo Digital único e não assinado.\\n* **Topic name** é um dado hex `H256` ou ASCII de comprimento de 32 bytes, o mesmo que [`Lançamento`](/docs/launch) parâmetro extrínseco. \\nPor exemplo: `0x1234....FF` ou `hello.parachain.robonomics.world`.\\n* **Source** - é algum endereço de conta.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Como discutido anteriormente na visão geral do extrínseco de lançamento, o `H256` pode ser representado como um CID IPFS codificado (consulte a\\n  [ferramenta Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) para isso).\\n  Portanto, os tópicos podem ser usados como algum armazenamento de dados também, digamos, uma descrição do módulo de um Gêmeo.\\n\\n</robo-wiki-note>\\n\\n\\n## Criar Gêmeo Digital\\n\\n### 1. Navegue até Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Escolha digitalTwin -> create na lista suspensa de possíveis extrínsecos\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nEnvie a transação. Aqui, nenhum parâmetro é necessário para criar um Gêmeo. Ele receberá um índice e apenas o proprietário do Gêmeo Digital poderá adicionar/modificar tópicos do Gêmeo a partir de agora.\\n\\nO ID do Gêmeo pode ser encontrado na página de visão geral do Explorador.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Adicionar Tópico\\n\\n### Escolha digitalTwin -> setSource na lista suspensa de possíveis extrínsecos\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID, obtido na página do Explorer.\\n* `topic` - nome do tópico `H256` discutido anteriormente. Nesta imagem, é uma string de 32 símbolos.\\n* `source` - endereço da conta a ser associada ao tópico.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Atenção que o tópico pode ser sobrescrito com outro endereço de origem, se necessário.\\n\\n</robo-wiki-note>\\n\\nAssine e envie o extrínseco.\\n\\n## Explore\\n\\nVocê pode encontrar todas as informações sobre os Gêmeos Digitais existentes no módulo de armazenamento `digitalTwin` do estado da cadeia em `Developer -> Chain state`.\\n\\n- Número total de Gêmeos - `total()`;\\n- Proprietário do Gêmeo Digital - `owner(u32)`;\\n- Informações sobre os tópicos de um Gêmeo Digital - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"c1b69c58e8bf662925d4dd40b5e63ed3\",\"title\":\"Criar identidade digital executada pelo Ethereum\",\"path\":\"/docs/pt/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nUm dos serviços da Robonomics é [Registro de Passaporte Digital](https://dapp.robonomics.network/#/passport/) para dados arbitrários. O serviço permite que você crie uma identidade digital salvando os hashes dos dados na blockchain pública e atribuindo um endereço único.\\n\\nVocê pode encontrar o serviço de \\\"Registro de passaporte digital\\\" em [Robonomics DApp](https://dapp.robonomics.network/) na seção \\\"Serviços\\\" ou apenas siga este [link direto](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Vídeo explicativo\\n\\nO seguinte vídeo mostra o progresso do registro do Whitepaper da Robonomics:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Passo a passo em imagens\\n\\n### 1. Abra o serviço\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Adicione as informações e arquivos necessários\\n\\nPor favor, note que é possível adicionar várias imagens.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Assine a demanda\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Aprovar tokens\\n\\nO serviço cobra uma pequena taxa. Mas primeiro você deve aprovar a quantidade necessária de tokens a serem gastos da sua conta.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Aceite a oferta e assine a mensagem novamente\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Dê uma olhada no passaporte criado\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nO processo de registro leva algum tempo. No final, você verá um link para a identidade criada.\\n\"}},{\"node\":{\"id\":\"33971223744aa9b48582a500ba8022b8\",\"title\":\"Datalog\",\"path\":\"/docs/pt/datalog/\",\"content\":\"\\n**Now that you have some funds on your account you can submit extrinsics. The first to try is a Datalog. It allows you  to store data in the blockchain persistently. Imagine a distributed and crypto-protected storage for your data and this is it!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nPor favor, preste atenção que este e os seguintes tutoriais são demonstrados em uma instância local do Robonomics Node. Configure o seu com [estas instruções](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navegue até Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Escolha datalog -> record na lista suspensa de extrínsecos possíveis\\n\\nTambém escolha uma conta com a qual você deseja enviar o extrínseco. Preencha o campo de registro.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog suporta uma string com um máximo de 512 bytes. Para armazenar uma grande quantidade de dados, pode-se usar [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Envie a transação\\n\\nAssine e envie a transação com uma conta criada anteriormente usando a extensão ou o DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  Você também pode apagar **TODOS** os seus registros com *datalog -> erase* call.\\n\\n</robo-wiki-note>\\n\\n## 4. Revise o seu datalog no armazenamento\\n\\nPara isso, navegue até *Developer -> Chain state*, selecione *datalog -> datalogIndex*, especifique sua conta e pressione o \\n\\\"+\\\" botão para obter os índices dos registros da sua conta e, em seguida, explore o que você precisa com *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Explorarr\\\">\\n\\n  Todos os eventos, incluindo o registro do datalog, podem ser vistos no fluxo de eventos no *Explorer*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"5122fd9ba5a1c23f16059940c6082eda\",\"title\":\"Criar conta para Robonomics Parachain\",\"path\":\"/docs/pt/create-account-in-dapp/\",\"content\":\"\\n**Para interagir e operar com Robonomics Parachain, desenvolvedores e usuários precisam criar uma conta no Portal Polkadot/Substrate. A conta executa funções básicas para a rede: seu endereço de rede pública (a chave pública), o controle de acesso ao endereço e aos fundos (a chave privada), enviando transações para a rede, mostrando seus tokens e sua quantidade, etc. duas maneiras principais de criar uma conta no Robonomics Parachain.**\\n\\n## 1. Usando a Extensão do Navegador Polkadot{.js}\\n\\nA Extensão Polkadot fornece um mecanismo para gerar a conta e interagir com todos os projetos Polkadot / Kusama, incluindo Robonomics Parachain. Esta não é a maneira mais segura de gerenciar sua conta, mas é a mais conveniente em termos de equilíbrio entre segurança / usabilidade.\\n\\n## 1.1. Instalar a Extensão do Navegador\\n\\nA extensão do navegador está disponível para [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) and [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (além de navegadores baseados em Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Abrir o Aplicativo Robonomics Parachain\\n\\nVá para [Aplicativo Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) no Portal Polkadot / Substrate. Se esta for a primeira vez que você entra no portal, ele solicitará acesso à extensão do navegador, então permita o acesso. \\n\\nDepois de abrir o aplicativo, dê uma olhada no canto superior esquerdo. Lá são exibidos o nome da rede, seu ícone e o número do último bloco. Clicar nesta área abrirá uma lista de todas as redes Polkadot/Kusama, incluindo redes de teste e nós locais. Você pode alternar entre redes selecionando a desejada e pressionando o botão `Switch`. **Certifique-se de estar conectado ao Robonomics Parachain agora**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Atualizar Metadados da Extensão\\n\\nÉ muito provável que o aplicativo solicite que você atualize os metadados da extensão para exibir as informações corretas sobre a cadeia à qual você está conectado. Vá para **Settings -> Metadata**, press `Update metadata` botão e, em seguida, na janela pop-up, permita que a extensão faça isso. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Criar Conta na Extensão\\n\\nAbra a extensão do navegador Polkadot{.js}. Clique no grande botão de adição ou selecione `Create new account` no pequeno ícone de adição no canto superior direito. Você deverá ver o seguinte menu, com uma semente mnemônica gerada na forma de doze palavras e o endereço. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nA semente é a chave para a conta. Saber a semente permite que você (ou qualquer outra pessoa que saiba a semente) controle essa conta e até mesmo a recrie, caso esqueça a senha. **É muito importante armazená-la em um local seguro**, preferencialmente em papel ou outro dispositivo não digital, não em armazenamento digital ou em um computador. \\n\\nSalve a semente e pressione `Next step`. Você deve ver o seguinte menu.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* permite que você escolha em qual das redes esta conta será usada exclusivamente. Você pode usar o mesmo endereço em várias redes, no entanto, por motivos de privacidade, é recomendável que você crie um novo endereço para cada rede que você usa. \\nSelecione a rede Robonomics na lista suspensa. Se você não conseguiu encontrar a rede Robonomics, provavelmente você não atualizou os metadados, volte e faça isso.\\n\\n    - Você notará que o formato do endereço e o ícone da conta mudarão - isso é normal. Os formatos de rede diferentes são apenas outras representações da mesma chave pública. \\n\\n- *Name* é apenas o nome da conta para seu uso exclusivo. Ele não é armazenado no blockchain e não será visível para outros usuários. \\n\\n- *Password* é usado para criptografar as informações da sua conta. Você precisará digitá-lo novamente ao assinar transações no portal. Crie um e lembre-se dele.\\n\\nComo resultado, após criar uma conta, você a verá na lista de contas na extensão Polkadot{.js}. Clicando em três pontos, você pode renomear a conta, exportá-la, removê-la da extensão e alterar a rede usada para a conta. \\n\\nAlém disso, a conta aparecerá no menu **Accounts -> Accounts** do portal, onde será notado que foi injetada utilizando a extensão.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Diretamente no aplicativo Robonomics Parachain\\n\\nVocê pode usar a interface do usuário no Portal Polkadot / Substrate para criar uma conta. Ela pode ser usada para desenvolvimento e testes. \\n\\n## 2.1. Abra o aplicativo Robonomics Parachain\\n\\nVá para [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) no Portal Polkadot / Substrate. **Verifique no canto superior esquerdo se você está conectado ao Robonomics Parachain**.  \\n\\nVá para **Accounts -> Accounts** e pressione o botão `Add account`.\\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Criar Conta\\n\\nVocê deve ver o seguinte menu pop-up com a semente da conta. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nTem duas formas: *Mnemonic* (legível por humanos) e *Raw* (uma sequência de dígitos e letras). Guarde a frase-semente de forma segura e pressione `Next`.\\n\\n> Também é possível alterar o tipo de criptografia para criar uma conta, para isso abra `Advanced creation options` e escolha o tipo (`ed25519` na imagem).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nNo próximo menu, você precisa definir o nome da conta e a senha, semelhante às instruções de extensão descritas acima.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nClicar no botão `Next` irá levá-lo para a última janela. Clique em `Save` para finalizar a criação da conta. Ele também irá gerar arquivos JSON de backup que você deve armazenar com segurança. Você pode usar este arquivo posteriormente para recuperar sua conta, caso se lembre da senha.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Adicionar conta ed25519 à extensão Polkadot\\n\\nVocê pode precisar adicionar a conta criada à extensão Polkadot.js (para contas ed25519, você só pode fazer isso com o arquivo JSON de backup). Para isso, você precisa criar um arquivo de backup da conta. Clique nos três pontos em sua conta e escolha `Create a backup file for this account` e escreva sua senha.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nEm seguida, abra uma extensão e clique no botão `+` no canto superior direito, em seguida, escolha `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nNa janela aberta, solte o arquivo salvo, insira a senha e pressione `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Conta criada com sucesso \\n\\nAgora você pode operar completamente com sua conta recém-criada. Envie e receba tokens, mensagens, escreva datalog e muito mais. Sinta-se à vontade para explorar todos os recursos do aplicativo. Para copiar o endereço da sua conta, basta clicar em seu ícone, o endereço será copiado para a área de transferência. \\n\\nSe você deseja saber mais sobre contas Polkadot / Kusama e outras formas adicionais de criá-las, mais informações podem ser encontradas [aqui](https://wiki.polkadot.network/docs/learn-accounts) e [aqui](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"3d8a5032b37e2826bcfe0ed0a5f122e1\",\"title\":\"Como contribuir para os recursos do Robonomics\",\"path\":\"/docs/pt/contributing/\",\"content\":\"\\nRobonomics Network é um projeto de código aberto e queremos facilitar a contribuição de qualquer pessoa. Você pode criar artigos, sugerir alterações, melhorar a documentação ou realizar testes. Se você quiser contribuir, por favor, abra um novo issue ou crie um pull request no mesmo repositório.\\n\\n## Principais repositórios do Robonomics \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Projeto principal da wiki\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Site principal oficial da Robonomics Network\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Casa para os Serviços Web do Robonomics\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Dapp oficial\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Site oficial da Robonomics Academy\\n\\n### Regras para relatar\\n\\nAo abrir um novo problema, não se esqueça de algumas regras básicas para relatar:\\n\\n1. Escolha o repositório exato para o qual você deseja enviar um problema.\\n\\n2. Se você estiver relatando um bug, verifique se o bug já foi relatado.\\n\\n3. Certifique-se de incluir título e descrição clara, o máximo de informações relevantes possível.\\n\\n4. Por favor, adicione um prefixo ao seu problema com um dos seguintes: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Solicitações de Pull\\n\\nQualquer repositório Robonomics pode estar sujeito a solicitações pull ou alterações por parte dos contribuidores, caso você acredite ter algo valioso para adicionar ou alterar. Por favor, não se esqueça das regras básicas para contribuidores.\\n\\n### Regras para contribuir\\n\\n1. Solicitações de pull são preferidas em relação a problemas, se você tiver correções, especialmente para pequenas alterações como erros de digitação.\\n\\n2. Certifique-se de que a descrição da solicitação de pull descreva claramente o problema e a solução. Inclua o número do problema relevante, se aplicável.\\n\\n3. Por favor, não corrija espaços em branco, formate o código ou faça uma correção puramente estética.\\n\\n4. Por favor, tente aderir ao estilo, linguagem e layout predominantes do Markdown.\\n\\n\\n\"}},{\"node\":{\"id\":\"455921273610fd86656ed3ac8beec23d\",\"title\":\"Conectar sensor\",\"path\":\"/docs/pt/carbon-footprint-sensor/\",\"content\":\"\\nExemplo de trabalho está no vídeo:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Requisitos\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (ou um dos [suportado](https://www.zigbee2mqtt.io/emformation/supported_adapters.html))\\n\\nO serviço está sendo executado no Raspberry Pi e entre em contato com o plugue inteligente via protocolo zigbee.\\n\\n## Zigbee stick\\n\\nSe você tiver o JetHome USB JetStick Z2, ele já possui o firmware necessário, portanto, não é necessário atualizá-lo. Mas se você tiver outro adaptador, primeiro você precisa atualizá-lo com o software zigbee2MQTT. Você pode encontrar instruções para o seu dispositivo [aqui](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nConecte o adaptador e verifique o endereço do adaptador (também pode ser `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nTalvez seja necessário obter acesso à porta USB primeiro. Adicione seu usuário a `dialout` grupo (funciona para o ubuntu, mas o nome do grupo pode ser diferente em outros sistemas operacionais).\\nPara ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nPara arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nEm seguida, faça logout e login ou reinicie o computador.\\n\\n## Instalação\\n\\nClone o repositório:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Configuração\\n\\nVá para `data/configuration.yaml` e defina `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nTambém pode ser necessário preencher os campos `server` and `port` com informações correspondentes. No campo `server` use o IP da `docker0` ponte para estabelecer a conexão: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nAqui seu endereço é `172.17.0.1`.\\n\\nEm seguida, crie o arquivo config/config.yaml com as seguintes informações e defina sua localização (você pode consultar https://countrycode.org/ para o código ISO de 3 letras):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Conectar Plug\\n\\nPrimeira execução:\\n\\n```\\ndocker-compose up     \\n```\\n\\nPara mudar para o modo de emparelhamento no plugue, pressione longamente o botão liga / desliga por alguns segundos até que a luz azul comece a piscar rapidamente.\\n\\nNos logs você deverá ver agora que seu plug começou a ser publicado no mqtt.\\n\\n## Após o emparelhamento\\n\\nSe você não quiser permitir que outros dispositivos se conectem ao seu adaptador, agora você deve ir para `data/configuration.yaml` e definir `permit_join: false`. Reinicie o serviço (use 'Ctrl+C' e\\n\\n```bash\\ndocker-compose up     \\n```\\nmais uma vez para enviar as alterações).\\n\\n## Executando\\nNo primeiro início, a conta para a tomada será criada. \\n> Se você já possui uma conta, você deve adicionar sua semente a `config.config.yaml` farquivo na seção `device_seed` :\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nApós criar a conta, você verá o endereço nos logs (a semente será adicionada a `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nVocê precisa transferir alguns tokens para esta conta para taxas de transação, você pode fazer isso em [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nO serviço verá que você tem tokens suficientes, nos logs você verá:\\n```\\nplug               | Balance is OK\\n```\\nO serviço verá mensagens mqtt da tomada e garantirá o uso seguro de energia. A cada hora (você pode alterar o tempo limite em `config/config.yaml` em `sending_timeout` seção, o tempo limite está em segundos) ele criará um registro de dados com as seguintes informações:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"f490c5ef35d022b8f5f0b2ac215ba756\",\"title\":\"Offsettemg Service\",\"path\":\"/docs/pt/carbon-footprint-service/\",\"content\":\"\\nExemplo de trabalho está no vídeo:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nServiço para compensar a pegada de carbono CO2 queimando tokens na rede Statemine. \\nO CO2 produzido é calculado da seguinte forma: dados do dispositivo em Wh multiplicados pelos coeficientes que dependem da região. 1 tonelada de CO2 é coberta pelo consumo de 1 token. [Aqui](/docs/carbon-footprint-sensor) estão as instruções para conectar o dispositivo.\\n\\n## Cenário\\n\\n1. Registre um novo dispositivo no Digital Twin na rede Robonomics\\n2. Uma vez em um intervalo, obtendo os últimos dados de todos os dispositivos e multiplicando pelo coeficiente dependendo da região\\n3. Somar os dados e convertê-los em toneladas de CO2\\n4. Subtrair o número total de tokens queimados dos dados atuais \\n5. Queimar um número inteiro de tokens na rede Statemine \\n6. Salvar o número total de tokens queimados no banco de dados local e no Datalog \\n\\n\\n## Instalação\\n\\nClone o repositório e edite o arquivo de configuração.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Configuração description\\n\\nNão edite `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network waqui Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nOs coeficientes para energia não renovável foram obtidos do [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) e armazenados em `utils/coefficients.py`. \\n\\n## Lançamento\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"0026e497d5d001cebc80ae9e7e579d86\",\"title\":\"Serviços de Backup\",\"path\":\"/docs/pt/backup-services/\",\"content\":\"\\n**Neste artigo, você aprenderá como gerar backups da configuração do seu Home Assistant e restaurá-la queo necessário. Para criar backups, é chamado um serviço que gera um arquivo seguro com os arquivos de configuração. O serviço também adiciona a configuração do Mosquitto brocker e do Zigbee2MQTT ao backup, se existirem. Em seguida, esse serviço adiciona o arquivo ao IPFS e armazena o CID resultante no Robonomics Digital Twin.**\\n## Criando Backup da Configuração do Home Assistant\\n\\nCriar um backup permite que você restaure facilmente a configuração do seu Home Assistant em caso de falha.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ATENÇÃO\\\">\\n\\nPara fazer backup e restaurar sua configuração, é necessário usar um **gateway IPFS personalizado** como o Pinata. Sem ele, seu backup será armazenado apenas no seu nó IPFS local, o que pode impedir que você restaure a configuração do seu Home Assistant em caso de falha do nó local.\\n\\n</robo-wiki-note>\\n\\n1. Na interface web do Home Assistant, vá para `Developer Tools` -> `Services`. Pesquise por `Robonomics: Save Backup to Robonomics` e pressione oione `CALL SERVICE`.\\n\\n2. Aguarde até ver a notificação `Backup was updated in Robonomics` aparecer em `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ATENÇÃO\\\">\\n\\nNão tente criar um backup ou restaurar a configuração imediatamente após carregar o Home Assistant e a integração Robonomics. Por favor, **aguarde aproximadamente 5 minutos** para permitir a conclusão da configuração inicial.\\n\\n</robo-wiki-note>\\n\\nArgumentos do serviço:\\n- **Backup Completo**  (default: False) - adicionar banco de dados ao backup, para que o histórico dos estados das entidades também seja armazenado.\\n- **Caminho para o arquivo de senha do mosquitto** (default: `/etc/mosquitto`) - Se você usou os métodos de instalação do Home Assistant Core ou Docker e não tem o caminho padrão para o Mosquitto brocker, você deve alterar esse parâmetro. *Não é necessário para o Home Assistant OS ou Supervisor*.\\n\\n## Restaurando a Configuração do Home Assistant a partir do Backup\\n\\nPara restaurar sua configuração, você precisará de um Home Assistant instalado e da integração Robonomics. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ATENÇÃO\\\">\\n\\nPara garantir a restauração bem-sucedida da sua configuração nos métodos de instalação do Home Assistant Core e Docker, você precisa realizar etapas adicionais de configuração conforme descrito no final da página.\\n\\n</robo-wiki-note>\\n\\n1. Instale o Home Assisntant com a integração Robonomics (se ainda não estiver instalado), seguindo as etapas do artigo para o [método de instalação desejado](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-aqui-your-smart-home).\\n\\n2. [Configurar a integração do Robonomics](https://wiki.robonomics.network/docs/robonomics-hass-integration) usando **as mesmas sementes** que você usou na configuração anterior do Robonomics. Se a sua assinatura tiver expirado, [reative-a](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. Na interface web do Home Assistant, vá para `Developer Tools` -> `Services`. Search for `Robonomics: Restore from the Backup in Robonomics` and press `CALL SERVICE`. Acesse a `Overview` Seite, um den Status Ihrer Sicherung zu überprüfen.\\n\\n4. Após a restauração, o Home Assistant reiniciará automaticamente. Se por algum motivo o Home Assistant não reiniciar, você pode verificar o status da restauração monitorando o estado da `robonomics.backup` entidade. Se o status for `restored` você precisará reiniciar manualmente o Home Assistant navegando até `Settings` > `System` e clicando no botão `RESTART` localizado no canto superior direito.\\n\\n5. Se o seu backup incluir a configuração do Zigbee2MQTT ou Mosquitto, você precisará reiniciar esses serviços para habilitar a nova configuração. Você pode fazer isso manualmente reiniciando os serviços individualmente, ou pode simplesmente reiniciar o computador do Home Assistant para garantir que todos os serviços sejam reiniciados.\\n\\nArgumentos de serviço:\\n- **Caminho para o arquivo de senha do mosquito** (default: `/etc/mosquitto`) - Se você usou os métodos de instalação do Home Assistant Core ou Docker e não tem o caminho padrão para o broker Mosquitto, você deve alterar esse parâmetro. *Não é necessário para o Home Assistant OS ou Supervisor*.\\n- **Caminho para a configuração do Zigbee2MQTT**  (default: `/opt/zigbee2mqtt`) - Se você usou os métodos de instalação do Home Assistant Core ou Docker e não tem o caminho padrão para o Zigbee2MQTT, você deve alterar esse parâmetro. *Não é necessário para o Home Assistant OS ou Supervisor*.\\n\\n## Restaurar a Configuração do Mosquitto e Zigbee2MQTT para o Método de Instalação do Home Assistant Core\\n\\nSe o backup incluir a configuração do Mosquitto ou Zigbee2MQTT, durante o processo de restauração, eles serão colocados no caminho padrão ou no caminho especificado nos argumentos. No entanto, se você instalou a integração do Robonomics em um Home Assistant Core existente *(não a partir da imagem pré-instalada do Robonomics)*, `homeassistant` o usuário pode não ter acesso a esse caminho.\\n\\nPortanto, para restaurar a configuração do Mosquitto e Zigbee2MQTT, você precisa conceder as permissões de leitura necessárias ao usuário `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Backup da Configuração do Mosquitto e Zigbee2MQTT para o Método de Instalação do Home Assistant Docker\\n\\nPara fazer backup das configurações do Mosquitto e Zigbee2MQTT de um contêiner Docker, você precisa criar volumes para suas respectivas configurações. Isso pode ser feito executando o seu contêiner do Home Assistant com argumentos adicionais:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nou faça alterações no seu `compose.yaml` arquivo:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nObserve que os caminhos padrão para as configurações do Mosquitto e Zigbee2MQTT são `/etc/mosquitto` and `/opt/zigbee2mqtt`, respectivamente. No entanto, esses caminhos podem variar dependendo da sua configuração específica.\\n\\n</robo-wiki-note>\\n\\n## Botões de Backup\\n\\nAlém de usar serviços para trabalhar com backups, você pode simplificar o processo usando os `botão.create_backup` and `button.restore_from_backup` botões da integração do Robonomics. Esses botões invocam os respectivos serviços com parâmetros padrão (o botão de backup cria um backup sem histórico).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nPara adicionar botões ao seu painel, siga estas etapas:\\n\\n1. Clique nos três pontos no canto superior direito do painel.\\n2. Selecione `Edit Dashboard`.\\n3. Clique no botão `Add Card` no canto inferior direito.\\n4. Escolha oe `Entities` cartão.\\n5. No campo `Entities` pesquise pelas entidades button.create_backup e button.restore_from_backup.\\n6. Pressione `Save` para adicionar as entidades ao cartão.\\n7. Finalize a edição clicando no botão `Done` no canto superior direito.\"}},{\"node\":{\"id\":\"c2b82c80df20a023fdac4789f53c9d2a\",\"title\":\"Adicioneo fundos à sua conta no Portal Robonomics\",\"path\":\"/docs/pt/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Depois de criar com sucesso suas contas no portal Robonomics, é hora de adicionar fundos a elas para que você possa emiciar transações.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nPor favor, preste atenção que este e os seguintes tutoriais são demonstrados em uma instância local do Robonomics Node. Configure a sua com [essas instruções](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navegue até a seção Contas no portal Robonomics \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Escolha a conta da qual você deseja transferir fundos\\n\\nNo modo de desenvolvimento, existem várias contas, com 10000 Unidades de fundos cada, que podem ser usadas para transferir fundos para outras contas criadas na rede de desenvolvimento. Essas contas são indicadas por sinais de chave inglesa <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> ao lado delas.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Clique no botão \\\"enviar\\\" da conta da qual você deseja transferir fundos, por exemplo BOB\\n\\n## 3. Escolha a conta para a qual você deseja transferir fundos\\nApós clicar no botão \\\"enviar\\\", você será solicitado com a \\\"janela de envio de fundos\\\". Na janela solicitada:\\n\\n- Da lista de contas disponíveis, escolha a conta para a qual você deseja enviar fundos.\\n- Digite a quantidade de Unidades que você deseja enviar.\\n- Pressione \\\"fazer transferência\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Autorize a transação\\n\\nApós pressione oionar \\\"fazer transferência\\\" na etapa anterior, você será solicitado com a \\\"janela de autorização de transação\\\".<br/>\\nRevise os detalhes da transação e finalmente clique no botão \\\"assinar e enviar\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nNeste exemplo, transferimos 500 unidades de fundos de \\\"BOB\\\" para \\\"EMPLOYER\\\". Você pode ver que a conta do EMPLOYER, que inicialmente não tinha fundos, agora possui 500 Unidades de fundos.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Certifique-se de ter fundos suficientes nas contas que você deseja usar no playground.**\"}},{\"node\":{\"id\":\"4b26165780893a8d1c9015e9788ffcbc\",\"title\":\"크로스 체인 메시징을 위한 Substrate Cumulus Parachain Testsuite\",\"path\":\"/docs/ko/xcm-robobank/\",\"content\":\"\\n\\n이 프로젝트의 주요 목표는 크로스 체인 메시지를 사용할 때 파라체인 런타임 개발을 간소화하는 것입니다. \\n이는 반복성이 높고 사용이 간단한 통합 테스트와 함께 런타임 코드의 개발을 능하게 합니다.\\n파이썬에서 구성 및 구성된 모든 것을 사용하여 릴레이 체인 + 2개의 파라체인으로 미리 설정된 네트워크 구성을 자동으로 빌드하고 구성하며, 파라체인 간의 메시지 전달 채널을 설정하고 메시징 테스트를 실행하여 메시지를 보내고 런타임에 대한 호출을 사용합니다.\\n\\nXCM Testsuite는 로보뱅크의 생산 주기 테스트에 사용됩니다. 이는 로봇이 외부 파라체인에 등록하고 선결제 주문을 받아들이고 외부 토큰을 사용하여 결제를 받을 수 있게 하는 Substrate 팔렛트의 집합입니다. 이를 통해 로봇은 필요한 모든 인프라를 갖춘 로보노믹스 네트워크 내에서 작동할 수 있지만, 동시에 다른 어떤 파라체인에서도 서비스를 제공할 수 있습니다.\\n\\n예제 비디오는 [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)에서 확인할 수 있습니다.\\n\\n데모 시나리오의 주요 단계는 다음과 같습니다:\\n- 6개의 프로세스 팩에서 릴레이 체인과 두 개의 파라체인 시작\\n- 파라체인 간의 XCM 메시지 채널 설정\\n- 두 파라체인에 로봇 등록\\n- 클라이언트 파라체인에서 이 로봇을 위한 주문 생성(주문 완료를 위한 결제 예약)\\n- Robonomics 파라체인으로 XCM 메시지 전송\\n- Robonomics 파라체인에 \\\"거울\\\" 주문 기록 생성\\n- 로봇이 Robonomics 파라체인에서 주문 수락\\n- 주문 수락에 대한 XCM 메시지를 클라이언트 파라체인으로 다시 전송\\n- 주문 수락(주문 완료 부족에 대한 벌금 수수료 예약)\\n- 로봇이 Robonomics 파라체인에서 주문 완료\\n- 주문 완료에 대한 XCM 메시지를 클라이언트 파라체인으로 전송\\n- 모든 결제 정산(클라이언트 결제는 로봇에게, 사용되지 않은 벌금 수수료도 함께)\\n- 주문1 종료\\n\\n\\n## 상류\\n이 프로젝트는\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\n테스트 중인 런타임 팔렛트의 코드를 포함합니다.\\n원래 노드 코드에서 파라체인의 코드는 \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\" 카탈로그에 있습니다.\\n\\n\\\"substrate-node-template\\\"과의 차이점:\\n- 이 콜레이터 런타임에는 HRMP 핸들러 모듈이 있으며, 형제 파라체인으로부터의 메시지를 처리할 수 있습니다.\\n- 내부 XCM 테스트를 위해 준비된 모의 테스트 런타임\\n\\n## 빌드 및 실행\\n권장(강력히) 설정: \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[참고] 첫 번째 빌드는 최적화되지 않은 기계에서 몇 시간까지 걸릴 수 있습니다.\\n\\n[참고] 스크립트는 릴레이 체인 및 파라체인의 고정 버전(Polkadot(Rococo)의 커밋 해시)과 함께 작동합니다.\\n\\n[참고] 기본적으로 스크립트는 모든 이전 상태를 제거하여 매번 동일한 환경을 재생성합니다. 이 동작은 \\\"config.sh\\\"에서 \\\"PERSISTENT\\\" 매개변수를 사용하여 변경할 수 있습니다.\\n\\n\\n빌드 및 설정 스크립트 실행  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\n\\\"init.sh\\\" 스크립트의 기본 작업:\\n - 구성 읽기(리비전 번호, 초기 노드 키 및 식별자, 체인 데이터 지속성 매개변수 등이 포함된 \\\"config.sh\\\" 파일)\\n - OS 패키지, Rust 및 Python 설정\\n - 릴레이 체인 및 두 개의 파라체인에 대한 별도의 이진 파일 빌드\\n    - 이진 파일은 ./bin 하위 디렉토리에 생성됩니다. \\n - (선택 사항) 모든 체인의 이전 체인 데이터 제거\\n    - \\\"config.sh\\\"에서 \\\"PERSISTENT=1\\\"로 설정된 경우 비활성화됩니다.\\n - 별도의 프로세스로 실행됩니다(별도의 PID 및 I/O 파이프 사용):\\n    - 릴레이 체인의 검증자(안정적인 Rococo 리비전을 실행하는 4개의 검증자)\\n    - 파라체인-100의 콜레이터(개발 중인 첫 번째 파라체인의 단일 콜레이터)\\n    - 파라체인-200의 콜레이터(개발 중인 두 번째 파라체인의 단일 콜레이터)\\n - 모든 체인의 모든 엔드포인트, 포트를 콘솔에 출력하여 프론트엔드 앱(탐색기, DApp)을 사용하여 모든 체인을 연구할 수 있습니다.\\n - 모든 체인의 모든 출력 데이터를 계속해서 콘솔에 출력합니다.\\n\\n[경고] 시작한 후에는 네트워크가 작동하기 시작하고 파라체인이 등록되었는지 확인하기 위해 대기하십시오. 이 프로세스는 약 5분(50개 블록 x 6초) 정도 소요됩니다.\\n\\n## 초기 설정이 작동하는지 확인 \\n\\n표준 Polkdot 프론트엔드 및 생성된 \\\"--ws-port\\\" 엔드포인트를 사용하여 각 노드에 연결합니다.\\n체인을 모니터링하기 위해 [Polkadot 애플리케이션](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)을 엽니다. \\n\\n### 예시:\\n로컬호스트, 4개의 릴레이 체인 검증자, 하나의 파라체인-100 콜레이터, 하나의 파라체인-200 콜레이터:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\n모든 것이 작동하고 합의가 시작되면, 테스트 케이스를 실행할 수 있습니다 (새로운 터미널에서).\\n\\n### UMP 메시지 전달 테스트\\n```bash\\n./scripts/init.sh ump\\n```\\n`parachain-100`에서 `Balance.transfer` 메시지를 생성하고 릴레이 체인으로 전달합니다.\\n릴레이 체인이 메시지를 받으면 `para 100` 계정에서 15 토큰을 Charlie 계정으로 이체합니다.\\n\\n\\n### HRMP 메시지 전달 테스트\\n```bash\\n./scripts/init.sh ump\\n```\\n\\n`parachain-100`에서 `Balance.transfer` 메시지를 생성하고 `sibling 200`으로 전달합니다.\\n그 전에, `subl 100` 계정에 1000 토큰을 할당하고 파라체인 간에 통신 채널을 설정합니다.\\n```bash\\n./scripts/init.sh hrmp\\n```\\n다음 메시지는 `hrmpm` 하위 명령을 실행하여 전송할 수 있습니다. 채널을 생성하지 않으므로 더 빠르게 실행됩니다.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### 추가 옵션\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## 로컬 테스트넷\\n\\n### 사용자 정의 체인 스펙 생성\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nrococo_local.json을 편집하여 잔액 및 권한 매개변수를 사용자의 것으로 바꿉니다.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\n//Alice//stash의 Polkadot 주소 (sr25519 암호화).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\n//Alice의 Polkadot grandpa 세션 키 (ed25519 암호화).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\n//Alice의 Polkadot 주소 (sr25519 암호화).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nrococo_local.json을 원시 형식으로 변환합니다.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\n새로운 체인 스펙을 사용하려면 ./config/ 디렉토리의 rococo.json 파일을 이 새로운 파일로 대체하고 체인을 다시 실행하십시오.\\n```bash\\n./scripts/init.sh run\\n```\\n코드를 자유롭게 편집할 수 있습니다. 위의 명령은 프로젝트를 다시 빌드하고 콜레이터 노드를 업데이트한 후 시작합니다.\\nCumulus는 여전히 개발 중인 사전 릴리스 소프트웨어입니다.\\n우리는 정 커밋의 polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)을 사용하고 있습니다.\\n\\n더 최신 버전의 소프트웨어를 사용할 수 있습니다. 이를 위해 ./scipt/config.sh의 POLKADOT_COMMIT을\\n `rococo-v1` 브랜치의 최신 커밋으로 변경하고 ./bin/polkadot을 삭제한 다음 실행하십시오. \\n```bash\\n./scripts/init.sh run\\n```\\n\\n콜레이터 프로젝트 종속성 업데이트 \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\n일부 종속성은 새로운 러스트 툴체인 기능을 요구할 수 있습니다. 이 프로젝트는 러스트 `nightly-2021-01-26`을 기반으로 합니다.\\n빌드하기 전에 ./scripts/config.sh에서 러스트 툴체인 버전을 업데이트하십시오.\\n\\n## 파라체인 해킹\\n[외부 팔렛 추가](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - 아마도 \\\"자세히 알아보기\\\"에 있어야 할 것입니다.\\n## Learn More\\n\\n이 프로젝트의 구조, 캡슐화된 기능 및 해당 기능이 구현된 방식에 대해 자세히 알아보려면 상위 [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template)을 참조하십시오. 공식 Polkadot 블로그에서 [파라체인 블록의 경로](https://polkadot.network/the-path-of-a-parachain-block/)에 대해 더 자세히 알아 수 있습니다. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)을 참조하십시오.\\n\"}},{\"node\":{\"id\":\"df9afd12b12b9be2f4e8e2677b34b50c\",\"title\":\"Zigbee2MQTT에 사전 설치된 이미지와 함께 사용되는 Zigbee 어댑터\",\"path\":\"/docs/ko/zigbee-to-mqtt-image/\",\"content\":\"\\n**이 문서에서는 스마트 기기를 페어링합니다.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\n웹 브라우저를 열고 `http://%RASPBERRY_IP_ADDRESS%:8099`로 이동합니다. 라즈베리 파이의 IP 주소는 [Fing 모바일 앱](https://www.fing.com/products) 또는 [nmap CLI 도구](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)를 사용하여 찾을 수 있습니다.\\n\\nZigbee2MQTT의 웹 인터페이스가 표시됩니다:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\n스마트 기기를 연결할 시간입니다. \\n먼저, Zigbee2MQTT의 웹 인터페이스 상단에 있는 `Permit join (All)` 버튼을 누릅니다. \\n\\n그런 다음, 기기를 페어링하기 시작합니다. 기기를 연결 모드로 전환하는 가장 일반적인 방법은 전원 버튼을 길게 누르거나 5번 켜고 끄는 것입니다. Zigbee2MQTT가 실행 중인지 확인하세요.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n기기가 연결되면 웹 인터페이스에서 확인할 수 있습니다:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\n이제 Home Assistant WebUI에서 이 센서를 볼 수 있어야 합니다. `Settings` -> `Devices & Services` -> `Devices`로 이동하세요:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\n모든 센서를 추가한 후에는 Zigbee2MQTT의 웹 인터페이스를 닫을 수 있습니다.\\n\"}},{\"node\":{\"id\":\"40057af871147ab00be40203a554f97e\",\"title\":\"블루프린트 사용 방법\",\"path\":\"/docs/ko/use-blueprints/\",\"content\":\"\\n이 문서에서는 Home Assistant에 자동화 블루프린트를 추가하고 구성하는 방법을 알 수 있습니다.\\n\\n## 블루프린트 자동화\\n\\n일부 블루프린트는 이미 설치되어 있습니다. 이러한 블루프린트를 기반으로 한 자동화는 구성만 해주면 니다. 웹 인터페이스에서는 `Settings/Automations & Scenes`에서 미리 설치된 블루프린트를 찾을 수 있습니다. `Blueprints`를 열고 사용하려는 블루프린트를 찾으세요. 이 예제에서는 `Motion-activated Light`를 사용합니다. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\n`Create Automation`을 클릭하여 자동화 편집기를 엽니다. 이름을 지정하고 사용할 블루프린트를 선택하세요 (우리의 경우 `Motion-activated Light`). 그 후 모션 센서와 램프를 선택해야 합니다. 구성이 완료되면 `Save`을 클릭하세요.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation 구성\\\" />\\n\\n변경 사항을 만들고 싶다면 `Settings/Automations & Scenes`으로 이동한 다음 `Automations`를 찾으세요. \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## 블루프린트 가져오기\\n\\nHome Assistant는 Home Assistant 포럼, GitHub 및 GitHub gists에서 블루프린트를 가져올 수 있습니다. 모든 블루프린트 목록은 [블루프린트 교환](https://community.home-assistant.io/c/blueprints-exchange/53)에서 찾을 수 있습니다. 선택한 후 `Settings/Automations & Scenes`으로 이동하여 `Blueprints`를 엽니다. `Import Blueprint`를 클릭하고 선택한 블루프린트의 URL을 입력하세요. 그런 다음 `PREVIEW BLUEPRINT`를 클릭하세요. 이 경우 [모든 배터리 센서에 대한 저전압 감지 및 알림](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664)를 사용합니다. \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\n이렇게 하면 블루프린트가 로드되고 가져오기 대화 상자에서 미리보기가 표시됩니다. 이름을 변경하고 가져오기를 완료할 수 있습니다. `Create Automation`을 클릭하여 자동화 편집기를 엽니다. 여기에서 자동화 매개변수를 구성하고 알림을 받기 위한 작업을 추가할 수 있습니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"6f2bc01d78533be2f98c69de497b8d92\",\"title\":\"구독으로 시작하는 발사 방법\",\"path\":\"/docs/ko/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  이 튜토리얼은 Robonomics Kusama 파라체인에서 구독을 사용하는 방법을 보여줍니다. [로컬 노드](/docs/run-dev-node)에서도 동일한 단계를 수행할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n활성 구독이 있는 경우 해당 계정의 비밀번호로 설정된 장치는 수료 없이 extrinsic을 보낼 수 있습니다. \\n'launch' 명령을 보내는 방법을 시도해 봅시다.\\n\\n`Developer/Extrinsics` 페이지로 이동한 다음 계정(장치 목록에서 선택한 계정)을 선택하고 `rws -> call(subscriptionId, call)`을 선택합니다. \\n그런 다음 `subscriptionId` 필드에 구독의 소유자 주소(경매에 입찰한 주소)를 붙여 넣고 다음 필드에서 `launch -> launch(robot, param)`을 선택합니다. `robot` 필드에는 `launch` 트랜잭션을 보낼 주소를 입력하고 명령을 삽입합니다 (launch 명령에 대한 설명은 [여기](/docs/launch)를 참조하십시오). 그런 다음 트랜잭션을 제출하십시오:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\n이제 `Network/탐색하기r` 페이지로 이동하면 생성한 두 개의 이벤트인 `rws.NewCall`과 `launch.New실행`이(가) 표시됩니다.\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"293f30b3e00bc2653b5a7d3da64cfde1\",\"title\":\"스마트 홈 텔레메트리 가져오기\",\"path\":\"/docs/ko/smart-home-telemetry/\",\"content\":\"\\n**이 문서에서는 스마트 홈 장치의 텔레메트리를 조회하는 Robonomics 서비스를 사용합니다.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Dapp으로 이동하여 [스마트홈 텔레메트리](https://dapp.robonomics.network/#/smarthome-telemetry) 서비스를 선택하십시오.\\n\\n2. 컨트롤러 필드에 `SUB_CONTROLLER` 주소를 입력하십시오. 데이터를 암호화하기 위해 시드 구문을 삽입하십시오.\\n\\n3. `Get telemetry` 블록에서 드롭다운 목록에서 타임스탬프를 선택하고 `DOWNLOAD TELEMETRY` 버튼을 누르십시오.\\n\\n4. 텔레메트리 다운로드에는 시간이 걸릴 수 있습니다. 완료 후 장치 및 센서에서 정보를 확인할 수 있습니다.\\n\\n\\n<!---\\n## 시작 devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"실행\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\n실행 command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"7e6f70b3ee6d96ef0aa3a56bbe36b3e6\",\"title\":\"구독 활성화\",\"path\":\"/docs/ko/sub-activate/\",\"content\":\"\\n이 문서에서는 Robonomics 파라체인 계정을 생성하고 IoT 구독을 구매하는 방법에 대해 알아볼 것입니다. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nRobonomics를 사용하여 Home Assistant를 제어하려면 Robonomics 파라체인에 2개의 계정이 필요합니다. 하나의 계정(`sub_owner`)에는 Robonomics 독을 구매해야 합니다. 두 번째 계정(`sub_controller`)은 Home Assistant의 모든 프로세스(예: 텔레메트리)를 제어하고 다른 사용자에게 액세스 권한을 부여할 것입니다. 이러한 계정들은 Home Assistant의 보안을 제공할 것입니다. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\n두 계정 모두 **ed25519** 암호화로 생성되어야 합니다. 따라서 Polkadot-JS UI를 사용하여 계정을 생성하고 필요한 암호화를 선택해야 합니다. \\n\\n이 기능은 Polkadot-JS UI에서 기본적으로 비활성화되어 있습니다. 활성화하려면 `Settings` -> `General` -> `account options`로 이동하고 드롭다운 메뉴 `in-browser account creation`에서 `Allow local in-browser account storage`를 선택하십시오.\\n\\n</robo-wiki-note>\\n\\n## 소유자 및 컨트롤러 계정 생성\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. [Robonomics Parachain 앱](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/)으로 이동하여 Polkadot / Substrate Portal에서 엽니다. **왼쪽 상단 모서리를 확인하여 Robonomics Parachain에 연결되었는지 확인하십시오.**\\n\\n2. `Accounts` -> `Accounts`로 이동하고 `Add account` 버튼을 누릅니다. 계정 시드가 포함된 팝업 메뉴가 표시됩니다. 이 시드는 두 가지 형식으로 제공됩니다: *Mnemonic*(인간이 읽을 수 있는 형식)과 *Raw*(숫자와 문자의 연속). \\n\\n3. `Advanced creation options`를 열고 계정 생성의 암호화 유형을 `Edwards - ed25519`로 변경한 후 `Next`를 누릅니다.\\n\\n\\n4. 니모닉 시드 구문을 안전하게 저장하고 `Next`를 누니다.\\n\\n5. 다음 메뉴에서 계정 이름과 비밀번호를 설정해야 합니다. 편의를 위해 `sub_owner`라는 이름을 지정하십시오. `Next`를 누릅니다.\\n\\n6. 마지막 창에서 `Save`를 클릭하여 계정 생성을 완료합니다. 또한 계정을 안전하게 저장할 수 있는 백업 JSON 파일도 생성됩니다. 나중에 비밀번호를 기억한다면 이 파일을 사용하여 계정을 복구할 수 있습니다.\\n\\n7. `sub_controller`라는 이름의 계정에 대해 이러한 단계를 반복합니다.\\n\\n\\n## Polkadot.js에 계정 추가\\n\\n편의를 위해 [Polkadot.js 확장 프로그램](https://polkadot.js.org/extension/)을 사용하여 이러한 새로 생성된 계정을 추가해야 합니다. ed25519 계정의 경우 백업 JSON 파일만 사용할 수 있습니다. 계정을 생성할 때 저장한 파일을 사용할 수 있습니다.\\n\\n계정의 백업 파일을 다시 얻으려면 계정의 세 개의 점을 클릭하고 `Create a backup file for this account`를 선택한 후 비밀번호를 입력하십시오.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. 확장 프로그램을 열고 오른쪽 상단에 있는 `+` 버튼을 누르고 `Restore account from backup JSON file`을 선택합니다.\\n\\n2. 열린 창에서 JSON 파일을 업로드하고 비밀번호를 입력한 후 `Restore`를 누릅니다.\\n\\n3. Polkadot.js 확장 프로그램에서 계정에 대해 Robonomics 네트워크가 선택되었는지 확인하십시오. Polkadot / Substrate Portal에서 `Setting` -> `Metadata`로 이동하고 `Update metadata` 버튼을 클릭하십시오. \\n\\n4. 팝업에서 메타데이터 업데이트를 확인하십시오. 이제 확장 프로그램에서 주소가 사용되는 네트워크의 레이블이 표시됩니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Robonomics 구독 활성화 \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\n이 단계에서는 `sub_owner` 계정에 충분한 양의 XRT 토큰(최소 2-3 XRT)이 있어야 합니다.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. [구독 페이지](https://dapp.robonomics.network/#/subscription)로 이동하여 Robonomics dapp에 접속하고 오른쪽 사이드바에서 계정에 연결 버튼을 누릅니다.\\n\\n2. 팝업 메뉴에서 Polkadot.js 확장 프로그램에 연결합니다. 계정 주소와 잔액이 표시됩니다.\\n\\n3. 구매 전에 `sub_owner` 계정을 선택했는지 확인하십시오. 주소 프로필 아이콘을 누르면 `Check owner account` 필드 아래에 `sub_owner` 계정이 표시되어야 합니다.\\n\\n4. 마지막으로 `SUBMIT` 버튼을 누르고 계정의 비밀번호를 입력한 후 활성화 프로세스가 완료될 때까지 기다리십시오. 잠시 후 구독 상태가 표시됩니다.\\n\\n\\n## 구독에 계정 추가\\n\\n이제 **액세스 목록**에 `sub_controller` 계정을 추가해야 합니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. 확장 프로그램을 열고 계정 이름 옆에 있는 아이콘을 클릭하십시오. 이렇게 하면 계정 주소가 복사됩니다.\\n\\n\\n2. 이 주소를 **Manage access** 부분의 `Robonomics parachain address` 필드에 붙여넣고 이름을 지정한 후 `+` 버튼을 누릅니다. \\n\\n3. `sub_owner` 계정에 대해 단계 1과 2를 반복합니다.\\n\\n4. `Save`를 누릅니다. 팝업 창에서 `sub_owner` 비밀번호를 입력한 후 활성화 프로세스가 완료될 때까지 기다리십시오.\\n\"}},{\"node\":{\"id\":\"2e0a5dda6a44b1747026aab5a26020fb\",\"title\":\"Robonomics SLS 게이트웨이\",\"path\":\"/docs/ko/sls-gateway/\",\"content\":\"\\n**이 문서에서는 Robonomics SLS 게이트웨이를 설정합니다. 게이트웨이에 필요한 소프트웨어를 설치하고 구성하며 Home Assistant에 연결합니다.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## 펌웨어\\n\\n먼저 게이트웨이의 마이크로컨트롤러 펌웨어를 설치해야 합니다. SLS 게이트웨이의 하단 부분에 있는 스위치 `1`과 `3`을 `ON`으로 설정하여 게이트웨이를 준비합니다. 다른 스위치는 `OFF`로 설정해야 합니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\n게이트웨이를 라즈베리 파이에 USB type-C 포트를 통해 연결합니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\n펌웨어가 있는 저장소를 라즈베리 파이에 복제합니다:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\n`robonomics-hass-utils/esp_firmware/linux`로 이동합니다. SLS 게이트웨이를 플래시하려면 `Clear` 및 `Flash_16mb` 스크립트를 실행해야 합니다.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### 문제 해결\\n\\n게이트웨이 펌웨어 업데이트에 문제가 있는 경우 추가 단계를 수행해야 합니다:\\n\\n1. pySerial 모듈이 설치되어 있는지 확인합니다.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. 사용자에게 USB 포트에 대한 액세스 권한을 부여하고 컴퓨터를 재부팅합니다.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. 일부 경우에는 스크립트에서 대역폭 설정을 변경하여 펌웨어를 업데이트해야 합니다. `Flash_16mb.sh` 스크립트를 `nano` 편집기로 열고 baud 매개변수를 `921600`에서 작은 값(예: `115200`)으로 변경합니다.\\n\\n## 구성\\n\\n1. SLS 게이트웨이를 컴퓨터에서 분리합니다. 게이트웨이 뒷면의 스위치를 올바른 위치로 설정합니다. 스위치 `5` (RX Zigbee to ESP)와 `6` (TX Zigbee to ESP)는 `ON` 위치에 있어야 하며, 다른 스위치는 `OFF`로 설정해야 합니다. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. type-C 전원 케이블을 연결합니다. 중앙의 표시등이 녹색으로 켜집니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. 처음 시작할 때 게이트웨이는 SSID `zgw****`로 Wi-Fi를 공유합니다. 이 네트워크에 연결합니다. 신호가 상당히 약할 수 있으므로 SLS 게이트웨이를 컴퓨터에 가까이 두는 것이 좋습니다. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. 연결이 성공하면 웹 인터페이스가 열립니다(또는 192.168.1.1 주소에서 찾을 수 있습니다). \\n\\n5. `Wi-Fi Settings` 페이지가 표시됩니다. Wi-Fi를 선택하고 암호를 입력합니다. `Apply` 버튼을 누릅니다. 게이트웨이가 재시작되고 Wi-Fi 네트워크에 연결됩니다. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. SLS 게이트웨이의 로컬 IP를 찾아 웹 인터페이스에 액세스합니다. [Fing 모바일 앱](https://www.fing.com/products) 또는 [nmap CLI 도구](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)를 사용하여 찾을 수 있습니다. 게이트웨이 이름은 `zgw****`와 같아야 합니다. 게이트웨이 IP를 브라우저에 붙여넣어 게이트웨이의 웹 인터페이스를 엽니다.\\n\\n7. `Setting` -> `Hardware`로 이동하여 설정이 이미지와 같은지 확인합니다. 필요한 경우 설정을 수정하고 `Save` 버튼을 클릭합니다:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\n필요한 값이 있는 테이블:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. 그런 다음 게이트이를 재부팅합니다. 오른쪽 상단 모서리에서 `Actions` -> `Reboot system`을 선택합니다.\\n\\n9. Zigbee 정보 창에서 게이트웨이가 올바르게 작동하는지 확인합니다. DeviceState는 `OK`여야 합니다.\\n\\n10. Home Assistant에 장치를 자동으로 추가하도록 구성합니다. `Zigbee` -> `Config`로 이동한 다음 `Home Assistant MQTT Discovery`와 `Clear States`를 선택합니다. 변경 사항을 저장하고 다시 **재부팅**합니다 SLS 게이트웨이.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n이미 활성화된 SLS 게이트웨이가 있는 경우 새로운 게이트웨이와 충돌할 수 있습니다. 이 문제를 해결하려면 새 장치의 채널을 변경해야 합니다. `Zigbee` -> `Config`로 이동하여 채널을 다른 채널로 변경합니다(예: 채널 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## SLS를 MQTT에 페어링\\n\\nSLS 게이트웨이를 구성한 후 SLS 게이트웨이를 Home Assistant에 연결해야 합니다. SLS 게이트웨이 웹 인터페이스를 열고 `Settings/Link` -> `MQTT Setup`로 이동합니다:\\n\\n\\n브로커 주소(로컬 네트워크의 Home Assistant가 있는 Raspberry Pi의 주소, [Fing 모바일 앱](https://www.fing.com/products) 또는 [nmap CLI 도구](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)를 사용하여 찾을 수 있음), 포트(기본값은 `1883`), 브로커 사용 이름 및 암호(이전에 생성한 것) 및 토픽 이름(임의로 선택 가능)을 추가합니다. 또한 Raspberry Pi IP 주소는 정적이어야 합니다. `Enable` 및 `Retain states`를 클릭합니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\n변경 사항을 저장합니다. 이제 장치가 자동으로 Home Assistant에 표시됩니다.\\n\\n## 장치 연결\\n\\n장치를 연결하려면 `Zigbee` -> `Join`으로 이동하세요. 센서를 페어링 모드로 설정하십시오. 장치를 연결 모드로 전환하는 가장 일반적인 방법은 전원 버튼을 길게 누르거나 5번 켜고 끄는 것입니다. `Enable Join` 버튼을 눌러 Zigbee 장치를 검색을 시작하세요. 성 센서를 확인할 수 있습니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\n이제 [**IoT Subscription**](/docs/sub-activate) 섹션으로 이동하여 Robonomics 구독을 활성화할 수 있습니다.\\n\"}},{\"node\":{\"id\":\"1c4d07cd6e236358375137ee4201b25e\",\"title\":\"분산 센서 네트워크\",\"path\":\"/docs/ko/sensors-network-introduction/\",\"content\":\"\\n분산 센서 네트워크에 대한 기사는 Robonomics Academy로 이전되었습니다: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"55922fa125b2d792e70714d6d7391917\",\"title\":\"클라우드 AI를 공장 바닥에 안전하게 연결합니다\",\"path\":\"/docs/ko/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\n로보노믹스 기술은 이미 4차 산업혁명이 직면한 문제를 해결할 수 있으며, 이미 산업 환경에서 실제 시나리오에 적용되고 있습니다.\\n\\n대부분의 AI 기업들은 공장 바닥의 프로세스를 최적화하기 위한 솔루션을 구축하고 있으며, 이를 통해 공장은 더 적은 비용으로 더 많은 생산을 할 수 있습니다. 그러나 대부분의 공장은 인프라를 클라우드에 직접 연결하는 것에 주저하고 있습니다. 이는 잠재적인 사이버 보안 위험으로 이어질 수 있으며, 수백만 달러의 손실과 심지어 인명 피해로 이어질 수 있습니다.\\n\\n[MerkleBot](https://merklebot.com)은 [Robonomics Network](https://robonomics.network)을 사용하여 공장을 클라우드 기반 AI에 안전하게 연결하는 솔루션을 구축했습니다.\\n\\n본 문서는 [Veracity Protocol](https://www.veracityprotocol.org/)과의 실험을 통해 작성되었으며, 이는 모바일 기기의 사진을 기반으로 물리적인 항목의 비침입적인 보호를 생성하는 알고리즘을 사용합니다.\\n\\n이 사용 사례에서는 로봇 팔을 사용하여 산업 부품을 스캔하는 과정을 보여줍니다.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## 단계별 프로세스\\n\\n### DApp은 사용자 인터페이스로 작동합니다\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp은 운영자를 위한 사용자 인터페이스로 작동합니다. 로봇의 실행을 요청하고 공장 환경과 클라우드 기반 AI 간의 안전한 통신을 허용하는 데 사용됩니다.\\n\\n### 로봇 실행\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\n운영자는 DApp에서 트랜잭션에 서명하여 로봇 스캔을 시작합니다. 이 단계는 공개 블록체인의 트랜잭션을 기반으로 공장 바닥의 프로세스가 시작될 수 있도록 보장합니다.\\n\\n로봇은 Robonomics Network를 통해 블록체인으로부터 명령을 받고 스캔을 시작합니다. Robonomics Network 기술을 통해 비즈니스 목표와 로봇 운영 간의 격차를 줄일 수 있습니다.\\n\\n### 데이터 수집 및 클라우드 기반 AI로의 전송\\n\\nDApp에서 운영자는 확인을 보고 로봇이 테이블에 배치된 항목을 스캔하기 시작합니다. 이와 같은 사용 사례에서는 공장 라인에 직접 배치될 수도 있습니다.\\n\\n<!-- ![](../images/Veracity_Protocol_실행.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_실행.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\n로봇이 데이터를 수집하면 로컬에 저장하고 IPFS 프로토콜을 통해 클라우드 기반 AI에 제합니다. 데이터를 암호화하고 블록체인 트랜잭션을 통해 데이터 교환을 조직함으로써 클라우드 기반 AI에 대한 액세스를 승인하면서 데이터가 안전하고 그대로 유지되도록 할 수 있습니다.\\n\\n공공 블록체인의 공유 보안을 기반으로 한 Robonomics에 내장된 보안 메커니즘을 통해 대부분의 공장이 직접 구축하기 어려운 수준의 보안을 확보할 수 있습니다.\\n\\n### 디지털 패스포트 생성\\n\\n클라우드 기반 AI가 데이터를 분석하면 로그 파일과 권장 사항이 자동으로 [디지털 패스포트](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/)로 기록됩니다. 블록체인 레코드는 IPFS 프로토콜을 통해 이러한 파일들에 대한 해시를 가지고 있으므로 모든 작업과 스캔을 추적할 수 있습니다.\\n\\n## 사용 사례에 대한 의견\\n\\n이 사용 사례에서는 Universal Robot UR3 산업 로봇 팔이 사용되었습니다. 그러나 ROS를 지원하는 Robonomics 덕분에 KUKA, Fanuc 및 Yaskawa를 포함한 대부분의 주요 산업 조작기를 안전하게 클라우드 기반 AI에 연결하여 사용할 수 있습니다.\\n\\n클라우드 기반 AI 도구의 배포 및 통합에 대해 더 자세히 알고 싶다면 [문의](mailto:v@merklebot.com)주세요.\\n\"}},{\"node\":{\"id\":\"2ee364fa84509943238dc776c549a49f\",\"title\":\"홈 어시스턴트에 SDS011 센서를 추가하는 방법\",\"path\":\"/docs/ko/sds-sensor-hass/\",\"content\":\"\\n이 문서에서는 SDS 공기 품질 센서를 [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) 및 [Robonomics](https://github.com/airalab/sensors-software) 펌웨어와 홈 어시스턴트에 연결하는 방법을 설명합니다.\\n\\n## 설치 \\n두 가지 설치 옵션이 있습니다.\\n\\n### 옵션 1: HACS\\n\\n로컬 Luftdaten 센서를 추가하는 가장 쉬운 방법은 HACS를 통해 설치하는 것입니다. [여기](https://hacs.xyz/docs/setup/download/)에서 HACS를 설정하는 방법에 대한 간단한 설명을 찾을 수 있습니다.\\n\\nHACS가 설치되면 HACS -> 통합으로 이동하여 `Local Luftdaten Sensor` 통합을 검색합니다. 다운로드 버튼을 클릭하고 통합이 다운로드된 후 Home Assistant를 다시 시작합니다.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### 옵션 2: 수동 설치\\n\\nhomeassistant 사용자로 프로젝트 저장소를 복제합니다.\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\n이미 사용자 정의 통합이 있는 경우 `custom_components/local_luftdaten/`를 `custom_components` 디렉토리로 복사합니다. 예를 들어,\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\n사용자 정의 통합이 없는 경우 전체 `custom_components` 디렉토리를 Home Assistant 구성 디렉토리로 복사합니다. 예를 들어,\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## 구성\\n\\n`configuration.yaml`에 새로운 센서 항목을 만들고 호스트 이름 또는 IP 주소를 조정합니다. 센서의 로컬 IP 주소를 찾으려면 [Fing 모바일 앱](https://www.fing.com/products) 또는 [nmap CLI 도구](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)를 사용할 수 있습니다. 이름은 아무거나 지정할 수 있습니다.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> 지원되는 모든 센서 록은 [저장소](https://github.com/lichtteil/local_luftdaten)에서 찾을 수 있습니다.\\n\\n홈 어시스턴트를 다시 시작합니다.\\n그 후 대시보드에 센서를 추가할 수 있습니다. 엔티티의 이름은 `configuration.yaml`에 추가한 이름이 됩니다.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"ada24b3cb4e1b09e99c2e50f9e8636e5\",\"title\":\"SDS011 센서 연결 방법\",\"path\":\"/docs/ko/sds-sensor-connect/\",\"content\":\"\\n** 로보노믹스 센서 네트워크에 센서를 연결하는 방법에 대한 단계별 안내서입니다. 저희 센서는 sensor.community 펌웨어의 향상된 버전인 로보노믹스 펌웨어를 사용합니다. 추가적인 센서가 포함되어 있으며 수정된 데이터 전송 메커니즘을 갖고 있습니다. **\\n\\n1. 센서를 소켓에 연결하여 전원을 공급합니다.\\n2. 보드는 `RobonomicsSensor-xxxxxxxxx`라는 Wi-Fi 네트워크를 생성합니다. 휴대폰이나 컴퓨터에서 해당 네트워크에 연결하세요. 인증 창이 표시됩니다 (표시되지 않으면 브라우저를 열고 `192.168.4.1`로 이동하세요).\\n3. 목록에서 Wi-Fi 네트워크를 선택하거나 목록에 없는 경우 직접 입력하고 암호 필드를 작성하세요.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\n센서는 2.4GHz Wi-Fi 네트워크에만 연결할 수 있습니다.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. 센서를 설치할 위치의 좌표를 작성하세요. 지도에서 얻을 수 있거나 [이 링크](https://www.latlong.net/convert-address-to-lat-long.html)를 사용하여 주소에서 얻을 수 있습니다.\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n센서 좌표는 공개적으로 사용 가능한 지도에 표시됩니다. 개인 정보를 공개하지 않으려면 정확하지 않은 좌표를 작성하세요.\\n</robo-wiki-note> \\n5. `Save configuration and restart`을 클릭하세요. 보드가 재부팅되고 지정된 Wi-Fi 네트워크에 연결됩니다.\\n6. [로보노믹스 센서 맵](https://sensors.robonomics.network/#/)을 열고 센서를 설치한 위치를 찾으세요. 몇 분 후에 지도에서 데이터와 함께 센서를 확인할 수 있습니다.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"9801283fe80ea3f02e312a739538c24a\",\"title\":\"로보노믹스 Dev 노드 실행 방법\",\"path\":\"/docs/ko/run-dev-node/\",\"content\":\"\\n**로보노믹스에서 애플리케이션을 테스트하려면 개발 모드에서 실행해야 할 수도 있습니다. 이 문서에서는 단계별로\\n로보노믹스의 로컬 테스트 인스턴스를 얻는 방법에 대한 지침을 제공합니다.**\\n\\n\\n## 노드 이진 일 가져오기\\n\\n1. 먼저 이진 파일이 필요합니다. 최신 [릴리스](https://github.com/airalab/robonomics/releases)에서 아카이브를 다운로드하세요.\\n\\n2. 아카이브 폴더로 이동하여 이진 파일을 압축 해제하고 권한을 변경하세요.\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## 실행\\n\\n다음 명령으로 노드를 실행하세요:\\n\\n```bash\\n./robonomics --dev\\n```\\n다음 출력이 표시됩니다:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  기존 블록을 삭제하려면 `/tmp/substrate******/chains/dev/db/full`에서 RocksDB를 제거할 수 있습니다.\\n  로그에서 표시된 해당 식별자로 `******`를 대체하세요.\\n\\n  매번 처음부터 노드를 시작하려면 `--tmp` 플래그를 사용하세요.\\n\\n</robo-wiki-note>\\n\\n## 연결\\n\\n이제 [Polkadot Portal](https://polkadot.js.org/apps/#/explorer)을 통해 로컬 노드에 연결할 수 있습니다.\\n\\n왼쪽 상단 모서리에서 네트워크를 `Local Node`로 변경하고 `Switch`를 누르세요.\\n\\n![switch](../images/dev-node/portal.png)\\n\\n로보노믹스의 로컬 인스턴스에 오신 것을 환영합니다!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"eefdaba57911768d0e9c89edabf92067\",\"title\":\"Robonomics 비디오 서비스\",\"path\":\"/docs/ko/robonomics-video/\",\"content\":\"\\n이 문서에서는 IP 카메라를 Home Assistant에 추가하고 Robonomics 웹 서비스로 비디오를 보내는 방법을 보여줍니다.\\n\\nHome Assistant에 카메라를 연결하려면 해당 카메라의 IP 주소를 알아야하며 RTSP 스트림에 연결하기 위해 로컬 카메라 계정을 생성해야합니다.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n각 카메라마다이 작업이 다르게 수행되므로이 프로세스는이 문서에서 고려되지 않습니다.\\n</robo-wiki-note>\\n\\n요구 사항:\\n- IP 카메라\\n- 구성된 로컬 카메라 계정\\n- 카메라의 IP 주소\\n- 설정된 홈 어시스턴트\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\n이 문서는 RTZ (회전, 기울기, 확대) 옵션이없는 일반 IP 카메라를 가정합니다. \\nRTZ 카메라가있는 경우 [\\\"RTZ 카메라\\\"문서](/docs/ptz-camera)를 확인하십시오. 그런 다음 여기에서 두 번째 단계로 돌아갑니다.\\n\\n</robo-wiki-note>\\n\\n## 카메라 연결\\n\\n먼저 카메라의 RTSP 스트림에 대한 URL을 찾아야 합니다.\\n이를 위해 다음 쿼리를 인터넷에 입력해보십시오: \\\"<카메라 이름> RTSP 스트림\\\".\\n스트림 URL은 `rtsp://<IP_주소>...`로 시작해야합니다. \\n\\n이 문서에서는 \\\"Tapo\\\" 카메라를 사용하고 스트림 경로는 `rtsp://<IP_주소>/stream1`입니다.\\n\\nHome Assistant를 열고 \\\"Settings\\\"-> \\\"Devices & Services\\\"로 이동하십시오. \\\"ADD INTEGRATION\\\" 버튼을 누르고\\n\\\"Generic Camera\\\"통합을 입력하십시오.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\n구성 창에서 다음 정보를 제공하십시오:\\n- Stream Source URL - 카메라의 RTSP 스트림 URL\\n- Username - 로컬 카메라 계정의 사용자 이름 작성\\n- Password - 로컬 카메라 계정의 비밀번호 작성\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\n설정을 아래로 스크롤하고 \\\"Submit\\\"버튼을 누릅니다.\\n\\n미리보기 창에서 \\\"This image looks good.\\\" 확인란을 활성화하고 \\\"Submit\\\"버튼을 누릅니다. 그런 다음 - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### 대시 보드에 추가\\n\\n또한 스트림을 대시 보드에 추가 할 수 있습니다. 이를 위해 대시 보드로 이동하여 새 카드를 만듭니다 \\n\\\"Picture Glance\\\". 추가 단계:\\n- 원하는 \\\"Title\\\"을 입력하십시오\\n- \\\"Image Path\\\"에서 데이터 삭제\\n- \\\"Camera Entity\\\"에서 카메라를 선택하십시오.\\n- \\\"Camera View\\\"에서 지연이 적도록 \\\"live\\\"을 선택하십시오\\n\\n그리고 저장하십시오.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## 미디어 폴더 확인\\n\\nRobonomics Video Service로 전송되기 전에 비디오는 폴더에 저장되어야 하며 홈어시스턴트가 이 폴더에 접근할 수 있어야 합니다.\\n이 경우 가장 쉬운 옵션은 Home Assistant가 모든 미디어를 저장하는 미디어 팩을 사용하는 것입니다.\\n\\n- HAOS 또는 사전 설치된 이미지를 사용하는 경우 Home Assistant에는 이미 미디어 폴더가 있습니다.\\n- Home Assistant Core를 사용하는 경우 `.homeassistant` 폴더로 이동하고 그 안에 `media` 폴더를 생성해야합니다.\\n- Home Assistant Docker를 사용하는 경우 Docker 명령에 ` -v /PATH_TO_YOUR_MEDIA:/media \\\\` 줄을 추가하십시오.\\n\\n모든 것이 올바르게 설정되었는지 확인하려면 Home Assistant에서 “Media” -> “local media” 탭으로 이동하십시오. \\n빈 폴더 (오류 없음)가 표시되어야합니다:\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## 서비스 호출\\n\\nRobonomics에 비디오를 보내려면 Home Assistant에서 전용 서비스를 호출해야합니다. \\n이 문서에서는이 작업을 수동으로 수행하지만 자동화를 만들 수 있습니다.\\n\\n이를 위해 \\\"Developer tools\\\" -> \\\"Services\\\"로 이동하여  \\\"Robonomics: Save recording to Robonomics\\\"을 찾으십시오.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\n\\\"Targets\\\"에서 카메라 엔티티를 선택하십시오.\\n\\\"Path to save the recording\\\"에서 폴더의 절대 경로를 제공해야 합니다.\\n홈어시스턴트가 비디오를 저장할 수 있는 위치:\\n- 사전 설치된 이미지의 경우 - `/home/homeassistant/.homeassistant/media`;\\n- HA OS 또는 Home Assistant Docker의 경우- `/media`;\\n- Home Assistant Core의 경우 - 이전에 생성된 미디어 폴더의 경로입니다.\\n\\n또한 녹화 기간을 선택할 수 있습니다.\\n\\n데이터를 입력하고 \\\"CALL SERVICE\\\" 버튼을 눌러 서비스를 호출하세요.\\n\\n## DAPP\\n\\n결과 비디오를 보려면 [Robonomics DAPP](https://vol4tim.github.io/videostream/)로 이동하십시오. \\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\n컨트롤러의 계정 주소를 붙여넣고 아래 버튼을 클릭하세요. \\\"Search for Twins\\\" 과정을 기다립니다.\\n결과적으로 녹화된 모든 비디오와 함께 IPFS CID를 받게 됩니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\n다음으로, 드롭다운 목록에서 컨트롤러 계정(또는 기타 계정)을 선택하고 인증을 위한 메시지에 서명하세요.\\nWeb3 IPFS 게이트웨이를 사용하여 모든 비디오를 다운로드하세요. 결과적으로 스마트 홈에서 녹화한 모든 비디오를 얻을 수 있습니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\n폴더 안의 모든 영상은 컨트롤러 키로 암호화되어 있으므로, 영상을 복호화하려면 컨트롤러 키를 삽입해야 합니다.\\n그 후 비디오 재생 버튼이 활성화됩니다. 클릭하시면 영상을 다운로드 받으실 수 있습니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"ce38a87498eb7be376b2d875ea728e2e\",\"title\":\"로보노믹스 스마트 홈 Overview\",\"path\":\"/docs/ko/robonomics-smart-home-overview/\",\"content\":\"\\n## 블록체인으로 안전한 IoT \\n\\n스마트 홈을 위해 현대 IoT 시장은 다양한 솔루션을 제공합니다. 그러나 일반적으로 중앙 집중식 클라우드 공급업체나 비싼 전용 게이트웨이에 종속되어 있습니다. 결과적으로 사용자로서 스트 시스템을 실행하기 위해 하드웨어 및 인프라 공급업체에 항상 의존해야 합니다. 동시에 클라우드 통계 및 분석 없이는 스마트 홈이 진정한 스마트가 될 수 없습니다.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**현재 스마트 홈에서 두 가지 주요 문제를 발견했습니다:**\\n\\n1. 공급업체나 제3자와 공유하는 데이터에 대한 제어권이 없습니다.\\n2. 중앙 집중식 클라우드 서버의 중단으로 인해 스마트 홈이 취약합니다. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\n두 가지 문제를 해결하기 위해 로보노믹스를 사용해 보시기를 제안합니다. 로보노믹스는 **안전한**, **서버리스** 및 **미래지향적인** 분산 클라우드를 제공합니다.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## 기업에 종속되지 않은 클라우드를 위한 단계\\n\\n홈 어시스턴트를 장치 통신 애플리케이션으로 사용하고 기업에 종속되지 않은 분산 클라우드 플랫폼인 로보노믹스를 사용하여 저렴한 스마트 홈을 만드는 몇 가지 간단한 단계를 안내합니다. 로보노믹스는 현대적이고 안전한 Web3 기술을 활용하여 프로세스 전반에 걸쳐 향상된 보안을 제공합니다..\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## 스마트 홈을 시작하세요\\n\\n로보노믹스에서 스마트 홈 설정에 대한 자세한 가이드를 준비했습니다. 단계는 특정 상황에 따라 를 수 있습니다. 이미 작동 중인 홈 어시스턴트와 페어링된 장치가 있는지, 아니면 스마트 홈을 구축하기 위해 처음부터 시작하는지에 따라 다를 수 있습니다.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ko/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ko/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"7fddb65d3ee32fae5da5cc00a7b07173\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/ko/robonomics-prometheus-grafana/\",\"content\":\"\\n**다음 지침은 [Hubo Bubo](https://github.com/hubobubo)에서 제공됩니다**\\n\\n**원본 문서는 [여기](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)에서 찾을 수 있습니다**\\n\\n## 소개\\n로보노믹스 노드를 더 잘 모니터링하고 유지하기 위 프로메테우스 서버와 그라파나를 기반으로 모니터링을 설정하는 것이 좋습니다. 이 문서에서는 노드를 완전히 모니터링하기 위해 각각을 구성하는 방법을 보여줍니다.\\n\\n##  전제 조건\\n* [Ubuntu 18.04에서 서버 설정](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [로보노믹스 파라체인 콜레이터 설치](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* 로보노믹스 서비스가 기기에서 작동하고 포트 9615에 접근 가능한지 확인하세요. \\n\\n## 1단계 - 서비스 사용자 생성\\n\\n보안 목적으로 두 개의 새 사용자 계정인 prometheus와 node_exporter를 생성하여 서버에 로그인할 수 없도록 _--no-create-home_ 및 _--shell /bin/false_ 옵션을 사용하여 이 사용자를 생성합니다.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\n프로메테우스 이진 파일을 다운로드하기 전에 프로메테우스 파일 및 데이터를 저장하기 위한 필요한 디렉토리를 생성하세요. 표준 Linux 규칙에 따라 프로메테우스의 구성 파일을 위해 _/etc_에 디렉토리를 생성하고 데이터를 위해 _/var/lib_에 디렉토리를 생성합니다.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\n이제 새 디렉토리의 사용자 및 그룹 소유권을 prometheus 사용자 설정하세요.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## 2단계 - 프로메테우스 다운로드\\n\\n먼저 현재 안정 버전의 프로메테우스를 홈 디렉토리에 다운로드하고 압축을 해제하세요. 최신 이진 파일은 [프로메테우스 다운로드 페이지](https://prometheus.io/download/)에서 찾을 수 있습니다.\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\n이제 다운로드한 아카이브를 압축 해제하세요.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\n이렇게 하면 _prometheus-2.21.0.linux-amd64_라는 디렉토리가 생성되며 두 개의 이진 파일 (prometheus 및 promtool), 웹 인터페이스 파일을 포함하는 _consoles_ 및 _console_libraries_ 디렉토리, 라이선스, 공지 및 여러 예제 파일이 포함됩니다.\\n\\n두 개의 이진 파일을 _/usr/local/bin_ 디렉토리로 복사하세요.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\n이진 파일의 사용자 및 그룹 소유권을 1단계에서 생성한 prometheus 사용자로 설정하세요.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nconsoles 및 _console_libraries_ 디렉토리를 _/etc/prometheus_로 복사하세요.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\n디렉토리의 사용자 및 그룹 소유권을 prometheus 사용자로 설정하세요. -R 플래그를 사용하면 디렉토리 내부의 파일에도 소유권이 설정됩니다.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\n프로메테우스가 설치되었으므로 첫 번째 실행을 준비하기 위해 구성 및 서비스 파일을 생성합니다.\\n\\n## 3단계 - 프로메테우스 구성\\n\\n_etc/prometheus_ 렉토리에서 nano 또는 좋아하는 텍스트 편집기를 사용하여 _prometheus.yml_이라는 구성 파일을 생성하세요.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\n전역 설정에서 메트릭 스크래핑의 기본 간격을 정의하세요. 프로메테우스는 개별 수출자의 설정이 전역 설정을 덮어쓰지 않는 한 이러한 설정을 모든 수출자에 적용합니다.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\n이 스크래핑 간격 값은 대부분의 수출자에 대해 충분한 15초마다 프로메테우스가 메트릭을 수집하도록 지정합니다.\\n이제 다음 스크래_configs 지시문을 사용하여 프로메테우스 자체를 스크래핑할 수출자 목록에 추가하세요:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\n프로메테우스는 _job_name_을 사용하여 쿼리 및 그래프에서 수출자에 레이블을 지정하므로 여기에서 설명적인 내용을 선택하세요.\\n\\n또한 프로메테우스는 성능 모니터링 및 디버깅에 사용할 수 있는 중요한 데이터를 내보내므로 더 자주 업데이트하기 위해 전역 스크래핑 간격 지시문을 15초에서 5초로 재정의했습니다.\\n\\n마지막으로 프로메테우스는 _static_configs_ 및 _targets_ 지시문을 사용하여 수출자가 실행되는 위치를 결정합니다. 이 특정 수출자는 프로메테우스 자체와 동일한 서버에서 실행되므로 IP 주소 대신 로컬호스트와 기본 포트 9090을 사용할 수 있습니다.\\n\\n구성 파일은 이제 다음과 같아야 합니다:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\n파일을 저장하고 텍스트 편집기를 종료하세요.\\n\\n이제 구성 파일의 사용자 및 그룹 소유권을 1단계에서 생성한 prometheus 사용자로 설정하세요.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\n구성이 완료되었으므로 프로메테우스를 처음 실행하여 테스트할 준비가 되었습니다.\\n\\n## 4단계 - 프로메테우스 실행\\n\\n_prometheus_ 사용자로 프로메테우스를 시작하고 구성 파일 및 데이터 디렉토리의 경로를 제공하세요.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n출력에는 프로메테우스의 로딩 진행 상황, 구성 파일 및 관련 서비스에 대한 정보가 포함됩니다. 또한 프로메테우스가 포트 _9090_에서 수신 대기 중임을 확인합니다.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\n에러 메시지가 나오면 구성 파일에서 YAML 구문을 사용했는지 확인한 다음 문제를 해결하기 위해 화면 안내에 따르십시오.\\n\\n이제 _CTRL+C_를 눌러 Prometheus를 중지하고 새로운 _systemd_ 서비스 파일을 엽니다.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\n서비스 파일은 _systemd_에게 prometheus 사용자로 Prometheus를 실행하고 _/etc/prometheus/prometheus.yml_ 디렉토리에 있는 구성 파일을 사용하며 데이터를 _/var/lib/prometheus_ 디렉토리에 저장하도록 지시합니다. 다음 내용을 파일에 복사하십시오.\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\n마지막으로 파일을 저장하고 텍스트 편집기를 닫으십시오. 새로 생성된 서비스를 사용하려면 systemd를 다시로드하십시오.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\n이제 다음 명령을 사용하여 Prometheus를 시작할 수 있습니다.\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nPrometheus가 실행 중인지 확인하려면 서비스의 상태를 확인하십시오.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n출력에서 Prometheus의 상태, 주 프로세스 식별자 (PID), 메모리 사용 등을 확인할 수 있습니다.\\n\\n서비스의 상태가 활성 상태가 아닌 경우, 문제를 해결하기 전에 화면 안내에 따라 이전 단계를 다시 추적하십시오.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n계속 진행하기 전에 상태 명령을 종료하려면 _Q_를 누르십시오. 마지막으로 서비스를 부팅 시 시작하도록 활성화하십시오.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\n이제 Prometheus가 실행되고 작동 중이므로 서버 리소스에 대한 메트릭을 생성하기 위해 추가적인 익스포터를 설치할 수 있습니다.\\n\\n## 단계 5 - Node Exporter 다운로드\\n\\nPrometheus를 자체 메트릭을 넘어서기 위해 Node Exporter라는 추가 익스포터를 설치할 것니다. Node Exporter는 CPU, 디스크 및 메모리 사용량을 포함한 시스템에 대한 자세한 정보를 제공합니다. Node Exporter의 최신 안정 버전을 홈 디렉토리에 다운로드하십시오. 최신 이진 파일은 [Prometheus 다운로드 페이지](https://prometheus.io/download/)에서 찾을 수 있습니다.\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\n이제 다운로드한 아카이브를 압축 해제하세요.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\n이렇게 하면 _node_exporter-1.0.1.linux-amd64_라는 디렉토리가 생성되며, 그 안에 _node_exporter_라는 이진 파일, 라이선스 및 공지가 포함됩니다.\\n\\n이진 파일을 _/usr/local/bin_ 디렉토리로 복사하고 사용자와 그룹 소유권을 Step 1에서 생성한 node_exporter 사용자로 설정하십시오.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\n이제 Node Exporter를 설치했으므로 부팅 시 시작되도록 서비스 파일을 생성하기 전에 실행하여 테스트해 보겠습니다.\\n\\n## 단계 6 - Node Exporter 실행\\n\\nNode Exporter를 실행하는 단계는 Prometheus 자체를 실행하는 단계와 유사합니다. 먼저 Node Exporter를 위한 Systemd 서비스 파일을 생성하십시오.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\n다음 내용을 서비스 파일에 복사하십시오.\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\n파일을 저장하고 텍스트 편집기를 닫으십시오. 마지막으로 systemd를 다시로드하여 새로 생성된 서비스를 사용하십시오.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\n이제 다음 명령을 사용하여 Node Exporter를 실행할 수 있습니다.\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\n확인 that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\n이전과 마찬가지로 이 출력에서 Node Exporter의 상태, 주 프로세스 식별자 (PID), 메모리 사용 등을 확인할 수 있습니다. 서비스의 상태가 활성 상태가 아닌 경우, 화면 안내에 따라 이전 단계를 다시 추적하여 문제를 해결하십시오.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\n마지막으로 Node Exporter를 부팅 시 시작하도록 활성화하십시오.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nNode Exporter가 완전히 구성되고 예상대로 실행되면 Prometheus에 새로운 메트릭을 스크래핑하도록 지시할 수 있습니다.\\n\\n## 단계 7 - Prometheus를 Node Exporter 스크래핑으로 구성하기\\n\\nPrometheus는 구성 파일의 scrape_configs 부분에 정의된 익스포터만 스크래핑하므로 Prometheus 자체와 마찬가지로 Node Exporter에 대한 항목을 추가해야 합니다. 구성 파일을 엽니다.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nscrape_configs 블록의 끝에 node_exporter라는 새 항목을 추가하십시오.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\n이 익스포터도 Prometheus 자체와 동일한 서버에서 실행되므로 IP 주소 대신 localhost를 사용하고 Node Exporter의 기본 포트인 9100을 사용할 수 있습니다. 전체 구성 파일은 다음과 같아야 합니다:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\n파일을 저장하고 텍스트 편집기를 종료하십시오. 변경 사항을 적용하기 위해 Prometheus를 다시 시작하십시오.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\n다시 한 번 상태 명령으로 모든 것이 올바르게 실행되는지 확인하십시오.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n서비스의 상태가 활성 상태로 설정되지 않은 경우, 화면 안내에 따라 이전 단계를 다시 추적하십시오.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n이제 Prometheus와 Node Exporter가 설치되고 구성되어 실행 중입니다.\\n\\n## 단계 8 - Robonomic 빌드인 node_exporter 추가\\n\\nPrometheus와 node_exporter를 성공적으로 설치한 후 모든 substrate 프로젝트에서 내장된 prometheus 익스포터를 사용해야 합니다. 이를 위해 _/etc/prometheus/prometheus.yml_에 추가 항목을 추가해야 합니다.. \\n구성 파일을 엽니다.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nscrape_configs 블록의 끝에 robonomic_exporter라는 새 항목을 추가하십시오.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n파일을 저장하고 텍스트 편집기를 종료하세요. 전체 구성 파일은 다음과 같아야 합니다:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\n마지막으로, 변경 사항을 적용하기 위해 Prometheus를 다시 시작하세요.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\n다시 한 번 상태 명령으로 모든 것이 올바르게 실행되는지 확인하십시오.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n이제 _Prometheus_, _Node Exporter_, 그리고 _Robonomic Exporter_가 설치되고 구성되어 실행 중입다. 이제 Grafana로 이동하세요.\\n\\n## 9단계 - Grafana 설정\\n\\n마지막 단계는 Grafana에서 Prometheus를 데이터 소스로 연결하는 것입니다. 이 튜토리얼에서는 최대 5개의 대시보드와 전용 [Robonomics 대시보드](https://grafana.com/grafana/dashboards/13015)를 사용할 수 있는 무료 클라우드 기반 grafana를 사용합니다. [grafana.com](https://grafana.com/)으로 이동하여 새 계정을 만들고 새로 생성된 grafana 인스턴스에 로그인하세요.\\n\\n먼저, 우리의 경우 Prometheus 서버가 될 새로운 _**데이터 소스**_를 Grafana에 추가해야 합니다.\\n데이터 소스로 이동하세요:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\n그런 다음 **_데이터 소스 추가_**를 클릭하세요.\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext επιλέξτε _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\n새로운 화면에서 **_Prometheus 서버 IP 주소와 9090 포트_**를 입력하세요.\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\n그 후, 모든 단계를 완료했다면 _**저장 및 테스트**_를 클릭하세요. 그러면 녹색으로 표시되어 대시보드를 가져오기 준비가 완료됩니다. 메인 사이트에서 **+**를 클릭한 다음 아래 그림과 같이 **가져오기**를 클릭하세요.\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\n그런 다음 가져오기 페이지가 표시됩니다.\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\n_Grafana.com 대시보드 URL 또는 ID_란에 _**13015**_를 입력하세요 (이는 Robonomic 대시보드의 ID입니다).\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\n외부 대시보드를 로드한 후에는 다음 화면이 표시됩니다.\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\n마지막 단계는 이전에 생성한 **_데이터 소스_**를 선택하고 _**가져오기**_를 클릭하는 것입니다.\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\n끝났습니다! 이 시점에서 가져온 대시보드가 표시됩니다. \\n\\n\\n## 참고 자료\\n\\n* [Ubuntu 16.04에 Prometheus 설치하는 방법](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Prometheus + Grafana로 모니터링 대시보드 만들기](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Prometheus를 위한 Grafana 지원](https://prometheus.io/docs/visualization/grafana/)\\n* [노드 익스포터로 Linux 호스트 메트릭 모니터링](https://prometheus.io/docs/guides/node-exporter/)\\n* [Prometheus 쿼리하기](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [노드 메트릭 시각화하기](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Polkadot 노드 메트릭](https://grafana.com/grafana/dashboards/12425)\\n* [Prometheus 대시드를 위한 Node Exporter](https://grafana.com/grafana/dashboards/11074)\\n* [Grafana ROBONOMICS (XRT) 메트릭](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"abe5c2ee1cc10e8fb7c8ec56aa958990\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/ko/robonomics-opengov/\",\"content\":\"\\n## 소개\\n\\nRobonomics는 파라체인의 거버넌스 모델을 Polkadot의 정교한 OpenGov 메커니즘으로 전환하여 토큰 홀더의 궁극적인 의지에 따라 체인이 시간이 지남에 따라 진화할 수 있도록 했습니다.\\nRobonomics의 OpenGov 전환은 주요 지분을 통제하는 토 홀더 DAO가 항상 Robonomics 파라체인의 방향을 지시할 수 있도록 보장하며, 네트워크에 적합한 모든 변경 사항을 시행할 수 있습니다.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov는 Kusama Relay Chain에 연결된 Substrate 기반 체인 인 Robonomics Parachain에만 적용됩니다. OpenGov는 Ethereum 주요 네트워크가 현재 OpenGov와 같은 정교한 거버넌스 시스템을 지원하지 않기 때문에 Robonomics Ethereum 구현에는 적용되지 않습니다.\\n</robo-wiki-note>\\n\\nOpenGov는 파라체인에서 일상적인 운영과 의사 결정이 이루어지는 방식을 변경합니다. 이는 레퍼런덤의 범위에 대한 명확성을 제공하며, 파라체인에서 이루어지는 결정의 처리량을 대폭 증가시킬 수 있는 잠재력을 가지고 있습니다.\\n\\nOpenGov는 글을 작성하는 시점에서 Kusama 릴레이 체인에서 몇 개월 동안 활성화되어 왔으며, 토큰 홀더 DAO가 제안하고 투표하며 투표를 통해 궁극적으로 프로토콜의 방향을 통제할 수 있는 결정(개별 및 분리된 레퍼런덤)의 수를 대폭 증가시키는 것을 입증했습니다.\\n\\n**이 위키 섹션의 다음 콘텐츠는 Robonomics 파라체인의 OpenGov의 핵심 원칙을 설명하고 OpenGov의 개념을 더 잘 이해하는 데 도움이 되도록 설계되었습니다.**\\n\\n*프로콜에서 거버넌스는 특히 구현 초기 단계에서 지속적으로 발전하는 메커니즘임을 유념해야 합니다.*\\n\\nRobonomics OpenGov Track 매개변수에만 관심이 있는 경우 [여기](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)를 참조하십시오.\\n\\n## 레퍼런덤에 대해\\n\\n레퍼런덤은 간단하고 포괄적이며 지분 기반 투표 체계입니다. 각 레퍼런덤은 체인의 런타임에서 특정 제안과 연결된 특권 함수 호출의 형태를 취합니다. 이는 가장 강력한 호출 'set_code'를 포함할 수도 있습니다.`, which has the ability to switch out the entire code of the chains' runtime – this is unique to Substrate based chains, and removes the requirement for a \\\"hard fork\\\" of the chain when updating the chains' business logic (runtime).\\n\\n레퍼런덤은 고정된 투표 기간을 가진 개별 이벤트입니다(레퍼런덤 수명주기의 다른 기간에 대해 나중에 자세히 설명합니다). 개별 토큰 홀더는 레퍼런덤에 대해 동의(AYE), 반대(NAY) 또는 투표를 완전히 거부(ABSTAIN)하는 세 가지 방법 중 하나로 투표할 수 있습니다.\\n\\n모든 레퍼런덤에는 실행 지연이 연결됩니다. 이는 레퍼런덤이 종료되고, 레퍼런덤이 승인되었다고 가정할 때 네트워크에서 변경 사항이 시행되기까지의 기간입니다. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  각 다른 유형의 원산지에 특정한 레퍼런덤에 대해 특정한 실행 기간이 설정되어 있습니다. 그러나 특정 레퍼런덤의 원조자는 해당 레퍼런덤의 작업을 미래의 많은 블록에서 실행하도록 설정할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n레퍼런덤은 닫혔고 투표가 집계되면 'baked'로 간주됩니다. 레퍼런덤이 승인되었다고 가정하면 네트워크에서 시행되기 위해 예약될 것입니다(체인의 스케줄러에서). 레퍼런덤은 현재 투표 중인 경우와 같이 결과가 보류 중인 경우 'unbaked'로 간주됩니다.\\n\\nOpenGov의 추가로 누구나 언제든지 레퍼런덤을 시작할 수 있으며, 원하는 만큼 여러 번 시작할 수 있습니다. OpenGov는 한 번에 처리할 수 있는 레퍼런덤이 1개뿐인 제한을 제거합니다(참고로 Gov v1에서는 한 번에 1개의 레퍼런덤에만 투표할 수 있습니다. 커뮤니티가 동시에 투표할 수 있는 추가 비상 레퍼런덤을 제외한 예외도 있습니다).\\n\\nOpenGov는 Origin 및 Track이라고 하는 여러 개의 새로운 기능/개념을 도입하며, 이는 프로토콜에서 레퍼런덤의 흐름과 처리를 돕기 위해 도입되었습니다.\\n\\n각 Origin은 단일 레퍼런덤 클래스와 연결되며, 각 클래스는 트랙과 연결됩니다. 트랙은 레퍼런덤의 수명주기를 개별 원산지에 대해 지정하며, 해당 특정 원산지에서 레퍼런덤이 발생합니다. 트랙에 고유한 매개변수가 있어 네트워크가 특권 수준에 따라 레퍼런덤의 수명주기를 동적으로 수정할 수 있습니다(특권 수준은 레퍼런덤이 얼마나 강력한지/프로토콜에 어떤 종류의 변경을 가할 수 있는지를 생각할 수 있습니다).\\n\\n*원산지는 레퍼런덤과 관련된 권한을 나타내는 것으로 생각하고, 트랙은 투표 기간의 길이 및 승인 및 지원 기준과 같은 레퍼런덤과 관련된 투표 매개변수로 생각할 수 있습니다.*\\n\\n예를 들어, 런타임 업그레이드는 작은 트레저 팁과는 다른 프로토콜에 대한 함의를 가지므로, 다른 원산지가 필요합니다. 이를 통해 체인의 팔레트에서 사전에 결정된 투표 기간, 승인 및 지원 기준(트랙)을 동적으로 수정할 수 있습니다.\\n\\n\\n## 제안 및 제안 생명주기 \\n\\n### 준비 기간\\n\\nOpenGov에서는 참여자 커뮤니티의 토큰 홀더가 참여하여 참조표를 즉시 투표할 수 있도록 참조표가 초기에 생성될 수 있습니다. 그러나 참조표는 즉시 종료되거나 투표가 집계되거나 승인되어 즉시 시행될 수 있는 상태가 아닙니다. 대신, 참조표는 결정 기간으로 이동하기 전에 일련의 기준을 충족해야 합니다. 참조표가 결정 기간으로 들어가기 전까지는 미결 상태로 남게 되며, 개별 추적에서 지정된 전체 생명주기 기간이 지난 후에는 최종적으로 시간이 초과됩니다.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\n참조표가 결정 기간으로 들어가기 위한 기준은 다음과 같습니다:\\n1. 결정 기간이 시작되기 전에 경과해야 하는 준비 기간입니다. 이 준비 기간은 \\\"결정 스나이핑\\\" 가능성에 대비하여 도움이 되며, 이는 다수의 투표 권한을 통제하는 공격자가 참조표가 제안된 후 즉시 통과되도록 큰 지분을 사용하여 다른 토큰 홀더 DAO 구성원이 참조표를 충분히 고려하고 투표에 참여할 시간을 가질 수 있는 가능성을 우회하는 것을 방지합니다. 따라서 더 높은 권한 수준을 가진 Origins는 준비 기간이 훨씬 더 길게 설정됩니다.\\n\\n2. 결정에 대한 여유 공간이 있어야 합니다. 각 추적은 동시에 결정할 수 있는 참조표의 수에 대한 제한을 가지고 있습니다 (max_deciding). 더 강력한 권한 수준을 가진 추적은 더 낮은 제한을 가집니다. 예를 들어, Root 수준의 origin은 Small Tipper origin과 같은 낮은 권한 수준의 origin과 비교하여 동시에 결정할 수 있는 참조표 수가 훨씬 적습니다.\\n\\n3. 결정 예치금을 제출해야 합니다. 참조표를 초기에 생성하는 것은 비교적 저렴하며, 제출 예치금의 가치(참조표가 초기에 생성될 때 예약되는 예치금)은 상당히 낮으며, 주로 참조표와 관련된 온체인 저장에 필요한 가치로 구성됩니다. 결정 예치금은 훨씬 더 높으며, 스팸을 방지하기 위해 필요하며, OpenGov가 가져오는 경제 게임에 영향을 미치며, 이에 대해 나중에 알아보겠습니다.\\n\\n위의 세 가지 기준이 모두 충족되면 참조표는 결정 기간으로 이동합니다. 참조표에 대한 투표는 그 결과에 반영됩니다.\\n\\n### 결정 기간\\n\\n*결정 기간에 대한 빠른 비디오 데모는 [이 비디오](https://www.youtube.com/watch?v=wk58C-2CqPI)를 참조하세요*.\\n\\n위의 섹션에서 상세히 설명된 기준을 모두 충족한 후 참조표는 결정 기간으로 진입합니다.\\n\\n결정 기간은 승인 및 지원 기준을 중심으로 합니다. \\n\\n승인은 승인 투표 가중치(AYE vs NAY)가 총 투표 가중치(모든 AYE 및 NAY 투표의 합산)와 비교되는 것으로 정의됩니다. 각 투표의 확신은 AYE/NAY 투표의 전체 가중치에 기여하(확신 투표 / 자발적 잠금에 대해 나중에 자세히 설명합니다), 승인 및 지원 기준에 대한 전반적인 가중치에 영향을 미칩니다.\\n\\n지원은 참조표에 참여한 투표(토큰)의 총 수로 정의되며(확신에 대해 조정되지 않음), 시스템에서 가능한 총 투표 수와 비교됩니다(이를 파라체인의 XRT의 총 발행으로 생각해보세요 - 특히 XRT의 총 유통 공급은 여기에서 주된 요소가 아닙니다. 일부는 Ethereum에서 ERC-20 토큰으로 존재하기 때문입니다).\\n\\n**ABSTAIN 방향의 투표는 승인 기준에 기여하지 않지만, 지원 기준에 포함되어 계산됩니다**\\n\\n확인 기간으로 진행하려면 결정 기간 동안 지원 및 승인 기준을 충족해야 합니다.\\n\\n각 추적에 대한 개별 지원 및 승인 기준에 대한 자세한 내용은 [이 스프레드시트](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)를 참조하세요.\\n\\n### 확인 기간\\n\\n각 추적은 자체적인 확인 기간을 가지고 있습니다. 더 높은 권한 수준을 가진 추적(예: Root)은 낮은 권한 수준을 가진 추적(예: Small Tipper)보다 훨씬 긴 확인 기간을 가지고 있습니다.\\n\\n참조표는 확인 기간 동안 승인 및 지원 기준을 계속 충족해야 하며, 그렇지 않으면 다시 결정 기간으로 돌아갑니다(참고: 확인 기간 동안 결정 기간이 일시 중지되지 않으므로, 결정 기간이 확인 기간 동안 만료될 수 있으며, 이는 참조표가 승인 및 지원 기준을 더 이상 충족하지 않아 확인 기간에서 제외되는 경우, 실패한 참조표로 간주되어 시행되지 않습니다).\\n\\n**개별 트랙에 대한 승인 및 지원 기준을 루트 오리진 권한을 가진 전체투표를 통해 조정할 수 있습니다.**\\n\\n낮은 권한 수준을 가진 오리진은 높은 권한 수준을 가진 오리진보다 승인 및 지원 기준이 훨씬 쉽습니다(트랙에서 설정됨). 마찬가지로, 높은 한 수준을 가진 오리진은 낮은 권한을 가진 오리진보다 덜 가파른 곡선을 가지며(트랙에서 정의됨), 토큰 홀더 DAO가 실제로 전체투표를 승인하고 고권한 오리진 전체투표에 대한 전쟁을 피하기 위해 조치됩니다.\\n\\nOpenGov에서 결정 기간이 만료된 후 승인되지 않은 전체투표는 기본적으로 거부된 것으로 간주되며, 제출 및 결정 예치금은 원조자에게 환불됩니다(참고: 결정 예치금은 전체투표의 원조자와 다른 사람이 게시할 수 있습니다).\\n\\n전체투표가 확인 기간 동안 계속해서 승인 및 지원 기준을 충족하는 경우, 승인된 것으로 간주되며, 제안된 오리진에서 실행될 예정이지만, 최소 시행 기간이 경과한 후에만 전체투표가 실행됩니다.\\n\\n### 시행 기간\\n\\n시행 기간은 전체투표가 제안될 때 원조자에 의해 지정되지만, 각 트랙에서 지정된 최소 시행 기간에 따라 달라집니다. 더 강력한 오리진은 덜 가지권을 가진 오리진보다 훨씬 더 긴 최소 시행 기간을 가지고 있습니다. 이는 강력한 전체투표가 가할 수 있는 변경 사항에 대비하기 위해 네트워크가 충분한 시간을 갖도록 보장합니다.\\n\\n## 자발적인 잠금 / 확신\\n\\nRobonomics는 자발적인 잠금 또는 확신 투표라고 알려진 개념을 사용합니다. 이를 통해 토큰 홀더는 특정 조사를 위해 자신의 토큰을 얼마 동안 잠금할 것인지 결정함으로써 투표 권한을 높일 수 있습니다. 이 메커니즘은 각 조사 승인 기준에만 영향을 미치며, 확신 투표는 지지 기준에 영향을 미치지 않습니다.\\n\\n확신 투표는 다음 공식을 사용하여 계산할 수 있습니다:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\n이 표는 잠금 기간의 증가 수준마다 승인 기준에 대한 투표가 어떻게 곱해지는지 보여줍니다:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\n토큰 홀더가 사용할 수 있는 최대 확신은 6배 확신입니다. 예를 들어, 5.5배 확신을 사용할 수 없습니다.\\n\\n투표로 인해 토큰이 잠겨 있을 때 다른 조사에 투표하는 데는 여전히 사용할 수 있지만, 이는 전송 가능한 잔액에 포함되지 않습니다(다른 계정으로 보낼 수 없음). 전체 잠금 기간이 만료되면 잔액은 다시 전송 가능해집니다.\\n\\n## 투표 위임\\n\\nOpenGov에서는 각 조사를 검토하는 데 충분한 시간이 없는 토큰 홀더가 여전히 거버넌스 시스템의 일부로 사용되도록 허용하기 위해 투표 위임이라고 알려진 메커니즘이 추가되었습니다.\\n\\n토큰 홀더는 시스템 내 다른 투표자(다른 계정)에게 투표 권한을 위임할 수 있습니다. 투표자는 각 개별 원본에 대해 투표 권한을 다른 계정에 할당할 수 있도록 유연하게 지정할 수 있습니다(토큰 수와 확신 수준).\\n\\n이 위임 기능은 투표자 투표을 높이고 승인 및 지지 기준을 충족시키기 위해 도움을 줄 목적으로 한다.\\n\\n투표 권한을 위임하려면 [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer)의 거버넌스 -> 조사 섹션에서 찾을 수 있는 \\\"위임\\\" 기능을 사용할 수 있습니다. 또는 사용자는 Robonomics Portal의 개발자 -> 외부 섹션을 사용하여 convictionVoting(Delegate) 외부를 제출할 수 있지만, 포털의 조사 섹션의 \\\"위임\\\" 기능을 사용하는 것이 훨씬 쉽습니다.\\n\\n## 조사 취소 / 종료 및 거버넌스 경제 게임\\n\\nOpenGov에서는 상태에 관계없이 진행 중인 조사를 거부하는 Origins가 있습니다. 이들은 거버넌스 Canceller 및 Governance Killer 트랙으로 알려져 있습니다.\\n\\n이러한 Origins는 이미 투표가 진행 중인 조사에 개입합니다. 이러한 Origins는 해당 Origin에서 시작된 조사가 승인되면 상태에 관계없이 진행 중인 조사를 즉시 거부합니다. \\n\\n취소 자체는 실행되기 위해 토큰 홀더가 투표해야 하는 유형의 조사입니다. 취소에는 자체 원본과 트랙이 있으며, 이들은 다른 Origins보다 낮은 리드 타임(의사 결정 기간 등)을 가지며, 승인 및 지지 곡선이 더 가파르고 날카로운 곡선을 가지고 있습니다(즉, 시간이 지남에 따라 기준을 충족하기가 훨씬 쉽습니다). 이는 조사의 취소가 일반적으로 긴급성을 동반하기 때문입니다.\\n\\n거버넌스 Canceller는 이미 진행 중인 조사를 즉시 거부하기 위해 설계되었습니다. 이 원본에 의해 조사가 취소되면 제출 및 결정 예치금이 원조자에게 환불됩니다. 조사 원조자가 조사 내용에 인간적인 실수를 저지른 경우와 악의적인 행동을 시도하지 않은 경우에 조사가 취소될 수 있습니다.\\n\\n거버넌스 Killer는 이미 진행 중인 조사를 즉시 거부하기 위해 설계되었습니다. 이는 거버넌스 경제 게임이 작용하는 곳입니다. Root와 같은 높은 특권 수준을 가진 Origins는 결정 기간에 진입하기 위해 높은 자본(XRT 토큰)을 요구하는 결정 예치금을 보증해야 합니다. \\n\\n악의적인 행위자가 Root 원본과 같은 조사를 제출하는 경우, 이에 대항하기 위해 토큰 홀더 DAO는 카운터 거버넌스 Killer 조사를 제기할 수 있습니다. 악의적인 조사가 거버넌스 Killer 원본을 통해 거부되면 제출 및 결정 예치금이 벌처럼 감소되므로, 원조자(이 예치금을 게시한 계정)는 해당 자금을 잃게 됩니다. \\n\\n이는 악의적인 행위자가 체인에 심각한 부정적인 영향을 미칠 수 있는 조사를 제기하려는 시도에 대해 심각한 경제적 결과가 있음을 의미하며, 이론적으로는 이를 시도하는 악의적인 행위자를 막을 것입니다.\\n\\n지배력 킬러 트랙 자체의 결정 예금은 상당히 높습니다. 이는 그 외에도 좋은 국민투표의 예금을 감소시키려는 악의적인 행위자들을 막기 위한 것입니다. **기존의 지배력 킬러 국민투표는 후속 지배력 킬러 국민투표에 의해 취소될 수 있습니다.**\\n\\n## Robonomics 기술위원회 및 화이트리스트 원천\\n\\n이 그룹은 Robonomics 네트워크 프로토콜의 기술 지식을 가진 사람들을 대표하는 주요 목표를 가진 자율적인 전문 기구입니다. \\n\\n이 그룹(그리고 오직 이 그룹만)은 화이트리스트 팔렛에서 국민투표를 발의할 수 있습니다. 이 팔렛은 한 원천이 다른 원천의 특정 작업에 대한 권한 수준을 높일 수 있도록 하는 한 가지 기능을 수행합니다. \\n\\n이 그룹은 화이트리스트-루트라고 알려진 원천으로부터 국민투표를 승인할 수 있으며, 이러한 국민투표는 루트 수준의 권한으로 실행될 수 있지만, 이러한 국민투표는 그룹에 의해 승인된 특정 지정 명령만 성공적으로 작동합니다. 화이트리스트 팔렛은 다음을 확인합니다:\\n1. 원천이 실제로 화이트리스트-루트인지(즉, 이 원천의 트랙을 통과한 국민투표인지).\\n2. 제안이 그룹에 의해 화이트리스트에 등재되었는지.\\n\\n두 가지 조건이 모두 참이면 작업은 루트 수준의 권한으로 실행됩니다.\\n\\n이 시스템은 새로운 병렬 트랙(화이트리스트-루트 원천)을 가질 수 있는 능력을 제공합니다. 이 트랙의 매개변수는 투표 회전 기간을 더 짧게 설정할 수 있도록 하며(승인 및 지원 기준은 루트보다 조금 더 쉽게 충족될 수 있음), 이 공개적이고 투명한 프로세스는 Robonomics 네트워크 프로토콜의 전문가 그룹이 안전하고 시급한 국민투표를 제안할 수 있도록 합니다.\\n\\n화이트리스트-루트 원천으로 시작된 국민투표의 지원 기준은 다른 원천/트랙과 달리 0으로 수렴하지 않습니다. 이는 이 그룹이 Robonomics 네트워크 프로토콜 전체를 사실상 통제하지 않도록 하며, 전체 토큰 홀더 DAO로부터 최소한의 지원(유권자 투표율)을 요구합니다.\\n\\n\\n## 국민투표 기간 \\n\\n각 개별 국민투표의 기간이 단단한 것이 아니라는 것을 이해하는 것이 중요합니다. 국민투표의 수명주기 내에서 최소 시행 기간과 같은 일부 기간은 실제로 구체적인 기간을 가지지만, 결정 기간을 포함한 다른 기간은 그렇지 않습니다. 예를 들어, 준비 기간, 결정 기간, 확인 기간 및 최소 시행 기간의 최대 기간을 더해서 \\\"각 국민투표는 X일이 걸린다\\\"고 주장하는 것은 그보다 훨씬 유동적입니다.\\n\\n이미지를 통해 같은 원천에서 시작된 몇 가지 별도의 국민투표를 살펴보겠습니다. 이 경우 루트 원천입니다. \\n\\n루트 원천은 각 기간의 기간과 승인 및 지원 곡선이 설정된 자체 트랙을 가지고 있음을 기억하는 것이 중요합니다.\\n\\n국민투표는 특정 조건이 충족될 경우에만 수명주기의 다음 단계로 진행됩니다. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\n다음 이미지에서는 위의 이미지에 설명된 대로 개별 국민투표의 수명주기의 다음 단계로 진행하기 위해 특정 조건이 충족되었다고 가정해야 합니다(그렇지 않은 경우를 제외하고).\\n\\n\\n### 투표자 투표율이 매우 낮은 경우의 최대 가능 기간\\n\\n아래 이미지는 국민투표의 최대 가능한 타임라인을 나타냅니다. 이는 다음과 같은 국민투표를 상상해보십시오:\\n1. 결정 예금이 게시되었으며, 따라서 결정 기간에 진입한 국민투표입니다.\\n2. 예를 들어, AYE 방향으로 1 XRT의 단일 투표가 있습니다 - 이는 전체적인 지원이 매우 낮기 때문에 결정 기간의 매우 끝에서 필요한 지원(유권자 투표율)을 충족할 것입니다. 그러나 100% 승인을 받으므로 결국 확인 기간에 진입하는 요구 사항을 충족할 것입니다.\\n3. 확인 기간 동안 앞서 언급한 기준을 계속 충족합니다.\\n4. 국민투표에 의해 제기된 제안은 최소 시행 기간이 끝나는 동일한 블록에서 실행될 것입다 - 기술적으로 국민투표의 발의자는 국민투표에 자세히 기술된 네트워크 변경 사항을 미래의 많은 블록에 적용할 수 있으므로 실제로 개별 국민투표의 수명주기는 여러 일, 주, 월 또는 년에 걸칠 수 있습니다.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\n이 예에서 국민투표의 수명주기는 (대략) 17일입니다.\\n\\n\\n### 투표자 투표율이 많은 경우의 기간 (AYE 투표가 많은 경우)\\n\\n이제 XRT 토큰 홀더 DAO가 많은 관심을 표명한 국민투표를 살펴보겠습니다. 이 예시에서는 전체 투표자 수가 약 248,771 XRT로 발생했으며, 모든 투표자가 찬성 방향으로 투표한다고 가정합니다 (참고: 기술적으로 Root 국민투표의 이 단계에서는 승인 기준을 충족하기 위해 찬성 방향의 투표가 전체 투표의 60% 이상이어야 합니다).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n 각 트랙에 대한 정확한 정보를 위해 항상 최신 트랙 정보를 참고하십시오. 자세한 내용은 [스프레드시트](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)에서 확인할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n이 예시에서는 다음과 같습니다:\\n1. 결정 예치금은 준비 기간 동안 게시되었으며, 따라서 준비 기간이 끝날 때 결정 기간으로 전환할 수 있었습니다.\\n2. 많은 투표자가 이 국민투표에 참여하여 상대적으로 짧은 시간 내에 약 248,771 XRT의 투표자 수를 얻었습니다.\\n3. 투표는 찬성 방향이 우세했습니다 (60% 이상 찬성).\\n4. 국민투표는 확인 기간 동안 항상 확인 기준을 충족합니다 (참고: 국민투표가 확인 기간의 기준을 충족하지 못하면 결정 기간으로 돌아갑니다).\\n5. 국민투표로 제기된 제안은 최소 시행 기간이 끝나는 동일한 블록에서 실제로 시행됩니다.\\n\\n약 248,771 XRT 투표가 발생했기 때문에 국민투표는 약 168시간 (7일) 후에 확인 기간에 진입할 수 있는 기준을 충족합니다.\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\n이 두 번째 예시에서는 투표자 수가 많았기 때문에 결정 기간이 최대 허용 시간의 절반을 지나서 종료되었습니다. 따라서 약 10일 후에 시행될 수 있는 국민투표가 이루어집니다.\\n\\n\\n### 결정 예치금이 게시되지 않은 기간\\n\\n이제 원래 제안되었지만 결정 예치금이 게시되지 않은 국민투표를 살펴보겠습니다. 이러한 국민투표는 \\\"준비 중인 상태\\\"에 머무르는 종류의 \\\"리무 상태\\\"입니다.\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\n이 세 번째 예시에서는 결정 예치금이 게시되지 않았기 때문에 국민투표가 실제로 결정 기간에 진입하지 않고 \\\"준비 중인 상태\\\"에 머무릅니다. 이는 결국, 결정 예치금이 게시되지 않으면 팔레트의 timeOut 상수에 지정된 기간이 경과한 후에 국민투표가 시간 초과됩니다.\\n\\n이는 이전에 Kusama에서 발생한 사례로, Root 출처로 국민투표가 게시되었지만 결정 예치금을 게시하기 위한 높은 자본 요구 사항으로 인해 국민투표가 수명 주기의 후반 단계로 진입하지 못한 경우입니다. 이러한 국민투표는 \\\"시간 초과\\\" 플래그로 종료됩니다.\\n\\n\\n### 결정 예치금이 늦게 게시된 기간\\n\\n마지막으로, 국민투표가 원래 제안된 후에 결정 예치금이 꽤 오랜 시간 동안 게시되지 않은 예시를 살펴보겠습니다. 이는 이전에 Kusama에서 발생한 사례로, Root 출처로 국민투표가 게시되었지만 원조자가 자신을 대신하여 결정 예치금을 게시하기 위해 높은 자본을 가진 사람을 찾는 데 시간을 소비해야 했던 경우입니다.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\n이 마지막 예시에서는 결정 예치금이 준비 기간이 끝난 후에 게시되었지만 국민투표가 시간 초과되기 전에 결정 기간에 진입하기 때문에 국민투표의 수명 주기가 실제로 정상보다 훨씬 길어집니다.\\n\\n준비 기간 또는 \\\"준비 중인 상태\\\"에 있는 국민투표에 대해 토큰 홀더 DAO가 찬성/반대로 투표할 수 있다는 점을 유념해야 합니다.\\n\"}},{\"node\":{\"id\":\"0e488dca819becd3ae0329150b7d181b\",\"title\":\"Robonomics 통합 설정\",\"path\":\"/docs/ko/robonomics-hass-integration/\",\"content\":\"\\n**이 문서에서는 Robonomics를 Home Assistant에 추가합니다. 이를 통해 Home Assistant가 암호화된 데이터로 데이터 로그를 Robonomics Parachain에 기록하고, 파라체인으로부터 발사 명령을 수신하여 스마트 기기를 제어할 수 있습니다. 통합은 데터를 저장하고 IPFS 해시를 데이터 로그 또는 발사 기능으로 전송하기 위해 IPFS를 사용합니다.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Home Assistant의 웹 인터페이스에서 `Settings` -> `Device & Services`로 이동하고 `ADD INTEGRATION`를 누릅니다. `Robonomics`를 검색합니다.\\n\\n2. Robonomics를 클릭하고 구성을 입력합니다: \\n\\n- `SUB_CONTROLLER` 계정의 시드를 컨트롤러 계정 시드에 추가합니다.\\n- `SUB_OWNER` 계정의 공개 주소를 구독 소유자 주소에 추가합니다.\\n- 데이터 전송 간격을 설정합니다 (기본값은 10분입니다).\\n- (선택 사항) 데이터를 IPFS 네트워크 전체에 널리 퍼뜨리기 위해 핀 서비스 Pinata 또는 기타 사용자 정의 게이트웨이에 대한 자격 증명을 추가할 수 있습니다.\\n\\n3. 구성을 완료한 후 `SUBMIT`을 누릅니다. 모든 항목을 올바르게 입력했다면 성공 창이 표시됩니다.\\n\\n이제 Robonomics 통합을 Home Assistant에 완전히 설정했습니다. 이제 모든 Robonomics 웹 서비스를 사용할 수 있습니다. 자세한 내용은 [\\\"사용\\\" 섹션](/docs/global-administration)을 참조하십시오. \\n\"}},{\"node\":{\"id\":\"8ab925e85c0aec51b110c564ad4fa6a4\",\"title\":\"이더리움에서의 Robonomics\",\"path\":\"/docs/ko/robonomics-ethereum/\",\"content\":\"\\n이더리움에서의 robonomics에 대한 모든 정보는 GitHub 저장소로 이동되었습니다. 필요한 모든 정보는 [여기에서 찾을 수 있습니다.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"9bfc59cbd94e4ece56411c09c467adb1\",\"title\":\"파이썬 인터페이스 및 Robonomics IO\",\"path\":\"/docs/ko/rinterface/\",\"content\":\"\\n**Robonomics 팔레트에 구현된 일부 extrinsic은 Polkadot 앱에서 제출하기 어렵습니다. 더욱이 \\n프로그래밍 언어를 사용하여이 기능과 상호 작용해야합니다. 이를 위해 간단한 파이썬 도구가 개발되었습니다.\\n[robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface)라고 합니다. Polkascan으로 관리되는 래퍼입니다.\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface)입니다. 이 패키지에 대한 간단한 설명은 아래에 나와 있습니다.\\n그리고 일부 유용한 링크와 예제가 있습니다. 또한, CLI 도구에 대해서도 논의됩니다.**\\n\\n## robonomics-interface\\n\\n[PyPi](https://pypi.org/project/robonomics-interface/) 패키지에서 사용할 수 있으며 다운로드 및 설정이 준비되어 있습니다.\\n자세한 docstring-generated [documentation](https://multi-agent-io.github.io/robonomics-interface/)도 사용할 수 있습니다.\\n\\n모두 모두, 이것은 프로그래밍 도구를 통해 Robonomics 블록 체인과 상호 작용하려는 개발자를 위한 도구입니다. \\n파라체인과 상호 작용하는 Robonomics 팀의 거의 모든 파이썬 프로젝트에서 이 인터페이스를 사용합니다.\\n\\n### 설치\\n\\n설치 프로세스를 위해서는 사용자가 적어도 Python 3.8이 설치되어 있어야합니다. `x86`, `arm7`, `arm8` 중 어느 아키텍처도 컴파일 프로세스가 필요하지 않습니다.\\n모든 휠은 종속성 유지 관리자에 의해 빌드되고 게시됩니다.\\n\\n`pip`는 설치 도구로 사용됩니다:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### 샘플 사용\\n\\n주요 아이디어는 `Account` 인스턴스를 생성 한 다음 팔레트 전용 인스턴스를 사용하는 것입니다.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, 데이터로그\\naccount = Account()\\ndatalog_ = 데이터로그(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  또한 사용자 정의 엔드 포인트 (예 : 테스트용 로컬 노드)를 사용할 수도 있습니다.\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nExtrinsic도 제출할 수 있습니다:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  말했듯이, 더 많은 예제는 [documentation](https://multi-agent-io.github.io/robonomics-interface/) 페이지에서 확인할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface`에는 프로토타이핑 및 빠른 테스트 목적으로 사용할 수있는 Python `click` CLI 도구도 포함되어 있습니다. 설치되어 있습니다.\\n패키지와 터미널에서 사용할 수 있습니다:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\n로컬 노드에서 사용해 볼 수 있습니다. 파이프 라인 철학이 채택되었습니다.\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"63d93a1ee4c3d01eb475c039f30073cf\",\"title\":\"홈 어시스턴트에서 PTZ 카메라 제어\",\"path\":\"/docs/ko/ptz-camera/\",\"content\":\"\\n이 기사는 홈 어시스턴트에서 PTZ 카메라 설정 과정을 다룹니다. \\nONVIF 프로토콜을 사용합니다. 이를 위해서는 로컬 카메라 계정이 필요합니다.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n로컬 카메라 계정 설정 과정은 이 문서에서 다루지 않습니다.\\n</robo-wiki-note>\\n\\n요구 사항:\\n- PTZ 카메라\\n- 로컬 카메라 계정\\n- 카메라 IP 주소\\n- 설정된 홈 어시스턴트\\n\\n## ONVIF 통합\\n\\n**ONVIF 통합** 설치로 시작해 봅시다. \\n\\n\\\"Settings\\\"에서 \\\"Devices & Services\\\"로 이동하여 \\\"ADD INTEGRATION\\\" 버튼을 누르세요.\\n\\\"ONVIF\\\"를 입력하고 통합을 선택하세요. 다음 창이 표시됩니다.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\n\\\"Submit\\\" 버튼을 누르세요. 카메라를 자동으로 검색하려고 시도합니다. 성공하면, \\n목록에서 카메라를 선택하고 빈 필드를 채우세요. \\n그렇지 않으면, 모든 필드를 수동으로 채워야 합니다. 다음 창이 표시됩니다.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\n빈 칸을 채우세요:\\n- Name - 카메라에 이름을 지정하세요\\n- Host - 카메라의 IP 주소를 제공하세요\\n- Port - 일반적으로 2020년입니다만, 카메라 제조업체에 따라 다를 수 있습니다\\n- Username - 카메라 로컬 계정의 사용자 이름을 입력하세요\\n  - Password - 카메라 로컬 계정의 비밀번호를 입력하세요\\n\\n그리고 \\\"Submit\\\"을 누르세요. 카메라의 위치를 선택하고 \\\"Finish\\\"를 클릭하세요.\\n\\n## 대시보드에 카메라 제어 추가\\n\\n카메라를 완전히 설정했으므로, 대시보드에 스트림과 제어 버튼을 추가할 수 있습니다.\\n\\n대시보드로 이동하여 새 카드를 만드세요. \\\"Picture Glance\\\"를 선택하세요.\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\n데이터를 입력하세요:\\n- Title - 카메라 이미지 제목을 선택하세요\\n- Camera Entity - 드롭다운 목록에서 카메라 엔티티를 선택하세요\\n- Camera View - 지연 시간을 줄이려면 \\\"live\\\"을 선택하세요\\n\\n다음으로, 왼쪽 하단의 버튼을 눌러 \\\"코드 편집기\\\" 모드로 전환하세요. 다음 코드가 표시됩니다:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\n`entities: []`의 내용을 아래 예시에 따라 바꾸세요 (`<YOUR_CAMERA_ENTITY>`는 `camera_image` 매개변수와 동일합니다):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\n이것으로 끝입니다. 이제 대시보드에 PTZ 카메라 카드와 제어 버튼이 표시됩니다.\\n\\n## 문제 해결\\n만약 Home Assistant Core를 사용하고 카메라에서 스트림을 보지 못하는 경우, \\\"stream\\\" 및 \\\"FFMPEG\\\" 통합을 설치해야 합니다. \\n이를 위해 `stream: `과 `ffmpeg: ` 문자열을 configuration.yaml의 끝에 추가해야 합니다.\"}},{\"node\":{\"id\":\"d2e0e4ce8dcf2dd97fc8c7ef7258c3b1\",\"title\":\"로보노믹스 스마트 홈\",\"path\":\"/docs/ko/notifications/\",\"content\":\"\\n스마트폰으로 알림을 받을 수 있습니다. [notify](https://notify.events/)를 사용하세요. 먼저 거기에 등록하고 `Control Panel`에서 새로운 채널을 생성하세요:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\n제목을 추가하고 `Save`을 누르세요:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\n그런 다음 `Add Source`를 누르고 `IoT and Smart Home` 탭에서 `Home Assistant`를 선택하세요:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\n제목을 작성하고 `Next`을 누르세요:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\n여기에서 홈 어시스턴트 구성 파일에 추가해야하는 토큰을 볼 수 있습니다. 어딘가에 저장하고 `Done`를 누르세요:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\n그런 다음 구독자를 추가하려면 `Subscribe`을 누르세요:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\n원하는 구독자를 선택하고 지침을 따르세요.\\n\\n이제 홈 어시스턴트에서 컴퓨터의 구성을 편집해야합니다. `homeassistant` 사용자가 `configuration.yaml` 파일을 엽니다:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\n다음 줄을 추가하세요:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\n`automation:` 라인 다음에 새로운 자동화를 추가하세요:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\n이 자동화는 `binary_sensor.contact_sensor_contact`의 상태가 `off`에서 `on`으로 변경될 때 메시지 `Door was changed to on/off`를 보냅니다.\\n\\n그리고 홈 어시스턴트를 다시 시작하세요:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"324e9e0e12a98b1b0f3f18b932480181\",\"title\":\"책임\",\"path\":\"/docs/ko/liability/\",\"content\":\"\\n로봇을 경제 주체로 전환하기 위해서는 이를 위한 계약 도구가 필요합니다. Liability - Robonomics 팔렛은 파라체인 계정 간의 계약을 구현합니다!\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  이 튜토리얼은 Robonomics Node의 로컬 인스턴스에서 설명됩니다. [이 지침](/docs/run-dev-node)을 사용하 자체 인스턴스를 설정하세요.\\n\\n</robo-wiki-note>\\n\\n## 이론 개요\\n\\nEthereum에서는 책임 상호작용의 복잡한 구조가 있었습니다. [여기](/docs/robonomics-how-it-works)에서 확인할 수 있습니다. 하지만 Kusama에서는 조금 더 간단해졌습니다!\\n\\n### 협상\\n\\n계약을 체결하려면 양측이 먼저 협상해야 합니다. 이는 [IPFS PubSub ](https://blog.ipfs.tech/25-pubsub/) 또는 Robonomics PubSub를 포함한 여러 가지 방법으로 수행될 수 있습니다. Robonomics PubSub를 사용하는 Python 코드 샘플은 다음과 같습니다.\\n[여기](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub)에 제시되어 있습니다.\\n\\n제안과 수요는 계약의 두 가지 주요 특성인 **작업 설명**과 **가격**을 포함하는 메시지입니다. 메시지 형식은 각 특정 응용 프로그램에 대해 사용자가 설계해야 합니다. 협상 과정에서 엄격한 형식 규칙을 따르는 것은 그다지 중요하지 않습니다. 가능한 흐름은 아래 그림에 나와 있습니다.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  PubSub은 개방형 프로토콜이므로 중요한 데이터를 전송해서는 안 됩니다. 이를 위해 다른 프로토콜을 사용해야 합니다.\\n\\n</robo-wiki-note>\\n\\n\\n### 서명\\n\\n협상이 성공적으로 끝나면 양측은 소위 서명이라는 합의에 서명해야 합니다. 계정의 개인 키로 서명된 **특정 형식**의 직무 설명 및 가격이 포함된 메시지입니다. \\n이를 위한 [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability)도 있습니다.\\n - 작업 설명은 **기술**이라고 합니다. 이는 인코딩된 IPFS CID일 수 있는 32바이트 길이의 문자열입다.\\n - 가격은 **경제학**이라고 합니다. 이는 XRT 소수점 - Weiner입니다. 1 Weiner = 10**-9 XRT입니다.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  [IPFS](https://ipfs.tech/) CID를 올바른 방식으로 포맷팅된 상태로 얻으려면 [Python 라이브러리](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes)를 사용할 수 있습니다.\\n  `sign_liability` 함수를 사용할 때 해시를 변환할 필요가 없으며, 자동으로 수행됩니다.\\n\\n</robo-wiki-note>\\n\\n커피 예제를 따라하면서:\\n\\n1. 작업은 JSON입니다.\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. 해당 작업의 IPFS CID는 `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`입니다.\\n3. 따라서 **기술** (변환된 CID)은 `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9`입니다. \\n4. **경제학**은 `1.5 XRT`입니다.\\n\\n서명이 완료되면 책임을 생성할 시간입니다! 이는 약속자 또는 약속받은 측 또는 이를 위한 제3자 계정에 의해 수행될 수 있습니다.\\n\\n## 책임 생성\\n\\n### 준비\\n\\n이전에 언급했듯이, 이 과정에는 적어도 두 가지 측이 관련됩니다. 이 예제에서는 세 가지 측을 사용하고 이를 위한 별도의 제공자를 만들어 보겠습니다. 협상이 이미 어떤 방식으로든 진행되었다고 가정합니다.\\n\\n### 1. 세 개의 계정을 생성하고 자금을 추가하세요.\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\n여기에서는 제공자에게 100 XRT를 책임 서명을 위해 제공하고, 약속받은 측에게는 작업에 대한 지불을 위해 2 XRT를 제공했습니다.\\n약속자에게는 자금이 부여되지 않았습니다 (최소 1 mXRT의 존재 예치금을 제외하고).\\n\\n### 1. Developer -> Extrinsics로 이동하세요\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. 가능한 외부 항목 드롭다운 목록에서 liability -> create를 선택합니다.\\n\\n또한 extrinsic을 제출할 계정을 선택하세요. 모든 매개변수를 입력하세요.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  여기에서는 제공자를 사용하므로 참가자의 시드를 알 필요가 없습니다. 그들의 서명만 필요합니다.\\n\\n</robo-wiki-note>\\n\\n### 3. 거래 제출\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. 이벤트에서 책임을 검토하세요.\\n\\n이를 위해 `Network -> 탐색하기r`로 이동하여 오른쪽에 이벤트 목록을 찾으세요. 삼각형 아이콘을 클릭하여 확장하세요.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  해시는 동일한 [Python 도구](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash)를 사용하여 IPFS CID로 변환될 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n### 5. 스토리지 탐색\\n\\n스토리지 모듈 `liability`에서 책임의 일부 특성을 탐색할 수도 있습니다.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  `Next Index` 스토리지 함수는 최신 책임 인덱스 +1을 표시합니다. 따라서 `1`이지만 책임 `0`이 탐색됩니다.\\n\\n</robo-wiki-note>\\n\\n## 보고서\\n\\n커피가 만들어졌고 이제 커피 머신이 어떻게 보고해야 할지 생각해보세요. 이때 책임 보고서가 등장합니다. 노동의 증거로 계정은 기존 책임을 최화할 때 다른 IPFS CID를 보고 내용으로 추가합니다. 이는 다시 약속자의 서명이 필요합니다.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  서명된 메시지는 기존의 책임 지수와 32바이트 표현으로 인코딩된 보고서 IPFS CID를 포함합니다. 다시 말해서, [Python 도구](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report)를 사용하여 보고서에 서명하는 데 도움을 받을 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n커피 머신 예제를 계속 사용하면서:\\n\\n1. 보고서는 JSON 형식입니다.\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. 보고서의 IPFS CID는 `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`입니다.\\n3. 따라서 **페이로드**(변환된 CID)는 `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2`입니다.\\n4. **인덱스**는 `0`이며, 기존의 책임 지수입니다.\\n\\n### 1. extrinsics로 이동하여 liability -> finalize(report)로 이동합니다.\\n\\n매개변수를 입력하고 외부 항목을 제출합니다. 이 작업은 제3자 계정을 통해 수행될 수도 있습니다.\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  promisor 계정이 \\\"죽은\\\" 상태가 아니어야 함에 유의하세요 - 최소 1 mXRT의 존재 예치금이 있어야 합니다.\\n\\n</robo-wiki-note>\\n\\n보고서에 서명하고 제출하세요. 완료되면 이벤트에서 확인할 수 있습니다.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. 보고서 탐색\\n\\n저장소에서 보고서를 확인할 수도 있습니다. `Developer -> Storage`로 이동하고 드롭다운 목록에서 `liability`를 선택하세요.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. 잔액 확인\\n\\n사진에서 보듯이, 현재 promisor가 \\\"급여\\\"를 받았습니다. 경제적인 관계가 형성되었습니다!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  현재 작업이 완료되었는지 확인할 방법은 없으므로, promisor가 보고서를 제출하면 토큰이 해당 계정으로 이체됩니다. \\n  검증 기능은 향후 추가될 예정입니다.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"1ac6d095741e3f2f35539606e8944e31\",\"title\":\"시작\",\"path\":\"/docs/ko/launch/\",\"content\":\"\\n**Robonomics 파라체인의 또 다른 기본 기능은 시작 팔레트입니다. 이를 통해 계정/그 뒤에 있는 모든 개체에 명령을 보낼 수 있습니다. 이 명령에는 실행할 작업을 지정하는 매개변수가 포함됩니다.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  이와 다음 튜토리얼은 Robonomics 노드의 로컬 스턴스에서 설명됩니다. [이 지침](/docs/run-dev-node)을 사용하여 자신의 인스턴스를 설정하세요.\\n\\n</robo-wiki-note>\\n\\n## 1. Developer -> Extrinsics 이동하세요\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. 가능한 엑스트린식 목록의 드롭다운 목록에서 launch -> launch 선택하세요\\n\\n또한 엑스트린식을 제출할 계정을 선택하세요. 대상 주소와 매개변수 필드를 작성하세요.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  실행는 32바이트 길이의 문자열을 명령으로 지원합니다([출처](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)).\\n  그래서 여기서 즉흥적으로 할 수 있는 여지가 있습니다:\\n  - 토글과 같은 기본 명령의 경우 \\\"0x000000000000000000000000000000000000000000000000000000000000001\\\"을 사용할 수 있습니다.\\n  \\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\".\\n  - json과 같은 고급 명령의 경우 [IPFS](https://ipfs.tech/) 형식의 CID를 사용할 수 있습니다.\\n  [적절한 방법](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. 거래 제출\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. 이벤트에서 시작 내용 검토\\n\\n이를 위해 *Network -> 탐색하기r*로 이동하여 오른쪽에서 이벤트 목록을 찾으세요. 확장하려면 삼각형 아이콘을 클릭하세요.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"8bd59a2b686ed055bdc759701594dc37\",\"title\":\"로보노믹스 콜레이터 노드 버전 업데이트 방법\",\"path\":\"/docs/ko/how-to-update-collator-node-version/\",\"content\":\"\\n이 게시물을 읽기 전에 다음 기사를 읽는 것을 권장합니다: [\\\"콜레이터 노드 빌드 방법\\\"](/docs/how-to-build-collator-node) 및 [\\\"로보노믹스 콜레이터 시작 방법\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\n기사에는 로보노믹스 콜레이터 노드를 업데이트하는 데 필요한 명령어와 그 이후의 예제가 포함되어 있습니다.\\n\\n## **필수 명령어**\\n\\n0. 시작하기 전에 `root`로 로그인하는 것이 좋습니다. 그렇지 않으면 다음을 사용하는 것을 권장합니다:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. 로보노믹스 서비스를 중지합니다:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. 이전 버전의 로보노믹스를 제거합니다 (올바른 디렉토리에 있는지 확인하세요):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. [최신 릴리스](https://github.com/airalab/robonomics/releases) 버전의 로보노믹스를 가져옵니다:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. 파일을 추출합니다:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. 파일을 이동합니다:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\n이 파일을 로보노믹스 노드를 설치한 올바른 디렉토리로 이동해야 합니다)\\n\\n</robo-wiki-note>\\n\\n6. 로보노믹스를 시작합니다:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\n콜레이터 노드를 로보노믹스 v1.8.4로 업그레이드하는 예제:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **베이스 경로가 설정되지 않은 쿠사마 릴레이 체인 데이터베이스 변경**\\n\\n쿠사마 릴레이 체인의 특정 스냅샷은 노드에 오류를 발생시킬 수 있습니다. 이로 인해 노드가 작동을 멈출 수 있습니다. 손상된 릴레이 체인 데이터베이스로 인한 예제 오류:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\n이 오류를 수정하려면 기존의 쿠사마 릴레이 체인 데이터베이스 (일반적으로 RocksDb)를 제거하고 ParityDb와 같은 다른 Db로 대체해야 합니다. 다음 명령어를 실행하세요:\\n\\n1. 로보노믹스 노드 디렉토리를 찾고 파일을 확인합니다:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. polkadot 디렉토리를 확인한 후 chains 디렉토리로 이동합니다:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. `ksmcc3` 디렉터리를 삭제합니다.\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. 새로운 `ksmcc3` 디렉토리를 만듭니다.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. 이제 새로운 스냅샷을 다운로드해야 합니다. 이 예제에서는 크게 가지치기된 릴레이 체인 스냅샷을 사용하지만 원하는 스냅샷으로 교체할 수 있습니다.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. 스냅샷이 다운로드되는 동안 새 세션을 열고 서비스 파일을 편집합니다:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\n데이터베이스와 가지치기와 관련된 서비스 파일 내의 줄을 수정합니다:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\n`Ctrl + S`를 누르고 `Ctrl + X`를 눌러 서비스 파일을 저장하고 종료합니다.\\n\\n7. 이제 데몬을 다시로드해야 합니다.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. 이 시간에 다른 세션에서 새로운 Db가 다운로드되었는지 확인합니다. 그런 다음 파일을 추출합니다:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. 압축 해제가 완료되면 다음을 실행합니다:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. 이제 서비스를 시작하고 오류를 모니터링하고 릴레이 체인과 파라체인 모두에서 피어링되는지 확인할 수 있습니다.\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"75916d0c7d87f689264e9c0544a7f5b6\",\"title\":\"로보노믹스 콜레이터를 시작하는 방법\",\"path\":\"/docs/ko/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  이 문서의 스크린 캐스트와 스크린샷에서는 Robonomics의 버전 1.4.0을 사용했습니다. 동일한 명령을 사용하지만 Robonomics의 버전을 현재 버전으로 바꿔야 합니다.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\n현재 로보노믹스 네트워크는 주로 초기 개발자들에 의해 유지되고 있지만, 누구나 프로젝트를 지원할 수 있습니다. 블록체인의 추가적인 전체 노드는 블록체인이 더욱 지속 가능하고 장애 허용성이 높아지도 도와줍니다. 로보노믹스 노드 이진 파일은 [릴리즈](https://github.com/airalab/robonomics/releases) 자산에서 사용할 수 있거나 [소스에서 빌드](/docs/how-to-build-collator-node/)할 수 있습니다.\\n\\n## 콜레이터란 무엇인가요\\n\\n콜레이터는 로보노믹스 파라체인의 일부입니다. 이 유형의 노드는 로보노믹스 체인을 위해 새로운 블록을 생성합니다.\\n\\n>콜레이터는 사용자로부터 파라체인 트랜잭션을 수집하고 Relay Chain 검증자를 위해 상태 전이 증명을 생성하여 파라체인을 유지합니다. 다시 말해, 콜레이터는 파라체인 트랜잭션을 파라체인 블록 후보로 집계하고 해당 블록을 기반으로 검증자를 위한 상태 전이 증명을 생성하여 파라체인을 유지합니다.\\n\\n관련된 [Polkadot 위키 페이지](https://wiki.polkadot.network/docs/learn-collator)에서 콜레이터에 대해 더 자세히 알아볼 수 있습니다.\\n\\nRobonomics 파라체인에서 모든 대조자는 대조자가 구축하는 모든 블록에 대해 (**0.001598184 XRT**)의 보상을 받습니다(보상은 블록이 체인에 봉인될 때 발생합니다).\\n또한 블록을 구축하는 콜레이터는 생성한 블록에 포함된 **거래 수수료의 50%**를 받습니다.\\n\\n## 요구 사항\\n\\n콜레이터를 시작할 때 [Polkadot 검증자](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware)를 위한 **표준 하드웨어 요구 사항**을 사용하는 것이 좋습니다:\\n+ x86-64 호환.\\n+ Intel Ice Lake 또는 이후 (Xeon 또는 Core 시리즈); AMD Zen3 또는 이후 (EPYC 또는 Ryzen).\\n+ 물리적인 코어 4개 @ 3.4GHz.\\n+ 동시 멀티스레딩 비활성화 (Intel의 Hyper-Threading, AMD의 SMT).\\n+ 저장소 - 1TB의 NVMe SSD (블록체인 성장을 처리하기에 적당한 크기여야 함).\\n+ 메모리 - 32GB DDR4 ECC\\n\\n\\n이 문서에서는 다음 사양을 사용합니:\\n+ 4 vCPU\\n+ 콜레이터의 데이터베이스에 700GB의 NVMe 공간. 이 디스크 공간을 확장할 수 있는 능력이 필요합니다.\\n+ 8GB RAM\\n\\n\\n## 중요한 정보\\n1. 이 지침에서는 몇 가지 변수를 사용하며, 모든 명령에서 자체 값을 대체해야 합니다:\\n    + **%NODE_NAME%**은 노드 이름입니다. 예: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%**는 마운트된 볼륨의 경로입니다. 예: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%**는 Polkadot 생태계의 SS58 형식의 계정 주소입니다. 예: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. 콜레이터의 서비스 시작에 *--state-cache-size=0*를 포함해야 합니다. 이 매개변수는 콜레이터의 안정성에 중요합니다.\\n관련된 [이슈](https://github.com/airalab/robonomics/issues/234)에서 더 많은 정보를 볼 수 있습니다.\\n\\n## 로보노믹스 콜레이터를 쉽게 시작하기\\n\\n명령줄에서 직접 콜레이터를 시작하여 오류를 확인할 수 있습니다.\\n이 작업을 수행한 후 로보노믹스 콜레이터를 서비스로 시작하는 것이 강력히 권장됩니다 (다음 단계 참조).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## 로보노믹스 콜레이터를 서비스로 시작하기\\n\\n1. 홈 디렉토리를 가진 서비스용 사용자를 생성합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. 로보노믹스 진 파일을 다운로드하고 압축을 해제한 후 */usr/local/bin/* 디렉토리로 이동합니다. 이 섹션의 명령에서 *$ROBONOMICS_VERSION*을 현재 로보노믹스 버전으로 대체해야 합니다. 현재 버전은 [github의 Robonomics 저장소의 릴리즈 페이지](https://github.com/airalab/robonomics/releases)에서 확인할 수 있습니다.\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. *robonomics.service*라는 systemd 서비스 파일을 생성합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    그리고 서비스 파일에 다음 줄을 추가합니다.\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. 이 파일을 저장한 후 서비스를 활성화하고 시작합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n텔레메트리 URL: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nCollator 로그는 `journalctl -u robonomics.service -f`를 사용하여 모니터링할 수 있습니다.\\n\\nRobonomics collator가 시작되면 Kusama Relay Chain과 동기화되기 시작합니다. 이는 네트워크 속도 및 시스템 사양에 따라 상당한 시간이 걸릴 수 있으므로 Kusama 스냅샷을 다운로드하는 것이 좋습니다.\\n\\n\\n## Kusama 스냅샷을 사용하여 동기화 프로세스 가속화\\n\\n로보노믹스 서비스를 생성하고 시작한 후에 즉시 이 작업을 수행하는 것이 좋습니다. 스냅샷 및 사용 지침에 대한 자세한 정보는 다음 페이지에서 확인할 수 있습니다: https://ksm-rocksdb.polkashots.io/\\n\\n지침:\\n\\n1. 로보노믹스 서비스를 중지하고 현재 Kusama 데이터베이스 디렉토리를 제거합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. 실제 스냅샷을 다운로드하고 압축을 해제합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    성공적으로 압축을 푼 후 다운로드한 아카이브를 제거할 수 있습니다.\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. 데이터베이스 폴더에 올바른 소유권을 설정합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. 로보노믹스 서비스를 다시 시작합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. 서비 로그를 확인합니다.\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## 문제 해결\\n### 오류: \\\"State Database error: Too many sibling blocks inserted\\\"\\n이 오류를 수정하려면 보관 모드에서 대조기를 실행하면 됩니다.\\n\\n1) 먼저, 로보노믹스 서비스를 중지해야 합니다. \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) 그런 다음 서비스 파일의 파라체인 부분에 `--state-pruning=archive` 매개변수를 추가하십시오. 편집된 서비스 파일의 예시:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) systemd 관리자 구성을 다시로드하십시오.\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) 기존의 파라체인 데이터베이스를 제거하십시오.\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) 로보노믹스 서비스를 시작하십시오.\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    그 후에는 파라체인 데이터베이스의 동기화를 기다려야합니다.\\n\\n### 오류: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\n이 오류는 가상화 매개변수와 관련이 있습니다. 에뮬레이션된 프로세서의 \\\"host-model\\\" 유형을 사용해야합니다. 이를 가상화 호스트에서 설정할 수 있습니다.\\n\\n그러나 호스팅에서 이 오류를 만나면 기술 지원에게 이 문제에 대해 문의해야합니다.\\n\"}},{\"node\":{\"id\":\"d68cdd274b6e4131345ca57917c515d8\",\"title\":\"홈 어시스턴트 OS 업그레이드\",\"path\":\"/docs/ko/hass-os-upgrade/\",\"content\":\"\\n**이 문서에는 Robonomics 통합을 사용하여 기존의 홈 어시스턴트 OS를 업그레이드하는 지침이 포함되어 있습니다.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## 설치 IPFS Add-on\\n\\n\\nRobonomics 통합은 로컬 IPFS 데몬을 사용하여 데이터를 저장하므로 먼저 설치해야 합다. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. 홈 어시스턴트용 [IPFS 애드온](https://github.com/airalab/ipfs-addon)이 있습니다. `Settings` -> `Add-ons`으로 이동하여 오른쪽 하단의 `ADD-ON STORE` 버튼을 누르면 설치할 수 있습니다.\\n\\n2. 오른쪽 상단의 세 개의 점을 누르고 `Repositories`를 선택합니다. 다음 링크를 추가합니다:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. `ADD` 버튼을 누릅니다.\\n\\n4. 저장소 관리자를 닫고 페이지를 새로 고칩니다. 이제 페이지 끝에 IPFS 데몬 애드온이 표시됩니다.\\n\\n5. 애드온을 열고 `INSTALL`를 누릅니다. 설치가 완료되면 `START`을 누릅니다.\\n\\n## HACS 설치\\n\\n[홈 어시스턴트 커뮤니티 스토어 (HACS)](https://hacs.xyz/)를 사용하면 사용자 정의 통합을 설치할 수 있습니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. 시작하기 전에 SSH를 사용하여 홈 어시스턴트 장치에 연결하는 애드온을 설치해야 합니다. 애드온 스토어에서 `ssh`를 검색합니다. `SSH & Web Terminal` 애드온을 설치하는 것을 권장합니다.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  SSH 애드온을 찾을 수 없는 경우 사용자 프로필 설정에서 고급 모드를 활성화해 보십시오. 이를 위해 왼쪽 하단의 프로필 아이콘을 클릭하고 고급 모드 옵션을 찾으십시오.\\n\\n</robo-wiki-note>\\n\\n2. 애드온을 선택하고 `INSTALL`를 누릅니다. 설치가 완료되면 `구성` 탭으로 이동하여 `password` 또는 `authorized_keys`를 추가합니다. 이 구성 부분을 저장하는 것을 잊지 마십시오.\\n\\n3. `Info` 탭에서 `START`을 누릅니다. 사이드바에 애드온을 표시하려면 `Show in sidebar`를 활성화하는 것을 잊지 마십시오. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. SSH 애드온을 열고 다음 명령을 실행합니다:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. 홈어시스턴트를 다시 시작하세요(`Settings`->`System`에서 할 수 있습니다). \\n\\n6. 이제 HACS 통합을 `Integrations` 메뉴에 추가할 수 있습니다. `Settings`->`Devices & Services`로 이동하여 `Add Integration`를 누르고 HACS를 찾습니다.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  HACS를 사용하려면 Github 계정이 필요합니다.\\n\\n</robo-wiki-note>\\n\\n7. 클릭한 후 설치 지침을 따릅니다. \\n\\n## Robonomics 통합 설치\\n\\n이제 HACS를 사용하여 Robonomics 통합을 설치할 수 있습니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\n사이드바 메뉴에서 HACS를 열고 `Integrations`으로 이동합니다. `탐색하기 & Download Repositories`를 클릭한 다음 `Robonomics`를 검색하고 오른쪽 하단에 있는 `Download` 버튼을 클릭합니다. 다운로드가 완료되면 홈 어시스턴트를 다시 시작하십시오.\"}},{\"node\":{\"id\":\"37a93f7b7837a176d25ba5f7dfea0d07\",\"title\":\"소스에서 콜레이터 노드를 빌드하는 방법\",\"path\":\"/docs/ko/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  이 문서의 스크린 캐스트와 스크린샷에서는 Robonomics의 버전 1.4.0을 사용했습니다. 동일한 명령을 사용하지만 Robonomics의 버전을 현재 버전으로 바꿔야 합니다.\\n</robo-wiki-note>\\n\\n## 콜레이터란 무엇인가요\\n\\n콜레이터는 Robonomics 파라체인의 일부입니다. 이 노드 유형은 체인에 새로운 블록을 생성합니다..\\n\\n>콜레이터는 사용자로부터 파라체인 트랜잭션을 수집하고 Relay Chain 검증자를 위해 상태 전이 증명을 생성하여 파라체인을 유지합니다. 다시 말해, 콜레이터는 파라체인 트랜잭션을 파라체인 블록 후보로 집계하고 해당 블록을 기반으로 검증자를 위한 상태 전이 증명을 생성하여 파라체인을 유지합니다.\\n\\n관련 [Polkadot 위키 페이지](https://wiki.polkadot.network/docs/learn-collator)에서 콜레이터에 대해 더 자세히 알아볼 수 있습니다.\\n\\nRobonomics 파라체인에서 모든 대조자는 자신이 만든 모든 블록에 대해 보상(**0.000380520 XRT**)을 받습니다(이 블록이 체인에 봉인된 경우).\\n또한 대조자는 이 블록에서 **50% 거래 수수료**를 받습니다.\\n\\n## 빌드 과정\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nRust와 관련 지원 소프트웨어가 설치되어 있는지 확인하세요. Rust 설치 프로그램에서 현재 설치 옵션에 대해 물어볼 것이며, '1) 설치 진행 (기본값)' 옵션을 선택해야 합니다.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![설치 Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\n필요한 nightly toolchain과 wasm target을 설치하세요.\\n다음 명령은 Robonomics v2.6.0에 대해 적용됩니다.\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\n또한 다음 패키지를 설치해야 합니다.\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\n이제 git 소스에서 robonomics 노드를 설치할 수 있습니다.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\n이 명령을 실행하면 컴파일된 robonomics 이진 파일이 '~/.cargo/bin' 디렉토리에 생성됩니다.\\n\\n다음 단계는 콜레이터 노드를 실하는 방법입니다. [\\\"Robonomics 콜레이터를 실행하는 방법\\\"](/docs/how-to-launch-the-robonomics-collator) 문서에서 자세히 읽을 수 있습니다.\"}},{\"node\":{\"id\":\"f5ea00f2353eb29e962bc571aaab59cf\",\"title\":\"홈 어시스턴트 초기화\",\"path\":\"/docs/ko/hass-init/\",\"content\":\"\\n**홈 어시스턴트를 설치한 후 초기화해야 합니다.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\n홈 어시스턴트의 소유자 계정 생성으로 시작합니다. 이 계정은 관리자이며 모든 변경 사항을 수행할 수 있습니다. 웹 브라우저를 열고 `http://%RASPBERRY_IP_ADDRESS%:8123`로 이동하세요. 라즈베리 파이의 IP 주소는 [Fing 모바일 앱](https://www.fing.com/products) 또는 [nmap CLI 도구](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)를 사용하여 확인할 수 있습니다.\\n\\n<robo-wiki-note type=\\\"note\\\">라즈베리 파이 주소는 시간이 지남에 따라 라우터 설정에 따라 변경될 수 있습니다.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. 첫 페이지에서 이름, 사용자 이름, 비밀번호를 입력하고 `CREATE ACCOUNT` 버튼을 클릭하세요.\\n\\n2. 다음 화면에서 집 이름을 입력하고 위치와 단위 시스템을 설정하세요. 위치를 찾고 해당 위치를 기반으로 시간대와 단위 시스템을 설정하려면 `DETECT`을 클릭하세요. 위치를 보내고 싶지 않은 경우 이 값을 수동으로 설정할 수 있습니다.\\n\\n3. 그 후, 홈 어시스턴트는 네트워크에서 발견한 장치를 표시합니다. 아래에 표시된 것보다 적은 항목이 표시되더라도 걱정하지 마세요. 나중에 장치를 수동으로 추가할 수 있습니다. 지금은 `FINISH`를 클릭하고 주 홈 어시스턴트 화면으로 이동하세요.\\n\\n4. 마지막으로, 홈 어시스턴트 웹 인터페이스가 표시되며 모든 장치가 표시됩니다. \\n\\n\\n## 문제 해결\\n\\n1. 로컬 사용자의 로그인 또는 비밀번호를 잊어버린 경우, [이 문서](https://www.home-assistant.io/docs/locked_out/)를 확인하여 자격 증명을 복원하세요.\\n\"}},{\"node\":{\"id\":\"a38471ee4f6ef41a0a2f5874624ae460\",\"title\":\"라즈베리 파이용 사전 설치 이미지\",\"path\":\"/docs/ko/hass-image-install/\",\"content\":\"\\n**라즈베리 파이에 Robonomics 통합을 사용하여 Home Assistant를 설치하는 가이드에 오신 것을 환영합니다. Home Assistant는 오픈 소스 홈 자동화 시스템으로, 가정 네트워크에서 스마트 기기를 제어하기 위한 중앙 허브를 공합니다. Robonomics와 통합함으로써 분산 클라우드 서비스를 활용하여 스마트 홈의 기능과 보안을 향상시킬 수 있습니다. 이 글에서는 라즈베리 파이에 Home Assistant와 Robonomics를 설치하는 단계별 지침을 제공하며, 안전하고 분산된 솔루션을 사용하여 가정의 다양한 측면을 자동화하고 제어할 수 있습니다. 시작해 봅시다!**\\n\\n## 설치에 필요한 하드웨어\\n\\n이미 Home Assistant를 스마트 홈 설정에 통합하지 않았다면, 처음부터 완전한 스마트 홈 시스템을 구축하기 위해 필요한 장비를 알고 있어야 합니다.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>라즈베리 파이 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Robonomics 사전 설치 이미지 다운로드\\n\\nRobonomics 사전 설치 이미지에는 다음이 포함되어 있습니다.\\n- Home Assistant Core\\n- IPFS\\n- MQTT 브로커 및 통합\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\n[GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)에서 소스 코드를 확인하고 최신 릴리스 이미지를 다운로드할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n\\n## 2. 이미지 구성\\n\\n컴퓨터에 [라즈베리 파이 Imager](https://www.raspberrypi.com/software/)를 설치하고 SD 카드를 삽입하세요.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nRaspberry Pi Imager 프로그램을 실행합니다. 필요한 이미지를 운영 체제로 선택하고 저장소 드롭다운 메뉴에서 SD 카드를 선택했는지 확인하세요. \\n설정에서 다음을 수행하세요:\\n- 사용자 이름과 비밀번호 설정(기본 사용자 이름 \\\"pi\\\"를 기억하기 쉽게 저장),  \\n- Wi-Fi 이름과 비밀번호 제공, \\n- 드롭다 목록에서 국가 선택\\n그리고 이미지를 `Write`하세요. \\n                   \\n<robo-wiki-note type=\\\"note\\\">사용자 이름과 비밀번호를 주의깊게 저장하세요. 문제 해결 시 이 자격 증명이 필요합니다.</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\n국가 코드는 [여기](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)에서 확인할 수 있습니다.\\n\\n## 3. 첫 번째 부팅\\n\\n**SD 카드를 안전하게 추출한 다음**, 라즈베리 파이에 삽입하세요. 그런 다음 라즈베리 파이에 **Zigbee 어댑터를 삽입하세요.**\\n\\n<robo-wiki-note type=\\\"warning\\\">라즈베리 파이를 처음 시작하기 전에 Zigbee 어댑터를 삽입하는 것이 중요합니다! \\nZigbee 네트워크의 자동 구성을 위해 필요합니다.</robo-wiki-note>\\n\\n**[JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en)(필요한 모든 펌웨어가 있는 어댑터)를 사용하는 경우, 이 지침을 따르기만 하면 됩니다. 그러나 다른 어댑터를 사용하는 경우, 먼저 Zigbee2MQTT 소프트웨어로 플래시해야 합니다. 디바이스에 대한 지침은 [여기](https://www.zigbee2mqtt.io/information/supported_adapters.html)에서 찾을 수 있습니다.**\\n\\n그런 다음 전원 케이블을 장치에 연결하세요. 장치는 Wi-Fi 네트워크에 연결해야 합니다. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nRaspberry Pi가 연결되면 빨간색 LED가 켜지고 녹색 LED가 잠시 동안 깜박입니다. Raspberry Pi가 부팅되고 네트워크에 등록될 때까지 최대 5분 정도 기다립니다.\\n\\n이제 라즈베리 파이의 IP 주소를 찾으세요. [Fing 모바일 앱](https://www.fing.com/products)이나 \\n[nmap CLI 도구](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)를 사용하여 찾을 수 있습니다. IP 목록에서 `robots-home`(옵션 이름은 `Home(homeassistant)`일 수 있음) \\n호스트 머신의 이름을 찾으세요. \\n\\n이 예제에서 주소는 `192.168.43.56`입니다. \\n\\n모든 것이 작동하는지 확인하려면 웹 브라우저를 열고 웹 페이지 `http://%RASPBERRY_IP_ADDRESS%:8123`로 이동하세요. 이 예제에서는 `192.168.43.56:8123`입니다.\\n모든 것이 정상이면 Home Assistant 웹 인터페이스가 표시됩니다. 웹 페이지가 열리지 않으면 라즈베리 파이가 부팅되기까지 최대 5분 동안 기다렸다가 다시 시도하세요. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## 문제 해결\\n\\n1. 나중에 Wi-Fi 설정을 변경하려면 `ssh` 명령을 사용하여 라즈베리 파이에 로그인해야 합니다. 이를 위해 컴퓨터에서 터미널을 열고\\n\\\"이미지 구성\\\" 단계에서 생성한 사용자 이름과 함께 ssh 명령을 입력하세요(기본값은 \\\"pi\\\"입니다). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\n그런 다음 `sudo raspi-config` 명령을 사용하세요. 이 명령에 대한 자세한 정보는 [공식 사이트](https://www.raspberrypi.com/documentation/computers/configuration.html)에서 확인할 수 있습니다.\\n\"}},{\"node\":{\"id\":\"7be9b04a4c23b7af12fe7a3cbd0506f5\",\"title\":\"Unix-like OS에서 Home Assistant Docker를 업그레이드하세요\",\"path\":\"/docs/ko/hass-docker-upgrade/\",\"content\":\"\\n**이 문서에는 Robonomics 통합을 사용하여 기존의 Home Assistant Docker(Unix-like OS에서)를 업그레이드하는 지침이 포함되어 있습니다.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Home Assistant의 기본 Docker 이미지와 컨테이너 이름이 <u>homeassistant</u>로 가정됩니다.\\n  2. IPFS가 호스트 머신에서 <u>systemd</u> 서비스로 설치되고 실행됩니다.\\n  3. [Python3.9](https://www.python.org/downloads/) 이상이 설치되어 있다고 가정합니다.\\n\\n</robo-wiki-note>\\n\\n## 설치\\n\\n설치 스크립트를 다운로드하고 터미널에서 실행하십시오:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\n다음 출력이 표시됩니다:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  `mkdir: can't create directory 'custom_components': File exists`와 같은 오류가 표시될 수 있습니다. 이는 이미 일부 사용자 정의 구성 요소가 있는 이 폴더가 이미 존재한다는 것을 의미합니다. 이 메시지를 무시하십시오.\\n\\n</robo-wiki-note>\\n\\n컨테이너 재시작:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## 확인\\n\\nIPFS 서비스가 실행 중인지 확인하십시오.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\n다음 출력이 표시됩니다:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"c8ff746d8aeb67068dce8f6b59d5a912\",\"title\":\"글로벌 관리\",\"path\":\"/docs/ko/global-administration/\",\"content\":\"\\n**이 문서에서는 Home Assistant에 새 사용자를 설정하는 방법을 안내합니다.**\\n\\n## 구독에 사용자 추가하기\\n\\nHome Assistant를 처음 시작할 때 생성한 계정은 `SUB_OWNER` 및 `SUB_CONTROLLER`가 보안을 제공하기 때문에 사용할 수 없습니다. Robonomics Parachain 계정이 없는 첫 번째 사용자니다.\\n\\n1. [이전 문서](/docs/sub-activate/)에서와 같이 Robonomics Parachain에 계정을 생성하세요.\\n\\n2. `SUB_OWNER` 계정을 사용하여 [dapp](https://dapp.robonomics.network/#/subscription/devices)에서 구독에 새 사용자 계정을 추가하세요. 이제 액세스 목록에는 `SUB_OWNER`, `SUB_CONTROLLER` 및 `USER` 세 개의 주소가 있어야 합니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## 사용자에게 액세스 권한 부여하기\\n\\n1. [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant)라는 dapp 서비스로 이동하세요. 오른쪽 사이드바에서 방금 생성한 계정을 선택하세요 (프로필 아이콘을 눌러 의도한 계정을 선택했는지 확인하세요).\\n\\n2. 필요한 필드에 `USER` 시드를 입력하세요. 관리자 크레딧 필드에 `SUB_OWNER` 및 `SUB_CONTROLLER` 주소를 추가하세요. 모든 것이 올바르면 확인 상태가 `VERIFIED`로 표시됩니다.\\n\\n3. 방금 등록한 새 사용자를 위해 비밀번호를 생성한 다음 거래를 확인하세요. 이제 구독으로 인해 수수료가 없는 거래입니다. 나중에 복구 탭에서 비밀번호를 복원할 수 있습니다.\\n\\n4. 등록 프로세스가 완료되면 새로 생성한 비밀번호로 Home Assistant에 로그인하세요.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\n이제 Robonomics를 통해 집을 제어하기 위해 dapp을 사용할 수 있으며, [**\\\"스마트 홈 텔레메트리 가져오기\\\"**](/docs/smart-home-telemetry/) 문서를 확인하세요.\\n\\n## 문제 해결\\n\\n1. Robonomics 계정에서 홈어시스턴트 비밀번호를 잊어버린 경우 [Dapp을 확인하세요.](https://dapp.robonomics.network/#/home-assistant)\\n\\\"Your Home Assistant password\\\" 부분으로 이동하여 \\\"Restore\\\" 탭을 선택하세요.\\n\"}},{\"node\":{\"id\":\"969f759197728225835e0dbe30ae526d\",\"title\":\"홈 어시스턴트 코어 업그레이드하기\",\"path\":\"/docs/ko/hass-core-upgrade/\",\"content\":\"\\n**이 문서에는 Robonomics 통합을 사용하여 기존 홈 어시스턴트 코어를 업그레이드하는 지침이 포함되어 있습니다.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. 홈 어시스턴트 코어 설치가 [공식 지침](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core)에 따라 완료되었으며 <u>homeassistant</u> 사용자와 `venv` 환경이 있다고 가정합니다. 그렇지 않은 경우 아래 지침을 따르되, **스크립트를 적절히 편집**하십시오.\\n  2. IPFS가 호스트 머신에서 <u>systemd</u> 서비스로 설치되고 실행됩니다.\\n  3. [Python3.9](https://www.python.org/downloads/) 이상이 설치되어 있다고 가정합니다.\\n\\n</robo-wiki-note>\\n\\n## 설치하다\\n\\n설치 스크립트를 다운로드하고 터미널에서 실행하십시오:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\n다음 출력이 표시됩니다:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n이 과정에서 여러 서비스의 다시 시작을 확인하라는 메시지가 표시됩니다. 'tab'을 사용하여 탐색하면 `yes` 옵션이 선택됩니다.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  `mkdir: can't create directory 'custom_components': File exists`와 같은 오류가 표시될 수 있습니다. 이는 이미 일부 사용자 정의 구성 요소가 있는 이 폴더가 이미 존재한다는 것을 의미합니다. 이 메시지를 무시하십시오.\\n\\n</robo-wiki-note>\\n  \\n완료 후 홈 어시스턴트를 재시작하십시오.\\n\\n## 확인하다\\n\\nIPFS 서비스가 실행 중인지 확인하십시오.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\n다음과 같은 출력이 표시됩니다.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"4fa4ec657d7ea98af6d3de36f93f07db\",\"title\":\"시작하기\",\"path\":\"/docs/ko/getting-started/\",\"content\":\"\\n## 로보노믹스란\\n\\n로보노믹스 플랫폼은 로봇 경제 네트워크와 함께 작업하기위한 도구를 제공합니다. 로보노믹스는 스마트 시티 및 산업 4.0 지역의 디자이너들이 [자율 로봇 서비스](/docs/glossary#cyber-physical-system) 간의 신뢰를 구축하고 자율 공장 및 도시 센서 네트워크의 제품을 주문하기 위해 [직접 사용자 액세스를 제공](/docs/glossary#dapp)하는 데 도움이됩니다. 이를 통해 우리는 사이버 물리 시스템의 활동을 전 세계적으로 모니터링하는 탈중앙화 된 시스템을 구축 할 수 있습니다.\\n\\n다음 차트는 로보노믹스가 시나리오에서 차지하는 위치를 설명합니다:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\n[로보노믹스 덱에서 dApps 빌드](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)에서 자세한 내용을 찾을 수 있습니다.\\n\\n## 로보노믹스 네트워크 빠른 시작\\n**새로 온 사람들을 위해 핵심 로보노믹스 개발자들은 [6 가지 수업 학습 곡선](/docs/wschool2021-intro/)을 생각해 냈습니다!**\\n\\n서버리스 IoT 아키텍처를 탐색 할 것입니다! 로보노믹스 웹 서비스 (RWS)는 Polkadot && IPFS 위에 로봇 공학 및 IoT를위한 기본 인프라 서비스입니다.\\n\\n과정 수료자는 로컬 릴레이 체인을 시작하고 ROS 호환 장치를 교차 체인 트랜잭션을 통해 제어 할 수 있습니다.\\n\\n**[로보노믹스 개발자 디스코드에 참여](https://discord.gg/jTxqGeF5Qy)하여 커뮤니티와 기술 지원을 받으세요.**\\n\\n### 로보노믹스 아카데미 수료자를위한 혜택\\n- 최고의 학생들을 위한 인턴십   로보노믹스 팀원이 되어 선택한 제품의 개발에 기여하세요.\\n- 능동적인 커뮤니티 및 정기적인 이벤트   학습자 커뮤니티의 일원이 되어 산업 전문가와 사용 사례를 논의하세요. 팀을 구성하고 해커톤에 참여하세요!\\n- 료증   IoT용 DAPP 구축 과정 수료증을 포트폴리오에 추가하세요.\\n- ITMO 대학 입학 지원   학사 또는 석사, 대학 입학에 대한 지원을 받으세요.\\n- 자금 지원 및 가속화 기회: 1) 최대 $50,000 학문 - 지원금 신청; 2) Web3 Foundation이 지원하는 Robonomics 빌더 가속화 프로그램 참여; 3) Robonomics 위에 독립적인 DAPP 배포; 4) 이를 통한 수익 창출 및 Robonomics 팀의 마케팅 지원.\\n\\n\\n## 문서에는 무엇이 포함되어 있나요\\n\\n### 나는 Dapp 개발자입니다\\n\\n- [GitHub의 Robonomics-js](https://github.com/airalab/robonomics-js) - Robonomics Network dApp 개발자를 위한 간단한 Javascript SDK.\\n- [dApp 템플릿](https://github.com/airalab/vue-dapp-robonomics-template) - Vue.js 사용\\n- [위키 문서](/docs/robonomics-js/)\\n\\n### 나는 로봇공학 엔지니어이다\\n\\n[사례](/docs/iot-sensors-connectivity/) 섹션을 확인하고 [예제](/docs/agent-development-examples)를 통해 개발을 시작하세요.\\n\\n\"}},{\"node\":{\"id\":\"1dcdc26b50c57c8502d7e561c29d206b\",\"title\":\"Glossary\",\"path\":\"/docs/ko/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\n공개-사설 키 쌍의 결합, 그 중 공개 부분은 사용자의 공개 주소이고, 비공개 부분은 이 주소의 제어에 액세스하기 위한 비밀 키입니다.\\n\\n\\n### Auction (of Parachains)\\nPolkadot 및 Kusama 생태계에서 파라체인에 대한 슬롯 임대 메커니즘; 파라체인은 슬롯을 얻기 위해 촛불 경매에서 리해야 합니다.\\n\\n### Autonomous Agent\\n환경으로부터 감각 데이터를 수신하고 외부 자극에 대한 응답 방법을 결정하여 목표를 달성하기 위한 계산 시스템입니다.\\n\\n### AIRA\\n또는 AIRA — 2015년 Robonomics 팀에서 개발한 소프트웨어로, 지적 책임 계약을 통해 경제적인 인간-기계 및 기계-기계 상호작용의 표준을 구현합니다.\\n\\n\\n## B\\n\\n### Blockchain\\n넓은 의미에서 암호화폐를 사용하여 참가자 그룹이 시스템의 변화하는 상태에 대해 신뢰할 수 있도록 하는 분산 네트워크입니다.\\n\\n### Blockchain 탐색하기r\\n블록체인 (예: Etherscan, Subscan)에서 다양한 블록, 거래 및 주소를 탐색할 수 있는 애플리케이션입니다.\\n\\n### Blueprint (Hass)\\nHome Assistant 인스턴스에 쉽게 추가할 수 있는 미리 만들어진 자동화 로직입니다.\\n\\n### Bridge\\n경제적으로 주관적이고 기술적으로 다양한 체인 간의 상호작용을 위한 기술 및 방법입니다. \\n\\n\\n## C\\n\\n### Coase (XRT)\\n또는 Cs — XRT 토큰 1개의 백만분의 1 지분, 1 XRT = 1,000,000 Cs; 제도경제학의 창시자이자 노벨경제학상을 받은 영국 경제학자 로널드 코스(Ronald Coase)의 이름을 따서 명명되었습니다.\\n\\n### Collator\\n파라체인 트랜잭션을 수집하고 검증자를 위한 상태 전이 증명을 생성하여 파라체인을 유지하는 노드입니다.\\n\\n### Consensus\\n블록체인 네트워크의 노드가 네트워크 내 데이터의 현재 상태에 대한 합의에 도달하는 프로세스(예: 작업 증명, 지분 증명)입니다.\\n\\n### Crowdloan\\nPolkadot / Kusama 생태계의 슬롯 경매에 입찰하기 위해 토큰을 모으는 크라우드펀딩 캠페인니다.\\n\\n### Cybernetics\\nN. 위너의 정의에 따라 동물과 기계의 제어와 통신에 대한 연구입니다.\\n\\n### Cyber-Physical System\\n또는 CPS — 여러 계산, 네트워킹 및 물리적 프로세스의 강력한 통합 및 상호 통합입니다.\\n\\n\\n## D\\n\\n### DAO\\n블록체인으로 자원 관리가 사전 합의 및 형식화된 규칙 세트에 따라 자동으로 수행되는, 집단 소유의 블록체인 기반 조직입니다.\\n\\n### 데이터로그 (Function)\\n로보노믹스 파라체인 기능으로, 장치 데이터를 블록체인에 저장합니다.\\n\\n### Dapp\\n분산 네트워크의 일부로 실행되며 사용자 친화적인 방식으로 기능에 액세스하는 애플리케이션입니다.\\n\\n### Decentralized Cloud\\n컴퓨팅, 네트워킹, 저장 등의 리소스를 제공하거나 서비스를 사용하기 위해 가입할 수 있는 분산 P2P 네트워크 기반의 클라우드 컴퓨팅 서비스입니다.\\n\\n### Digital Twin\\n실제 장비의 디지털 버전으로, 기술적 특성과 역사적 데이터를 복사합니다.\\n\\n\\n## E\\n\\n### Edge-system\\n로컬로 접근 가능한 임베디드 시스템과 글로벌 네트워크 사이의 링크로 작동하는 IoT 장치로, 일반적으로 통신 프로토콜을 지원하고 텔레메트리 및 제어 신호를 전송합니다.\\n\\n### Embedded System\\n컴퓨팅 및 통신 자원이 제한된 IoT 장치로, 일반적으로 사용자 인터페이스 이 최하위 수준에서 기본 기능 (센서, 액추에이터, 버튼)을 제공합니다.\\n\\n### Ethereum\\n다른 암호화폐들뿐만 아니라 탈중앙화된 오픈 소스 블록체인 시스템으로, 탈중앙화된 스마트 계약의 실행을 위한 플랫폼으로 작동합니다.\\n\\n### Ethereum Upgrade\\n이더리움 프로토콜의 업그레이드로 이전에는 Ethereum 2.0 또는 Eth2로 알려져 있었으며, 네트워크를 보다 확장 가능하고 안전하며 지속 가능하게 만들기 위해 합의를 Proof-of-Stake로 변경하고 샤딩 메커니즘을 추가하는 것이 제안되었습니다.\\n\\n### Exodus\\n이더리움 네트워크에서 XRT 토큰을 Robonomics 패러체인으로 이전하는 과정입니다.\\n\\n### Extrinsic\\nPolkadot 및 Kusama 네트워크에서 상태 전이를 트리거할 수 있는 기능으로, 상태 외부에서 네트워크 상태 전이를 시작할 수 있습니다.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\n또는 Gk는 XRT 토큰의 천분의 일로, 1 XRT = 1,000 Gk입니다. 이는 소련의 수학자이자 정보 기술과 사이버네틱스의 창시자 중 한 명인 Victor Glushkov의 이름을 따온 것입니다.\\n\\n\\n## H\\n\\n### Home Assistant\\n또는 Hass — 스마트 장치의 중앙 허브로 설계된 오픈 소스 제어 시스템 소프트웨어입니다.\\n\\n### HRMP\\n또는 수평 릴레이 라우팅 메시지 전달 — 파라체인으로 전송하기 전에 모든 메시지를 릴레이 체인 저장소에 저장하는 파라체인 간에 전달되는 보안 메시지입니다.\\n\\n### HMI\\n또는 인간-기계 인터페이스는 사용자를 기계, 시스템 또는 장치에 연결하는 사용자 인터페이스 또는 대시보드입니다.\\n\\n\\n## I\\n\\n### Industry 4.0\\n또는 제4차 산업 혁명은 현대 스마트 기술을 사용하여 전통적인 제조  산업 관행을 자동화하는 지속적인 과정입니다.\\n\\n### IPFS\\n또는 InterPlanetary File System은 분산 파일 시스템에서 데이터를 저장하고 공유하기 위한 P2P 소프트웨어입니다.\\n\\n### IoT\\n또는 사물 인터넷은 수십억 대의 장치가 연결되어 데이터를 수집하고 환경에 통합될 수 있는 글로벌 네트워크에 대한 연결입니다.\\n\\n### IoT Gateway\\nIoT 장치와 네트워크 간에 데이터를 집계하고 전송하는 엣지 시스템으로, 이러한 장치들은 종종 WiFi 라우터의 더 복잡한 버전입니다.\\n\\n### IoT Provider\\nIoT 사용자에게 원격 데이터 및 분석에 대한 액세스 및 인터넷을 통한 스마트 장치의 제어를 제공하는 외부 서비스입니다.\\n\\n### IoT Subscription\\nRobonomics 패러체인의 모든 기능을 일정 기간 동안 수수료 없이 사용할 수 있는 기능입니다.\\n\\n\\n## K\\n\\n### KSM\\nKusama 네트워크의 네이티브 토큰입니다.\\n\\n### Kusama\\nPolkadot의 \\\"카나리아 네트워크\\\"로, Polkadot 소프트웨어의 초기 버전으로서 아직 감사되지 않은 버전으로 구성됩니다.\\n\\n\\n## L\\n\\n### 시작 (Function)\\n블록체인을 통해 명령을 보내어 장치를 시작하거나 중지하는 Robonomics 패러체인 기능입니다.\\n\\n### Lease Period\\n패러체인이 Relay Chain에 연결할 수 있는 시간의 양입니다.\\n\\n### Libp2p\\n암호화된 P2P 네트워크를 생성하기 위한 오픈 소스 라이브리입니다.\\n\\n### Lights-out Factory\\n또는 스마트 공장은 완전히 자동화되어 현장에 인간의 존재가 필요하지 않은 공장입니다.\\n\\n### Lighthouse\\n로봇 경제 개념에서 Provider가 Promisor와 Promisee 사이에서 시장 매칭을 설정할 때 거래를 수행하는 스마트 계약입니다.\\n\\n### 책임\\n사이버-물리 시스템끼리 또는 사람과 함께 작성된 스마트 계약으로, 지불을 위해 작업을 실행합니다.\\n\\n### Liability Market\\n로봇 경제 개념에서 노드 간의 제안과 수요를 매칭하는 역할을 담당하는 플랫폼입니다.\\n\\n\\n## M\\n\\n### MQTT\\n또는 메시지 큐 텔레메트리 전송 - 저대역폭, 높은 지연 시간, 신뢰할 수 없는 네트워크를 위해 설계된 발행-구독 프로토콜로, 대량의 IoT 장치 메시지를 처리합니다.\\n\\n### MQTT Broker\\nMQTT 클라이언트로부터 모든 메시지를 수신하고 해당 구독 클라이언트로 메시지를 라우팅하는 서비스입니다.\\n\\n\\n## N\\n\\n### NFT\\n또는 비교 가능하고 구별 가능하지 않은 다른 토큰과 교환할 수 없는 토큰으로, 고유한 항목의 토큰화를 허용하고 해당 토큰에 대한 독점적인 소유권을 제공합니다.\\n\\n### Node (of Robonomics)\\n로보노믹스 네트워크에 연결하기 위한 로보노믹스 확장을 갖춘 Substrate 기반 또는 이더리움 기반 블록체인 모듈입니다.\\n\\n\\n## O\\n\\n### On-chain Governance\\n네트워크 자체에 존재하며 코드 수정 또는 자금 이동과 같은 네트워크 변경 사항이 허용되는 프로세스로, 네트워크를 직접 변경할 수 있습니다.\\n\\n\\n## P\\n\\n### Pallet\\nSubstrate 기반 블록체인의 런타임을 위한 특정 로직이나 알고리즘을 번들로 묶은 Rust로 작성된 Substrate 모듈입니다.\\n\\n### Parachain\\n사용자가 검증할 수 있는 사용자 정의 응용 프로그램별 데이터 구조(일반적으로 블록체인)로, 릴레이 체인에 통합되어 검증될 수 있습니다.\\n\\n### Parathread\\n릴레이 체인 보안에 일시적으로 참여할 수 있는 슬롯이 없는 파라체인입니다(수수료와 함께 블록별 기반).\\n\\n### Polkadot\\n공유 보안 하에 임의의 특성을 가진 다양한 블록체인이 임의의 크로스체인 통신을 수행할 수 있는 이종 다중 체인 네트워크입니다.\\n\\n### Polkadot/Substrate Portal\\nPolkadot, Kusama 및 기타 Substrate 네트워크와 상호 작용하기 위한 기본 Substrate UI입니다.\\n\\n### Proposal (on Polkadot / Kusama)\\nPolkadot, Kusama 또는 파라체인 국민투표에서 투표할 잠재적 기능 호출.\\n\\n### Proof-of-Work\\n합의를 도달하기 위해 네트워크 참가자가 계산 작업을 수행해야 하는 합의 메커니즘입니다.\\n\\n### Proof-of-Stake\\n합의를 도달하기 위해 네트워크 참가자가 관련 암호화폐의 자본을 스테이킹해야 하는 합의 메커니즘입니다.\\n\\n### Promisee\\n로봇 경제 개념에서 작업 실행을 위해 주문을하는 노드입니다.\\n\\n### Promisor\\n로봇 경제 개념에서 지불을 받기 위해 작업을 실행하는 노드입니다.\\n\\n### Provider (Robonomics)\\n책임 시장의 메시지를 모니터링하고 적은 비용으로 제안과 수요를 일치시키는 로봇 경제 개념의 노드입니다.\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\n온체인 거버넌스의 일부로서, 네트워크 사용자가 제안을 수락해야 하는지 여부에 대해 투표합니다.\\n\\n### Relay Chain\\nPolkadot / Kusama의 합의를 조정하고 파라체인 간의 통신을 조정하는 주요 체인입니다.\\n\\n### Robofirm\\n비즈니스 프로세스 주기 전체가 완전히 자동화되어 인간의 참여가 필요하지 않은 조직입니다.\\n\\n### Rococo\\nKusama에서 파라체인을 테스트하기 위한 테스트넷입니다.\\n\\n### robonomics-interface\\n로보노믹스와 편리한 프로그래밍을 위한 인터페이스에 특화된 Python 라이브러리입니다.\\n\\n### 이더리움에서의 Robonomics\\n2018년에 출시된 이더리움 위에서 실행되는 로보노믹스 네트워크의 버전입니다.\\n\\n### Robot Economy\\n기존에는 인간에게만 고유한 주요 경제 활동을 수행할 수 있는 독립적인 에이전트로서 장치가 작동하는 경제 시스템입니다.\\n\\n### Robot-as-a-Service\\n또는 RaaS - 회사가 로봇 장비를 임대하여 클라이언트와 고객이 단기 또는 장기간 사용하는 비즈니스 모델입니다.\\n\\n### ROS\\n로봇 소프트웨어 개발을 위한 프레임워크로, 하드웨어 추상화, 저수준 장치 제어, 일반적으로 사용되는 기능의 구현, 프로세스 간 메시지 전달 및 패키지 관리 기능을 제공합니다.\\n\\n### ROS 2\\n다중 로봇 및 소형 임베디드 시스템 지원, 실시간 통합 등의 새로운 기능을 갖춘 로봇 운영 체제의 업데이트 및 재구축 버전입니다.\\n\\n### ROS 2 Middleware\\nROS 2의 표준 기능인 검색, 직렬화 및 전송을 제공하는 프로토콜로, 프로젝트 요구 사항에 가장 적합한 미들웨어 구현을 지원합니다.\\n\\n### RWS\\n로보노믹스와 IoT를 위한 분산 인프라 서비스로, 장치를 쉽게 연결하고 사용자 응용 프로그램, 클라우드 서비스 및 기타 장치와 안전하게 상호 작용할 수 있습니다. RWS라고도 불리는 자체 토큰을 갖고 있으며, 로보노믹스 파라체인에서 평생 IoT 구독을 제공합니다.\\n\\n### 실행time\\n블록체인의 상태를 결정하는 유효한 알고리즘을 정의하는 블록체인의 상태 전이 함수입니다.\\n\\n\\n## S\\n\\n### Seed Phrase\\n블록체인 주소 및 해당 토큰에 액세스하기 위해 필요한 난수 단어의 시퀀스로 생성된 사람이 읽을 수 있는 개인 키입니다.\\n\\n### Shared Security\\nPolkadot / Kusama의 보안 모델로, 모든 체인이 파라체인 블록의 유효성을 증명하기 위해 증거를 릴레이 체인에 배치하여 잠재적인 공격자가 전체 시스템을 공격하기 위서는 전체 시스템을 공격해야 합니다.\\n\\n### SLS Gateway\\nSmart Logic System에서 개발한 ESP32 마이크로컨트롤러 기반의 Zigbee 장치용 오픈 소스 IoT 게이트웨이입니다.\\n\\n### Slot (of Parachain)\\nPolkadot / Kusama 생태계에서 연결된 파라체인에 대해 각 블록마다 수수료 없이 연결할 수 있는 희소 자원입니다.\\n\\n### Smart Leasing\\n시간당이 아닌 특정 작업 및 해당 수행 횟수에 대해 지불되는 로봇 서비스 모델 변형입니다.\\n\\n### Smart Contract\\n미리 정해진 조건이 충족되면 자동으로 실행되는 블록체인에 저장된 프로그램 또는 알고리즘입니다.\\n\\n### SSH\\n또는 Secure Shell — 공개 키 암호화를 사용하여 원격 컴퓨터를 인증하는 보안되지 않은 네트워크를 통해 네트워크 서비스를 안전하게 운영하기 위한 네트워크 프로토콜입니다.\\n\\n### Staking\\n스테이킹, 유효한 블록 생성 및 보상 획득 기회를 위해 토큰을 예치하는 Proof-of-Stake 합의의 일부로서의 토큰 예치 행위입니다.\\n\\n### Substrate\\nPolkadot 및 Kusama와 같은 블록체인을 구축하기 위한 모듈식 프레임워크입니다.\\n\\n\\n## T\\n\\n### Treasury\\n블록 생성 보상, 거래 수수료, 스테이킹 등을 통해 모은 자금의 모음으로, 지출 제안을 통해 사용할 수 있습니다. 자금의 일부를 소비하지 않고 지출 기간을 마감하면 일부 자금이 소각됩니다.\\n\\n### Transaction Costs\\n경제 주체의 유한한 이성성 및 프로세스의 복잡성으로 인해 정보 수집 및 처리 비용입니다.\\n\\n\\n## V\\n\\n### Validator\\n리레이 체인을 보호하기 위해 토큰을 스테이킹하고, 패러체인의 콜렉터로부터의 증명을 검증하며, 다른 검증자들과 함께 합의에 투표하는 노드입니다.\\n\\n\\n## W\\n\\n### Web3\\n분산화, 블록체인 기술 및 토큰 기반 경제와 같은 개념을 통합한 웹의 새로운 반복에 대한 아이어입니다.\\n\\n### Wiener (XRT)\\n또는 Wn — 1 XRT 토큰의 10억 분의 1 주식, 1 XRT = 10억 Wn; 노르베르트 위너(Norbert Wiener)라는 미국 수학자에게 따라 이름이 지어진 사이버네틱스와 인공지능 이론의 창시자 중 한 명입니다.\\n\\n\\n## X\\n\\n### XCM\\n또는 크로스-컨센서스 메시지 형식 — Polkadot / Kusama에서 다른 블록체인 시스템 간의 메시징 형식입니다.\\n\\n\\n### XRT\\n로보노믹스 네트워크의 네이티브 토큰으로, 이더리움 및 Kusama 네트워크에서 독립적으로 존재합니다.\\n\\n\\n## Y\\n\\n### Yggdrasil\\n메시 네트워크에 대한 완전한 엔드 투 엔드 암호화된 라우팅 스킴의 오버레이 네트워크 구현입니다.\\n\\n\\n## Z\\n\\n### Zigbee\\n저전력 소비, 구성의 용이성 및 유연성, 자기 조직화 및 자가 복구 네트워크 토폴로지 지원으로 인해 스마트 기기 연결에 매우 일반적으로 사용되는 무선 통신 프로토콜입니다.\\n\\n### Zigbee Adapter\\nZigbee 네트워크와 다른 네트워크(예: Wi-Fi) 간에 데이터를 전송하는 장치로, Zigbee 기기를 제어하는 데 사용됩니다.\\n\\n### Zigbee2MQTT\\n한 네트워크에서 다른 네트워크로 메시지를 변환하여 Zigbee를 MQTT 네트워크에 연결할 수 있게 해주는 소프트웨어입니다.\"}},{\"node\":{\"id\":\"a1fd3921031ce4c42636cb7794eace1c\",\"title\":\"구독 구매 방법\",\"path\":\"/docs/ko/get-subscription/\",\"content\":\"\\n**블록체인에서 거래에 대한 수수료를 지불하는 것은 귀찮은 일입니다. 5-10분마다 텔레메트리를 보내는 IoT 장치를 상상해보십시오. 이로 인해 한 달 동안 상당한 금액을 지불해야합니다. Robonomics Network의 주요 기능 중 하나는 RWS - Robonomics 웹 서비스 구독입니다. 매월 지불하고 거래 비용을 잊어 버리세요! 이론적 배경은 [여기](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) 기사를 참조하십시오.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Robonomics Kusama 파라체인에서 구독을 구매하는 튜토리얼을 주의 깊게 살펴보십시오. [로컬 노드](/docs/run-dev-node)에서도 동일한 단계를 수행 할 수 있습니다.\\n\\n  시작하기 전에 한 가지 더. 이것은 구독을 구매하는 \\\"어려운\\\" 방법입니다. [Robonomics DApp](https://dapp.robonomics.network/#/)을 통해 이를 수행하는 전통적인 방법이 있습니다.\\n\\n</robo-wiki-note>\\n\\n## 경매에 입찰하기\\n\\nRobonomics의 구독은 경매 모델로 판매됩니다. 구독을 얻으려면 경매에 입찰하고 이기면됩니다 (걱정하지 마세요, 빠릅니다).\\n\\n`Developer/Chain state`에서 사용 가능한 경매를 볼 수 있습니다. \\n`rws`와 `auctionQueue`를 선택하고 `+` 버튼을 누르면 사용 가능한 경매의 ID를 볼 수 있습니다:\\n\\n![queue](../images/rws/queue.png)\\n\\n경매에 대한 정보를 보려면 `rws` `경매`와 경매 ID를 사용하면 됩니다 (사진에서 경매 ID는 79입니다):\\n\\n![auction](../images/rws/auction.png)\\n\\n경매에 대한 정보에서 `winner` 필드를 볼 수 있습니다. 현재는 `null`이므로 아무도이 구독을 가지고 있지 않으며 가올 수 있습니다. 그러기 위해 `Developer/Extrinsic`로 이동하여 계정과 `rws -> bid`을 선택하십시오. 또한 경매 ID (79)와 입찰 할 단위 수를 설정하십시오 (1000000000 Wn 이상):\\n\\n![bid](../images/rws/bid.png)\\n\\n트랜잭션을 제출하고 ID 79의 경매에 대한 정보를 확인하십시오 (`Chain state`에서 `rws -> auction`를 선택하고 ID 79를 선택하십시오):\\n\\n![win](../images/rws/auc_win.png)\\n\\n이제 `winner` 필드에서 계정 주소를 볼 수 있으므로이 계정에는 구독 79가 있습니다. 경매는 첫 번째 입찰로 시작되며 몇 개의 블록 동안 지속됩니다. 따라서 다음 몇 개의 블록에서 당신보다 더 많은 토큰을 입찰하는 사람이 이길 것입니다.\\n\\n이제 장치를 추가 할 수 있습니다. 장치는이 구독을 사용하고 수수료없이 외부를 제출 할 수있는 계정입니다.\\n테스트를 위해 토큰이없는 새 계정을 만들고 장치에 추가하십시오. \\n\\n`Developer/Extrinsic`에서 `rws -> setDevices`를 선택하여 장치를 추가하십시오. 그런 다음 `Add Item` 버튼을 누르고 토큰이없는 최근에 생성된 계정을 선택하십시오:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\n트랜잭션을 제출하십시오. 이제 `Chain state`에서 `rws -> devices`를 사용하여 장치 목록을 확인할 수 있습니다. 거기에서 토큰이없는 계정의 주소를 볼 수 있습다. 구독을 구매 한 계정을 선택하고 `+`를 누르십시오:\\n\\n![devices](../images/rws/devices.png)\\n\\n이제 구독을 사용하여 [발사](/docs/subscription-launch) 외부를 보내 볼 수 있습니다.\"}},{\"node\":{\"id\":\"502c79588683b7f7ddbd7e51a46ce714\",\"title\":\"위키 편집 방법\",\"path\":\"/docs/ko/edit-wiki/\",\"content\":\"\\n**Robonomics 위키는 오픈 소스입니다. 오류 수정, 오타 수정, 명확하지 않거나 오래된 정보 수정, 어떤 언어로든 번역을 환영합니다. [GitHub](https://github.com/) 계정이 필요합니다.**\\n\\n\\n## 편집하는 방법\\n\\nRobonomics 위키 문서를 편집해야 하는 경우 다음 단계를 따르십시오.\\n\\n[Node.js](https://nodejs.org/en/download/package-manager/)와 [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool)이 설치되어 있는지 확인하십시오.\\n\\n### 1. 저장소 복제\\n\\n먼저 위키 저장소를 복제해야 합니다.\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\n저장소 디렉토리로 이동한 다음 다음 명령을 실행하십시오.\\n\\n`npm 사용`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`yarn 사용`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. 로컬로 서비스 제공 (개발, 개발-m1)\\n\\n그런 다음 프로젝트를 로컬로 배포하십시오. \\n\\n```\\ngridsome develop\\n```\\n\\n> `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS` 오류가 발생하는 경우 다음 명령을 실행하십시오.\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. PR 생성\\n\\n[풀 리퀘스트 생성](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request)를 [위키 저장소](https://github.com/airalab/robonomics-wiki)에 제출하십시오.\\n\\n## 구성 요소\\n\\n### Asciinema\\nRobonomics 위키는 Asciinema를 지원합니다. Asciinema를 삽입하려면 다음 지침을 따르십시오.\\n* frontmatter 블록 이후에 컴포넌트를 가져옵니다. `import Asciinema from '~/components/Asciinema.vue'`\\n* 별도의 단락으로 삽입합니다. `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, 여기서 vid는 특정 asciicast의 ID입니다.\\n\\n> asciicast 페이지의 \\\"Embed\\\" 링크를 클릭하여 특정 asciicast에 대한 위젯 스크립트를 얻을 수 있습니다.\\n> 이렇게 보입니다:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Asciinema docs](https://asciinema.org/docs/embedding)\\n\\n위의 예시에서 vid는 14입니다.\\n\\n### 코드\\n\\n 코드에 유용한 추가 기능을 추가할 수 있습니다.  \\n\\n`복사 버튼이 있는 코드`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n또는 `추가 줄이 있는 코드`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**code-helper 속성**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nRobonomics 위키 문서에는 frontmatter 블록이 포함되어야 합니다. 이는 Markdown 파일의 맨 위에 있어야 하며, 세 개의 대시로 둘러싸인 유효한 YAML 형식으로 작성되어야 합니다. 세 개의 대시 사이에서 다음 옵션을 설정하거나 편집할 수 있습니다.\\n\\n```YAML\\n---\\ntitle: How to contribute #  페이지 제목은 텍스트에서 중복으로 작성할 필요가 없습니다.\\ncontributors: [positivecrash] #  주요 기여자 (이 페이지를 적극적으로 관리하는 사람)입니다. 추가 기호 없이 GitHub 닉네임이 필요합니다.\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/설치\\n    #  기술 테스트에 사용된 도구입니다.\\n---\\n```\\n\\n### Grid \\n요소에 그리드 레이아웃을 추가하는 데 도움이 됩니다.\\n\\n- 먼저 그리드 래퍼 컴포넌트를 사용하십시오. \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- 그런 다음 래퍼 내부에서 원하는 만큼의 그리드 항목 구성 요소를 사용합니다.\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**robo-wiki-grid-element-wrapper 속성** \\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>라즈베리 파이 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### 이미지\\n\\n#### 업로드하는 방법 \\n`/docs/images/url-of-your-doc` 폴더에 이미지를 업로드하세요\\n* 이미지가 로컬라이즈되어야 하는 경우, 모두 한 폴더에 삽입하세요\\n* 로컬라이즈된 경우 이미지 이름에 로케일 접미사를 사용하세요. 예: `image_en.jpg`\\n* 이미지가 웹 최적화되어 있고 동시에 좋아 보이는지 확인하세요\\n\\n#### 삽입하는 방법 \\n\\n문서에 사진을 삽입하는 두 가지 방법이 있습니다:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n내장 태그 `<robo-wiki-picture>`를 사용하여 사진을 삽입하는 것이 권장됩니다. 그러나 Markdown 파일의 표준 방법도 사용할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n`캡션과 함께`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`캡션 없이` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`간단한 이미지` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`캡션 있는 간단한 이미지`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`대체 텍스트가 있는 이미지`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**robo-wiki-picture의 속성:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### 참고 사항 및 경고\\n참고 사항을 추가하고 특정 유형을 지정할 수 있습니다:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`제목이 있는 참고 사항`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`내용이 있는 참고 사항`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`제목과 내용이 있는 참고 사항`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**robo-wiki-note의 속성:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\n문서에 탭을 추가할 수 있습니다:\\n\\n- 탭 래퍼 컴포넌트를 사용하세요: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- 그런 다음 원하는 만큼 탭 항목 컴포넌트를 래퍼 내부에 사용하세요:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`수평 탭`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`수직 탭`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`테두리가 있는 탭 항목`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**robo-wiki-tabs (래퍼)의 속성:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**robo-wiki-tab (항목)의 속성:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### 앵커가 있는 제목\\n앵커가 있는 사용자 정의 제목을 만들고 특정 값을 지정할 수 있습니다.\\n\\n`앵커가 있는 제목`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\n또는\\n\\n'앵커 없는 제목'\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**robo-wiki-title의 속성:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### 동영상\\n\\n문서에 동영상을 삽입하는 두 가지 방법이 있습니다:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n내장 태그 `<robo-wiki-video>`를 사용하여 동영상을 삽입하는 것이 권장됩니다. 그러나 Markdown 파일의 표준 방법도 사용할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / 서버\\n동영상의 형식을 지정해야 합니다.\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### 속성\\n\\n- <span style=\\\"color:#af1c1c\\\">10MB</span> 이상의 파일을 추가하는 경우 저장소가 아닌 서버에 업로드하세요.\\n\\n- [HTML5 비디오 태그](https://www.w3schools.com/tags/tag_video.asp)에는 어떤 속성이든 사용할 수 있습니다.\\n\\n- 허용되는 형식 - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nYouTube 동영상을 문서에 삽입하려면 공유 링크를 따옴표나 태그 없이 별도의 단락으로 삽입하세요. 예: `https://youtu.be/kQaSwNYHJQ8`\\n\\n그러나 자동 재생이 필요한 경우 특수 컴포넌트를 사용해야 합니다. \\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**robo-wiki-youtube의 속성:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## 편집하는 방법 sidebar navigation\\n\\nRobonomics Wiki의 사이드바 탐색을 편집해야 하는 경우 다음 단계를 따르세요:\\n\\n* 파일 `/data/sidebar_docs.yaml`을 편집하세요.\\n\\n* 문서를 어디에 배치할지 결정하세요.\\n\\n* `/data/sidebar_docs.yaml`에 유효한 YAML을 사용하고 기존 파일 구조를 따르세요.\\n\\n* **중요한 참고 사항:** 동일한 문서를 다른 섹션/하위 섹션에 사용하는 경우: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Pre-installed Image For 라즈베리 파이\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\n다음과 같이 `topic` 매개변수를 추가해야 합니다: \\n\\n(탐색이 올바르게 작동하려면) \\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## 문서에 사용자 정의 탐색을 추가하는 방법 \\n\\n* 파일 `/data/sidebar_docs.yaml`을 편집하세요.\\n\\n* 올바른 문서를 찾고 다음과 같이 'prev' 및 'next' 매개변수를 추가하세요.\\n\\n```\\n    - title_en: 위키 편집 방법\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* 탐색을 완전히 제거하려면 `withoutNav` 매개변수를 추가하세요.\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* 이전 페이지 또는 다음 페이지 탐색만 제거하려면 `withoutPrev` 또는 `withoutNext` 매개변수를 추가하세요.\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\n또는\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"c40597475d1db55db0b12dd66cb01056\",\"title\":\"Amazon FreeRTOS 장치를 MQTT를 통해 Robonomics에 연결하기\",\"path\":\"/docs/ko/freertos-mqtt/\",\"content\":\"\\n[Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/)를 실행하는 마이크로컨트롤러가 MQTT를 통해 Robonomics 네트워크에 연결되는 방법을 시연합니다. 프로젝트 소스 코드는 [이 저장소](http://github.com/khssnv/freertos_mqtt_robonomics_example)에서 확인하십시오.\\n\\n우리는 [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/)를 사용하며, FreeRTOS 배포 및 MQTT 구현은 [Espressif IoT Development Framework](https://github.com/espressif/esp-idf)에서 제공합니다. Espressif는 사용된 마이크로컨트롤러의 공급업체입니다.\\n\\n또한 시연 목적으로 [PMS-3003](http://www.plantower.com/en/content/?107.html) 센서가 있습니다. 이 센서는 대기 중의 미립자 측정을 수행하며, 이를 사용하여 대기 질을 추정할 수 있습니다.\\n\\n대기 질은 이 문서의 주제가 아니며, WHO 웹사이트에서 자세한 정보를 찾을 수 있습니다: [대기 (실외) 대기 오염](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). 시스템의 목표는 센서 측정 값을 Airalab의 Robonomics 네트워크에 게시하는 것입니다.\\n\\n## 하드웨어 설정\\n\\nPMS3003 TXD PIN5를 ESP32 DevKitC IO17에 연결하여 UART를 통해 측정 값을 전송합니다.\\n또한 두 장치 모두 전원과 공통 접지가 필요합니다.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## 데이터 흐름\\n\\nRobonomics 네트워크에 센서 측정 값을 전달하기 위해 펌웨어 수준에서는 센서에서 데이터를 가져와서 내장된 통신 프로토콜 (우리의 경우 UART)을 통해 AIRA 인스턴스로 전달하는 것이 목표입니다.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\n우리의 예제에서는 공용 IP 주소와 도메인 이름으로 사용 가능한 AIRA 클라우드 배포를 사용합니다.\\nAIRA 인스턴스에서는 `mosquitto` MQTT 브로커를 설정하고 MQTT에서 메시지를 받기 위해 `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` 주제에 구독합니다.\\n\\n그런 다음 메시지를 `robonomics io` writer로 전달합니다.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\n이제 Robonomics 네트워크에서 데이터를 사용할 수 있으며, 다시 `robonomics io`로 읽을 수 있습니다.\\n\\n## 펌웨어\\n\\n[ESP-MQTT TCP 전송을 사용한 MQTT 샘플 애플리케이션](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp)을 기반으로 사용합니다.\\n\\nUART 연결, SNTP 시간 동기화 및 주기적인 MQTT 게시자 루틴을 위해 `main/app_main.c`만 수정합니다.\\n\\n프로젝트를 반복하려는 경우, ESP IDF 기반 프로젝트이고 처음이라면 먼저 [Espressif의 ESP-IDF 프로그래밍 가이드](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step)를 따라 펌웨어 구성, 빌드 및 `idf.py` 도구를 사용한 업로드와 같은 작업에 익숙해지기 바랍니다.\\n\\n### Wi-Fi 구성\\n\\n클우드에 배포된 AIRA 인스턴스와 통신하기 위해 마이크로컨트롤러는 인터넷 연결이 필요합니다.\\n우리는 ESP32의 Wi-Fi를 사용합니다.\\nEspressif는 기판 Wi-Fi를 구성하기 위한 유틸리티를 제공합니다.\\n우리의 예제에서는 Ubuntu 20.04 GNU/Linux 개발 환경을 사용합니다.\\nWi-Fi를 구성하기 위해 프로젝트 폴더로 이동하여 SDK 구성 도구를 실행합니다.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\n그런 다음 `연결 구성 예시` 섹션에서 Wi-Fi 액세스 포인트 SSID와 비밀번호를 설정합니다.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### MQTT 엔드포인트 구성\\n\\nMQTT를 구성하기 위해 두 가지를 설정해야 합니다.\\n첫 번째는 MQTT 브로커 주소입니다.\\nSDK 구성 도구로 구성할 수 있습니다.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\n`Example Configuration` 섹션에서 `Broker URL`을 설정합니다.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\n두 번째는 MQTT 주제입니다.\\n프로젝트 이름 접두사와 ESP32 MAC 주소를 이어서 설정합니다.\\n이렇게 하면 특정 마이크로칩에 대해 `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`가 됩니다.\\n\\n## MQTT에서 Robonomics로\\n\\n먼저 MQTT로 데이터를 수신하는지 확인해 봅시다.\\nMosquitto MQTT 브로커 주제에 구독하여 장치가 게시하는 데이터를 받을 수 있습니다.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\n여기에서는 `mosquitto` 패키지를 환경에 가져와 `mosquitto_sub` 유틸리티를 사용합니다.\\n그런 다음 펌웨어에 설정된 주제에 가입합니다.\\n우리는 MQTT를 통해 데이터를 정확하게 수신하는 것을 의미하는 측정치를 얻었습니다.\\n이제 이러한 메시지를 Robonomics Network로 전달합시다.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\n여기에서는 `robonomics` 유틸리티를 사용하여 `/freertos_mqtt_robonomics_example` pubsub 채널에 메시지를 게시합니다.\\n최소한 하나의 연결이 설정되도록 `bootnodes`를 지정합니다.\\n\\n이제 동일한 pubsub 채널에서 이러한 메시지를 읽습니다.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## 사용된 원본 자료\\n\\n* GoJimmy의 블로그 https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html에서 ESP32 DevKitC 핀 배치도\\n* OpenAirProject https://github.com/openairproject/sensor-esp32에서 PSM3003 데이터 구조 및 디코더\\n\\n**모두에게 감사드립니다!**\\n\"}},{\"node\":{\"id\":\"83b5ce1b04353c26a9ac22798ceb6d76\",\"title\":\"Gaka-Chu setup and software 설치\",\"path\":\"/docs/ko/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**이 기사에서는 로봇 페인터를 설정하기 위한 몇 가지 설치 및 실행 단계를 살펴보겠습니다. 요구 사항:**\\n- KUKA KR6 R900 sixx 및 KRC4와 SmartPad;\\n- [ROS melodic](http://wiki.ros.org/melodic/설치/Ubuntu)이 설치된 Intel NUC;\\n- 테이블, 페인트, 브러시, 물.\\n\\n## KRC4에 소프트웨어 설치\\nKRC4와 NUC 모두에 EKI 인터페이스가 필요합니다. KRC4에서 설정하는 방법에 대한 자세한 정보는 [여기](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl)에서 제공됩니다. 로봇 컨트롤러에서 실행하세요.\\n\\n## NUC에 소프트웨어 설치\\ncatkin 작업 공간을 생성하세요.\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nROS 패키지를 다운로드하세요. 모든 스크립트는 [여기](https://github.com/airalab/robot_painter/tree/test_branch)에 저장되어 있습니다. 리포지토리를 복제하세요.\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\n모두가 올바르게 작동하려면 일부 헤더 파일과 라이브러리가 필요할 수 있습니다. 다운로드하세요.\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\n`.bashrc` 파일에 소스 명령을 추가하세요.\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\n지금까지 스크립트를 실행할 수 있어야 합니다. 문제가 발생하면 [문제 해결](https://github.com/airalab/robot_painter/issues)을 시도하세요.\\n\\n## 상수 채우기\\n먼저, 로봇은 캔버스 위치와 방향, 그리고 페인트 통 위치를 알아야 합니다. 이 모든 것은 `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`에서 지정됩니다. 살펴보겠습니다.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\n이것들은 3D 공간에서 캔버스 위치를 지정하는 평면 방정식 상수입니다. 아래에서 설명하는 보정 과정 중에 얻어야 합니다. 다음은 페인트입니다.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\n이것들은 페인트 통 좌표입니다. 보정하는 동안 지정할 수도 있습니다. 캔버스 크기는\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\n`local_task_planner/src/Drawing.cpp`에 저장된 몇 가지 더 중요한 상수가 있습니.\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\n상수의 이름이 그 자체로 말해주기 때문에 상황에 맞게 채우세요.\\n\\n## Gaka-Chu 보정\\n보정 과정 자체는 매우 간단합니다.\\n\\n1) KRC4에서 EKI 인터페이스 시작:\\n\\n'AUT' 모드로 로그인하고 드라이버를 켜고 `eki_hw_interface` 스크립트를 실행하세요.\\n\\n2) NUC에서 EKI 인터페이스 시작\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n무한한 로그가 출력되어야 합니다.\\n\\n3) RViz 시작\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n다음을 볼 수 있어야 합니다.\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\n끝 지점을 이동하고 '계획 및 실행'을 클릭해 보세요. 로봇이 움직여야 합니다. SmartPad에서 **Display -> Actual position**으로 이동하여 끝 지점의 좌표를 확인하세요. 캔버스를 로봇 베이스에 수평으로 배치하세요. 브러시를 브러시 홀더에 연결하고 조심스럽게 캔버스에 거의 닿을 때까지 이동하세요. 이 위치에서 끝 지점의 좌표를 저장하세요. 12-15번 반복하세요. 또한 캔버스 중심과 페인트 통의 좌표를 저장하세요.\\n좌표 세트가 있으면 [이](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab 스크립트를 사용하여 누락된 상수와 쿼터니온을 해결하세요. 붙여넣으세요. 다음으로\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## 작업 공간을 다시 빌드하세요.\\nGaka-Chu 보정 테스트\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\n보정된 후에는 Gaka-Chu를 사용하여 캔버스의 테두리를 그리는 테스트를 수행해야 합니다. 각각을 새로운 터미널에서 실행하세요.\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\n터미널에서 테스트를 수행하려면 \\\"S\\\"를 누르세요. 로봇의 엔드 이펙터는 캔버스의 테두리 바로 위로 이동해야 하며 브러시는 이동 동안 캔버스에 부드럽게 닿아야 합니다. 그렇지 않으면 재보정을 시도해보세요. 캔버스 모델이 잘못 회전된 경우, Matlab에서 쿼터니언을 변경하여 회전시킬 수 있습니다.\\n\\n## 아트 만들기\\n모두 작동하려면 6개의 기본 모듈이 필요합니다:\\n- EKI 인터페이스;\\n- MOVEit + RViz;\\n- 환경 프레임 브로드캐스팅;\\n- 사진 변환 서비스;\\n- 트라젝토리 그리기 모듈;\\n- 시작 트리거.\\n\\n하나씩 실행해 보겠습니다.\\n\\n### Eki 인터페이스\\nKRC4에서 `eki_hw_interface`를 실행하고, 새 터미널에서 NUC에서 다음을 수행하세요:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz와 MOVEit\\n플래너와 시뮬레이션이 필요합니다. 다음과 같이 실행하세요.\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### 환경\\n로봇에게 페인트 통과 캔버스의 위치를 알려주세요. `draw workspace` 노드를 실행할 필요는 없으며, `tf_broadcaster`가 캔버스 크기를 공유합니다. 그저 RViz에 표시되지 않을 뿐입니다.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### 사진 처리기\\n들어오는 모든 사진은 처리되어야 합니다. 서비스를 실행하세요.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\n호출을 받으면 HP 필터로 사진을 처리하고 트라젝토리가 포함된 rosbag 파일을 생성합니다.\\n\\n### 트라젝토리 그리기\\n가장 중요한 스크립트는 트라젝토리 그리기 자체입니다. 그림을 기다리고 TextConverter 서비스를 호출하여 그림을 그립니다.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## 로봇에게 그릴 그림을 보내세요\\n로봇은 특정 ROS 픽을 청취하여 원하는 그림의 경로를 전달해야 합니다. 그림은 정사각형이어야 하며 (너비와 높이가 같아야 함) 선으로 이루어져 있어야 합니다. 경로를 전송하세요:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\n이후에 두 개의 창이 나타나고 윤곽과 트랙이 표시됩니다. 이를 닫고 Gaka-Chu의 그림을 확인하세요. 안전에 주의하고 언제든지 비상 정지 버튼을 누를 준비를 해야 합니다.\\nGaka-Chu가 그림을 완성하면 다른 경로를 그림에 전송할 수 있으며, 화가는 전체 과정을 반복합니다.\\n\"}},{\"node\":{\"id\":\"8b0e36c5d83fc5ddce5dff5acb17139c\",\"title\":\"문이 열릴 때 알림 받기\",\"path\":\"/docs/ko/door-notification/\",\"content\":\"\\n이 문서에서는 텔레그램 봇 알림 통합을 설치하고 자동화를 구성하는 방법을 알려드리겠습니다. 이 자동화는 문이 열릴 때 텔레그램 계정으로 알림을 보냅니다.\\n\\n## 텔레그램 봇 알림\\n\\n먼저 개인 텔레그램 봇을 만들어야 합니다. 이를 위해서는 [특수 텔레그램 봇 @BotFather](https://t.me/botfather)로 이동하여 지침을 따르세요. \\nHTTP API에 액세스하기 위한 토큰을 저장하세요.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n토큰을 **안전하게** 보관하고 **안전하게** 저장하세요. 누구나 이 토큰을 사용하여 봇을 제어할 수 있습니다. \\n\\n</robo-wiki-note>\\n\\n다음 단계는 ***사용자 채팅 ID***를 찾는 것입니다. 이를 위해 다음 [GetIdsBot](https://t.me/getidsbot)을 사용하세요. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\n이제 \\\"텔레그램 방송\\\" 통합을 설치해 보겠습니다. 이 통합은 텔레그램으로 메시지를 보냅니다.\\n\\nRobonomics 사전 설치된 이미지, Home Assistant Docker 또는 Home Assistant Core의 경우 `configuration.yaml`을 편집해야 합니다. `ssh`를 통해 Raspberry Pi에 연결하세요.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\n다음 줄을 파일 끝에 붙여넣으세요. **봇 API 키**와 **사용자 채팅 ID**를 입력하세요. 또한 알림 서비스의 이름을 만들어 주세요.\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**구성을 저장하고 Home Assistant를 다시 로드하세요.**\\n\\n\\n결과적으로 Home Assistant 서비스에는 메시지를 텔레그램 채팅으로 보내는 서비스가 생성됩니다. \\nHome Assistant 웹 인터페이스의 개발자 도구 메뉴에서 확인할 수 있습니다. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  문이 열릴 때 알림\\n\\n이제 자동화를 생성할 시간입니다. 먼저 이 링크에서 Home Assistant로 블루프린트를 가져옵니다:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\n그리고 자동화를 생성하세요:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\n이제 문이 열릴 때마다 텔레그램 봇으로 메시지를 받게 됩니다.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\n이 자동화를 집의 모든 문/창문에 사용할 수 있습니다.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"c4785727c5a4dc7b0b4f8aba3f7cc2e6\",\"title\":\"데이터로그\",\"path\":\"/docs/ko/datalog/\",\"content\":\"\\n**계정에 일정 금액의 자금이 있으므로 extrinsic을 제출할 수 있습니다. 먼저 시도해 볼 수 있는 것은 데이터로그입니다. 이를 통해 데이터를 블록체인에 영구적으로 저장할 수 있습니다. 분산 및 암호화된 데이터 저장소를 상상해보세요. 그게 바로 데이터로그입니다!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  주의하세요. 이 튜토리얼 및 다음 튜토리얼은 로보노믹스 노드의 로컬 인스턴스에서 보여집니다. [이 지침](/docs/run-dev-node)을 따라 직접 설정하세요.\\n\\n</robo-wiki-note>\\n\\n## 1. Developer -> Extrinsics로 이동하기\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. 드롭다운 목록에서 datalog -> record를 선택하기\\n\\n또한 extrinsic을 제출할 계정을 선택하세요. record 필드를 작성하세요.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  데이터로그는 최대 512바이트의 문자열을 지원합니다. 대량의 데이터를 저장하려면 [IPFS](https://ipfs.tech/)를 사용할 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n## 3. 트랜잭션 제출하기\\n\\n확장 프로그램이나 DApp을 사용하여 트랜잭션에 서명하고 제출하세요.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  또한 *datalog -> erase* 호출로 **모든** 레코드를 삭제할 수도 있습니다.\\n\\n</robo-wiki-note>\\n\\n## 4. 스토리지에서 데이터로그 검토하기\\n\\n이를 위해 *Developer -> Chain state*,로 이동하고 *datalog -> datalogIndex*를 선택한 다음, 계정을 지정하고 \\\"+\\\" 버튼을 눌러 계정의 레코드 인덱스를 가져온 다음, *datalog -> datalogItem*을 사용하여 필요한 레코드를 탐색하세요.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"탐색하기r\\\">\\n\\n  데이터로그 레코드를 포함한 모든 이벤트는 *Explorer*의 이벤트 플로우에서 볼 수 있습니다.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"1c16ac0d01787d21c01fb97f0c724c03\",\"title\":\"디지털 트윈\",\"path\":\"/docs/ko/digital-twins/\",\"content\":\"  \\n**여러 모듈을 유지 관리하고 몇 가지 계정 사용해야 하는 복잡한 장치나 시스템을 상상해보세요. 이 모든 것을 한 곳에 유지하거나 별도의 계정으로 일부 기능을 인코딩하거나 예를 들어 다른 정보 흐름에 대해 다른 데이터로그 소스를 설정하려면 디지털 트윈 모듈을 사용해야 합니다.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  이 튜토리얼 및 다음 튜토리얼은 Robonomics 노드의 로컬 인스턴스에서 보여줍니다. [이 지침](/docs/run-dev-node)을 사용하여 자신의 인스턴스를 설정하세요.\\n\\n</robo-wiki-note>\\n\\n## 이론 개요\\n어떤 계정이든 디지털 트윈을 생성하고 관리할 수 있습니다. 트윈은 다음 내용을 포함하는 테이블로 상상할 수 있습니다:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\n여기서:\\n* **DT id**는 부호 없는 정수로 고유한 디지털 트윈 인덱스입니다.\\n* **Topic name** is a hex `H256` or ASCII data of 32 bytes length, same as [`실행`](/docs/launch) extrinsic parameter. \\n예를 들어: `0x1234....FF` 또는 `hello.parachain.robonomics.world`입니다.\\n* **Source** - 는 어떤 계정 주소입니다.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  이전에 외부 개요 실행에서 논의한 대로 `H256`은 인코딩된 IPFS CID로 표시될 수 있습니다([Python 도구](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes)). 따라서 주제는 Twin의 모듈 설명과 같은 일부 데이터 저장소로도 사용될 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n\\n## 디지털 트윈 생성하기\\n\\n### 1. 개발자 -> Extrinsics로 이동하기\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. 드롭다운 목록에서 digitalTwin -> create를 선택하기\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\n트랜잭션 제출하기. 여기서는 트윈을 생성하기 위해 매개변수가 필요하지 않습니다. 트윈은 인덱스가 부여되며 이후로는 디지털 트윈 소유자만 트윈의 주제를 추가/수정할 수 있습니다.\\n\\n트윈 ID는 탐색기 개요 페이지에서 찾을 수 있습니다.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## 주제 추가하기\\n\\n### 드롭다운 목록에서 digitalTwin -> setSource를 선택하기\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - 탐색기 페이지에서 얻은 디지털 트윈 ID.\\n* `topic` - 이전에 논의한 `H256` 주제 이름입니다. 이 그림에서는 32자리 문자열입니다.\\n* `source` - 주제와 연결할 계정 주소입니다.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  주제가 필요한 경우 다른 소스 주소로 덮어쓸 수 있습니다.\\n\\n</robo-wiki-note>\\n\\nextrinsic에 서명하고 제출하세요.\\n\\n## 탐색하기\\n\\n`Developer -> Chain state` 스토리지 모듈 `digitalTwin`에서 기존 디지털 트윈에 대한 모든 정보를 찾을 수 있습니다.\\n\\n- 총 트윈 수 - `total()`;\\n- 디지털 트윈 소유자 - `owner(u32)`;\\n- 디지털 트윈의 주제에 대한 정보 - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"cd94c40ea0c7a7ed12d5cbba45897878\",\"title\":\"이더리움으로 운영되는 디지털 신분 생성\",\"path\":\"/docs/ko/create-digital-identity-run-by-ethereum/\",\"content\":\"\\n로보노믹스 서비스 중 하나는 임의의 데이터를 위한 [디지털 여권 등록](https://dapp.robonomics.network/#/passport/)입니다. 이 서비스를 통해 데이터의 해시를 공개 블록체인에 저장하고 고유한 주소를 할당하여 디지털 신분을 생성할 수 있습니다.\\n\\n\\\"Digital passport registration\\\" 서비스는 [로보노믹스 DApp](https://dapp.robonomics.network/)의 \\\"Services\\\" 섹션에서 찾을 수 있으며, 이 [직접 링크](https://dapp.robonomics.network/#/passport/)를 따를 수도 있습니다.\\n\\n\\n## 비디오 안내\\n\\n다음 비디오는 로보노믹스 화이트페이퍼 등록의 진행 상황을 보여줍니다:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## 그림으로 단계별로\\n\\n### 1. 서비스 열기\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. 필요한 정보와 파일 추가하기\\n\\n여러 이미지를 추가할 수 있습니다.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. 요구 사항에 서명하기\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. 토큰 승인하기\\n\\n서비스는 소액의 수수료를 부과합니다. 그러나 먼저 계정에서 사용할 토큰의 필요 금액을 승인해야 합니다.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. 제안 수락하고 메시지 다시 서명하기\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. 생성된 여권 확인하기\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\n등록 과정은 시간이 소요됩니다. 마지막에 생성된 신분에 대한 링크가 표시됩니다.\\n\"}},{\"node\":{\"id\":\"6ba30379a47ad940d6450eaa4560bcc7\",\"title\":\"로보노믹스 리소스에 기여하는 방법\",\"path\":\"/docs/ko/contributing/\",\"content\":\"\\n로보노믹스 트워크는 오픈 소스 프로젝트이며 누구나 기여하기 쉽도록 만들고자 합니다. 기사를 작성하거나 변경 사항을 제안하거나 문서를 개선하거나 테스트를 실행할 수 있습니다. 기여하려면 동일한 저장소에서 새로운 이슈를 열거나 풀 리퀘스트를 생성해주세요.\\n\\n## 주요 로보노믹스 저장소 \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) - 주요 위키 프로젝트\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) - 로보노믹스 네트워크의 공식 메인 웹사이트 \\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) - 로보노믹스 웹 서비스를 위한 홈\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) - 공식 Dapp\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) - 로보노믹스 아카데미의 공식 웹사이트\\n\\n### 보고 규칙\\n\\n새로운 이슈를 열 때, 보고에 대한 몇 가지 기본 규칙을 잊지 마세요:\\n\\n1. 이슈를 제출하려는 정확한 저장소를 선택하세요.\\n\\n2. 버그를 보고하는 경우, 이미 보고된 버그인지 확인하세요.\\n\\n3. 제목과 명확한 설명을 포함하고 가능한 한 많은 관련 정보를 제공하세요.\\n\\n4. 이슈를 다음 중 하나 접두사를 붙여주세요: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## 풀 리퀘스트\\n\\n어떤 로보노믹스 저장소도 기여자에 의해 풀 리퀘스트나 변경의 대상이 될 수 있습니다. 가치 있는 내용을 추가하거나 변경할 수 있다고 생각되는 경우에는 기여자를 위한 기본 규칙을 잊지 마십시오.\\n\\n### 기여 규칙\\n\\n1. 작은 변경 사항(오타 등)을 위한 경우를 포함하여 수정 사항이 있는 경우 이슈 대신 풀 리퀘스트를 선호합니다.\\n\\n2. PR 설명이 문제와 해결책을 명확히 설명하도록 하십시오. 해당되는 경우 관련 이슈 번호를 포함하십시오.\\n\\n3. 공백을 수정하거나 코드 형식을 지정하거나 순전히 겉모습을 개선하는 패치를 하지 마십시오.\\n\\n4. 우세한 마크다운 스타일, 언어 및 레이아웃을 준수하려고 노력하십시오.\\n\\n\\n\"}},{\"node\":{\"id\":\"a09bf3b4ce9df39f246e84ea6bc64c97\",\"title\":\"Create Account for Robonomics Parachain\",\"path\":\"/docs/ko/create-account-in-dapp/\",\"content\":\"\\n**로보노믹스 파라체인과 상호 작용하고 운영하기 위해서는 개발자와 사용자가 Polkadot / Substrate 포털에 계정을 생성해야 합니다. 계정은 네트워크를 위한 기본 기능을 수행합니다: 공개 네트워크 주소(공개 키), 주소 및 자금에 대한 액세스 제어(개인 키), 네트워크로의 트랜잭션 전송, 토큰 및 수량 표시 등. 로보노믹스 파라체인을 위한 계정을 생성하는 두 가지 주요 방법은 다음과 같습니다.**\\n\\n## 1. Polkadot{.js} 브라우저 확장 프로그램 사용\\n\\nPolkadot 확장 프로그램은 로보노믹스 파라체인을 포함한 모든 Polkadot / Kusama 프로젝트와 상호 작용하고 계정을 생성하는 메커니즘을 제공합니다. 이는 계정을 관리하는 가장 안전한 방법은 아니지만 보 / 사용성 균형 측면에서 가장 편리한 방법입니다.\\n\\n## 1.1. 브라우저 확장 프로그램 설치\\n\\n브라우저 확장 프로그램은 [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) 및 [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (및 Chromium 기반 브라우저)에서 사용할 수 있습니다.\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. 로보노믹스 파라체인 앱 열기\\n\\nPolkadot / Substrate 포털의 [로보노믹스 파라체인 앱](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/)로 이동하십시오. 이 포털에 처음으로 접속하는 경우 브라우저 확장 프로그램에 대한 액세스 권한을 요청할 것이므로 액세스를 허용하십시오. \\n\\n앱을 열었으면 왼쪽 상단을 살펴보십시오. 네트워크 이름, 아이콘 및 마지막 블록 번호가 표시됩니다. 이 영역을 클릭하면 테스트 네트워크 및 로컬 노드를 포함한 모든 Polkadot / Kusama 네트워크 목록이 열립니다. 필요한 네트워크를 선택하고 `Switch` 버튼을 눌러 네트워크 간에 전환할 수 있습니다. **지금 로보노믹스 파라체인에 연결되어 있는지 확인하십시오**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. 확장 프로그램 메타데이터 업데이트\\n\\n앱에서 확장 프로그램의 메타데이터를 업데이트하여 연결된 체인에 대한 올바른 정보를 표시하도록 요청할 수 있습니다. **Settings -> Metadata**로 이동하여 `메타데이터 업데이트` 버튼을 누르고 팝업 창에서 확장 프로그램이 업데이트하도록 허용하십시오. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. 확장 프로그램에서 계정 생성\\n\\nPolkadot{.js} 브라우저 확장 프로그램을 엽니다. 큰 플러스 버튼을 클릭하거나 오른쪽 상단의 작은 플러스 아이콘에서 `Create new account`을 선택하십시오. 다음과 같은 메뉴가 표시됩니다. 12개의 단어로 된 니모닉 시드와 주소가 생성됩니다. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\n시드는 계정의 키입니다. 시드를 알고 있다면(또는 시드를 알고 있는 다른 사람이 있다면)이 계정을 제어하고 비밀번호를 잊어버린 경우에도 다시 생성할 수 있습니다. **시드를 안전한 곳에 저장하는 것이 매우 중요합니다**, 가능하면 종이나 기타 비디오 장치에 저장하십시오. \\n\\n시드를 저장하고 `Next step`를 누르십시오. 다음과 같은 메뉴가 표시됩니다.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* 네트워크 중에서 이 계정을 독점적으로 사용할 네트워크를 선택할 수 있습니다. 동일한 주소를 여러 네트워크에서 사용할 수 있지만, 개인 정보 보호를 위해 각 사용하는 네트워크마다 새 주소를 생성하는 것이 권장됩니다. \\n드롭다운 목록에서 로보노믹스 네트워크를 선택하십시오. 로보노믹스 네트워크를 찾을 수 없는 경우 메타데이터를 업데이트하지 않은 것입니다. 되돌아가서 업데이트하십시오.\\n\\n    - 주소 형식과 계정 아이콘이 변경되는 것을 알 수 있습니다. 이는 정상입니다. 다른 네트워크 형식은 동일한 공개 키의 다른 표현일 뿐입니다. \\n\\n- *Name* 계정 이름은 사용자만을 위한 것입니다. 블록체인에 저장되지 않으며 다른 사용자에게는 표시되지 않습니다. \\n\\n- *Password* 계정 정보를 암호화하는 데 사용됩니다. 포털에서 거래를 서명할 때 다시 입력해야 합니다. 하나를 생성하고 기억하세요.\\n\\n결과적으로 계정을 생성한 후에는 Polkadot{.js} 확장 프로그램의 계정 목록에서 볼 수 있습니다. 세 개의 점을 클릭하여 계정의 름을 변경하거나 내보내거나 확장 프로그램에서 제거하고 계정에 사용되는 네트워크를 변경할 수 있습니다. \\n\\n또한, 계정은 확장 프로그램을 사용하여 주입되었음을 나타내는 **Accounts -> Accounts** 메뉴에 나타납니다.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Robonomics Parachain 앱에서 직접\\n\\nPolkadot / Substrate 포털에서 사용자 인터페이스를 사용하여 계정을 생성할 수 있습니다. 개발 및 테스트에 사용할 수 있습니다. \\n\\n## 2.1. Robonomics Parachain 앱 열기\\n\\nPolkadot / Substrate 포털의 [Robonomics Parachain 앱](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/)로 이동하세요. **왼쪽 상단 모서리에서 Robonomics Parachain에 연결되었는지 확인하세요**.  \\n\\n**Accounts -> Accounts** 으로 이동하여 `계정 추가` 버튼을 누르세요. \\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. 계정 생성\\n\\n다음과 같은 팝업 메뉴가 표시됩니다. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\n두 가지 형식이 있습니다: *니모닉* (인간이 읽을 수 있는 형식) 및 *Raw* (숫자와 문자의 연속). 시드 구문을 안전하게 저장하고 `다음`을 누르세요.\\n\\n> 또한, 계정 생성의 암호 유형을 변경할 수도 있습니다. `고급 생성 옵션`을 열고 형식(`ed25519`이 그림에서 선택된 형식)을 선택하세요.\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\n다음 메뉴에서 계정 이름과 비밀번호를 설정해야 합니다. 위에서 설명한 확장 프로그램의 지침과 유사합니다.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\n`Next` 버튼을 클릭하면 마지막 창으로 이동합니다. 계정 생성을 완료하려면 `Save`을 클릭하세요. 또한, 계정을 안전하게 보관해야 하는 백업 JSON 파일도 생성됩니다. 나중에 비밀번호를 기억한다면 이 파일을 사용하여 계정을 복구할 수 있습니다.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 ed25519 계정을 Polkadot 확장 프로그램에 추가\\n\\n생성한 계정을 Polkadot.js 확장 프로그램에 추가해야 할 수도 있습니다 (ed25519 계정의 경우 백업 JSON 파일만 사용할 수 있습니다). 계정의 세 개의 점을 누르고 `이 계정에 대한 백업 파일 생성`을 선택하고 비밀번호를 입력하세요.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\n그런 다음 확장 프로그램을 열고 오른쪽 상단의 `+` 버튼을 누르고 `Restore account from backup JSON file`을 선택하세요.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\n열린 창에 저장된 파일을 놓고 비밀번호를 입력하고 `Restore`을 누르세요.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. 계정이 성공적으로 생성되었습니다 \\n\\n이제 새로 생성한 계정을 완전히 사용할 수 있습니다. 토큰을 보내고 받고, 메시지를 보내고, 데이터로그를 작성하는 등의 작업을 수행할 수 있습니다. 앱의 모든 기능을 자유롭 탐색하세요. 계정 주소를 복사하려면 해당 아이콘을 클릭하면 주소가 클립보드에 복사됩니다. \\n\\nPolkadot / Kusama 계정 및 추가적인 생성 방법에 대해 더 알고 싶다면 [여기](https://wiki.polkadot.network/docs/learn-accounts)와 [여기](https://wiki.polkadot.network/docs/learn-account-generation)에서 자세한 정보를 찾을 수 있습니다.\\n\"}},{\"node\":{\"id\":\"d5c957828da2c5e6c69a12b16249b60b\",\"title\":\"오셋팅 서비스\",\"path\":\"/docs/ko/carbon-footprint-service/\",\"content\":\"\\n작업 예시는 동영상에 있습니다:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nService to offset CO2 footprint by burning tokens in Statemine network. \\n생산된 CO2는 다음과 같이 계산됩니다: 기기에서의 데이터(Wh)에 지역에 따라 다른 계수를 곱합니다. 1톤의 CO2는 1토큰의 소비로 상쇄됩니다. [여기](/docs/carbon-footprint-sensor)에서 기기 연결을 위한 지침을 확인할 수 있습니다.\\n\\n## 시나리오\\n\\n1. 로보노믹스 네트워크의 디지털 트윈에 새로운 기기를 등록합니다. \\n2. 일정 간격으로 모든 기기에서 최신 데이터를 가져와 지역에 따라 계수를 곱합니다.\\n3. 데이터를 합산하고 CO2 톤으로 변환합니다.\\n4. 현재 데이터에서 총 연소 토큰 수를 차감합니다. \\n5. Statemine 네트워크에서 정수 개수의 토큰을 연소합니다. \\n6. 로컬 DB와 데이터로그에 총 연소 토큰 수를 저장합니다. \\n\\n\\n## 설치\\n\\n저장소를 복제하고 구성 파일을 편집합니다.\\n\\n```\\ngir clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## 구성 description\\n\\n`config/config_template.yaml` 파일을 편집하지 마세요!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network where Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\n재생 가능하지 않은 에너지에 대한 계수는 [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg)에서 가져와 `utils/coefficients.py`에 저장되어 있습니다. \\n\\n## 실행\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"899f206a9c105cc06004d095e951018a\",\"title\":\"센서 연결\",\"path\":\"/docs/ko/carbon-footprint-sensor/\",\"content\":\"\\n작업 예시는 동영상에 있습니다:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## 요구 사항\\n\\n* [Aqara 스마트 플러그](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* 라즈베리 파이\\n* Zigbee 어댑터 [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (또는 [지원되는](https://www.zigbee2mqtt.io/information/supported_adapters.html) 어댑터 중 하나)\\n\\n서비스는 라즈베리 파이에서 실행되며 zigbee 프로토콜을 통해 스마트 플러그와 통신합니다.\\n\\n## Zigbee 스틱\\n\\nJetHome USB JetStick Z2를 가지고 있다면 이미 필요한 펌웨어가 있으므로 플래시 할 필요가 없습니다. 그러나 다른 어댑터를 가지고 있다면 먼저 zigbee2MQTT 소프트웨어로 플래시해야 합니다. 당신의 장치에 대한 지침은 [여기](https://www.zigbee2mqtt.io/information/supported_adapters.html)에서 찾을 수 있습니다.\\n\\n어댑터를 연결하고 어댑터 주소를 확인하세요 (또는 `/dev/ttyUSB1`일 수도 있음):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\n먼저 USB 포트에 액세스해야 할 수도 있습니다. 사용자를 `dialout` 그룹에 추가하세요 (ubuntu에서 작동하지만 다른 OS에서는 그룹 이름이 다를 수 있음).\\nubuntu의 경우:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\narch의 경우:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\n그런 다음 로그아웃하고 로그인하거나 컴퓨터를 다시 시작하세요.\\n\\n## 설치\\n\\n저장소를 복제하세요:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## 구성\\n\\n`data/configuration.yaml`로 이동하고 `permit_join: true`로 설정하세요:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\n또한 `server` 필드와 `port` 필드를 해당 정보로 채우고 연결을 설정할 수 있습니다. `server` 필드에서는 `docker0` 브리지의 IP를 사용하세요: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\n여기에서 주소는 `172.17.0.1`입니다.\\n\\n그런 다음 다음 정보를 포함하는 파일 config/config.yaml을 생성하고 위치를 설정하세요 (3자리 ISO 코드에 대한 정보는 https://countrycode.org/에서 찾을 수 있습니다):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## 플러그 연결\\n\\n첫 실행:\\n\\n```\\ndocker-compose up     \\n```\\n\\n플러그의 페어링 모드로 전환하려면 전원 버튼을 길게 눌러 파란색 빠르게 깜박이는 빛이 나타날 때까지 몇 초 동안 누르세요. \\n\\n로그에서 이제 플러그가 mqtt로 게시되기 시작한 것을 볼 수 있어야 합니다. \\n\\n\\n## 페어링 후\\n\\n다른 장치가 스틱과 페어링할 수 없도록 하려면 이제 `data/configuration.yaml`로 이동하고 `permit_join: false`로 설정하세요. 서비스를 다시 시작하세요 ('Ctrl+C'를 사용하여 변경  \\n\\n```bash\\ndocker-compose up     \\n```\\n사항을 제출한 후 다시 시작).\\n\\n## 실행\\n플러그에 대한 계정이 처음 시작할 때 생성됩니다. \\n> 이미 계정이 있는 경우 `config.config.yaml` 파일의 `device_seed` 섹션에 시드를 추가해야 합니다:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\n 계정을 생성한 후 로그에서 주소를 확인할 수 있습니다 (시드는 `config/config.yaml`에 추가됩니다):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\n이 계정에 일부 토큰을 이체하여 거래 수수료를 지불해야 합니다. [Robonomics 포털](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts)에서 이를 수행할 수 있습니다. \\n\\n서비스는 충분한 토큰이 있는 것을 인식하고 로그에서 다음과 같이 볼 수 있습니다:\\n```\\nplug               | Balance is OK\\n```\\n서비스는 플러그와 안전한 전력 사용으로부터 MQTT 메시지를 수신합니다. 매 시간마다(`config/config.yaml`의 `sending_timeout` 섹션에서 타임아웃을 변경할 수 있으며, 타임아웃은 초 단위로 설정됩니다) 다음 정보를 포함하는 데이터로그를 생성합니다:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"e63b5af92b1cd581a6f093a891881312\",\"title\":\"백업 서비스\",\"path\":\"/docs/ko/backup-services/\",\"content\":\"\\n**이 문서에서는 Home Assistant 구성의 백업을 생성하고 필요할 때 복원하는 방법을 배우게 됩니다. 백업을 생성하기 위해 구성 파일이 포함된 안전한 아카이브를 생성하는 서비스를 호출합니다. 또한 서비스는 Mosquitto 브로커와 Zigbee2MQTT 구성도 백업에 추가합니다(있는 경우). 그런 다음이 서비스는 아카이브를 IPFS에 추가하고 결과 CID를 Robonomics Digital Twin에 저장합니다.**\\n## Home Assistant 구성의 백업 생성하기\\n\\n백업을 생성하면 장애 발생 시 Home Assistant 구성을 쉽게 복원할 수 있습니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\n구성을 백업하고 복원하려면 **Pinata와 같은 사용자 정의 IPFS 게이트웨이**를 사용해야 합니다. 그렇지 않으면 백업은 로컬 IPFS 노드에만 저장되어 로컬 노드 장애 시 Home Assistant 구성을 복원할 수 없을 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n1. Home Assistant의 웹 인터페이스에서 `Developer Tools` -> `Services`로 이동합니다. `Robonomics: Save Backup to Robonomics`를 검색하고 `CALL SERVICE`를 누릅니다.\\n\\n2. `Notification`에 `Backup was updated in Robonomics`라는 알림이 표시될 때까지 기다립니다.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nHome Assistant 및 Robonomics 통합을 로드 한 직후에는 즉시 백업을 생성하거나 구성을 복원하지 마십시오. 초기 설정이 완료되기까지 약 5 분 정도 기다려야합니다.\\n\\n</robo-wiki-note>\\n\\n서비스 인수:\\n- **전체 백업** (기본값: False) - 데이터베이스를 백업에 추가하여 엔티티 상태의 기록이 저장됩니다.\\n- **Mosquitto 비밀번호 파일 경로** (기본값: `/etc/mosquitto`) - Home Assistant Core 또는 Docker 설치 방법을 사용하고 기본 Mosquitto 브로커 경로가 없는 경우이 매개 변수를 변경해야합니다. *Home Assistant OS 또는 Superviser에는 필요하지 않음*.\\n\\n## 백업에서 Home Assistant 구성 복원하기\\n\\n구성을 복원하려면 설치된 Home Assistant 및 Robonomics 통합이 필요합니다. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nHome Assistant Core 및 Docker 설치 방법에서 구성을 성공적으로 복원하려면 페이지 맨 아래에 설명 된 추가 설정 단계를 수행해야합니다.\\n\\n</robo-wiki-note>\\n\\n1. [원하는 설치 방법](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home)에 대한 기사에서 Home Assisntant와 Robonomics 통합을 설치합니다(아직 설치되지 않은 경우).\\n\\n2. 이전 Robonomics 구성에서 사용한 **동일한 시드**를 사용하여 [Robonomics 통합 설정](https://wiki.robonomics.network/docs/robonomics-hass-integration)을 수행합니다. 구독이 종료된 경우 [재활성화](https://wiki.robonomics.network/docs/sub-activate)하세요.\\n\\n3. Home Assistant의 웹 인터페이스에서 `Developer Tools` -> `Services`로 이동합니다. `Robonomics: Restore from the Backup in Robonomics`을 검색하고 'CALL SERVICE'를 누르세요. `Overview` 페이지로 이동하여 백업 상태를 확인하세요.\\n\\n4. 복원 후, 홈 어시스턴트는 자으로 재시작됩니다. 홈 어시스턴트가 어떤 이유로 인해 재시작되지 않는 경우, `robonomics.backup` 엔티티의 상태를 모니터링하여 복원 상태를 확인할 수 있습니다. 상태가 `restored`인 경우, `Settings` > `System`으로 이동하여 오른쪽 상단에 있는 `RESTART` 버튼을 클릭하여 홈 어시스턴트를 수동으로 재시작해야 합니다.\\n\\n5. 백업에 Zigbee2MQTT 또는 Mosquitto 구성이 포함된 경우, 새 구성을 활성화하기 위해 이러한 서비스를 재시작해야 합니다. 이를 수동으로 개별적으로 재시작하거나 홈 어시스턴트 컴퓨터 전체를 재시작하여 모든 서비스를 재시작할 수 있습니다.\\n\\n서비스 인수:\\n- **Mosquitto 패스워드 파일 경로** (기본값: `/etc/mosquitto`) - Home Assistant Core 또는 Docker 설치 방법을 사용하고 Mosquitto 브로커의 기본 경로가 아닌 경우,이 매개 변수를 변경해야 합니다. *Home Assistant OS 또는 Superviser에는 필요하지 않음*.\\n- **Zigbee2MQTT 구성 파일 경로** (기본값: `/opt/zigbee2mqtt`) - Home Assistant Core 또는 Docker 설치 방법을 사용하고 Zigbee2MQTT의 기본 경로가 아닌 경우,이 매개 변수를 변경해야 합니다. *Home Assistant OS 또는 Superviser에는 필요하지 않음*.\\n\\n## Home Assistant Core 치 방법을 위한 Mosquitto 및 Zigbee2MQTT 구성 복원\\n\\n백업에 Mosquitto 또는 Zigbee2MQTT 구성이 포함된 경우, 복원 프로세스 중에 해당 구성이 기본 경로 또는 인수로 지정된 경로에 배치됩니다. 그러나 Robonomics 통합을 기존의 Home Assistant Core에 설치한 경우 *(미리 설치된 Robonomics 이미지가 아닌 경우)*, `homeassistant` 사용자가이 경로에 액세스 할 수 없을 수 있습니다.\\n\\n따라서 Mosquitto 및 Zigbee2MQTT 구성을 복원하려면 사용자 `homeassistant`에 필요한 읽기 권한을 부여해야 합니다.\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Home Assistant Docker 설치 방법을 위한 Mosquitto 및 Zigbee2MQTT 구성 백업\\n\\nDocker 컨테이너에서 Mosquitto 및 Zigbee2MQTT 구성을 백업하려면 각각의 구성을 위한 볼륨을 생성해야 합니다. 이는 Home Assistant 컨테이너를 추가 인수와 함께 실행하여 달성할 수 있습니다:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\n또는 `compose.yaml` 파일에서 변경을 수행할 수 있습니다:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\n기본 Mosquitto 및 Zigbee2MQTT 구성 경로는 각각 `/etc/mosquitto` 및 `/opt/zigbee2mqtt`입니다. 그러나 이러한 경로는 특정 설정에 따라 다를 수 있습니다.\\n\\n</robo-wiki-note>\\n\\n## 백업 버튼\\n\\n백업 작업을 위해 서비스를 사용하는 것 외에도 Robonomics 통합에서 `button.create_backup` 및 `button.restore_from_backup` 버튼을 사용하여 프로세스를 간소화할 수 있습니다. 이러한 버튼은 기본 매개 변수 (백업 버튼은 히스토리없이 백업을 생성함)으로 해당 서비스를 호출합니다.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\n대시보드에 버튼을 추가하려면 다음 단계를 따르십시오:\\n\\n1. 대시보드의 오른쪽 상단에있는 세 개의 점을 클릭하십시오.\\n2. `Edit Dashboard`을 선택하십시오.\\n3. 오른쪽 하단에있는 `Add Card` 버튼을 클릭하십시오.\\n4. `Entities` 카드를 선택하십시오.\\n5. `Entities` 필드에서 button.create_backup 및 button.restore_from_backup 엔티티를 검색하십시오.\\n6. 엔티티를 카드에 추가하려면 `Save`을 누르십시오.\\n7. 완료를 위해 오른쪽 상단에있는 `Done` 버튼을 클릭하여 편집을 마칩니다.\"}},{\"node\":{\"id\":\"fdad1844a8b3b30dd9803f77dada443f\",\"title\":\"Robonomics 포털에서 계정에 자금 추가하기\",\"path\":\"/docs/ko/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Robonomics 포털에서 계정을 성공적으로 생성한 후에는 거래를 시작할 수 있도록 자금을 추가해야 합니다.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  이 튜토리얼 및 다음 튜토리얼은 Robonomics 노드의 로컬 인스턴스에서 보여줍니다. [이 지침](/docs/run-dev-node)을 사용하여 자신의 인스턴스를 설정하세요.\\n\\n</robo-wiki-note>\\n\\n## 1. Robonomics 포털의 계정 섹션으로 이동합니다.\\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. 자금을 이체하려는 계정 선택하기\\n\\n개발 모드에서는 개발 네트워크에서 생성된 다른 계정으로 자금을 이체할 수 있는 10000 유닛 가치의 자금을 가진 여러 계정이 존재합니다. 이러한 계정은 옆에 렌치 표시 <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" />로 표시됩니다.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- 예를 들어 BOB에서 자금을 이체하려는 계정의 \\\"send\\\" 버튼을 클릭하세요.\\n\\n## 3. 자금을 이체하려는 계정 선택하기\\n\\\"send\\\" 버튼을 클릭한 후에는 \\\"send funds window\\\"이 표시됩니다. 표시된 창에서:\\n\\n- 사용 가능한 계정 목록에서 자금을 보내려는 계정을 선택하세요.\\n- 보내려는 유닛 수를 입력하세요.\\n- \\\"make transfer\\\"을 누르세요.\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. 거래 승인하기\\n\\n이전 단계에서 \\\"make transfer\\\"을 누른 후에는  \\\"authorize transaction window\\\"이 표시됩니다.<br/>\\n거래의 세부 정보를 검토한 후에 \\\"sign and submit\\\" 버튼을 클릭하세요.\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\n이 예제에서는 \\\"BOB\\\"에서 \\\"EMPLOYER\\\"로 500 유닛의 자금을 이체했습니다. 초기에 자금이 없던 EMPLOYER의 계정에는 이제 500 유닛의 자금이 있음을 확인할 수 있습니다.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**플레이그라운드에서 사용하려는 계정에 충분한 자금이 있는지 확인하세요.**\"}},{\"node\":{\"id\":\"c48a00eb630772976dfaefb89f6bd2d6\",\"title\":\"Zigbee2MQTTを使用したZigbeeアダプターのプリインストールイメージ\",\"path\":\"/docs/ja/zigbee-to-mqtt-image/\",\"content\":\"\\n**この記事では、スマートデバイスをペアリングします。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nウェブブラウザを開き、`http://%RASPBERRY_IP_ADDRESS%:8099`にアクセスします。Raspberry PiのIPアドレスは、[Fingモバイルアプリ](https://www.fing.com/products)または[nmap CLIツール](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)を使用して見つけることができます。\\n\\nZigbee2MQTTのウェブインターフェースが表示されます：\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nスマートデバイスを接続する時間です。 \\nまず、Zigbee2MQTTのウェブインターフェースの上部にある`Permit join (All)`ボタンを押します。 \\n\\n次に、デバイスをペアリングします。デバイスを接続モードに切り替える最も一般的な方法は、電源ボタンを長押しするか、5回オン/オフすることです。Zigbee2MQTTが実行されていることを確認してください。\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nデバイスが接続されると、ウェブインターフェースに表示されます：\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nこれでHome Assistant WebUIでこのセンサーが表示されるはずです。`Settings` -> `Devices & Services` -> `Devices`に移動します：\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nすべてのセンサーを追加した後、Zigbee2MQTTのウェブインターフェースを閉じることができます。\\n\"}},{\"node\":{\"id\":\"41eff665bf4ae4c80baf994069206948\",\"title\":\"クロスチェーンメッセージングのためのSubstrate Cumulus Parachain Testsuite\",\"path\":\"/docs/ja/xcm-robobank/\",\"content\":\"\\n\\nこのプロジェクトの主な目標は、クロスチェーンメッセージが使用される場合のパラチェーンランタイムの開発を簡素化することです。 \\nこれにより、高い再現性と簡単な使法を備えた統合テストを使用してランタイムコードの開発が可能になります。\\nこれにより、ビルドの自動化、事前に設定されたネットワーク構成（リレーチェーン+2つのパラチェーン）、パラチェーン間のメッセージパッシングチャネルの設定、メッセージングテストの実行、ランタイムへの呼び出しを使用したメッセージの送信などが、すべてPythonで構築および構成されます。\\n\\nXCM Testsuiteは、Robobankの製品サイクルのテストに使用されます。Robobankは、外部パラチェーンに登録し、前払い注文を受け取り、それらを実行し、外部トークンを使用して支払いを受け取るためのSubstrateパレットのセットです。これにより、ロボットは必要なインフラストラクチャを備えたRobonomicsネットワーク内で動作することができますが、同時に、他のどのパラチェーンでもサービスを提供することができます。\\n\\n[YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)で例のビデオをご覧いただけます。\\n\\nデモシナリオの主なステップは次のとおりです。\\n- リレーチェーンと2つのパラチェーンを6つのプロセスのパックで起動する\\n- パチェーン間のXCMメッセージチャネルの設定\\n- 両方のパラチェーンにロボットを登録する\\n- クライアントパラチェーンでこのロボットの注文を作成する（注文の完了に対する支払いを予約する）\\n- RobonomicsパラチェーンにXCMメッセージを送信する\\n- Robonomicsパラチェーンに\\\"ミラーリング\\\"された注文レコードを作成する\\n- ロボットがRobonomicsパラチェーンで注文を受け入れる\\n- 注文の受け入れに関するXCMメッセージをクライアントパラチェーンに送信する\\n- クライアントパラチェーンで注文を受け入れる（注文の締め切りまでの未完了注文に対するペナルティ料金を予約する）\\n- ロボットがRobonomicsパラチェーンで注文を完了する\\n- 注文の完了に関するXCMメッセージをクライアントパラチェーンに送信する\\n- すべての支払いを解決する（クライアントの支払いはロボットに転送され、未使用のペナルティ料金も転送される）\\n- 注文1を閉じる\\n\\n\\n## 上流\\nこのプロジェクトはのフォークです\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nテストされているランタイムパレットのコードが含まれています。\\n元のノードコードのパラチェーンは、\\\"./pallets\\\"、\\\"./runtime\\\"、\\\"./node\\\"のカタログにあります。\\n\\n\\\"substrate-node-template\\\"との違い\\n- このコレータランタイムにはHRMPハンドラモジュールがあり、兄弟パラチェーンからのメッセージを処理できます\\n- 内部XCMテスト用のモックテストランタイムが準備されています\\n\\n## ビルド＆実行\\n推奨（非常に）セットアップ： \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[注意]最初のビルドには多くの時間がかかる場合があります。サブオプティマルなマシンでは数時間かかることがあります。\\n\\n[注意]スクリプトは、リレーチェーンとパラチェーンのFIXEDバージョン（コミットハッシュ）で動作します。\\n\\n[注意]デフォルトでは、スクリプトは前回の状態をすべて削除して、毎回同じ環境を再作成します。この動作は、\\\"config.sh\\\"で\\\"PERSISTENT\\\"パラメータを使用して変更できます。\\n\\n\\nビルドおよびセットアップスクリプトを実行します。  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\n\\\"init.sh\\\"スクリプトの基本的なアクション：\\n - 設定を読み取る（リビジョン番号、初期ノードキーと識別子、チェーンデータの永続性パラメータなどが記述された\\\"config.sh\\\"ファイル）\\n - OSパケッ、Rust、Pythonのセットアップ\\n - リレーチェーンと両方のパラチェーンのために別々のバイナリをビルドする\\n    - バイナリは./binサブディレクトリに生成されます。 \\n - （オプション）すべてのチェーンの前のチェーンデータを削除します\\n    - \\\"config.sh\\\"で\\\"PERSISTENT=1\\\"が設定されている場合は無効になります\\n - 別々のプロセス（別々のPIDとI/Oパイプで実行）として実行されます：\\n    - リレーチェーンのバリデータ（安定したRococoリビジョンを実行する4つのバリデータ）\\n    - パラチェーン-100のコレータ（開発中の最初のパラチェーンのための単一のコレータ）\\n    - パラチェーン-200のコレータ（開発中の2番目のパラチェーンのための単一のコレータ）\\n - すべてのチェーンのすべてのエンドポイント、ポートをコンソールに表示し、フロントエンドアプリ（エクスプローラ、DApp）を使用して任意のチェーンを研究できるようにします\\n - すべてのチェーンのすべての出力データをコンソールに継続的に表示し続けます\\n\\n[警告]起動後、ネットワークが起動し、ブロックの最終化が開始され、パラチェーンが登録されまで待機してください。これらのプロセスは約5分（50ブロック×6秒）かかるはずです。\\n\\n## 初期セットアップが機能していることを確認する \\n\\n標準のPolkdotフロントエンドと生成された\\\"--ws-port\\\"エンドポイントを使用して各ノードに接続するために、[Polkadotアプリケーション](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)を開きます。\\n例： \\n\\n### ローカルホスト、4つのリレーチェーンバリデータ、1つのパラチェーン-100コレータ、1つのパラチェーン-200コレータ：\\nLocalhost, 4 relay chain validators, one parachain-100 collator, one parachain-200 collator:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nすべてがうまくいけば、合意が始まり、テストケースを実行することができます（新しいターミナルで）。\\n\\n### UMPメッセージパッシングテスト\\n```bash\\n./scripts/init.sh ump\\n```\\n`parachain-100`で`Balance.transfer`メッセージを作成し、リレーションチェーンに渡します。\\nリレーションチェーンがメッセージを受信すると、`para 100`アカウントからCharlieアカウントに15トークンを転送します。\\n\\n\\n### HRMPメッセージパッシングテスト\\n```bash\\n./scripts/init.sh ump\\n```\\n\\n`parachain-100`で`Balance.transfer`メッセージを作成し、`sibling 200`に渡します。\\nその前に、`subl 100`アカウントに1000トークンを与え、パラチェーン間の通信チャネルを確立します。\\n```bash\\n./scripts/init.sh hrmp\\n```\\n次のメッセージは`hrmpm`サブコマンドを実行することで送信できます。チャネルは作成されないため、より高速に実行されます。\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### その他のオプション\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## ローカルテストネット\\n\\n### カスタマイズされたチェーン仕様の作成\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nrococo_local.jsonを編集し、残高と権限のパラメータを自分のものに置き換えます。\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\n//Alice//stashのPolkadotアドレス（sr25519暗号化）\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\n//AliceのPolkadotグランドパセッションキー（ed25519暗号化）\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\n//AliceのPolkadotアドレス（sr25519暗号化）\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nrococo_local.jsonを生の形式に変換します。\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\n新しいチェーン仕様を使用するには、./config/ディレクトリのrococo.jsonファイルをこの新しいものに置き換えてチェーンを再実行します。\\n```bash\\n./scripts/init.sh run\\n```\\nコードを自由に編集できます。上記のコマンドはプジェクトを再構築し、コラーターノードを更新してから開始します。\\nCumulusはまだ開発中のプレリリースソフトウェアです。\\n私たちは特定のコミットのpolkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)を使用しています。\\n\\nより新しいバージョンのソフトウェアを使用することもできます。これを行うには、./scipt/config.shのPOLKADOT_COMMITを`\\nrococo-v1`ブランチの最新のコミットに変更し、./bin/polkadotを削除して実行します。 \\n```bash\\n./scripts/init.sh run\\n```\\n\\nコラータープロジェクトの依存関係を更新します. \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\n一部の依存関係はおそらく新しいRustツールチェーンの機能を必要とします。このプロジェクトはRust `nightly-2021-01-26`に基づいています。\\nビルド前に./scripts/config.shでRustツールチェーンのバージョンを更新してください。\\n\\n## パラチェーンをハックする \\n[外部パレットを追加](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - おそらく「詳細を学ぶ」にあるべきですか？\\n## Learn More\\n\\nこのプロジェクトの構造、カプセル化された機能、およびそれらの機能が実装される方法については、上流の[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template)を参照してください。公式のPolkadotブログで[パラチェーンブロックの経路](https://polkadot.network/the-path-of-a-parachain-block/)について詳しく学ぶことができます。[Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"51c3a9d1336eab7f553f8403891895ac\",\"title\":\"ブループリントの使い方\",\"path\":\"/docs/ja/use-blueprints/\",\"content\":\"\\nこの記事では、自動化ブループリントをHome Assistantに追加し、設定する方法について説明します。\\n\\n## ブループリント自動化\\n\\n一部のブループリントはすでにインストールされています。このようなブループリントに基く自動化は、設定するだけで済みます。Webインターフェースでは、`Settings/Automations & Scenes`で事前にインストールされたブループリントを見つけることができます。`Blueprints`を開き、使用したいブループリントを見つけます。この例では、`Motion-activated Light`を使用します。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\n`Create Automation`をクリックして自動化エディタを開きます。名前を付け、使用するブループリントを選択します（この場合は`Motion-activated Light`）。その後、モーションセンサーとランプを選択する必要があります。構成が完了したら、`Save`をクリックします。\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation 設定\\\" />\\n\\n変更を加えたい場合は、 `Settings/Automations & Scenes`に移動し、`Automations`を選択します。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## ブループリントのインポート\\n\\nHome Assistantは、Home Assistantフォーラム、GitHub、GitHub gistsからブループリントをインポートすることができます。すべてのブループリントのリストは[ブループリントエクスチェンジ](https://community.home-assistant.io/c/blueprints-exchange/53)にあります。選択した後、`Settings/Automations & Scenes`に移動し、`Blueprints`を開きます。`Import Blueprint`をクリックし、選択したブループリントのURLを挿入します。その後、`PREVIEW BLUEPRINT`をクリックします。この場合、[すべてのバッテリーセンサーの低バッテリーレベル検出と通知](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664)を使用します。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nこれにより、ブループリントが読み込まれ、インポートダイアログでプレビューが表示されます。名前を変更し、インポートを完了します。`Create Automation`をクリックして自動化エディタを開きます。ここで、自動化のパラメータを設定し、通知を受け取るためのアクションを追加することができます。\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"799ccfa37a5bb5249f5e8e6e667aa5db\",\"title\":\"サブスクリプションを使用して起動を送信する方法\",\"path\":\"/docs/ja/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  このチュートリアルでは、Robonomics Kusamaパラチェーンでサブスクリプションを使用する方法を示しています。同じ手順を[ローカルノード](/docs/run-dev-node)でも実行できます。\\n\\n</robo-wiki-note>\\n\\nアドレスにアクィブなサブスクリプションがある場合、そのアカウントのシークレットで設定されたデバイスは手数料なしでエクストリンシックを送信できます。 \\n`launch`コマンドを送信してみましょう。\\n\\n`Developer/Extrinsics`ページに移動し、アカウント（デバイスリストからのアカウント）を選択し、`rws -> call(subscriptionId, call)`を選択します。 \\n次に、`subscriptionId`フィールドにサブスクリプションの所有者アドレス（オークションに入札したアドレス）を貼り付け、次のフィールドで`launch -> launch(robot, param)`を選択します。`robot`フィールドには`launch`トランザクションを送信したいアドレスを入力し、コマンドを挿入します（起動コマンドの説明については[こちら](/docs/launch)を参照してください）。その後、トランザクションを送信します。\\n\\n![launch](../images/rws/launch.png)\\n\\n\\n今、`Network/Explorer`ページに移動し、`Recent Events`エリアに作成した2つのイベント、`rws.NewCall`と`launch.NewLaunch`が表示されます。\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"50efc2ecc7adcb0f55b7d4fb9dcb7186\",\"title\":\"サブスクリプションを有効にする\",\"path\":\"/docs/ja/sub-activate/\",\"content\":\"\\nこの記事では、Robonomicsパラチェーンアカウントを作成し、IoTサブスクリプションを購入します。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nRobonomicsを使用してHome Assistantを制御するには、Robonomicsパラチェーン上に2つのアカウントが必要です。1つのアカウント（`sub_owner`）ではRobonomicsのサブスクリプションを購入します。2番目のアカウント（`sub_controller`）ではHome Assistantのすべてのプロセス（テレメトリなど）を制御し、他のユーザーにアクセスを提供します。これらのアカウントはHome Assistantのセキュリティを提供します。 \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nどちらのアカウントも **ed25519** 暗号化を使用して作成する必要があります。 このため、Polkadot-JS UI を使用してアカウントを作成し、必要な暗号化を選択する必要があります。 \\n\\nこの機能はPolkadot-JS UIではデフォルトで無効になっています。有効にするには、`Settings` -> `General` -> `account options` に移動し、 `Allow local in-browser account storage` をドロップダウンメニュー`in-browser account creation` で選択します。\\n\\n</robo-wiki-note>\\n\\n## 所有者アカウントとコントローラーアカウントを作成する\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. [Robonomics Parachainアプリ](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/)にアクセスします。**左上隅を確認して、Robonomics Parachainに接続されていることを確認してください。**\\n\\n2. `Accounts` -> `Accounts` に移動し、`Add account` ボタンを押します。 アカウント シードを含むポップアップ メニューが表示されます。 これには、*Mnemonic* (人間が読める形式) と *Raw* (一連の数字と文字) の 2 つの形式があります。 \\n\\n3. `Advanced creation options`を開き、アカウントの暗号タイプを`Edwards - ed25519`に変更し、`Next`を押します。\\n\\n\\n4. ニーモニックシードフレーズを安全に保存し、`Next`を押します。\\n\\n5. 次のメニューで、アカウント名とパスワードを設定する必要があります。便宜のために`sub_owner`という名前を付けます。`Next`を押します。\\n\\n6. 最後のウィンドウで`保存`をクリックしてアカウントの作成を完了します。また、バックアップのJSONファイルも生成されますので、安全に保存してください。パスワードを覚えている場合は、後でこのファイルを使用してアカウントを回復することができます。\\n\\n7. `sub_controller`という名前のアカウントについても、これらの手順を繰り返します。\\n\\n\\n## Polkadot.jsにアカウントを追加する\\n\\n便利のために、[Polkadot.js拡張機能](https://polkadot.js.org/extension/)を使用して、これらの新しく作成されたアカウントを追加する必要があります。ed25519アカウントの場合、バックアップJSONファイルのみを使用して行うことができます。アカウントを作成したときに保存したファイルを使用できます。\\n\\nアカウントのバックアップファイを作成するには、アカウント上の3つのドットを押し、`Create a backup file for this account` を選択し、パスワードを入力します。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. 拡張機能を開き、右上の`+`ボタンを押し、`Restore account from backup JSON file` を選択します。\\n\\n2. 開いたウィンドウでJSONファイルをアップロードし、パスワードを入力して `Restore` を押します。\\n\\n3. Polkadot.js拡張機能のアカウントにRobonomicsネットワークが選択されていることを確認してください。Polkadot / Substrate Portalで`Setting` -> `Metadata` に移動し、`Update metadata` ボタンをクリックします。 \\n\\n4. ポップアップでメタデータの更新を確認します。これで、拡張機能はアドレスが使用されるネットワークのラベルを表示します。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Robonomicsサブスクリプションを有効にする \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nこの手順では、`sub_owner`アカウントに十分な量のXRTトークン（最小2-3 XRT）が必要です。\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. RobonomicsのDappにアクセスし、[サブスクリプションページ](https://dapp.robonomics.network/#/subscription)に移動し、右サイドバーの「アカウントに接続」を押します。\\n\\n2. 次のップアップメニューでPolkadot.js拡張機能に接続します。アカウントアドレスと残高が表示されます。\\n\\n3. 購入する前に、`sub_owner`アカウントを選択したことを確認してください。アドレスプロファイルアイコンを押すと、`Check owner account` フィールドの下に`sub_owner`アカウントが表示されるはずです。\\n\\n4. 最後に、「SUBMIT」ボタンを押し、アカウントのパスワードを入力します。その後、アクティベーションプロセスが完了するまで待ちます。しばらくすると、サブスクリプションの状態が表示されます。\\n\\n\\n## サブスクリプションにアカウントを追加する\\n\\n次に、`sub_controller` アカウントを **アクセス リスト** に追加する必要があります。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. 拡張機能を開き、アカウント名の近くのアイコンをクリックします。これにより、アカウントアドレスがコピーされます。\\n\\n\\n2. このアドレスを**アクセスの管理**部分の`Robonomics parachain address` フィールドに貼り付けます。名前を付けて、「+」ボタンを押します。 \\n\\n3. `sub_owner`アカウントについても、手順1と2を繰り返します。\\n\\n4. `Save`を押します。ポップアップウィンドウで`sub_owner`のパスワードを入力し、アクティベーションロセスが完了するまで待ちます。\\n\"}},{\"node\":{\"id\":\"264ad1ecb8b010711c5aebaeea28c630\",\"title\":\"スマートホームテレメトリを取得する\",\"path\":\"/docs/ja/smart-home-telemetry/\",\"content\":\"\\n**この記事では、スマートホームデバイスのテレメトリをクエリするRobonomicsサービスを使用します。**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. dappに移動し、[スマートホームテレメトリ](https://dapp.robonomics.network/#/smarthome-telemetry)サービスを選択します。\\n\\n2. コントローラーフィールドに`SUB_CONTROLLER`アドレスを入力します。データを暗号化するためのシードフレーズを挿入します。\\n\\n3. `Get telemetry`ブロックで、ドロップダウンリストからタイムスタンプを選択し、`DOWNLOAD TELEMETRY`ボタンを押します。\\n\\n4. テレメトリのダウンロードには時間がかかる場合があります。完了後、デバイスとセンサーからの情報が表示されます。\\n\\n\\n<!---\\n## 起動 devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Launch\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"5022cdd659f0c1052ae570e8d543f097\",\"title\":\"Robonomics SLS ゲートウェイ\",\"path\":\"/docs/ja/sls-gateway/\",\"content\":\"\\n**この記事では、Robonomics SLS ゲートウェイをセットアップします。ゲートウェイに必要なソフトウェアをインストールし、設定し、Home Assistant に接続します。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nまず、ゲートウェイのマイクロコンローラーファームウェアをインストールする必要があります。SLS ゲートウェイの下部のスイッチ `1` と `3` を `ON` に設定して、他のスイッチは `OFF` にします。\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nゲートウェイを Raspberry Pi に USB タイプ-C ポートで接続します。\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nファームウェアのリポジトリを Raspberry Pi にクローンします:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\n`robonomics-hass-utils/esp_firmware/linux` に移動します。SLS ゲートウェイをフラッシュするには、`Clear` と `Flash_16mb` スクリプトを実行する必要があります。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### トラブルシューティング\\n\\nゲートウェイのファームウェアの更新に問題がある場合は、追加の手順が必要です:\\n\\n1. pySerial モジュールがインストールされていることを確認してください。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. ユーザーに USB ポートへのアクセス権限を与え、コンピューターを再起動してください。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. 一部の場合、ファームウェアを更新するためにスクリプトの帯域幅設定を変更する必要があります。`Flash_16mb.sh` スクリプトを `nano` エディタで開き、baud パラメータを `921600` から小さい値（例: `115200`）に変更します。\\n\\n## 設定\\n\\n1. SLS ゲートウェイをコンピューターから切断します。ゲートウェイの背面のスイッチを適切な位置に設定します。スイッチ `5`（RX Zigbee to ESP）と `6`（TX Zigbee to ESP）は `ON` の位置にする必要があります。他のスイッチは `OFF` にします。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. タイプ-C 電源ケーブルを接続します。中央のインジケーターライトが緑になるはずです。\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. 初回起動時に、ゲートウェイは Wi-Fi を SSID `zgw****` で共有します。このネットワークに接続します。信号がかなり弱い場合があるため、SLS ゲートウェイをコンピューターに近づける方が良いです。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. 接続が成功した場合、Web インターフェースが開きます（または 192.168.1.1 アドレスで見つけることができます）。 \\n\\n5. `Wi-Fi Settings` ページが表示されます。Wi-Fi を選択し、パスワードを入力します。`Apply` ボタンを押します。ゲートウェイは再起動し、Wi-Fi ネットワークに接続します。 \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. SLS ゲートウェイのローカル IP を見つけて、Web インターフェースにアクセスします。[Fing モバイルアプリ](https://www.fing.com/products) または [nmap CLI ツール](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) を使用して見つけることができます。ゲートウェイの名前は次のようになります: `zgw****`。ゲートウェイの IP をブラウザに貼り付けて、ゲートウェイの Web インターフェースを開きます。\\n\\n7. `Setting` -> `Hardware` に移動し、設定が画像のようになっていることを確認します。必要に応じて設定を修正し、`Save` ボタンをクリックします:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\n必要な値のテーブル:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. 次に、ゲートウェイを再起動します。右上隅の `Actions` -> `Reboot system` を選択します。\\n\\n9. Zigbee 情報ウィンドウでゲートウェイが正常に動作していることを確認してください。DeviceState は `OK` である必要があります。\\n\\n10. Home Assistant へのデバイスの自動追加を設定します。`Zigbee` -> `Config` に移動し、`Home Assistant MQTT Discovery` と `Clear States` を選択します。変更を保存し、再度 **ゲートウェイを再起動** します。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n自宅に既にアクティブな SLS ゲートウェイがあり、別のゲートウェイを設定している場合、それらは互いに競合します。この問題を解決するには、新しいデバイスでチャンネルを変更する必要があります。`Zigbee` -> `Config` に移動し、チャンネルを別のチャンネルに変更します（例: ャンネル 15）。\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## SLS を MQTT にペアリングする\\n\\nSLS ゲートウェイの設定が完了したら、SLS ゲートウェイを Home Assistant に接続する必要があります。SLS ゲートウェイの Web インターフェースを開き、`Settings/Link` -> `MQTT Setup` に移動します:\\n\\n\\nブローカーアドレス（ローカルネットワーク内の Home Assistant を実行している Raspberry Pi のアドレス、[Fing モバイルアプリ](https://www.fing.com/products) または [nmap CLI ツール](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) で見つけることができます）、ポート（デフォルトは `1883`）、ブローカーのユーザー名とパスワード（以前に作成したもの）、トピック名（任意の名前を選択できます）を追加します。また、Raspberry Pi の IP アドレスは静的である必要があります。`Enable` と `Retain states` をクリックします。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\n変更を保存します。これでデバイスが自動的に Home Assistant に表示されます。\\n\\n## デバイスを接続します\\n\\nデバイスを接続するには、`Zigbee` -> `Join`に移動してください。ペアリングモードにセンサーを設定します。デバイスを接続モードに切り替える最も一般的な方法は、電源ボタンを長押しするか、5回オン/オフすることです。`Enable Join`ボタを押して、Zigbeeデバイスの検索を開始します。アクティブなセンサーが表示されます。\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\n[**IoTサブスクリプション**](/docs/sub-activate)セクションに移動し、Robonomicsサブスクリプションのアクティベートを開始できます。\\n\"}},{\"node\":{\"id\":\"bb6ab533f2bd8a81d74d084499090d93\",\"title\":\"分散型センサーネットワーク\",\"path\":\"/docs/ja/sensors-network-introduction/\",\"content\":\"\\n分散型センサーネットワクに関する記事はRobonomics Academyに移されました：https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"ed644dc535b9427eb7202b9a4a2dbff2\",\"title\":\"クラウドAIを工場の現場に安全に接続する\",\"path\":\"/docs/ja/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nRobonomicsの技術は、Industry 4.0が直面する課題を既に解決しており、産業環境での実際のシナリオに既に適用されています。\\n\\n多くのAI企業が工場の現場のプロセスを最適化するためのソリューションを構築しており、工場がより少ないコストでより多くの生産を行うことを可能にしています。しかし、ほとんどの工場は、インフラを直接クラウドに接続することに躊躇しています。なぜなら、これにより潜在的なサイバーセキュリティリスクが生じ、数百万ドルの損失や人命の喪失につながる可能性があるからです。\\n\\n[MerkleBot](https://merklebot.com)は、工業クライアントが工場をクラウドベースのAIに安全に接続するためのソリューションを構築するために[Robonomics Network](https://robonomics.network)を使用しました。\\n\\nこの記事は、モバイルデバイスの写真に基づいて物理的なアイテムの非侵襲的な保護を作成するアルゴリズムを使用する[Veracity Protocol](https://www.veracityprotocol.org/)との実験の結果を受けて書かれています。\\n\\nこのユースケースでは、ロボットアームを使用して工業部品をスキャンするプロセスが示されています。\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## ステップバイステップのプロセス\\n\\n### DAppとしてのユーザーインターフェース\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDAppはオペレーターのためのユーザーインターフェースとして機能します。これは、工場環境とクラウドベースのAIの間で安全な通信を可能にするために使用されます。\\n\\n### ロボットの起動\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nオペレーターはDAppでトランザクションに署名することでロボットスキャンを起動します。このステップにより、工場の現場でのプロセスは公開ブロックチェーンのトランザクションに基づいてのみ開始されることが保証されます。\\n\\nロボットはRobonomics Networkを介してブロックチェーンからコマンドを受け取り、スキャンを開始します。Robonomics Networkの技術により、ビジネス目標とロボット操作のギャップを埋めることができます。\\n\\n### データの収集とクラウドベースのAIへの送信\\n\\nDAppでは、オペレーターは確認を表示し、ロボットはテーブル上に配置されたアイテム（このユースケースの場合）または必要に応じて直接工場ライン上にスキャンを開始します。\\n\\n<!-- ![](../images/Veracity_Protocol_Launch.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nロボットがデータを収集すると、それをローカルに保存し、IPFSプロトコルを介してクラウドベースのAIに利用可能にします。データを暗号化し、ブロックチェーンのトランザクションを介してデータ交換を組織することで、データへのアクセスをクラウドベースのAIに許可しデータが安全かつ確実に保たれることができます。\\n\\nRobonomicsに組み込まれたセキュリティメカニズムは、公開ブロックチェーンの共有セキュリティに基づいており、ほとんどの工場が独自に組織することができないほどのセキュリティレベルを確保することができます。\\n\\n### デジタルパスポートの作成\\n\\nクラウドベースのAIがデータを分析すると、ログファイルと推奨事項が自動的に[デジタルパスポート](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/)として記録されます。ブロックチェーンの記録には、IPFSプロトコルを介してこれらのファイルへのハッシュが含まれているため、すべての操作とスキャンを追跡することができます。\\n\\n## ユースケースに関するコメント\\n\\nこのユースケースでは、Universal Robot UR3工業用アームが使用されました。しかし、RobonomicsはROSをサポートしているため、KUKA、Fanuc、Yaskawaなどの主要な産業用マニピュレータを使用して、クラウドベースのAIに安全に接続することができます。\\n\\nクラウドベースのAIインストゥルメントの展開と統合について詳しく知りたい場合は、[お問い合わせください](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"d5cc6d1b06664bb87dbe17d36c01c838\",\"title\":\"Home AssistantへのSDS011センサーの追加方法\",\"path\":\"/docs/ja/sds-sensor-hass/\",\"content\":\"\\nこの記事では、SDS空気品質センサーを[Luftdaten](https://github.com/opendata-stuttgart/sensors-software)＆[Robonomics](https://github.com/airalab/sensors-software)ファームウェアとHome Assistantに接続する方法について説明します。\\n\\n## Installation \\n2のインストールオプションがあります：\\n\\n### オプション1：HACS\\n\\nローカルLuftdatenセンサーを追加する最も簡単な方法は、HACSを介して行うことです。[ここ](https://hacs.xyz/docs/setup/download/)で、HACSのセットアップ方法についての簡単な説明を見つけることができます。\\n\\nHACSがインストールされたら、HACS->統合に移動し、`Local Luftdaten Sensor`統合を検索します。ダウンロードボタンをクリックし、統合がダウンロードされたらHome Assistantを再起動します。\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### オプション2：手動インストール\\n\\nhomeassistantユーザーの下で、プロジェクトリポジトリをクローンします：\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nすでにカスタム統合がある場合は、`custom_components/local_luftdaten/`を`custom_components`ディレクトリにコピーします。例：\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nカスタム統合がない場合は、`custom_components`ディレクトリ全体をHome Assistantの設定ディレクトリにコピーします。例：\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## 設定\\n\\n`configuration.yaml`に新しいセンサーエントリを作成し、ホスト名またはIPアドレスを調整します。センサーのローカルIPアドレスを見つけるには、[Fingモバイルアプリ](https://www.fing.com/products)または[nmap CLIツール](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)を使用できます。名前は任意です。\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> すべてのサポートされているセンサーのリストは、[リポジトリ](https://github.com/lichtteil/local_luftdaten)で見つけることができます。\\n\\nHome Assistantを再起動します。\\nその後、ダッシュボードにセンサーを追加できます。エンティティの名前は、`configuration.yaml`に追加した名前になります。\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"420217a420580b0a25c72d2e66a0047c\",\"title\":\"Robonomicsビデオサービス\",\"path\":\"/docs/ja/robonomics-video/\",\"content\":\"\\nこの記事では、IPカメラをHome Assistantに追加し、ビデオをRobonomics Webサービスに送信する方法を説明します。\\n\\nカメラをHome Assistantに接続するには、そのIPアドレスを知り、RTSPストリームに接続するためのローカルカメラカウントを作成する必要があります。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nこれは各カメラごとに異なる方法で行われるため、この記事では考慮されていません。\\n</robo-wiki-note>\\n\\n要件:\\n- IPカメラ\\n- 設定済みのローカルカメラアカウント\\n- カメラのIPアドレス\\n- 設定済みのHome Assistant\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nこの記事では、RTZ（回転、傾斜、ズーム）オプションのない一般的なIPカメラを使用していることを前提としています。 \\nRTZカメラを使用している場合は、[\\\"RTZカメラ\\\"の記事](/docs/ptz-camera)を確認してから、ここで2番目のステップに戻ってください。\\n\\n</robo-wiki-note>\\n\\n## カメラを接続する\\n\\nまず、カメラの RTSP ストリームの URL を見つける必要があります。\\nそれを行うには、インターネットで次のクエリを入力してみてください：\\\"<カメラ名> RTSPストリーム\\\"。\\nストリームURLは `rtsp://<IPアドレス>...` で始まる必要があります。 \\n\\nこの記事では「Tapo」カメラを使用し、ストリームパスは `rtsp://<IPアドレス>/stream1` です。\\n\\nHome Assistantを開き、 \\\"Settings\\\"-> \\\"Devices & Services\\\" に移動します。\\\"ADD INTEGRATION\\\"ボタンを押して、\\n\\\"Generic Camera\\\"インテグレーションを入力し始めます。それを選択します。\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\n構成ウィンドウで次の情報を入します：\\n- Stream Source URL - カメラのRTSPストリームのURL\\n- Username - ローカルカメラアカウントのユーザー名を入力します\\n- Password - ローカルカメラアカウントのパスワードを入力します\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\n設定をスクロールダウンし、「Submit」ボタンを押します。\\n\\nプレビューウィンドウで、「This image looks good.」のチェックボックスをアクティブにし、「Submit」ボタンを押します。その後、「Finish」を押します。\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### ダッシュボードに追加する\\n\\nさらに、ストリームをダッシュボードに追加することもできます。これを行うには、ダッシュボードに移動し、新しいカードを作成します \\n\\\"Picture Glance\\\"。以下の手順を実行します：\\n- 希望する\\\"タイトル\\\"を入力します\\n- \\\"Image Path\\\"からデータを削除します\\n- \\\"Camera Entity\\\"でカメラを選択します\\n- \\\"Camera View\\\"で\\\"live\\\"を選択し、遅延が少なくなるようにします\\n\\nそして保存します。\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## メディアフォルダを確認する\\n\\nRobonomics Video Service に送信される前に、ビデオをフォルダーに保存する必要があり、Home Assistant がこのフォルダーにアクセスできる必要があります。\\nこの場合、最も簡単なオプションは、Home Assistantがすべてのメディアを保存するメディアパックを使用することです。\\n\\n- HAOSまたはプリインストールイメージを使用している場合、Home Assistantにはすでにメディアフォルダがあります。\\n- Home Assistant Coreを使用している場合は、`.homeassistant`フォルダに移動し、その中に`media`フォルダを作成する必要があります。\\n- Home Assistant Dockerを使用している場合は、Dockerコマンドに` -v /PATH_TO_YOUR_MEDIA:/media \\\\`の行を追加します。\\n\\nすべてが正しく設定されているかどうかを確認するには、Home Assistantの “Media” -> “local media” タブに移動します。 \\n空のフォルダ（エラーなし）が表示されるはずです。\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## サービスコール\\n\\nビデオをRobonomicsに送信するには、Home Assistantで専用のサービスを呼び出す必要があります。 \\nこの記事では手動で行っていますが、自動化することもできます。\\n\\nこれを行うには、\\\"Developer tools\\\" -> \\\"Services\\\" に移動し、「Robonomics: Save recording to Robonomics」を検索します。\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\n\\\"Targets\\\"でカメラエンティティを選択します。\\n\\\"Path to save the recording\\\"には、Home Assistantがビデオを保存できるフォルダへの絶対パスを指定する必要があります。\\nプリインストールイメージの場合\\n- HA OSまたはHome Assistant Dockerの場合 - `/home/homeassistant/.homeassistant/media`;\\n- Home Assistant Coreの場合-以前に作成したメディアフォルダへのパス。- `/media`;\\n- さらに、録画の期間を選択することもできます。\\n\\nデータを入力し、「CALL SERVICE」ボタンでサービスを呼び出します。 \\n\\n\\n## DAPP\\n\\n結果のビデオを表示するには、[Robonomics DAPP](https://vol4tim.github.io/videostream/)に移動します。\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nコントローラのアカウントアドレスを貼り付け、下のボタンをクリックします。\\\"Search for Twins\\\"プロセスを待ちます\\n結果として、すべての録画ビデオを含むIPFS CIDが表示されます。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\n次に、ドロップダウンリストからコントローラアカウント（またはその他のアカウント）を選択し、Web3 IPFSゲートウェイで認証のためのメッセージに署名します。\\nその結果、スマートホームで録画されたすべてのビデオを取得できます。\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nフォルダ内のすべてのビデオはコントローラキーで暗号化されているため、復号化するためにそれを挿入する必要があります。\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\nその後、ビデオの再生ボタンがアクティブになります。クリックしてビデオをダウンロードします。\\nその後、ビデオ再生ボタンがアクティブになります。 それをクリックしてビデオをダウンロードします。\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"3b069b44c2a98bbe822cb54cfd39bc67\",\"title\":\"SDS011センサーの接続方法\",\"path\":\"/docs/ja/sds-sensor-connect/\",\"content\":\"\\n** 以下は、Robonomicsセンサーネットワークにセンサーを接続する手順のガイドです。当社のセンサーは、sensor.communityファームウェアの拡張バージョンであるRobonomicsファームウェアを使用しています。追加のセンサーが含れており、データ送信メカニズムが変更されています。 **\\n\\n1. センサーをソケットに差し込んで電源を入れます。\\n2. ボードは`RobonomicsSensor-xxxxxxxxx`という名前のWi-Fiネットワークを作成します。携帯電話やコンピュータからそれに接続してください：認証ウィンドウが表示されます（表示されない場合は、ブラウザを開き、`192.168.4.1`にアクセスしてください）。\\n3. リストからWi-Fiネットワークを選択します（リストにない場合は自分で入力してください）そしてパスワード欄を入力します。\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nセンサーは 2.4GHz Wi-Fi ネットワークにのみ接続できます。\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. センサーを設置する場所の座標を入力します。地図から取得するか、[このリンク](https://www.latlong.net/convert-address-to-lat-long.html)を使用して住所から取得できます。\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nセンサーの座標は公開されている地図に表示されます。個人情報を表示したくない場合は、近いが正確でない座標を入力してください。\\n</robo-wiki-note> \\n5. `Save configuration and restart`をクリックします。ボードが再起動し、指定したWi-Fiネットワークに接続されます。\\n6. [Robonomicsセンサーマップ](https://sensors.robonomics.network/#/)を開き、センサーを設置した場所を見けます。数分後に、地図上でデータ付きのセンサーを表示できるようになります。\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"ba5fc12415cace30016980beada2fc81\",\"title\":\"Robonomics Dev Nodeの実行方法\",\"path\":\"/docs/ja/run-dev-node/\",\"content\":\"\\n**Robonomicsでアプリケーションをテストする場合、開発モードで実行することができます。この記事では、Robonomicsのローカルテストインスタンスを取得するためのステップバイステップの手順を説明します。**\\n\\n\\n## ノードイナリの取得\\n\\n1. まず、バイナリファイルが必要です。最新の[リリース](https://github.com/airalab/robonomics/releases)からアーカイブをダウンロードしてください。\\n\\n2. アーカイブフォルダに移動し、バイナリを展開して権限を変更します。\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## 実行\\n\\n次のコマンドでノードを実行します。\\n\\n```bash\\n./robonomics --dev\\n```\\n次の出力が表示されます。\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  既存のブロックを削除する場合は、`/tmp/substrate******/chains/dev/db/full`でRocksDBを削除してください。\\n  `******`を起動時のログに表示される対応する識別子で置き換えてください。\\n\\n  ノードを毎回ゼロから開始する場合は、`--tmp`フラグを使用してください。\\n\\n</robo-wiki-note>\\n\\n## 接続\\n\\nローカルノードには、[Polkadot Portal](https://polkadot.js.org/apps/#/explorer)を介して接続できます。\\n\\n左上隅のネットワークを「Local Node」に変更し、「Switch」を押してください。\\n\\n![switch](../images/dev-node/portal.png)\\n\\nRobonomicsのローカルインスタンスへようこそ！\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"ee920dd2f90c26548c8e4aaede5a414c\",\"title\":\"Robonomics Smart Homeの概要\",\"path\":\"/docs/ja/robonomics-smart-home-overview/\",\"content\":\"\\n## ブロックチェーンによる安全なIoT \\n\\nスマートホームには、現代のIoT市場がさまざまなソリューションを提供しています。しかし、通常は中央集権型のクラウドプロバイダーまたは高価な専用ゲートウェイに縛られています。その結果、ユーザーとしては常にハードウェアやインフラストラクチャのベンダーに依存することになります。同時に、クラウドの統計データや分析なしでは、スマートホームは本当の意味でスマートではありません。\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n現在のスマートホームには次の2つの主な問題があります：\\n\\n1. ベンダーや第三者と共有するデータを制御することができません。\\n2. スマートホームは中央集権型のクラウドサーバーのシャットダウンの脆弱性があります。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\n両方の問題を解決するために、私たちはRobonomicsをお試しください。私たちの安全で、サーバーレスで、未来志向の分散型クラウドです。\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## 企業から解放されたクラウドへのステップ\\n\\n以下は、デバイス通信アプリケーションとしてのHome Assistantと、企業から解放された分散型クラウドプラットフォームであるRobonomicsを使用して、手頃な価格のスマートホームを作成するための簡単な手順です。Robonomicsは、モダンで安全なWeb3技術を活用し、プロセス全体で強化されたセキュリティを提供します。.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## ここからスマートホームを始めましょう\\n\\nRobonomicsでスマーホームを設定するための詳細なガイドを用意しました。手順は、既にペアリングされたデバイスを持つ動作中のHome Assistantがあるか、スマートホームを構築するためにゼロから始めるかによって異なる場合があります。\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ja/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ja/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"8fb16f0f38cf9a4f37c4c6119b484f09\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/ja/robonomics-opengov/\",\"content\":\"\\n## 導入\\n\\nRobonomicsはパラチェーンのガバナンスモデルをPolkadotの洗練されたOpenGovメカニズムに移行しました。これにより、トークン保有者の最終的な意思によって、チェーンが時間とともに進化することが可能になりました。\\nRobonomicsのOpenGovへの移行により、ステークの大部分を制御するトークン保有者DAOは常にRobonomicsパラチェーンの方向を指示し、ネットワークへの任意の変更を実行することができます。\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGovは、SubstrateベースのチェーンであるRobonomics Parachainにのみ適用され、Kusamaリレーチェーンに接続されています。OpenGovはRobonomics Ethereumの実装には適用されません。なぜなら、Ethereumメインネットは現在、OpenGovのような洗練されたガバナンスシステムをサポートしていないからです。\\n</robo-wiki-note>\\n\\nOpenGovは、パラチェーンでの日常の運営と意思決定の方法を変えます。それは、リファレンダムの範囲についてより明確にし、パラチェーンで行われる意思決定のスループットを劇的に増加させる可能性があります。\\n\\nOpenGovは、執筆時点でKusamaリレーチェーンで稼働しており、トークン保有者DAOが提案し、投票し、投票を通じてプロトコルの方向を最終的に制御できる意思決定（個別および個別のリファレンダム）の数を劇的に増やすことが証明されています。\\n\\n**このウィキのこのセクションに含まれるコンテンツは、Robonomicsパラチェーン上のOpenGovの基本原則について説明し、OpenGovの背後にある概念をより理解するのに役立つことを目指しています.**\\n\\n*プロトコルにおけるガバナンスは、特に実装の初期段階では、絶えず進化するメカニズムであることに注意してください。*\\n\\nRobonomics OpenGovトラックのパラメータに純粋に興味がある方は、[こちら](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)をご覧ください。\\n\\n## リファレンダムについて\\n\\nリファレンダムはシンプルで包括的なステークベースの投票方式です。各リファレンダムには、チェーンのランタイムで特権関数呼び出しの形で表される特定の提案が関連付けられています。これには最も強力な呼び出し`set_code` は、チェーンのランタイムのコード全体を切り替える機能を備えています。これは、Substrate ベースのチェーンに特有のもので、チェーンのビジネス ロジック (ランタイム) を更新する際のチェーンの「ハード フォーク」の要件を削除します。e).\\n\\nリファレンダムは、固定された投票期間を持つ個別のイベントです（リファレンダムのライフサイクルの異なる期間については後述します）。個々のトークン保有者は、リファレンダムに対してAYE（同意/はい）、NAY（不同意/いいえ）、または投票を全く行わないようにすることのいずれかの方法で投票することができま。\\n\\nすべてのリファレンダムには、それに関連する執行遅延があります。これは、リファレンダムが終了し、リファレンダムが承認された場合にネットワーク上で変更が実施されるまでの期間です。 \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  特定のリファレンダムの発起人は、その特定のリファレンダムのタスクを将来の多くのブロックで実行するように設定することができます。\\n\\n</robo-wiki-note>\\n\\nリファレンダムは、「ベイク済み」と見なされます。これは、リファレンダムが終了し、投票が集計された場合です。リファレンダムが承認された場合、それは実施のためにスケジュールされます（チェーンのスケジューラーで）。リファレンダムは、「ベイクされていない」と見なされます。その結果が保留中の場合、つまりリファレンダムが現在投票中の場合です。\\n\\nOpenGovの追加により、誰でもいつでもリファレンダムを開始することができ、何度でも開始することができます。OpenGovにより、1回に処理できるリファレンダムが1つだけであるという制限がなくなります（Gov v1では、1つのリファレンダムのみが同時に投票できます。ただし、追加の緊急リファレンダムは、コミュニティによって同時に投票されることもあります）。\\n\\nOpenGovは、プロトコルのリファレンダムのフローと処理を支援するために、OriginとTrackといういくつかの新しい機能/コンセプトを導入します。\\n\\n各Originは単一のリファレンダムクラスに関連付けられており、各クラスはトラックに関連付けられています。トラックはリファレンダムのライフサイクルを概説し、その特定のOriginに固有のものです。トラックごとに固有のパラメータを持つことで、特権レベルに基づいてリファレンダムのライフサイクルを動的に変更することができます（特権レベルは、リファレンダムがどれだけ強力であるか、プロトコルにどのような変更を加えることができるかを考えることができます）。\\n\\n*オリジンは国民投票に関連付けられた権力であると考え、トラックは期間の長さや承認と支持の基準など、国民投票に関連付けられた投票パラメータであると考えてください。*\\n\\nたとえば、ランタイムのアップグレードは、小さな財務のヒントと同じようなプロトコルへの影響を持たないため、異なる起源が必要です。これにより、チェーンのパレットで事前に異なるターンアウト、承認、預金、および施行期間（トラック）が決定されます。\\n\\n## 国民投票と国民投票ライフサイクルの提案 \\n\\n### 準備期間\\n\\nOpenGovでは、国民投票が最初に作成されると、トークン保有者コミュニティによってすぐに投票されることができます。ただし、即座に終了したり、投票が集計されたり、承認されたり、即に施行されたりする状態にはなりません。代わりに、国民投票は決定期間に移動する前に、いくつかの基準を満たさなければなりません。国民投票が決定期間に入るまで、未決定のままとなり、個々のトラックで指定された全体のライフサイクル期間が経過すると、最終的にタイムアウトします。\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\n国民投票が決定期間に入るための基準は次のとおりです。\\n1. 決定期間が開始されるまでに経過する必要がある準備期間。この準備期間は、「意思決定スナイピング」という可能性に対処するために役立ちます。これは、大量の投票権を制御する攻撃者が、提案後すぐに国民投票が承認されるようにし、トークン保有者DAOの他のメンバーが国民投票を十分に検討し、投票に参加するための十分な時間を持つことを回避する可能性があるためです。したがって、特権レベルの高いオリジンは、はるかに長い準備期間を持ちます。\\n\\n2. 決定のための余地がなければなりません。各トラックには、同時に決定できる国民投票の数に制限があります（max_deciding）。特権レベルの高いトラックほど制限が低くなります。たえば、ルートレベルのオリジンは、スモールティッパーオリジンなどの特権レベルの低いオリジンと比較して、同時に決定できる国民投票の数がはるかに少なくなります。\\n\\n3. 決定デポジットを提出する必要があります。国民投票を最初に作成するのはかなり安価であり、提案時に予約される提出デポジットの価値はかなり低く、主に国民投票に関連するオンチェーンストレージの価値で構成されています。決定デポジットははるかに高くなっており、スパム対策に必要であり、OpenGovがもたらす経済的なゲームに関与しています。これについては後で説明します。\\n\\n上記の3つの基準がすべて満たされると、国民投票は決定期間に移動します。国民投票の投票はその後、結果に対してカウントされます。\\n\\n### 決定期間\\n\\n*決定期間のクイックビデオデモについては、[このビデオ](https://www.youtube.com/watch?v=wk58C-2CqPI)を参照してください*。\\n\\n上記のセクションで詳細に説明されている基準をすべて満たした国民投票は、決定期間に入ります。\\n\\n決定期間は、承認基準とサポート基準という2つの主要な概念を中心に開されます。 \\n\\n承認は、承認投票の重み（AYEs対NAYs）を総投票重み（すべてのAYEおよびNAYの投票を合算したもの）と比較したものです。各投票の確信は、AYE/NAYの投票の総重みに対して貢献します（確信投票/自発的なロックアップについては後のセクションで詳しく説明します）。\\n\\nサポートは、国民投票に参加した投票（トークン）の総数（確信に対して調整されません）を、システムで可能な総投票数と比較したものです（これは、パラチェーン上のXRTの総発行量と考えることができます）。なお、XRTの総流通供給量は、ここでは主要な要素ではありません。なぜなら、その数の一部がERC-20トークンとしてEthereum上に存在するためです。\\n\\n**ABSTAIN方向の投票は承認基準に貢献しませんが、サポート基準には含まれ、サポート基準としてカウントされます**\\n\\n国民投票は、決定期間中にサポート基準と承認基準の両方を満たさなければならず、それを満たさない場合は再び決定期間に戻されます（注：決定期間は確認期間中に一時停止されないため、決定期間が確認期間中に期限切れになる可能性がありますしたがって、国民投票が承認基準とサポート基準を満たさなくなったために確認期間から外れた場合、それは失敗した国民投票と見なされ、施行されません）。\\n\\n各トラックの個別のサポートおよび承認基準の詳細については、この[スプレッドシート](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)を参照してください。\\n\\n### 確認期間\\n\\n各トラックには、確認期間のための固有の期間があります。特権レベルが高い（ルートなど）トラックは、特権レベルが低い（小さなチッパーなど）トラックよりもはるかに長い確認期間を持っています。\\n\\n議決期間全体で承認およびサポート基準を満たし続ける必要があります。そうでない場合、再び決定期間に戻されます（注：確認期間中に決定期間は一時停止されないため、決定期間が確認期間中に期限切れになる可能性があります。したがって、承認およびサポート基準を満たさなくなったために確認期間から外れた場合、それは失敗した住民投票と見なされ、施行されません）。\\n\\n**個々のトラックについては、ルートオリジンの特権を持つ住民投票によって承認基準と支持基準を調整することが可能です。**\\n\\n特権レベルの低いオリジンは、高い特権レベルを持つオリジンよりもはるかに簡単な承認基準と支持基準（トラックよって設定される）を満たす必要があります。同様に、特権レベルの高いオリジンは、特権の少ないオリジンよりも緩やかなカーブを持っており、トークン保有者のDAOが住民投票を承認し、特権の高いオリジンの住民投票に対する住民投票スナイピングを回避することを保証するためです。\\n\\nOpenGovでは、決定期間が終了した後に承認されなかった住民投票は、デフォルトで拒否されたと見なされ、提出および決定のデポジットはそれぞれ元の提案者に返金されます（注：決定のデポジットは、住民投票の提案者以外の誰かによって投稿される場合があります）。\\n\\n住民投票が確認期間全体で承認基準と支持基準を継続的に満たすことができれば、承認されたと見なされ、提案されたオリジンから実行するためにスケジュールされますが、住民投票は最小の施行期間が経過した後にのみ実行されます。\\n\\n### 施行期間\\n\\n施行期間は、住民投票が提案されたときに提案者によって指定されますが、それは各トラックで指定された最小施行期間に従うものです。特権のあるオリジンは、特権の少ないオリジンよりもはかに長い最小施行期間を持っています。これにより、強力な住民投票がもたらす変更に対してネットワークが準備する十分な時間が確保されます。\\n\\n## 自発的なロックアップ/確信\\n\\nRobonomicsでは、自発的なロックアップまたは確信投票という概念を使用しています。これにより、トークン保有者は、特定の住民投票のためにトークンをロックする期間を決定することで、投票力を増やすことができます。このメカニズムは、各住民投票の承認基準のみに影響を与え、確信投票はサポート基準には影響しません。\\n\\n確信投票は次の式を使用して計算できます。\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nこの表は、ロックアップ期間の各増加レベルが承認基準の投票をどのように乗算するかを示しています。\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nトークン保有者が使用できる最大の確信は6倍の確信です。たとえば、5.5倍の確信を使用することはできません。\\n\\n投票によるロック中のトークンは、他の住民投票での投票に使用することができますが、移転可能な残高の一部ではありません（別のアカウントに送信することはできません）。また、残高は、ロックアップ期間全体が終了するまで再び移転可能になりません。\\n\\n## 投票委任\\n\\nOpenGovでは、各住民投票をレビューするための十分な時間を持っていないトークン保有者が、ガバナンスシステムの一部としてトークンを使用できるようにするために、投票委任というメカニズムが追加されました。\\n\\nトークン保有者は、システム内の別の投票者（別のアカウントに投票力を委任することができます。投票者は、各個別の起源ごとに投票力を委任することができ、各起源ごとに異なる投票力の割合を設定することもできます（トークンの数と確信レベル）。\\n\\nこの委任機能の目的は、投票率を向上させ、承認およびサポート基準を満たすために必要な投票率を確保することです。\\n\\n投票力を委任するには、「Delegate」機能を使用できます。これは、[Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer)のガバナンス->住民投票セクションで見つけることができます。また、ユーザーはRobonomics PortalのDeveloper->Extrinsicsセクションを使用してconvictionVoting（Delegate）extrinsicを送信することもできますが、ポータルの住民投票セクションの「Delegate」機能を使用する方が簡単です。\\n\\n## 住民投票のキャンセル/中止とガバナンス経済ゲーム\\n\\nOpenGovでは、進行中の住民投票を拒否するために専用の起源があります。これらはガバナンスキャンセラーおよびガバナンスキラートラックとして知られています。\\n\\nこれらの起源は、すでに投票された住民投に介入します。これらの起源から発生した住民投票が承認されると、進行中の住民投票はその状態に関係なく即座に拒否されます。 \\n\\nキャンセル自体は、実行するためにトークン保有者によって投票する必要があるタイプの住民投票です。キャンセルには、他の起源やトラックと比較してリードタイム（決定期間など）が低く、承認およびサポート曲線がより急な曲線を持つ起源とトラックがあります（つまり、時間の経過とともに基準を満たしやすくなります）。これは、住民投票のキャンセルは通常、緊急性を伴う場合があるためです。\\n\\nガバナンスキャンセラーは、すでに進行中の住民投票を即座に拒否することを目指しています。この起源によって住民投票がキャンセルされると、提出と決定のデポジットが元の所有者に返金されます。住民投票がキャンセルされると考えられる例は、起源者が住民投票の内容に人為的なミスを犯した場合であり、必ずしも悪意を持って何かをしようとしたわけではありません。\\n\\nガバナンスキラーは、すでに進行中の住民投票を即座に拒否することを目指しています。これはガバナンス経済ゲームが登場する場所です。Rootなどの特権レベルの高い起源は、住民投票が決定期間に入るためには高額の資本（XRTトークン）を投稿する必要がある決定デポジットを持っています。 \\n\\n悪意のあるアクターが住民投票を提出した場合、例えばRootの起源でチェーンのランタイムの`set_code`を何かに設定してチェーンがブロックを生成しないようにするような住民投票を提出した場合、トークン保有者のDAOはこの行動を罰するためにカウンターガバナンスキラー住民投票を提起することができます。悪意のある住民投票がガバナンスキラーの起源によって拒否されると、提出と決定のデポジットが削減され、つまり、元の所有者（これらのデポジットを投稿したアカウント）はそれらの資金を失います。 \\n\\nこれにより、チェーンに対して深刻な悪影響をもたらす可能性のる住民投票を提起しようとする悪意のあるアクターには、厳しい経済的な結果が生じることになります。これにより、理論上は、悪意のあるアクターがこれを試みることを防ぐことができます。\\n\\nガバナンスキラートラック自体の決定デポジットは非常に高いです。これは、それ以外の良い住民投票のデポジットを削減しようとする同様に悪意のあるアクターが試みるのを防ぐためです。**既存のガバナンスキラー住民投票は、後続のガバナンスキラー住民投票によってキャンセルされることがあります。**\\n\\n## Robonomics技術委員会＆ホワイトリストの起源\\n\\nこのグループは、Robonomicsネットワークプロトコルの技術的な知識を具備し体現する人々を代表することを主な目標とする、自己統治の専門機関です。 \\n\\nこのグループ（そしてこのグループのみ）は、ホワイトリストパレットから住民投票を発信することができます。このパレットは1つの起源が他の起源の特権レベルを特定の操作のためにエスカレーションさせることを可能にする1つのことを行います。 \\n\\nこのグループは、ホワイトリスト-Rootとして知られる起源からの住民投票を承認することができ、これらの住民投票はRootレベルの特権で実行されますが、このグループによって承認された特定の指示のみが正常に機能します。ホワイトリストパレットは2つのことを検証します。\\n1. 起源が本当にホワイトリスト-Rootであること（つまり、住民投票がこの起源のトラックを通過したこと）。\\n2. 提案がグループによってホワイトリストに登録されていること。\\n\\n両方の条件が真である場合、操作はRootレベルの特権で実行されます。\\n\\nこのシステムにより、新しい並行トラック（ホワイトリスト-Root起源）を持つ能力が可能になります。このトラックのパラメータは、投票のターンアラウンドが短くなるように設定されています（承認およびサポートの基準はRootよりもわずかに容易に満たすことができます）。このオープンで透明なプロセスにより、Robonomicsネットワークプロトコルの専門家グループは、安全で時間的に重要な住民投票を提案することができます。\\n\\nホワイトリスト-Root起源で開始された住民投票のサポート基準は、他の多くの起源/トラックとは異なり、0に向かってトレンドするわけではありません。これにより、このグループがRobonomicsネットワークプロトコル全体を事実上制御することはなく、全体のトークン保有者から最低限のサポート（投票者の投票率）が必要とされます。\\n\\n\\n## 住民投票の期間 \\n\\n各個別の住民投票の期間は具体的なものではないことを理解することが重要です。住民投票のライフサイクル内の一部の期間、例えば最小成立期間などは具体的な期間を持っていますが、決定期間などはそうではありません。例えば、「準備期間、決定期間、確認期間、最小成立期間の最大期間を合計して、各住民投票にX日かかる」と述べることは正確ではありません。それはそれよりもはるかに流動的です。\\n\\n以下の画像は、同じ起源（この場合、Root起源）から発信されるいくつかの別々の住民投票をレンズを通して見るものです。 \\n\\nRoot起源には、各期間の期間、承認およびサポート曲線が設定されているトラックがあります。\\n\\n住民投票は、特定の条件が満たされた場合にのみ、ライフサイクルの次の段階に進むことになります。 \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\n以下の画像は、以下の条件が満たされた場合にのみ、住民投票がライフサイクルの次の段階に進むと仮定してください（別の場合は記載されている場合を除く）。\\n\\n\\n### 非常に少ない投票者数での最大の可能な期間\\n\\n\\n以下の画像は、最大の可能なタイムラインを表しています。これは、次のような住民投票を想定してください：\\n1. 決定保証金が支払われており、決定期間に入っています。\\n2. AYE方向に1 XRT（例えば）の単一の投票を持ち、決定期間の最後に必要な支持（投票率）に達することを意味します（全体的な支持が非常に低いため）。しかし、100％の承認を持つため、最終的には入札期間の要件を満たすことになります。\\n3. 確認期間中も前述の基準を満たし続けます。\\n4. リファレンダムによって提起された提案は、最小成立期間が終了すると同じブロックで実施されます。技術的には、リファレンダムの発起者は、将来の多くのブロックを実施するためのネットワーク変更をリファレンダムの詳細に設定できるため、実際には個々のリファレンダムのライフサイクルは数日、数週間、数ヶ月、または数年にわたる可能性があります。\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nこの例では、リファレンダムのライフサイクルは（おおよそ）17日になることがわかります。\\n\\n\\n### 多くの投票率（高いAYE投票数）を持つ期間\\n\\n次に、XRTトークン保有者DAOが大いに関心を示したリファレンダムを見てみましょう。この例では、全体的な投票率が約248,771 XRTであり、すべての投票者がAYE方向に投票していると仮定します（注：技術的には、Rootリファレンダムのこの段階では、承認基準を満たすためには投票の60％がAYE方向にある必要があります）。\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n 正確な情報については、各トラックに関する最新のトラック情報を参照してください。詳細は[スプレッドシート](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing)で確認できます。\\n\\n</robo-wiki-note>\\n\\nこの例では：\\n1. 決定預金は準備期間中に投稿され、そのため準備期間の終わりに決定期間に移行することができました。\\n2. 多くの投票者がこのリファレンダムに投票し、比較的短期間で約248,771 XRTの投票率を獲得しました。\\n3. 投票はAYE方向が多数でした（60％以上のAYE）。\\n4. リファレンダムは確認期間の基準をその確認期間全体で継続的に満たします（注：リファレンダムが確認期間の基準を満たさなくなった場合、決定期間に戻されます）。\\n5. リファレンダムによって提起された提案は、最小成立期間が終了すると同じブロックで実施されます。\\n\\n約168時間（7日）後に、248,771 XRTの投票率があったため、リファレンダムは確認期間に入る基準を満たすことになります。\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nこの2番目の例では、投票率が十分に高かったため、決定期間が最大許容時間の半分で終了しました。結果として、約10日で実施可能なリファレンダムが生まれました。\\n\\n\\n### 決定預金が投稿されない期間\\n\\n次に、発起されたが決預金が投稿されなかったリファレンダムを見てみましょう。このようなリファレンダムは「準備中の状態」にとどまり、準備期間は終了していますが、決定預金が投稿されなかったためです。\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nこの3番目の例では、決定預金が投稿されなかったため、リファレンダムは実際には決定期間に入ることはありません。代わりに、「準備中の状態」にとどまります。これは、最終的には決定預金が投稿されない場合、リファレンダムがパレットのtimeOut定数で指定された期間が経過した後にタイムアウトすることを意味します。\\n\\nこれは以前にKusamaで起こったことであり、ルートの起源でリファレンダムが投稿されましたが、決定預金を投稿するための高い資本要件のために、リファレンダムはライフサイクルの後半に進むことはありませんでした。このようなリファレンダムは「タイムアウト」フラグで終了します。\\n\\n\\n### 決定預金が遅れて投稿される期間\\n\\n最後に、リファレンダムが発起されてからかなりの時間が経過してから決定預金が投稿された例を見てみましょう。これは以前にKusamaで起こったことでり、ルートの起源でリファレンダムが投稿されましたが、発起者は自身の代わりに高額な資本を持つ人物を見つけるために時間を費やさなければなりませんでした。\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nこの最後の例では、決定預金が準備期間が終了した後に投稿されましたが、リファレンダムがタイムアウトする前に、リファレンダムのライフサイクルは通常よりもはるかに長くなります。したがって、決定期間にはより長い時間がかかります。\\n\\nトークン保有者DAOは、準備期間中または「準備状態」にある住民投票に対してAYE/NAYで投票することができることに注意することが重要です。\\n\"}},{\"node\":{\"id\":\"c0a27d2c25eadaae092e6ca0bb821e80\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/ja/robonomics-prometheus-grafana/\",\"content\":\"\\n**以下の指示は[Hubo Bubo](https://github.com/hubobubo)によって提供されています**\\n\\n**元の記事は[こちら](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## はじめに\\nRobonomicsノードをより効果的に監視および維持するために、Prometheus ServerとGrafanaに基づいた監視を設定することが良いでしょう。このドキュメントでは、ノードを完全に監視するためにそれぞれの設定方法を示します。\\n\\n##  前提条件\\n* [Ubuntu 18.04でのサーバーのセットアップ](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Robonomicsパラチェーンコレータのインストール](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* robonomics.serviceがマシンで動作しており、ポート9615に到達可能であることを確認してください。 \\n\\n## ステップ1 — サービスユーザーの作成\\n\\nセキュリティ上の理由から、まずprometheusとnode_exporterの2つの新しいユーザーアカウントを作成します。これらの2つのユーザーを作成し、_--no-create-home_と _--shell /bin/false_ オプションを使用して、これらのユーザーがサーバーにログインできないようにします。\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nPrometheusのファイルとデータを保存するための必要なディレクトリをダウンロードする前に作成します。標準のLinuxの規則に従って、Prometheusの設定ファイルのために_/etc_にディレクトリを作成し、デーのために_/var/lib_にディレクトリを作成します。\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\n次に、新しいディレクトリのユーザーとグループの所有権をprometheusユーザーに設定します。\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## ステップ2 — Prometheusのダウンロード\\n\\nまず、現在の安定版のPrometheusをホームディレクトリにダウンロードして展開します。最新のバイナリは[Prometheusのダウンロードページ](https://prometheus.io/download/)で入手できます。\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\n次に、ダウンロードしたアーカイブを展開します。\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nこれにより、prometheus-2.21.0.linux-amd64というディレクトリが作成され、2つのバイナリファイル（prometheusとpromtool）、ウェブインターフェースファイルを含む_consoles_と_console_libraries_ディレクトリ、ライセンス、通知、およびいくつかのサンプルファイルが含まれます。\\n\\n2つのバイナリを_/usr/local/bin_ディレクトリにコピーします。\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nバイナリにユーザーとグループの所有権をステップ1で作成したprometheusユーザーに設定します。\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nconsolesと_console_libraries_ディレクトリを_/etc/prometheus_にコピーします。\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nディレクトリにユーザーとグループの所有権をprometheusユーザーに設定します。-Rフラグを使用すると、ディレクトリ内のファイルにも所有権が設定されます。\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nPrometheusがインストールされたので、最初の実行の準備として、その設定ファイルとサービスファイルを作成します。\\n\\n## ステップ3 — Prometheusの設定\\n\\n_/etc/prometheus_ディレクトリで、nanoまたはお気に入りのテキストエディタを使用して、_prometheus.yml_という名前の設定ファイルを作成します。\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nグローバル設定では、メトリクスのスクレイピングのデフォルト間隔を定義します。Prometheusは、個々のエクスポーターの設定がグローバル設定を上書きしない限り、これらの設定をすべてのエクスポーターに適用します。\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nこのscrape_interval値は、Prometheusがエクスポーターからメトリクスを15秒ごとに収集することを示しており、ほとんどのエクスポーターには十分な時間です。\\n次に、以下のscrape_configsディレクティブを使用して、Prometheus自体をスクレイピングするエクスポーターのリストに追加します。\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheusは、クエリやグラフ上でエクスポーターをラベル付けするために_job_name_を使用するため、ここで説明的なものを選択してください\\n\\nまた、Prometheusはパフォーマンスの監視とデバッグに使用できる重要なデータをエクスポートするため、より頻繁な更新のためにグローバルなscrape_intervalディレクティブを15秒から5秒に上書きしています。\\n\\n最後に、Prometheusは_static_configs_と_targets_ディレクティブを使用して、エクスポーターが実行されている場所を特定します。この特定のエクスポーターはPrometheus自体と同じサーバー上で実行されているため、デフォルトのポート9090とともにIPアドレスの代わりにlocalhostを使用できます。\\n\\n設定ファイルは以下のようになります。\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nファイルを保存してテキストエディタを終了します。\\n\\n設定ファイルのユーザーとグループの所有権をステップ1で作成したprometheusユーザーに設定します。\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\n設定が完了したので、Prometheusを初めて実行してテストする準備が整いました。\\n\\n## ステップ4 — Prometheusの実行\\n\\n_prometheus_ユーザーとしてPrometheusを起動し、設定ファイルとデータディレクトリのパスを指定します。\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n出力には、Prometheusの読み込みの進行状況、設定ファイル、関連するサービスに関する情報が含れます。また、Prometheusがポート_9090_でリッスンしていることも確認されます。\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nエラーメッセージが表示された場合は、構成ファイルでYAML構文を使用していることを再確認し、問題を解決するための画面上の指示に従ってください。\\n\\n次に、_CTRL+C_を押してPrometheusを停止し、新しい_systemd_サービスファイルを開きます。\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nサービスファイルは、_systemd_に対して、prometheusユーザーとしてPrometheusを実行し、構成ファイルを_ /etc/prometheus/prometheus.yml_ディレクトリに配置し、データを_ /var/lib/prometheus_ディレクトリに保存するように指示します。次のコンテンツをファイルにコピーします。\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\n最後に、ファイルを保存してテキストエディタを閉じます。新しく作成したサービスを使用するには、systemdをリロードします。\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\n次のコマンドを使用してPrometheusを起動できます。\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nPrometheusが実行されていることを確認するには、サービスのステータスを確認します。\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n出力には、Prometheusのステータス、メインプロセスID（PID）、メモリ使用量などが表示されます。\\n\\nサービスのステータスがアクティブでない場合は、画面上の指示に従って前の手順を再確認し、問題を解決してからチュートリアルを続行してください。\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\n次に進む準備ができたら、ステータスコマンドを終了するために_Q_を押します。最後に、サービスを起動時に開始するように有効にします。\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nPrometheusが起動して実行されているので、サーバーのリソースに関るメトリクスを生成するための追加のエクスポーターをインストールできます。\\n\\n## ステップ5 - Node Exporterのダウンロード\\n\\nPrometheus自体に関するメトリクスを超えてPrometheusを拡張するために、Node Exporterと呼ばれる追加のエクスポーターをインストールします。Node Exporterは、CPU、ディスク、メモリの使用状況を含むシステムの詳細な情報を提供します。最新のバイナリは[Prometheusのダウンロードページ]（https://prometheus.io/download/）で入手できます。\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\n次に、ダウンロードしたアーカイブを展開します。\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nこれにより、_node_exporter-1.0.1.linux-amd64_というディレクトリが作成され、バイナリファイルの_node_exporter_、ライセンス、および通知が含まれます。\\n\\nバイナリを_ /usr/local/bin_ディレクトリにコピーし、所有者をステップ1で作成したnode_exporterユーザーに設定します。\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nNode Exporterをインストールしたので、起動時にサービスファイルを作成する前に実行してテストしてみましょう。\\n\\n## ステップ6 - Node Exporterの実行\\n\\nNode Exporterを実行するための手順は、Prometheus自体を実行する手順と似ています。まず、Node ExporterのためのSystemdサービスファイルを作成しま。\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\n次のコンテンツをサービスファイルにコピーします。\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nファイルを保存してテキストエディタを閉じます。最後に、新しく作成したサービスを使用するためにsystemdをリロードします。\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\n次のコマンドを使用してNode Exporterを実行できます。\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\n検証する that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\n前と同様に、この出力にはNode Exporterのステータス、メインプロセスID（PID）、メモリ使用量などが表示されます。サービスのステータスがアクティブでない場合は、画面上のメッセージに従って前の手順を再確認し、問題を解決してから続行してください。\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\n最後に、Node Exporterを起動時に開始するように有効にします。\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nNode Exporterが正しく構成され、期待どおりに実行されていることを確認したら、新しいメトリクスをスクレイピングするようにPrometheusに指示します。\\n\\n## ステップ7 - PrometheusのNode Exporterのスクレイピングを構成する\\n\\nPrometheusは、構成ファイルのscrape_configsセクションで定義されているエクスポーターのみをスクレイピングするため、Prometheus自体と同様にNode Exporterのエントリを追加する必要があります。構成ファイルを開きます。\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nscrape_configsブロックの最後に、node_exporterという新しいエントリを追加します。\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nこのエクスポーターもPrometheus自体と同じサーバーで実行されているため、IPアドレスの代わりにlocalhostを使用し、Node Exporterのデフォルトポートである9100を使用できます。構成ファイル全体は次のようになります。\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nファイルを保存し、テキストエディタを終了します。変更を有効にするために最後にPrometheusを再起動します。\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\n再度、ステータスコマンドを使用してすべてが正常に実行されていることを確認します。\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nサービスのステータスがアクティブに設定されていない場合は、画面上の指示に従って前の手順を再確認してから続行してください。\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nPrometheusとNode Exporterがインストールされ、構成され、実行されていることが確認できました。\\n\\n## ステップ8 - Robonomicビルドのnode_exporterの追加\\n\\nPrometheusとnode_exporterを正常にインストールした後、すべてのsubstrateプロジェクトでビルドインのprometheusエクスポーターを使する必要があります。これを実現するには、_ /etc/prometheus/prometheus.yml_に追加のエントリを追加する必要があります。. \\n構成ファイルを開きます。\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nscrape_configsブロックの最後に、robonomic_exporterという新しいエントリを追加します。\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nファイルを保存してテキストエディタを終了します。設定ファイル全体は次のようになるはずです。\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\n最後に、変更を有効にするためにPrometheusを再起動します。\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\n再度、ステータスコマンドを使用してすべてが正常に実行されていることを確認します。\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\n今、_Prometheus_と_Node Exporter_、そして_Robonomic Exporter_がインストールされ、設定れ、実行されています。次にGrafanaに進んでください。\\n\\n## ステップ9 - Grafanaの設定\\n\\n最後のステップは、GrafanaでPrometheusをデータソースとして接続することです。このチュートリアルでは、最大5つのダッシュボードと専用の[Robonomicsダッシュボード](https://grafana.com/grafana/dashboards/13015)を使用できる無料のクラウドベースのGrafanaを使用します。[grafana.com](https://grafana.com/)にアクセスして新しいアカウントを作成し、新しく作成したGrafanaインスタンスにログインしてください。\\n\\n最初に、Grafanaに新しい_**データソース**_を追加する必要があります。この場合、データソースはPrometheusサーバーになります。\\nデータソースに移動します：\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\n次に、**_データソースを追加_**をクリックします\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\n次に、_**Prometheus**_を選択します\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\n新しい画面で、**_PrometheusサーバーのIPアドレスと9090ポート_**を入力します\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nその後、すべての手順を実行した場合は、_**保存してテスト**_をクリックします。緑色になり、ダッシュボードのインポートに進む準備が整います。メインサイトで**+**をクリックし、以下の画像にすように**インポート**をクリックします：\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\n次に、インポートページが表示されます：\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\n_Grafana.comダッシュボードのURLまたはID_に_**13015**_と入力します（これはRobonomicダッシュボードのIDです）\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\n外部ダッシュボードを読み込んだ後、この画面が表示されます：\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\n最後のステップは、以前に作成した**_データソース_**を選択し、_**インポート**_をクリックすることです\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\n以上です！この時点でインポートされたダッシュボードが表示されるはずです。 \\n\\n\\n## 参考文献\\n\\n* [Ubuntu 16.04にPrometheusをインストールする方法](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Prometheus + Grafanaによる監視ダッシュボードの構築](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [PrometheusのGrafanaサポート](https://prometheus.io/docs/visualization/grafana/)\\n* [ノードエクスポーターを使用したLinuxホストメトリクスの監視](https://prometheus.io/docs/guides/node-exporter/)\\n* [Prometheusのクエリ](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [ノードメトリクスの可視化](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Polkadotノードメトリクス](https://grafana.com/grafana/dashboards/12425)\\n* [Prometheusのノードエクスポーター用ダッシュボード](https://grafana.com/grafana/dashboards/11074)\\n* [Grafana ROBONOMICS（XRT）メトリクス](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"c6d9db9a4ad5051b1c822f4d3fb2bead\",\"title\":\"Robonomicsの統合セットアップ\",\"path\":\"/docs/ja/robonomics-hass-integration/\",\"content\":\"\\n**この記事では、RobonomicsをHome Assistantに追加します。これにより、Home Assistantは暗号化されたデータをRobonomics Parachainに記録し、パラチェーンからの起動コマンドを受け取ってスマートデバイスを制御することができま。統合では、データを保存し、IPFSハッシュをデータログまたは起動関数に送信するためにIPFSを使用します。**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Home AssistantのWebインターフェースで、`Settings` -> `Device & Services` に移動し、`ADD INTEGRATION` をクリックします。Robonomicsを検索します。\\n\\n2. Robonomicsをクリックし、設定を入力します。 \\n\\n- 「SUB_CONTROLLER」アカウントのシードをコントローラーアカウントのシードに追加します。\\n- 「SUB_OWNER」アカウントの公開アドレスを購読所有者のアドレスに追加します。\\n- データ送信の間隔を設定します（デフォルトでは10分です）。\\n- （オプション）データをIPFSネットワーク全体に広げるために、ピニングサービスPinataや他のカスタムゲートウェイの資格情報を追加できます。\\n\\n3. 設定を完了したら、`SUBMIT` を押します。すべて正しく入力した場合、成功ウィンドウが表示されます。\\n\\n以上です！Robonomicsの統合をHome Assistantに完全にセットアップしました。これですべてのRobonomicsウェブサービスを使用できます。詳細については、[「使用」セクション](/docs/global-administration)をご覧ください。 \\n\"}},{\"node\":{\"id\":\"3e9c02efa1f209a9eea3462de0ec9290\",\"title\":\"Robonomics on Ethereum\",\"path\":\"/docs/ja/robonomics-ethereum/\",\"content\":\"\\nすべてのロボノミクスに関する情報はGitHubリポジトリに移動しました。必要な情報は[こちらで見つけることができます。](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"0064b636783b3ace6f2a85a4d037dfef\",\"title\":\"PythonインターフェースとロボノミクスIO\",\"path\":\"/docs/ja/rinterface/\",\"content\":\"\\n**ロボノミクス パレットに実装されている一部の外部機能は、Polkadot アプリから送信するのが困難です。 さらに、プログラミング言語を使用してこの機能を操作する必要があります。 この目的のために、[robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface) と呼ばれる単純な Python ツールが開発されました。 これは、polkascan が保守する [py-substrate-interface](https://github.com/polkascan/py-substrate-interface) のラッパーです。 以下に、このパッケージの簡単な説明と、いくつかの役立つリンクと例を示します。 CLI ツールについても説明します。**\\n\\n## robonomics-interface\\n\\n[PyPi](https://pypi.org/project/robonomics-interface/)パッケージがダウンロードおよびセットアップできる状態で利用可能です。\\n詳細なドキュメント生成された[ドキュメンテーション](https://multi-agent-io.github.io/robonomics-interface/)も利用可能です。\\n\\n全体として、これはプログラミングツールを介してRobonomicsブロックチェーンと対話したい開発者向けのツールです。RobonomicsチームのほとんどのPythonプロジェクトは、このインターフェースを使用してパラチェーンと対話します。\\n\\n### インストール\\n\\nインストールプロセスには、少なくともPython 3.8がインストールされている必要があります。`x86`、`arm7`、`arm8`のいずれのアーキテクチャもコンパイルプロセスを必要としません。すべてのホイールは依存関係のメンテナによってビルドおよび公開されます\\n\\nインストールツールとして`pip`を使用しま：\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### 使用例\\n\\n主なアイデアは、`Account`インスタンスを作成し、それを使用してパレット専用のインスタンスを作成することです。\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  カスタムエンドポイント（たとえば、テスト用のローカルノード）を使用することも可能です:\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nエクストリンシックも提出することが可能です:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  前述のように、より多くの例は[ドキュメンテーション](https://multi-agent-io.github.io/robonomics-interface/)ページで利用可能です。\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface`には、プロトタイピングやクイックテストの目的で使用するためのPython `click` CLIツールも含まれています。パッケージとともにインストールされ、ターミナルで利用できます：\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nローカルノードでそれを使用してみることもできます。パイプラインの哲学が採用されています：\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"70b4136b026a129d07b94234b4bf8c61\",\"title\":\"Home AssistantでのPTZカメラ制御\",\"path\":\"/docs/ja/ptz-camera/\",\"content\":\"\\nこの記事では、Home AssistantでのPTZカメラのセットアップのプロセスについて説明します。 \\nONVIFプロトコルが使用されます。これにはローカルカメラアカウントが必要です。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nローカルカメラアカウントの設定手順は、この記事では説明されていません。\\n</robo-wiki-note>\\n\\n要件:\\n- PTZカメラ\\n- ローカルカメラアカウント\\n- カメラのIPアドレス\\n- 設定済みのHome Assistant\\n\\n## ONVIF統合\\n\\n**ONVIF統合**のインストールから始めましょう。 \\n\\n「Settings」の「Devices & Services」に移動し、「ADD INTEGRATION」ボタンを押します。\\n「ONVIF」と入力し、統合を選択します。次のウィンドウが表示されます。\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\n「Submit」ボタンを押します。自動的にカメラを検索しようとします。成功した場合は、 \\nリストからカメラを選択し、空白のフィールドを入力します。 \\nそれ以外の場合は、すべてのフィールドを手動で入力する必要があります。次のウィンドウが表示されます。\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\n空白を埋める:\\n- Name - カメラに名前を付ける\\n- Host - カメラのIPアドレスを入力する\\n- Port - ほとんどの場合、2020年ですが、カメラの提供元によっては変更される場合があります\\n- Username - カメラのローカルアカウントのユーザー名を入力する\\n  - Password - カメラのローカルアカウントのパスワードを入力する\\n\\nそして、「Submit」を押します。カメラのエリアを選択し、「Finish」をクリックします。\\n\\n## ダッシュボードにカメラ制御を追加する\\n\\nカメラの設定が完了したので、ストリームと制御ボタンをダッシュボードに追加できます。\\n\\nダッシュードに移動し、新しいカードを作成します。「Picture Glance」を選択します。\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nデータを入力します:\\n- Title - カメラ画像のタイトルを選択します\\n- Camera Entity - ドロップダウンリストからカメラエンティティを選択します\\n- Camera View - 遅延を少なくするために「live」を選択します\\n\\n次に、左下のボタンを押して「Code Editor」モードに切り替えます。次のコードが表示されます。\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\n`entities: []`の内容を以下の例に従って置き換えます（`<YOUR_CAMERA_ENTITY>`は`camera_image`パラメータと同じです）:\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\n以上です。ダッシュボードにPTZカメラカードと制御ボタンが表示されるはずです.\\n\\n## トラブルシューティング\\nHome Assistant Coreを使用しており、カメラからのストリームが表示されない場合は、「stream」と「FFMPEG」の統合をインストールする必要があります。 \\nこれを行うには、`stream: `と`ffmpeg: `の文字列をconfiguration.yamlの末尾に追加する必要があります。\"}},{\"node\":{\"id\":\"a35071f368dc83f9dd76416b8e370d69\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/ja/notifications/\",\"content\":\"\\nスマートホームのRobonomics\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nあなたは[notify](https://notify.events/)でスマートフォンに通知を受け取ることができます。まずそこで登録し、`Control Panel`で新しいチャンネルを作成してください。\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nタイトルを追加して`Save`を押してください。\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\n次に`Add Source`を押して、`IoT and Smart Home`タブで`Home Assistant`を選択してください。 \\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nタイトルを書いて`Next`を押してください。\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nそこにはHome Assistantの設定ファイルに追加する必要のあるトークンが表示されます。どこかに保存して`Done`を押してください。\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\n次に`Subscribe`を押して購読者を追加してください。\\n\\n希望する購読者を選択し、指示に従ってください。\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\n今度はHome Assistantでコンピュータの設定を編集する必要があります。`homeassistant`ユーザーで`configuration.yaml`ファイルを開いてください。\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nそして、以下の行を追加してください。\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\n`automation:`の後に新しい自動化を追加してください。\\n\\nこの自動化は、エンティティIDが`binary_sensor.contact_sensor_contact`で状態が`off`から`on`に変わったときにメッセージ`Door was changed to on/off`を送信します。\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"5f0504b8a9fd72ad9e5dc7ccfaa8faec\",\"title\":\"責任\",\"path\":\"/docs/ja/liability/\",\"content\":\"\\n**ロボットを経済主体にするには、そのための契約ツールが必要です。 Liability - Robonomicsパレットは、パラチェーンアカウント間の契約を実装します！**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  このチュートリアルはRobonomics Nodeのローカルインスタンスでデモンストレーションれていることに注意してください。[こちらの手順](/docs/run-dev-node)で自分のものをセットアップしてください。\\n\\n</robo-wiki-note>\\n\\n## 理論の概要\\n\\nEthereumでは、責任の相互作用の構造がかなり複雑でした。[こちら](/docs/robonomics-how-it-works)で詳細をご覧いただけます。現在はKusamaで少し簡単になりました！\\n\\n### 交渉\\n\\n契約に署名するには、まず双方が交渉する必要があります。 これは、[IPFS PubSub ](https://blog.ipfs.tech/25-pubsub/) や Robonomics PubSub など、いくつかの方法で実行できます。 Robonomics PubSub を使用した Python コードのサンプルは次のとおりです。\\n[ここ](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub) で紹介されています。\\n\\nオファーと需要は、契約の2つの主要な特性である「ジョブの説明」と「価格」を含むメッセージです。メッセージの形式は、各特定のアプリケーションごとにユーザーによって設計される必要があります。交渉プロセスでは、厳格な形式のルールに従うことはあまり重要ではありません。可能なフローは、以下の図に示されています。\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  PubSubはオープンなプロトコルであるため、機密データは転送されません。そのため、他のプロトコルを使用する必要があります。\\n\\n</robo-wiki-note>\\n\\n\\n### 署名\\n\\n交渉が無事に終わったら、双方は署名と呼ばれるいわゆる合意書に署名する必要があります。 これは、アカウントの秘密キーで署名された**特定の形式**の仕事の説明と価格を含むメッセージです。\\n[Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability) も同様です。\\n - ジョブの説明は「テクニック」と呼ばれます。これは、エンコードされたIPFS CIDである可能性のある32バイトの長さの文字列です。\\n - 価格は「経済学」と呼ばれます。これはXRTの小数点以下の桁数です。1 Weiner = 10**-9 XRTです。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  [IPFS](https://ipfs.tech/) CIDを適切な形式で取得するには、[Pythonライブラリ](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes)を使用できます。\\n  `sign_liability`関数を使用する場合、ハッシュを変換する必要はありません。自動的に行われます。\\n\\n</robo-wiki-note>\\n\\nコーヒーの例に従うと、\\n\\n1. タスクはJSONです\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. IPFS CIDは`QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`です\\n3. したがって、**テクニック**（変換されたCID）は`0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9`です \\n4. **経済学**は`1.5 XRT`です。\\n\\n署名が完了したら、責任を作成する時が来ました！これは、約束者または約束者または第三者のアカウントで行うことができます。\\n\\n## 責任を作成する\\n\\n### 準備\\n\\n前述のように、少なくとも2つの側面が関与ています。この例では、3つの側面を使用して、それぞれにプロバイダを作成します。交渉はすでに何らかの形で行われたと仮定します。\\n\\n### 1. 3つのアカウントを作成し、それらに資金を追加します\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nここでは、プロバイダに100 XRTを提供して責任の外部性を署名し、約束者には作業の支払いに2 XRTを提供しました。\\n約束者には（少なくとも1 mXRTの存在保証金を除く）資金は与えられませんでした。\\n\\n### 1. Developer -> Extrinsics に移動します\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. 可能な外部機能のドロップダウン リストから liability -> createate を選択します。\\n\\nまた、外部性を提出するアカウントも選択します。すべてのパラメータを入力します。\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  ここではプロバイダが使用されているため、参加者のシードを知る必要はありません。署名のみが必要です。\\n\\n</robo-wiki-note>\\n\\n### 3. トランザクションを送信します\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. イベントで責任を確認する\\n\\nこれには、`Network -> Explorer`に移動し、右側にイベントのリストを見つけます。三角形のアイコンをクリックして展開します。\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  ハッシュは、同じ [Python ツール](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash) を使用して IPFS CID に変換できます。\\n\\n</robo-wiki-note>\\n\\n### 5. ストレージの探索\\n\\nストレージモジュール`liability`で責任のいくつかの特性を探索することもできます。\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  `Next Index`ストレージ関数は、最新の責任インデックス+1を表示しますので、`1`であっても責任`0`が探索されます。\\n\\n</robo-wiki-note>\\n\\n## レポート\\n\\nコーヒーが作られ、コーヒーマシンがなんらかの方法で報告する必要があると想像してください。それが責任報告が登場する場所です。労働の証拠として、アカウントは既存の責任を最終化する際に別のIPFS CIDを報告内容として追加します。これには再び約束者の署名が必要です。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  署名されたメッセージには、既存の負債インデックスと32バイト表現でエンコードされたレポートIPFS CIDが含まれています。再度、[Pythonツール](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report)を使用してレポートに名することができます。\\n\\n</robo-wiki-note>\\n\\nコーヒーマシンの例に従って：\\n\\n1. レポートはJSON形式です\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. IPFS CIDは`QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`です\\n3. したがって、**ペイロード** (変換された CID) は `0xf06f2394f55537a5f37d63fd72bbfef50e9f60ea9e0e34224e455afae27a97a2` になります。\\n4. **インデックス**は`0`で、既存の負債インデックスです。\\n\\n### 1. extrinsicsに移動し、liability -> finalize(report)に移動します\\n\\nパラメータを入力し、外部を送信します。 繰り返しますが、これはサードパーティのアカウントによって実行される可能性があります。\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  注意：約束者のアカウントは「死んでいない」ことに注意してください - 少なくとも1 mXRTの存在保証金を持っている必要があります。\\n\\n</robo-wiki-note>\\n\\nレポートに署名して送信します。完了したら、イベントでそれを確認できます。\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. レポートを探索する\\n\\nストレージでもレポートを確認できます。`Developer -> Storage`に移動し、ドロップダウンリストから`liability`を選択します。\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. 残高を確認する\\n\\n画像では、約束者が「給料」を受け取ったことが示されています。経済的な関係が生まれました！\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  現時点では、ジョブが完了したかどうかを確認する方法はありませんので、約束者が報告するとトークンがそのアカウントに転送されます。 \\n  検証機能は将来追加される予定です。\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"2ab130d0920e43efe152dd33c09dbc04\",\"title\":\"起動\",\"path\":\"/docs/ja/launch/\",\"content\":\"\\n**Robonomicsパラチェーンのもう一つの基本的な機能は、起動パレットです。これにより、アカウント/それらの背後にあるエンティティにコマンドを送信することができます。これらのコマンドには、実行するタスクを指定するためのパラメータが含まれます。**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  このチュートリアルおよび以下のチュートリアルは、Robonomics Nodeのローカルインスタンスでデモンストレーションされていることに注意してください。[これらの手順](/docs/run-dev-node)で自分自身のインスタンスをセットアップしてください。\\n\\n</robo-wiki-note>\\n\\n## 1. Developer -> Extrinsicsに移動します\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. 可能な外部機能のドロップダウン リストから launch -> launch を選択します。\\n\\nまた、エクストリンシックスを提出するアカウントも選択します。ターゲットアドレスとパラメータフィールドを入力します。\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  - Launch はコマンドとして 32 バイト長の文字列をサポートします ([ソース](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256))。\\n  ここには即興の余地があります:\\n  - 切り替えなどの基本的なコマンドの場合は、「0x00000000000000000000000000000000000000000000000000000000000001」または\\n  「0x000000000000000000000000000000000000000000000000000000000000」。\\n  - json のような高度なコマンドの場合は、[IPFS](https://ipfs.tech/) CID を使用できます [適切な方法](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes)。\\n\\n</robo-wiki-note>\\n\\n## 3. トランザクションを送信します\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. イベントで起動を確認します\\n\\nこれには、*ネットワーク -> エクスプローラー*に移動し、右側にイベントのリストを見つけます。三角形のアイコンをクリックして展開します。\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"54eecad4db6fe1e3b4347df358bb2b12\",\"title\":\"Robonomics Collatorノードバージョンの更新方法\",\"path\":\"/docs/ja/how-to-update-collator-node-version/\",\"content\":\"\\nこの投稿を読む前に、以下の記事を読むことをおすすめします：[\\\"Collator Nodeのビルド方法\\\"](/docs/how-to-build-collator-node)および[\\\"Robonomics Collatorの起動方法\\\"](/docs/how-to-launch-the-robonomics-collator)。\\n\\nの記事では、Robonomics Collatorノード（Ubuntuで実行）の更新に必要なコマンドと、その後の例を示します。\\n\\n## **必要なコマンド**\\n\\n0. 開始する前に、`root`としてログインしていることをおすすめします。そうでない場合は、以下を使用することをおすすめします：\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Robonomicsサービスを停止します。\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. 以前のバージョンのRobonomicsを削除します（正しいディレクトリにいることを確認してください）。\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Robonomicsの[最新リリース](https://github.com/airalab/robonomics/releases)バージョンを取得します。\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. ファイルを展開します。\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. ファイルを移動します。\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nこのファイルを、Robonomicsノードをインストールした正しいディレクトリに移動する必要があります。\\n\\n</robo-wiki-note>\\n\\n6. Robonomicsを起動します。\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nCollatorノードをRobonomics v1.8.4にアップグレードする例：\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **ベースパスが設定されていないKusamaリレーチェーンデータベースの変更**\\n\\nKusamaリレーチェーンの特定のスナップショットがノードにエラーを引き起こすことがあります。これにより、ノードが動作しなくなることがよくあります。壊れたリレーチェーンデータースによるエラーの例：\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nこのエラーを修正するには、既存のKusamaリレーチェーンデータベース（おそらくRocksDb）を削除し、ParityDbなどの別のDbで置き換える必要があります。次のコマンドを実行します：\\n\\n1. Robonomicsノードのディレクトリを見つけ、ファイルを確認します。\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. polkadotディレクトリが表示されることを確認し、chainsディレクトリに移動します。\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. `ksmcc3` ディレクトリを削除します。\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. 新しい`ksmcc3`ディレクトリを作成します。\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. 新しいスナップショットをダウンロードする必要があります。この例では、大幅にプルーンされたリレーチェンスナップショットを使用していますが、好みのスナップショットに置き換えることができます。\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. スナップショットがダウンロード中の間に、新しいセッションを開き、サービスファイルを編集します。\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nデータベースとプルーニングに関連するサービスファイル内の行を変更します。\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\n`Ctrl + S`を押してから`Ctrl + X`を押して、サービスファイルを保存して終了します。\\n\\n7. デーモンを再読み込みする必要があります。\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. この時点で、他のセッションでは、新しいDbがダウンードされていることを願っていますので、ファイルを展開します。\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. 展開が完了したら、次のコマンドを実行します。\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. これでサービスを開始し、エラーがないか監視し、リレーチェーンとパラチェーンの両方でピアリングされていることを確認できます。\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"f411ed9773f3a8c5bcddcaebdf6f3926\",\"title\":\"Robonomicsコレータの起動方法\",\"path\":\"/docs/ja/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  この記事のスクリーンキャストとスクリーンショットでは、Robonomicsのバージョン1.4.0を使用しました。同じコマンドを使用する必要がありますが、Robonomicsのバージョンを現在のバージョンに置き換えてください。\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\n現在、Robonomicsネットワークは主に初期開発者によって維持されていますが、誰でもプロジェクトをサポートすることができます。ブロックチェーンの追加のフルノードは、より持続可能で耐障害性のあるものにするに役立ちます。Robonomicsノードのバイナリは[リリース](https://github.com/airalab/robonomics/releases)のアセットで利用可能であり、また[ソースからビルド](/docs/how-to-build-collator-node/)することもできます。\\n\\n## コレーターとは何ですか\\n\\nコレータはRobonomicsパラチェーンの一部です。このタイプのノードはRobonomicsチェーンの新しいブロックを作成します。\\n\\n>コレーターは、ユーザーからのパラチェーントランザクションを収集し、リレーチェーンのバリデーターに対して状態遷移の証明を生成することで、パラチェーンを維持します。言い換えれば、コレーターはパラチェーントランザクションをパラチェーンブロック候補に集約し、それらのブロックに基づいてバリデーターに対して状態遷移の証明を生成することで、パラチェーンを維持します。\\n\\n関連する[Polkadot wikiページ](https://wiki.polkadot.network/docs/learn-collator)でコレータについて詳しく学ぶことができます。\\n\\nロボノミクス パラチェーンでは、すべてのコレーターは、コレーターが構築するブロックごとに (**0.001598184 XRT**) の報酬を受け取ります (報酬はブロックがチェーンに封印されるときに発生します)。\\nまた、ブロックを構築するコレータは、作成されたブロック内に含まれる**トランザクション手数料の50%**を受け取ります。\\n\\n## 要件\\n\\nコレータを起動する際には、[Polkadotバリデータ](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware)の**標準ハードウェア要件**を使用することを推奨します。\\n+ x86-64互換。\\n+ Intel Ice Lake、またはそれ以降のバージョン（XeonまたはCoreシリーズ）；AMD Zen3、またはそれ以降のバージョン（EPYCまたはRyzen）。\\n+ 物理コア数4つ @ 3.4GHz。\\n+ 同時マルチスレッディング無効（IntelのHyper-Threading、AMDのSMT）。\\n+ ストレージ - 1TBのNVMe SSD（ブロックチェーンの成長に対応するために適切なサイズである必要があります）。\\n+ メモリ - 32GB DDR4 ECC\\n\\n\\nこの記事では次の仕様を使用します：\\n+ 4 vCPU\\n+ コレータのデータベース用に700GBのNVMeスペース。このディスクスペースを拡張できる能力が必要です。\\n+ 8GBのRAM\\n\\n\\n## 重要な情報\\n1. これらの手順ではいくつかの変数を使用しており、すべてのコマンドで自分自身の値に置き換える必要があります：\\n    + **%NODE_NAME%**はノード名です。例：*my-robonomics-kusama-collator*\\n    + **%BASE_PATH%**はマウントされたボリュームへのパスです。例：*/mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%**はPolkadotエコシステムのアカウントアドレス（SS58形式）です。例：*4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. コレータのサービス起動時には*--state-cache-size=0*を含める必要があります。このパラメータはコレータの安定性に重要です。\\n関連する[issue](https://github.com/airalab/robonomics/issues/234)で詳細を確認できます。\\n\\n## 初めて簡単にRobonomicsコレータを起動する\\n\\nエラーをチェックするために、コマンドラインで簡単にコレータを起動できます。\\nれを行った後、Robonomicsコレータをサービスとして起動することを強くお勧めします（次の手順を参照）。\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Robonomicsコレータをサービスとして起動する\\n\\n1. ホームディレクトリを持つサービス用のユーザを作成します。\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Robonomicsバイナリをダウンロードし、展開して*/usr/local/bin/*ディレクトリに移動します。このセクションのコマンドでRobonomicsの現在のバージョンで*$ROBONOMICS_VERSION*を置き換える必要があります。現在のバージョンは[githubのRobonomicsリポジトリのReleasesページ](https://github.com/airalab/robonomics/releases)で確認できます。\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. *robonomics.service*というsystemdサービスファイルを作成します：\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    そして、以下の行をサービスファイルに追加します：\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. このファイルを保存し、サービスを有効化して起動します：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nテレメトリURL：https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nCollators ログは、`journalctl -u robonomics.service -f` で監視できます。\\n\\nRobonomics Collator が起動されると、Kusama リレー チェーンとの同期が開始されます。これには、ネットワーク速度とシステム仕様によってはかなりの時間がかかる場合があるため、Kusama スナップショットをダウンロードすることをお勧めします。\\n\\n\\n## Kusamaスナップショットを使用して同期プロセスを高速化する\\n\\nRobonomicsサービスを作成して起動した直後にこれを行うことをおすすめします。スナップショットと使用方法の詳細については、次のページを参照してください：https://ksm-rocksdb.polkashots.io/\\n\\n手順：\\n\\n1. Robonomicsサービスを停止し、現在のKusamaデータベースディレクトリを削除します：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. 実際のスナップショットをダウンロードして展開します：\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    You can remove the downloaded archive after succesful unpacking:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. データベースフォルダの適切な所有権を設定します：\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Robonomicsサービスを再起動します：\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. サービスログを確認します：\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## トラブルシューティング\\n### エラー：「State Database error: Too many sibling blocks inserted」\\nこのエラーを修正するには、コレーターをアーカイブ モードで起動するだけです。\\n\\n1) まず、Robonomicsサービスを停止する必要があります： \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2）次に、サービスファイルのパラチェーン部分にパラメーター `--state-pruning=archive` を追加します。編集されたサービスファイルの例：\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3）systemdマネージャーの設定を再読み込みします。\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4）既存のパラチェーンデータベースを削除します。\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5）robonomicsサービスを起動します。\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    その後、パラチェーンデータベースの同期が完了するまで待つ必要があります。\\n\\n### エラー：「cannot create module: compilation settings are not compatible with the native host」\\nこのエラーは仮想化パラメーターに関連しています。エミュレートされたプロセッサの「host-model」タイプを使用する必要があります。これは仮想化ホストで設定できます。\\n\\nただし、このエラーがホスティング上で発生した場合は、この問題について技術サポートに問い合わせる必要があります。\\n\"}},{\"node\":{\"id\":\"57f800cc196cf3bd59ba2a16151bf695\",\"title\":\"ソースからコレーターノードをビルドする方法\",\"path\":\"/docs/ja/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  この記事のスクリーンキャストとスクリーンショットでは、Robonomicsのバージョン1.4.0を使用しました。同じコマンドを使用する必要がありますが、Robonomicsのバージョンを現在のバージョンに置き換えてください。\\n</robo-wiki-note>\\n\\n## コレーターとは何ですか\\n\\nコレーターはRobonomicsパラチェーンの一部です。このノードタイプはチェーンの新しいブロックを作成します.\\n\\n>コレーターは、ユーザーからのパラチェーントランザクションを収集し、リレーチェーンのバリデーターに対して状態遷移の証明を生成することで、パラチェーンを維持します。言い換えれば、コレーターはパラチェーントランザクションをパラチェーンブロック候補に集約し、それらのブロックに基づいてバリデーターに対して状態遷移の証明を生成することで、パラチェーンを維持します。\\n\\n関連する[Polkadot wikiページ](https://wiki.polkadot.network/docs/learn-collator)でコレーターについて詳しく学ぶことができます\\n\\nロボノミクス パラチェーンでは、ブロックがチェーンに封印されていた場合、すべての照合者は構築したブロックごとに報酬 (**0.000380520 XRT**) を受け取ります。\\nまた、照合者はこのブロックから **50% の取引手数料**を受け取ります。\\n\\n## ビルドプロセス\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nRustとサポートソフトウェアがインストールされていることを確認してください。Rustインストーラーは現在のインストールオプションについて尋ねますが、`1) インストールを続行します（デフォルト）`オプションを選択する必要があります。\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![インストール Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\n必要なナイトリーツールチェーンとwasmターゲットをインストールします。\\n次のコマンドはRobonomics v2.6.0に対して有効です。\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\n次に、次のパッケージをインストールする必要があります。\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\n今、gitソースからrobonomicsノードをインストールできます。\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nこのコマンドの後、コンパイルされたrobonomicsバイナリは`~/.cargo/bin`ディレクトリにあります。\\n\\n次のステップは、コレーターノードの起動方法です。[\\\"Robonomicsコレーターの起動方法\\\"](/docs/how-to-launch-the-robonomics-collator)の記事で詳しく説明しています。\"}},{\"node\":{\"id\":\"dcaa078fc9c47f57354736a5dc776afc\",\"title\":\"ホームアシスタントOSをアップグレードする\",\"path\":\"/docs/ja/hass-os-upgrade/\",\"content\":\"\\n**この記事には、Robonomics統合を使用して既存のHome Assistant OSをアップグレードする手順が含まれています。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## インストール IPFS Add-on\\n\\n\\nRobonomics統合は、ローカルのIPFSデーモンを使用してデータを保存するため、まずインストールする必要があります。 \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. [Home Assistant用のIPFSアドオン](https://github.com/airalab/ipfs-addon)があります。インストールするには、`Settings` -> `Add-ons`に移動し、右下の`ADD-ON STORE`ボタンを押します。\\n\\n2. 右上の3つの点を押して、`Repositories`を選択します。以下のリンクを追加します。\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. `ADD`ボタンを押します。\\n\\n4. リポジトリマネージャーを閉じて、ページを更新します。これでページの最後にIPFSデーモンアドオンが表示されます。\\n\\n5. アドオンを開き、`INSTALL`を押します。インストール後に`START`を押します。\\n\\n## HACSをインストールする\\n\\n[Home Assistant Community Store（HACS）](https://hacs.xyz/)を使用すると、カスタムインテグレーションをインストールできます。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. 開始する前に、SSHでHome Assistantデバイスに接続するためのアドオンをインストールする必要があります。アドオンストアで`ssh`を検索します。`SSH＆Web Terminal`アドオンをインストールすることをお勧めします。\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  SSHアドオンが見つからない場合は、ユーザープロファイル設定で高度なモードを有効にしてみてください。これを行うには、左下のプロファイルアイコンをクリックし、高度なモードオプションを見つけます。\\n\\n</robo-wiki-note>\\n\\n2. アドオンを選択し、`INSTALL`を押します。インストールが完了したら、`設定`タブに移動し、`password`または`authorized_keys`を追加します。この構成の一部を保存するのを忘れないでください。\\n\\n3. `Info`タブで`START`を押します。サイドバーにアドオンを表示するには、`Show in sidebar`を有効にするのを忘れないでください。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. SSHアドオンを開き、次のコマンドを実行します。\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. ホーム アシスタントを再起動します (`Settings`-> `System` で実行できます)。\\n\\n6. これでHACS統合が`Integrations`メニューに追加されます。`Settings`->`Devices & Services`に移動し、`Add Integration`を押してHACSを見つけます。\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  HACSを使用するには、Githubアカウントが必要です。\\n\\n</robo-wiki-note>\\n\\n7. クリックしてインストール手順に従います。 \\n\\n## Robonomics統合をインストールする\\n\\nHACSを使用してRobonomics統合をインストールできます。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nサイドバーメニューからHACSを開き、`Integrations`に移動します。`Explore & Download Repositories`をクリックし、`Robonomics`を検索して、右下の`Download`ボタンをクリックします。ダウンロードが完了したら、Home Assistantを再起動します。\"}},{\"node\":{\"id\":\"cf010bae3a3e666ca31a0e63f20948e5\",\"title\":\"ホームアシスタントの初期化\",\"path\":\"/docs/ja/hass-init/\",\"content\":\"\\n**ホームアシスタントをインストールした後、初期化する必要があります。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nホームアシスタントのオーナーアカウントの作成を開始します。このアカウントは管理者であり、任意の変更を行うことができます。ェブブラウザを開き、`http://%RASPBERRY_IP_ADDRESS%:8123`にアクセスします。Raspberry PiのIPアドレスは、[Fingモバイルアプリ](https://www.fing.com/products)または[nmap CLIツール](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)を使用して確認できます。\\n\\n<robo-wiki-note type=\\\"note\\\">ルーターの設定により、Raspberry Piのアドレスは時間とともに変更される場合があります。</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. 最初のページで、名前、ユーザー名、パスワードを入力し、「CREATE ACCOUNT」ボタンをクリックします。\\n\\n2. 次の画面で、ホームの名前を入力し、場所と単位系を設定します。`DETECT`をクリックして場所を検出し、その場所に基づいてタイムゾーンと単位系を設定します。場所情報を送信したくない場合は、これらの値を手動で設定することもできます。\\n\\n3. その後、ホームアシスタントはネットワーク上で検出したデバイスを表示します。以下に表示されるアイテムよりも少ないアイテムが表示されても心配しないでください。後でデバイスを手動で追加することができます。今は単に「FINISH」をクリックして、メインのホームアシスタント画面に移動します。\\n\\n4. 最後に、ホームアシスタントのウェブインターフェースが表示され、すべてのデバイスが表示されます。 \\n\\n\\n## トラブルシューティング\\n\\n1. ローカルユーザーのログインまたはパスワードを忘れた場合は、[この記事](https://www.home-assistant.io/docs/locked_out/)を確認して資格情報を復元してください。\\n\"}},{\"node\":{\"id\":\"34a7375d04c6a6bce6481d92b7a4f659\",\"title\":\"Raspberry Piのためのプリインストールイメージ\",\"path\":\"/docs/ja/hass-image-install/\",\"content\":\"\\n**Raspberry PiにHome AssistantとRobonomicsの統合をインストールするガイドへようこそ。Home Assistantはオープンソースのホームオートメーションシステムであり、家庭ネットワーク内のスマートデバイスを制するための中央集約ハブを提供します。Robonomicsと統合することで、分散型クラウドサービスを活用してスマートホームの機能とセキュリティを向上させることができます。この記事では、Raspberry PiにHome AssistantとRobonomicsをインストールする手順をステップバイステップで説明し、安全で分散化されたソリューションを使用して自宅のさまざまな側面を自動化および制御する能力を提供します。さあ、始めましょう！**\\n\\n## インストールに必要なハードウェア\\n\\nすでにHome Assistantをスマートホームに組み込んでいない場合、完全なスマートホームシステムを構築するために必要な機器を把握することが重要です。\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Robonomicsのプリインストールイメージをダウンロードする\\n\\nRobonomicsのプリインストールイメージには以下が含まれています。\\n- Home Assistant Core\\n- IPFS\\n- MQTTブローカーと統合\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nソースコードを確認し、最新リリースのイメージを[GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)でダウンロードできます。\\n\\n</robo-wiki-note>\\n\\n\\n## 2. イメージの設定\\n\\nコンピュータに[Raspberry Pi Imager](https://www.raspberrypi.com/software/)をインストールします。の後、SDカードを挿入します。\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nRaspberry Pi Imager プログラムを実行します。 オペレーティング システムとして必要なイメージを選択し、ストレージ ドロップダウン メニューから SD カードを必ず選択してください。\\n設定で以下を行います。\\n- ユーザー名とパスワードを設定します（デフォルトのユーザー名「pi」を保存しておくと覚えやすいです）、  \\n- Wi-Fiの名前とパスワードを入力します、 \\n- ドロップダウンリストから国を選択します\\nそしてイメージを`書き込み`します。 \\n                   \\n<robo-wiki-note type=\\\"note\\\">ユーザー名とパスワードを注意深く保存してください。これらの資格情報はトラブルシューティングの場合に必要になります。</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\n国コードは[こちら](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)で確認できます。\\n\\n## 3. 初回起動\\n\\n**SDカードを安全に取り外し**、Raspberry Piに挿入します。次に、**Zigbeeアダプター**をRaspberry Piに挿入します。\\n\\n<robo-wiki-note type=\\\"warning\\\">Raspberry Piを初めて起動する前にZigbeeアダプターを挿入することが重要です！ \\nこれはZigbeeネットワークの自動設定に必要です。</robo-wiki-note>\\n\\n**[JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en)（必要なファームウェアをすべて備えている）をお持ちの場合、これらの手順に従って簡単に進めることができます。ただし、他のアダプターをお持ちの場合は、まずZigbee2MQTTソフトウェアでフラッシュする必要があります。お使いのデバイスの手順は[こちら](https://www.zigbee2mqtt.io/information/supported_adapters.html)で確認できます。**\\n\\n次に、電源ケーブルをデバイスに接続します。これにより、Wi-Fiネットワークに接続されます。 \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nRaspberry Pi が接続されると、赤色の LED が点灯し、緑色の LED がしばらく点滅します。 Raspberry Pi が起動してネットワークに登録されるまで、最大 5 分間待ちます。\\n\\n次に、Raspberry PiのIPアドレスを見つけます。[Fingモバイルアプリ](https://www.fing.com/products)や \\n[nmap CLIツール](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)を使用してIPアドレスを見つけます。IPリストで`robots-home`（オプションの名前は`Home(homeassistant)`） \\nホストマシンの名前です。 \\n\\nこの例ではアドレスは`192.168.43.56`です。 \\n\\nすべてが正常に動作しているかを確認するために、ウェブブラウザを開き、`http://%RASPBERRY_IP_ADDRESS%:8123`にアクセスします。この例では`192.168.43.56:8123`になります。\\nすべてが正常であれば、Home Assistantのウェブインターフェースが表示されます。ウェブページが開かない場合は、Raspberry Piの起動まで最大5分待ってから再試行してください。 \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## トラブルシューティング\\n\\n1. Wi-Fiの設定を後で変更するには、Raspberry Piに`ssh`コマンドでログインする必要があります。これにはコンピュータのターミナルを開き、\\n\\\"Configuring the Image\\\"ステップで作成したユーザー名を使用してsshコマンドを入力します（デフォルトは\\\"pi\\\"です）。 \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\nそして`sudo raspi-config`コマンドを使用します。このコマンドについての詳細な情報は[公式サイト](https://www.raspberrypi.com/documentation/computers/configuration.html)を参照してください。\\n\"}},{\"node\":{\"id\":\"6db0697cc125d12d6ca5db9aefd52173\",\"title\":\"Unix-like OSでHome Assistant Dockerをアップグレードする\",\"path\":\"/docs/ja/hass-docker-upgrade/\",\"content\":\"\\n**この記事には、Robonomics統合を使用して既存のHome Assistant Docker（Unix-like OS上）をアップグレードする手順が記載されています。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. デフォルトのDockerイメージとHome Assistantのコンテナの名前が<u>homeassistant</u>であることを前提としています。\\n  2. IPFSはホストマシン上で<u>systemd</u>サービスとしてインストールおよび実行されます。\\n  3. [Python3.9](https://www.python.org/downloads/)以上がインストールされていることを前提としています。\\n\\n</robo-wiki-note>\\n\\n## インストール\\n\\nインストールスクリプトをダウンロードしてターミナルで実行します。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\n次の出力が表示されます。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  `mkdir: can't create directory 'custom_components': File exists`のようなエラーが表示される場合があります。これは、すでにいくつかのカスタムコンポーネントがインストールされたこのフォルダが存在することを意味します。このメッセージは無視してください。\\n\\n</robo-wiki-note>\\n\\nコンテナを再起動する：\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## 検証する\\n\\nIPFSサービスが起動していることを確認してください。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\n次の出力が表示されます。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"62a6c994887bb4076d3007b9a656a51b\",\"title\":\"ホームアシスタントコアをアップグレードする\",\"path\":\"/docs/ja/hass-core-upgrade/\",\"content\":\"\\n**この記事には、Robonomics統合を使用して既存のホームアシスタントコアをアップグレードする手順が含まれています。**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. ホームアシスタントコアのインストールが[公式の手順](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core)に従って完了しており、<u>homeassistant</u>ユーザーと`venv`環境が存在することを前提としています。そうでない場合は、以下の手順に従ってくださいが、スクリプトを適宜編集してください。\\n  2. IPFSはホストマシン上で<u>systemd</u>サービスとしてインストールおよび実行されます。\\n  3. [Python3.10](https://www.python.org/downloads/) 以降がインストールされていることが前提となります。\\n\\n</robo-wiki-note>\\n\\n## インストール\\n\\nインストールスクリプトをダウンロードしてターミナルで実行します。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\n次の出力が表示されます。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nプロセス中に、いくつかのサービスの再起動を確認するように求められます。`tab`キーで移動し、`yes`オプションを選択します。\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  `mkdir: can't create directory 'custom_components': File exists`のようなエラーが表示される場合があります。これは、すでにいくつかのカスタムコンポーネントがインストールされたこのフォルダが存在することを意味します。このメッセージは無視してください。\\n\\n</robo-wiki-note>\\n  \\n完了後、ホームアシスタントを再起動します。\\n\\n## 確認する\\n\\nIPFSサービスが起動していることを確認してください。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\n次の出力が表示されます。\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"404ef1fb2f377cba6e130f5166857ac9\",\"title\":\"Glossary\",\"path\":\"/docs/ja/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\n公開鍵と秘密鍵のペアの組み合わせ。その公開部分はユーザーの公開アドレスであり、秘密部分はこのアドレスの制御にアクセスするための秘密鍵です。\\n\\n\\n### Auction (of Parachains)\\nPolkadot および Kusama エコシステムにおけるパラチェーンのスロットをリースするメカニズム。 パラチェーンがキャンドルオークションに勝利してスロットを獲得しました。\\n\\n### Autonomous Agent\\n環境から感覚データを受け取り、目標を達成するために外部刺激にどのように反応するかを決定する計算システム。\\n\\n### AIRA\\n自律型インテリジェント ロボット エージェント — 2015 年にロボノミクス チームによって開発されたソフトウェアで、知的責任契約を通じて経済的な人間と機械、および機械と機械の相互作用の標準を実装します。\\n\\n\\n## B\\n\\n### Blockchain\\n広い意味では、暗号化を使用して、参加者のグループがシステムの変化する状態についてトラストレスに合意に達することを可能にする分散ネットワーク。\\n\\n### Blockchain 探索するr\\nブロックチェーン上のさまざまなブロック、トランザクション、アドレスを探索できるアプリケーション (Etherscan、Subscan など)。\\n\\n### Blueprint (Hass)\\nホーム アシスタント インスタンスに簡単に追加できる、事前に作成された自動化ロジック。\\n\\n### Bridge\\n経済的に主権があり、技術的に多様な 2 つのチェーンが相互に通信するための技術と方法。 \\n\\n\\n## C\\n\\n### Coase (XRT)\\nまたは Cs — 1 つの XRT トークンの 100 万分の 1 シェア、1 XRT = 1,000,000 Cs。 制度経済学の創始者の一人であり、ノーベル経済学賞受賞者である英国の経済学者、ロナルド・コースにちなんで命名されました。\\n\\n### Collator\\nパラチェーントランザクションを収集し、バリデーターの状態遷移証明を生成することによってパラチェーンを維持するノード。\\n\\n### Consensus\\nブロックチェーン ネットワークのノードがネットワーク内のデータの現在の状態について合意に達するプロセス (例: Proof-of-Work、Proof-of-Stake)。\\n\\n### Crowdloan\\nPolkadot/Kusama エコシステムのスロット オークションに入札するためのトークンを集めるクラウドファンディング キャンペーン。\\n\\n### Cybernetics\\nN. ウィーナーの定義によると、動物と機械における制御とコミュニケーションの研究。\\n\\n### Cyber-Physical System\\nまたは CPS — 複数の計算プロセス、ネットワーキングプロセス、物理プロセスの強力な統合と相互統合。\\n\\n\\n## D\\n\\n### DAO\\n集合的に所有され、ブロックチェーンによって管理される組織。そこでは、事前に合意され正式に定められた一連のルールに従ってリソース管理が実行され、その施行は自動的に行われます。。\\n\\n### Datalog (Function)\\nデバイスデータをブロックチェーンに保存するロボノミクスパラチェーン機能。\\n\\n### Dapp\\nまたは分散アプリケーション — 分散ネットワークの一部として実行され、ユーザーフレンドリーな方法でその機能へのアクセスを提供するアプリケーション。\\n\\n### Decentralized Cloud\\nユーザーがサービスを使用したり、コンピューティング、ネットワーキング、ストレージなどのリソースを提供したりするために参加できる、分散型ピアツーピア ネットワークに基づくクラウド コンピューティング サービス。\\n\\n### Digital Twin\\n技術的特性と履歴データをコピーした実際の機器のデジタル バージョン。\\n\\n\\n## E\\n\\n### Edge-system\\nローカルでアクセス可能な組み込みシステムとグローバル ネットワークの間のリンクとして機能する IoT デバイス。通常は通信プロトコルをサポートし、テレメトリ信号と制御信号を送信します。\\n\\n### Embedded System\\n限られたコンピューティング リソースと通信リソースを備えた IoT デバイスで、通常はユーザー インターフェイスを持たず、最下位レベルで基本機能 (センサー、アクチュエーター、ボタン) を提供します。\\n\\n### Ethereum\\n分散型オープンソース ブロックチェーン システムで、他の多数の暗号通貨のプラットフォームとして機能するだけでなく、分散型スマート コントラクトの実行にも使用されます。\\n\\n### Ethereum Upgrade\\n以前はイーサリアム 2.0 または Eth2 として知られていました。ネットワークをよりスケーラブルで安全かつ持続可能なものにするイーサリアム プロトコルのアップグレードです。 これらの目的のために、コンセンサスを Proof-of-Stake に変更し、ネットワーク容量を増やすためにシャーディング メカニズムを追加することが提案されています。\\n\\n### Exodus\\nXRT トークンをイーサリアム ネットワークからロボノミクス パラチェーンに転送するプロセス。\\n\\n### Extrinsic\\n状態の外部からネットワーク状態遷移をトリガーできる、Polkadot および Kusama ネットワーク上の機能。\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nまたは Gk — 1 XRT トークンの 1,000 分の 1、1 XRT = 1,000 Gk。 ソ連の情報技術とサイバネティクスの創始者の一人であるソ連の数学者、ヴィクトル・グルシコフにちなんで命名されました。\\n\\n\\n## H\\n\\n### Home Assistant\\nまたは Hass — スマート デバイスの中央ハブとして設計されたオープン ソースの制御システム ソフトウェア。\\n\\n### HRMP\\nまたは、水平リレー ルーティング メッセージ パッシング — パラチェーン間で受け渡される安全なメッセージ。すべてのメッセージをパラチェーンに送信する前にリレー チェーン ストレージに保存します。\\n\\n### HMI\\nまたはヒューマン マシン インターフェイス — ユーザーをマシン、システム、またはデバイスに接続するユーザー インターフェイスまたはダッシュボード。\\n\\n\\n## I\\n\\n### Industry 4.0\\nまたは第 4 次産業革命 — 最新のスマート テクノロジーを使用した、伝統的な製造および産業慣行の継続的な自動化。\\n\\n### IPFS\\nまたは InterPlanetary File System — 分散ファイル システムにデータを保存および共有するためのピアツーピア ソフトウェア。\\n\\n### IoT\\nまたはモノのインターネット — データを収集し、環境に統合できる、数十億のデバイスからなるグローバル ネットワークへの接続。\\n\\n### IoT Gateway\\nIoT デバイスからネットワークへ、またはその逆にデータを集約して送信するエッジ システム。 多くの場合、これらのデバイスは WiFi ルーターのより複雑なバージョンです。\\n\\n### IoT Provider\\nIoT ユーザーにデータと分析へのリモート アクセス、およびインターネット経由でのスマート デバイスの制御を提供する外部サービス。\\n\\n### IoT Subscription\\nパラチェーンの全機能を一定期間無料で利用できるロボノミクスパラチェーン機能。\\n\\n\\n## K\\n\\n### KSM\\nKusama ネットワークのネイティブ トークン。\\n\\n### Kusama\\nPolkadot の「カナリア ネットワーク」。Polkadot ソフトウェアの早期リリースの未監査バージョンで構成されます。\\n\\n\\n## L\\n\\n### 起動 (Function)\\nブロックチェーン経由でコマンドを送信することでデバイスを起動または停止するロボノミクス パラチェーン機能。\\n\\n### Lease Period\\nパラチェーンがリレー チェーンに接続できる時間。\\n\\n### Libp2p\\n暗号化されたピアツーピア ネットワークを作成するためのオープンソース ライブラリ。\\n\\n### Lights-out Factory\\nまたはスマートファクトリー-完全に自動化され、現場に人間の存在を必要としない工場。\\n\\n### Lighthouse\\nロボット経済の概念におけるスマートコントラクトは、プロバイダが約束者と約束者の間で市場のマッチングを確立したときにトランザクションを実行すものです。\\n\\n### 責任\\nサイバーフィジカルシステム同士または人間との間で作成されたスマートコントラクトは、支払いのためにタスクを実行します。\\n\\n### Liability Market\\nロボット経済の概念におけるプラットフォームは、システムのノード間でのオファーと需要のマッチングを担当します。\\n\\n\\n## M\\n\\n### MQTT\\nまたはメッセージキューイングテレメトリトランスポート（MQTT）は、低帯域幅、高遅延、信頼性の低いネットワーク向けに設計されたパブリッシュ-サブスクライブプロトコルであり、IoTデバイスメッセージの高いボリュームを操作します。\\n\\n### MQTT Broker\\nMQTTクライアントからすべてのメッセージを受信し、適切なサブスクライブクライアントにメッセージをルーティングするサービス。\\n\\n\\n## N\\n\\n### NFT\\nまたは非代替可能トークン（NFT）は、他のトークンと区別できず、ユニークなアイテムのトークン化とそれらのトークンの独占的な所有権を提供するトークンです。\\n\\n### Node (of Robonomics)\\nRobonomicsネットワークに接続するためのRobonomics拡張機能を備えたSubstrateベースまたはEthereumベースのブロックチェーンモジュール。\\n\\n\\n## O\\n\\n### On-chain Governance\\nネットワーク自体に存在し、ネットワークへの変更（コードの変更や資金の移動など）が直接変更できるネットワークで許可される変更のプロセス。\\n\\n\\n## P\\n\\n### Pallet\\na Substrate module written in Rust that bundles specific logic or algorithm for runtime of Substrate-based blockchain. \\n\\n### Parachain\\nリレー・チェーンに統合され、バリデータによって検証できるカスタムのアプリケーション固有のデータ構造（通常はブロックチェーン）。\\n\\n### Parathread\\nスロットのないパラチェーンであり、リレー・チェーンのセキュリティに一時的に参加する（ブロックごとに手数料を支払う）ことができる。\\n\\n### Polkadot\\nさまざまな特性を持つさまざまなブロックチェーンが共有のセキュリティの下で任意のクロスチェーン通信を実行できる異種多ェーンネットワーク。\\n\\n### Polkadot/Substrate Portal\\nPolkadot、Kusama、その他のSubstrateネットワークとの対話のための基本的なSubstrate UI。\\n\\n### Proposal (on Polkadot / Kusama)\\na potential function call to be voted on in a Polkadot, Kusama or parachains referendum. \\n\\n### Proof-of-Work\\n合意に達するために、ネットワーク参加者が計算作業を実行する必要がある合意メカニズム。\\n\\n### Proof-of-Stake\\n合意に達するために、ネットワーク参加者が関連する暗号通貨の資本をステークする必要がある合意メカニズム。\\n\\n### Promisee\\nロボット経済概念において、タスクの実行のための注文を出すノード。\\n\\n### Promisor\\nロボット経済概念において、支払いを受けてタスクを実行することに同意するノード。\\n\\n### Provider (Robonomics)\\na node, in the robot economy concept, that monitors the messages of the Liability Market and matches an offer and a demand for a small fee. \\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\na part of on-chain governance, vote on whether or not a proposal should be accepted by the network users. \\n\\n### Relay Chain\\nPolkadot / Kusamaの合意を調整し、パラチェーン間の通信を行うメインチェーン。\\n\\n### Robofirm\\nビジネスプロセスサイクル全体が完全に自動化され、人間の参加を必要としない組織。\\n\\n### Rococo\\nKusamaでパラチェーンをテストするためのテストネット。\\n\\n### robonomics-interface\\nRobonomicsとの便利なプログラミングのためのPythonライブラリ。\\n\\n### Robonomics on Ethereum\\n2018年にリリースされたEthereum上で動作するRobonomics Networkのバージョン。\\n\\n### Robot Economy\\nデバイスが独立したエージェントとして行動し、以前は人間に固有の主要な経済活動を実行できる経済システム。\\n\\n### Robot-as-a-Service\\nまたはRaaSは、企業がロボット機器をクライアントや顧客に短期間または長期間貸し出すビジネスモデル。\\n\\n### ROS\\nロボットソフトウェア開発のためのフレームワークであり、ハードウェア抽象化、低レベルデバイス制御、一般的に使用される機能の実装、プロセス間のメッセージパッシング、パッケージ管理などを提供する。\\n\\n### ROS 2\\nマルチロボットと小型組み込みシステムのサポート、リアルタイムとの統合などの新機能を備えた、Robot Operating Systemの更新および再構築バージョン。\\n\\n### ROS 2 Middleware\\nROS 2の機能であるディスカバリ、シリアル化、輸送などの標準を提供するプロトコル。ROS 2は、プロジェクトの要件に最適なミドルウェアの実装を選択できる。\\n\\n### RWS\\nロボティクスとIoTのための分散型インフラストラクチャサービスであり、デバイスを簡単に接続し、ユーザーアプリケーション、クラウドサービス、他のデバイスと安全にやり取りすることができる。RWSと呼ばれる独自のトークンも持っており、Robonomicsパラチェーンでの終身IoTサブスクリプションを提供する。\\n\\n### 実行time\\nブロックチェーンの状態を決定するための有効なアルゴリズムを定義すブロックチェーンの状態遷移関数。\\n\\n\\n## S\\n\\n### Seed Phrase\\nブロックチェーンアドレスとそのトークンにアクセスするために必要なランダムな単語のシーケンスである人間が読めるプライベートキー。\\n\\n### Shared Security\\nPolkadot / Kusamaのセキュリティモデルであり、パラチェーンブロックの妥当性の証明をリレー・チェーンに配置することで、潜在的な攻撃者がシステム全体を攻撃する必要がある。\\n\\n### SLS Gateway\\nSmart Logic Systemによって開発されたESP32マイクロコントローラをベースにしたZigbeeデバイスのためのオープンソースIoTゲートウェイ。\\n\\n### Slot (of Parachain)\\nPolkadot / Kusamaエコシステムでの希少なリソースであり、パラチェーンをリレー・チェーンに接続するためのブロックごとの手数料が不要となる。\\n\\n### Smart Leasing\\n時間ではなく特定の操作とその数に対して支払いが行われるロボットサービスモデルのバリエーション。\\n\\n### Smart Contract\\n特定の条件が満たされたときに自動的に実行されるブロックチェーン上に格納されたプログラムまたはアルゴリズム。\\n\\n### SSH\\nor Secure Shell — a network protocol for operating network services securely over an unsecured network, that uses public-key cryptography to authenticate the remote computer. \\n\\n### Staking\\nProof-of-Stake合意の一部であり、有効なブロックを生成し報酬を得る機会のためにトークンを担保として預ける行為。\\n\\n### Substrate\\nPolkadotやKusamaのようなブロックチェーンを構築するためのモジュラーフレームワーク。\\n\\n\\n## T\\n\\n### Treasury\\nブロック生成報酬、トランザクション手数料、ステーキングなどから集められた資金のポットであり、支出提案によって使用できる。予算がすべての資金を使い切らずに支出期間を終えると、一部の資金が焼失する。\\n\\n### Transaction Costs\\n経済主体の有限な合理性とプロセスの複雑さによる情報の収集と処理のコスト。\\n\\n\\n## V\\n\\n### Validator\\nリレーチェーンをトークンのステーキングによって保護し、パラチェーンのコレータからの証明を検証し、他のバリデータと共にコンセンサスに投票するノード。\\n\\n\\n## W\\n\\n### Web3\\n分散化、ブロックチェーン技術、トークンベースの経済などの概念を取り入れたWebの新しいイテレーションのアイデア。\\n\\n### Wiener (XRT)\\nまたはWn — 1 XRTトークンの10億分の1のシェア、1 XRT = 1 000 000 000 Wn；ノーバート・ワイナー（Norbert Wiener）にちなんで名付けられた、サイバネティックスと人工知能の理論の創始者の一人であるアメリカの数学者。\\n\\n\\n## X\\n\\n### XCM\\nまたはクロスコンセンサスメッセージフォーマット — Polkadot / Kusama内の異なるブロックチェーンシステム間のメッセージングのフォーマット。\\n\\n\\n### XRT\\nRobonomics NetworkのEthereumとKusamaネットワーク上で独立して存在するネイティブトークン。\\n\\n\\n## Y\\n\\n### Yggdrasil\\nメッシュネットワークの完全なエンドツーエンド暗号化ルーティングスキームのオーバーレイネットワーク実装。\\n\\n\\n## Z\\n\\n### Zigbee\\n低消費電力、容易な設定、自己組織化および自己回復型ネットワークトポロジーのサポートにより、スマートデバイスの接続に非常に一般的に使用されるワイヤレス通信プロトコル。\\n\\n### Zigbee Adapter\\nZigbeeネットワークと他のネットワーク（Wi-Fiなど）との間でデータを転送するデバイス、Zigbeeデバイスの制御に使用される。\\n\\n### Zigbee2MQTT\\nあるネットワークから別のネットワークにメッセージを変換することで、Zigbee を MQTT ネットワークに接続できるようにするソフトウェア。\"}},{\"node\":{\"id\":\"e666298a353dc289a79c8ad406ab5107\",\"title\":\"グローバル管理\",\"path\":\"/docs/ja/global-administration/\",\"content\":\"\\n**この記事では、Home Assistantに新しいユーザーを設定する方法を紹介します。**\\n\\n## サブスクリプションへのユーザーの追加\\n\\n以前に作成されたアカウントは使用できません。なぜなら、`SUB_OWNER`と`SUB_CONTROLLER`がセキュリティを提供し、最初にHome Assistantを起動したときに作成したユーザーにはRobonomics Parachainアカウントがないからです。\\n\\n1. [前の記事](/docs/sub-activate/)で行ったように、Robonomicsパラチェーンでアカウントを作成します。\\n\\n2. `SUB_OWNER`アカウントを使用して、[dapp](https://dapp.robonomics.network/#/subscription/devices)で新しいユーザーアカウントをサブスクリプションに追加します。アクセスリストには、`SUB_OWNER`、`SUB_CONTROLLER`、および`USER`の3つのアドレスが表示されるはずです。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## ユーザーへのアクセスの付与\\n\\n1. [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant)というdappサービスに移動します。右側のサイドバーで、さきほど作成したアカウントを選択します（プロファイルアイコンを押して、意図したアカウントを選択したことを確認してください）。\\n\\n2. 必要なフィールドに`USER`のシードを入力します。管理者クレジットフィールドに`SUB_OWNER`と`SUB_CONTROLLER`のアドレスを追加します。すべてが正しい場合、検証ステータスが「VERIFIED」と表示されます。\\n\\n3. さきほど登録した新しいユーザーのためにパスワードを作成、トランザクションを確認します。これはサブスクリプションのため手数料はかかりません。後でパスワードを「Restore」タブで復元することもできます。\\n\\n4. 登録プロセスの後、ユーザーアドレスと新しく作成したパスワードを使用してHome Assistantにログインできます。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nこれで、Robonomicsを介して自宅を制御するためにdappを使用できます。[**「スマートホームテレメトリを取得する」**](/docs/smart-home-telemetry/)の記事を確認してください。\\n\\n## トラブルシューティング\\n\\n1. Robonomics アカウントから Home Assistant へのパスワードを忘れた場合は、[Dapp を確認してください。](https://dapp.robonomics.network/#/home-assistant)\\n「Your Home Assistant password」の部分に移動し、「Restore」タブを選択します。\\n\"}},{\"node\":{\"id\":\"f1d7cb71b6c1ee74303497aaf643b7a1\",\"title\":\"はじめに\",\"path\":\"/docs/ja/getting-started/\",\"content\":\"\\n## Robonomicsとは何か\\n\\nRobonomicsプラットフォームは、ロボット経済ネットワークとの連携に必要なツールを提供します。Robonomicsは、スマートシティや産業4.0ゾーンの設計者が[自律型ロボットサービス](/docs/glossary#cyber-physical-system)間で信頼築き、自律型工場や都市センサーネットワークのサービスから製品を注文するための[dappを介した直接ユーザーアクセス](/docs/glossary#dapp)を提供することを可能にします。これにより、サイバーフィジカルシステムの活動をグローバルに監視する分散システムを構築することができます。\\n\\n次のチャートは、Robonomicsがシナリオでどのような位置を占めるかを示しています。\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\n[RobonomicsでのdAppの構築についての詳細はこちら](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)をご覧ください。\\n\\n## Robonomicsネットワークのクイックスタート\\n**初心者の利便性のために、Robonomicsのコア開発者が[6つのレッスンの学習カーブ](/docs/wschool2021-intro/)を提案しました！**\\n\\nサーバーレスのIoTアーキテクチャを探索します！ Robonomics Web Services（RWS）は、Polkadot && IPFSの上でのロボティクスとIoTの基本的なインフラサービスです。\\n\\nコースの卒業生は、クロスチェーントランザクションを介してROS互換デバイスを制御し、ローカルリレーチェーンを起動することができます。\\n\\n**[Robonomics Developers Discordに参加](https://discord.gg/jTxqGeF5Qy)して、コミュニティと技術サポートを受けましょう。**\\n\\n### Robonomics Academy卒業生の特典\\n- 優秀な学生のためのインターンシップ   Robonomicsチームの一員になり、選ばれた製品の開発に貢献しましょう。\\n- アクティブなコミュニティと定期的なイベント   学習者コミュニティの一員になり、業界の専門家とユースケースを議論しましょう。チームを組んでハッカソンに参加しましょう！\\n- 修了証   IoT向けのDAPPの構築コースの修了証をポートフォリオに追加しましょう。\\n- ITMO大学への入学支援   学士または修士であるかに関係なく、大学への入学支援を受けることができます。\\n- 資金調達と加速の機会：1）最大$50,000のアカデミアサポートグラントに申し込む；2）Web3 Foundationの支援を受けたRobonomicsビルダーアクセラレーションプログラムに参加する；3）Robonomicsの上に独立したDAPPを展開する；4）それを収益化し、Robonomicsチームからマーケティングサポートを受ける。\\n\\n\\n## ドキュメントに含まれる内容\\n\\n### 私はDapp開発者です\\n\\n- [GitHubのRobonomics-js](https://github.com/airalab/robonomics-js) - Robonomics Network dApp開発者向けのシンプルなJavascript SDK。\\n- [dAppテンプレート](https://github.com/airalab/vue-dapp-robonomics-template) - Vue.jsを使用しています。\\n- [Wikiドキュメント](/docs/robonomics-js/)\\n\\n### 私はロボティクスエンジニアです\\n\\n[ケース](/docs/iot-sensors-connectivity/)セクションをチェックし、[例](/docs/agent-development-examples)から開発を開始してください。\\n\\n\"}},{\"node\":{\"id\":\"2126bcb8c846b9c692ce7479f7bd445e\",\"title\":\"Gaka-Chuのセットアップとソフトウェアのインストール\",\"path\":\"/docs/ja/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**この記事では、ロボットペインターのセットアップのためのインストールと起動手順について説明します。要件:**\\n- KUKA KR6 R900 sixxとKRC4およびSmartPad;\\n- [ROS melodic](http://wiki.ros.org/melodic/インストールation/Ubuntu)がインストールされたIntel NUC;\\n- テーブル、絵の具、筆、水。\\n\\n## KRC4へのソフトウェアのインストール\\nKRC4とNUCの両方にEKIインターフェースが必要です。KRC4での設定方法の詳細は[こちら](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl)に示されています。ロボットのコントローラーで起動してください。\\n\\n## NUCへのソフトウェアのインストール\\ncatkinワークスペースを作成してください。\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nROSパッケージをダウンロードしてください。すべてのスクリプトは[ここ](https://github.com/airalab/robot_painter/tree/test_branch)に保存されています。リポジトリをクローンしてください。\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nすべてが正しく動作するために、いくつかのヘッダーファイルとライブラリが必要になる場合があります。それらをダウンロードしてください。\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\n`.bashrc`ファイルにソースコマンドを追加してください。\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nこれで、スクリプトを起動できるはずです。何か問題が発生した場合は、[トラブルシューティング](https://github.com/airalab/robot_painter/issues)を試してください。\\n\\n## 定数の入力\\nま、ロボットはキャンバスの位置と向き、および絵の具の位置を知る必要があります。これらはすべて`fake_painter_enviroment_tf/src/tf_broadcaster.cpp`で指定されています。詳細を見てみましょう。\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nこれらは3D空間でキャンバスの位置を指定する平面方程式の定数です。次に絵の具があります。\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nこれらは絵の具の座標です。これらもキャリブレーション時に指定することができます。キャンバスのサイズは次のように指定されます\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nその他の重要な定数は`local_task_planner/src/Drawing.cpp`に保存されています。\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nその名前からもわかるように、状況に応じてそれらを入力してください。\\n\\n## Gaka-Chuのキャリブレーション\\nキャリブレーションプロセス自体は非常にシンプルです。\\n\\n1) KRC4でEKIインターフェースを起動します。\\n\\n'AUT'モードでログインし、ドライバをオンにし、スクリプト`eki_hw_interface`を起動します。\\n\\n2) NUCでEKIインターフェースを起動します\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n無限のログが出力されるはずです。\\n\\n3) RVizを起動します\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n次のように表示されるはずです。\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nエンドエフェクタを動かして「Plan and Execute」をクリックしてみてください。ロボットが動くはずです。SmartPadで**Display -> Actual position**に移動し、エンドエフェクタの座標を確認します。キャンバスをロボットのベースに水平に配置します。ブラシをブラシホルダーに差し込み、キャンバスにかろうじて触れるまで注意深く移動します。この位置でエンドエフェクタの座標を保存します。12〜15回繰り返します。また、キャンバスの中心と絵の具の座標も保存します。\\n座標が揃ったら、[こちら](https://github.com/nakata5321/Matlab_scripts_gaka-chu)のMatlabスクリプトを使用して、不足している定数とクォータニオンを解決します。それらを貼り付けます。\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Gaka-Chuのキャリブレーションのテスト\\nキャリブレーションが完了したら、Gaka-Chuをテストする必要があります。キャンバスの境界線を描くために次のコマンドを新しいターミナルで実行してください。\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nこれで、RVizにキャンバスの輪郭が表示されるはずです。\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nターミナルで「S」を押してテストを実行します。ロボットのエンドエフェクタはキャンバスの境界線のすぐ上に移動し、ブラシは移動中ずっとキャンバスに優しく触れるはずです。そうでない場合は、再キャリブレーションを試してください。キャンバスモデルが誤って回転している場合は、Matlabでクォータニオンを変更して回転させることができます。\\n\\n## アート作成\\nすべてが正常に動作するには、6つの基本モジュールが必要です。\\n- EKIインターフェース;\\n- MOVEit + RViz;\\n- 環境フレームのブロードキャスト;\\n- 画像変換サービス;\\n- 軌跡描画モジュール;\\n- 起動トリガー。\\n\\nそれぞれを順番に起動しましょう。\\n\\n### EKIインターフェース\\nKRC4で`eki_hw_interface`を起動し、NUCでは新しいターミナルで次のコマンドを実行してください。\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RVizとMOVEit\\nプランナーとシミュレーションが必要です。次のコマンドで起動してください。\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### 環境\\nロボットに絵の具缶とキャンバスの位置を伝えます。`draw workspace`ノードを起動する必要はありませんが、`tf_broadcaster`はキャンバスのサイズを共有します。ただし、RVizには表示されません。\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### 画像処理\\nすべての入力画像を処理する必要があります。サービスを起動してください。\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\n通話を受けると、HPフィルターで画像を処理し、軌跡を持つrosbagファイルを作成します。\\n\\n### 軌跡描画\\nここで最も重要なスクリプトは、軌跡描画自体です。画像を待ち、TextConverterサービスを呼び出して絵を描きます。\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## ロボットに描画するための画像を送信してください\\nロボットは特定のROSトピックをリッスンし、所望の画像のパスを渡す必要があります。画像は正方形で（幅と高さが等しい）線で構成されている必要があります。パスを送信してください：\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nその後、輪郭とトラックが表示される2つのウィンドウが表示されます。それらを閉じて、Gaka-Chuの描画を見てください。安全に注意し、常に緊急停止ボタンを押す準備をしてください。\\nGaka-Chuがアートを終えたら、別のパスを画像に送信し、画家が全体のプロセスを繰り返します。\\n\"}},{\"node\":{\"id\":\"313f04e158e031c293f370cb3d19eec1\",\"title\":\"サブスクリプションの購入方法\",\"path\":\"/docs/ja/get-subscription/\",\"content\":\"\\n**ブロックチェーン上の取引に手数料を支払うのは面倒です。IoTデバイスが5〜10分ごとにテレメトリを送信することを想像してみてください。これにより、毎月かなりの費用がかかります。Robonomics Networkの主な特の1つは、RWS（Robonomics Web Service）サブスクリプションです。毎月支払い、取引コストを忘れましょう！理論的な背景については、[こちら](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855)の記事を参照してください。**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  始める前に注意してください。このチュートリアルでは、Robonomics Kusamaパラチェーンでのサブスクリプションの購入方法を示しています。同じ手順を[ローカルノード](/docs/run-dev-node)でも実行できます。\\n\\n  始める前にもう一つ。サブスクリプションを購入するための「困難な」方法です。[Robonomics DApp](https://dapp.robonomics.network/#/)を介して通常の方法で行うこともできます。\\n\\n</robo-wiki-note>\\n\\n## オークションに入札する\\n\\nRobonomicsのサブスクリプションはオークションモデルで販売されています。サブスクリプションを入手するには、オークションに入札して勝つ必要があります（心配しないで、すばやいです）。\\n\\n`Developer/Chain state`で利用可能なオークションを確認できます。 \\n`rws`と`auctionQueue`を選択し、`+`ボタンを押すと、利用可能なオークションのIDが表示されます。\\n\\n![queue](../images/rws/queue.png)\\n\\nオークションの情報は`rws` `auction`とオークションのIDで確認できます（画像のオークションのIDは79です）。\\n\\n![auction](../images/rws/auction.png)\\n\\nオークションの情報では、`winner`フィールドを見ることができます。現時点では`null`なので、誰もこのサブスクリプションを持っていません。入手することができます。そのためには、`Developer/Extrinsic`に移動し、アカウントと`rws -> bid`を選択します。また、オークションID（79）と入札する単位の量（1000000000 Wn以上）を設定します。\\n\\n![bid](../images/rws/bid.png)\\n\\nトランザクションを送信し、ID 79のオークションの情報を確認します（`Chain state`で`rws -> auction`とID 79を選択します）。\\n\\n![win](../images/rws/auc_win.png)\\n\\n今、`winner`フィールドにはあなたのアカウントアドレスが表示されます。これは、このアカウントがサブスクリプション79を持っていることを意味します。オークションは最初の入札で始まり、数ブロック続きます。次の数ブロックであなたよりも多くのトークンを入札する人が勝者となり、サブスクリプションを取得します。\\n\\nこれでデバイスを追加できます。デバイスは、このサブスクリプションを使用してエクストリンシックを手数料なしで送信できるアカウントす。\\nテストするには、トークンなしで新しいアカウントを作成し、デバイスに追加します。 \\n\\nデバイスを追加するには、`Developer/Extrinsic`で`rws -> setDevices`を選択します。その後、`Add Item`ボタンを押して、トークンを持たない最近作成されたアカウントを選択します。\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nトランザクションを送信します。これで、`Chain state`の`rws -> devices`でデバイスのリストを確認できます。そこには、トークンを持たないアカウントのアドレスが表示されます。サブスクリプションを購入したアカウントを選択し、`+`を押します。\\n\\n![devices](../images/rws/devices.png)\\n\\nこれで、サブスクリプションを使用して[起動を送信](/docs/subscription-launch)することができます。\"}},{\"node\":{\"id\":\"a87f4a8d1e39f9d0b66d7eb057ab56b0\",\"title\":\"Amazon FreeRTOSデバイスをMQTTでRobonomicsに接続する\",\"path\":\"/docs/ja/freertos-mqtt/\",\"content\":\"\\n[Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/)を実行するマイクロコントローラーが、MQTTを介してRobonomicsネットワークに接続されるデモンストレーションです。プロジェクトのソースコードにつては、[このリポジトリ](http://github.com/khssnv/freertos_mqtt_robonomics_example)をご確認ください。\\n\\n私たちは、FreeRTOSディストリビューションとMQTT実装を提供する[Espressif IoT Development Framework](https://github.com/espressif/esp-idf)を使用して、[ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/)を使用しています。Espressifは使用されるマイクロコントローラーのベンダーです。\\n\\nデモンストレーションの目的で[PMS-3003](http://www.plantower.com/en/content/?107.html)センサーもあります。このセンサーは、大気中の微粒子の存在を測定し、空気の品質を推定するために使用することができます。\\n\\n空気の品質はこの記事のテーマではありませんが、WHOのウェブサイトで詳細を確認できます：[Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health)。システムの目標は、センサーの測定値をAiralabのRobonomicsネットワークに公開することです。\\n\\n## ハードウェアのセットアップ\\n\\nPMS3003のTXD PIN5をESP32 DevKitC IO17に接続して、UARTで測定値を転送します。\\nまた、両方のデバイスには電源と共通のグラウンドが必要です。\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## データフロー\\n\\nセンサーの測定値をRobonomicsネットワークに配信するために、ファームウェアレベルでの目標は、センサーからデータを取得することです。埋め込み通信プロトコル（私たちの場合はUART）を介してAIRAインスタンスに渡します。\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nこの例では、パブリックIPアドレスとドメイン名が割り当てられたAIRAクラウド展開を使用しています。\\nAIRAインスタンスでは、`mosquitto` MQTTブローカーをセットアップし、`/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`トピックにサブスクライブしてMQTTからメッセージを取得します。\\n\\nその後、メッセージをパイプを介して`robonomics io`ライターに渡します。\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nこれでデータがRobonomicsネットワークで利用可能になり、再び`robonomics io`で読み取ることができます。\\n\\n## ファームウェア\\n\\n[ESP-MQTTサンプルアプリケーション（TCPトランスポート）](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp)をベースにしています。\\n\\nUART接続、SNTP時刻同期、定期的なMQTTパブリッシャールーチンのために、`main/app_main.c`のみを変更します。\\n\\nプロジェクトを繰り返し実行しようとしている場合、およびこれが最初のESP IDFベースのプロジェクトである場合は、まず[EspressifのESP-IDFプログラミングガイド](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step)の導入に従って、設定、ビルド、`idf.py`ツールを使用したアップロードなどのファームウェア操作に慣れるようにしてください。\\n\\n### Wi-Fiの設定\\n\\nクラウドに展開されたAIRAインスタンスと通信するために、マイクロコントローラーにはインターネット接続が必要です。\\nそれにはESP32のWi-Fiを使用します。\\nEspressifはオンボードWi-Fiを設定するためのユーティリティを提供しています。\\nこの例では、Ubuntu 20.04 GNU/Linuxを使用した開発環境を使用しています。\\nWi-Fiを設定するには、プロジェクトフォルダに移動し、SDK設定ツールを実行します。\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\n次に、`Example 接続ion 設定`セクションでWi-FiアクセスポイントのSSIDとパスワードを設定します。\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### MQTTエンドポイントの設定\\n\\nMQTTの設定には2つの項目があります。\\n1つ目はMQTTブローカーアドレスです。\\nSDKの設定ツールで設定可能です。\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\n`Example 設定`セクションで`Broker URL`を設定します。\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\n2つ目はMQTTトピックです。\\nプロジェクト名の接頭辞に続くESP32のMACアドレスでファームウェアに設定します。\\nこれにより、特定のマイクロチップに対して`/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`が与えられます。\\n\\n## MQTTからRobonomicsへ\\n\\nまず、MQTTでデータを受信しているか確認しましょう。\\nMosquitto MQTTブローカートピックにデバイスがパブリッシュするためにサブスクライブできます。\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nここでは、`mosquitto`パッケージを環境に取り込んで`mosquitto_sub`ユーティリティを使用します。\\n次に、ファームウェアで設定されたトピックにサブスクライブします。\\nデータを受信できたので、AIRAは正しくMQTTでデータを受信しています。\\nさて、これらのメッセージをRobonomicsネットワークにパイプしましょう。\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nここでは、`robonomics`ユーティリティを使用してpubsubチャンネル`/freertos_mqtt_robonomics_example`にメッセージをパブリッシュします。\\n少なくとも1つの接続が確立されるように、`bootnodes`を指定します。\\n\\nこれで、同じpubsubチャンネルからこれらのメッセージを読み取ることができます。\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## 使用された元のリソース\\n\\n* GoJimmyのブログからのESP32 DevKitCピン配置 https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* OpenAirProjectからのPSM3003データ構造とデコーダー https://github.com/openairproject/sensor-esp32\\n\\n**皆さん、ありがとうございました！**\\n\"}},{\"node\":{\"id\":\"98b1c2569cca28586e1c221a5e189f0b\",\"title\":\"Wikiの編集方法\",\"path\":\"/docs/ja/edit-wiki/\",\"content\":\"\\n**ロボノミクス Wiki はオープンソースです。 エラー、タイプミス、不明瞭または古い情報の修正、任意の言語への翻訳など、あらゆる修正を歓迎します。 [GitHub](https://github.com/) アカウントが必要です。**\\n\\n\\n## 編集方法\\n\\nRobonomics Wiki のドキュメントを編集する必要がある場合は、次の手順に従ってください。\\n\\n[Node.js](https://nodejs.org/en/download/package-manager/) と [Gridsome](https://gridsome.org/docs/#1-install-gridsome-) があることを確認してください。 cli-tool) がインストールされています。\\n\\n### 1. リポジトリのクローンを作成する\\n\\nまず、Wiki リポジトリのクローンを作成する必要があります。\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nリポジトリのディレクトリに移動し、次のコマンドを実行します。\\n\\n`npmを使用して`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`yarnを使用して`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. ローカルでサービスを提供する (develop、develop-m1)\\n\\n次に、プロジェクトをローカルにデプロイします。\\n\\n```\\ngridsome develop\\n```\\n\\n> エラー `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`,が発生した場合は、次のコマンドを実行します。\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. PRを行う\\n\\n[プル リクエストを作成](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) から [wiki リポジトリ](https://github.com/airalab/robonomics-wiki)\\n\\n## コンポーネント\\n\\n### Asciinema\\nRobonomics Wiki は Asciinema をサポートしています。 Asciinema を挿入するには、次の手順に従ってください。\\n* フロントマターブロックの後にコンポーネントをインポートします `import Asciinema from '~/components/Asciinema.vue'`\\n* 別の段落「<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>」として挿入します。ここで、vid は特定の asciicast の ID です\\n\\n> asciicast ページの「Embed」リンクをクリックすると、特定の asciicast のウィジェット スクリプトを取得できます。\\n> 次のようになります。\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Asciinema docs](https://asciinema.org/docs/embedding)\\n\\n上の例では、vid は 14 です。\\n\\n### コード\\n\\nコードに役立つ追加機能を追加できます。\\n\\n`コピーボタンのあるコード`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nまたは `追加の行を含むコード`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**code-helper のプロパティ**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nRobonomics Wiki のドキュメントには、frontmatter ブロックが含まれています。 これは Markdown ファイルの先頭になければならず、三点鎖線の間にある有効な YAML セットの形式をとる必要があります。 三点鎖線の間で、次のオプションを設定または編集できます。\\n\\n```YAML\\n---\\ntitle: How to contribute # ページのタイトル。テキスト内でそれを複製する必要はありません\\ncontributors: [positivecrash] # 主な寄稿者 (このページを積極的にキュレーションしている人)。 GitHub ニックネームが必要です。追加の記号は不要です\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/インストールation\\n    # テクノロジーテストに使用されたツール\\n---\\n```\\n\\n### Grid \\n要素にグリッド レイアウトを追加するのに役立ちます。\\n\\n- 最初にグリッド ラッパー コンポーネントを使用します。\\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- そして、ラッパー内で好きなだけグリッド項目コンポーネントを使用します。\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS ゲートウェイ</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**robo-wiki-grid-element-wrapper のプロパティ**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### 画像\\n\\n#### アップロード方法\\n画像をフォルダー「/docs/images/url-of-your-doc」にアップロードします\\n* 画像をローカライズする必要がある場合は、すべてを 1 つのフォルダーに挿入してください\\n* ローカライズされている場合は、画像の名前にロケールの付録を使用します。 `image_ja.jpg`\\n* 画像が Web に最適化されており、同時に見た目も良いことを確認してください\\n\\n#### 挿入方法\\n\\nドキュメントに画像を挿入するには 2 つの方法があります。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n組み込みタグ `<robo-wiki-picture>` を使用して画像を挿入することをお勧めしますが、Markdown ファイルの標準的な方法を使用することもできます。\\n\\n</robo-wiki-note>\\n\\n`キャプション付き`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`またはキャプションなし` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`または単純なイメージ` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`またはキャプション付きの単純な画像`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`alt付きの画像`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**robo-wiki-picture のプロパティ:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### 注意事項と警告\\nメモを追加して特定の種類を指定できます。\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`タイトル付きのメモ`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`内容のあるメモ`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`タイトルと内容が記載されたメモ`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**robo-wiki-note のプロパティ**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nドキュメントにタブを追加できます。\\n\\n- タブラッパーコンポーネントを使用します。\\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- 次に、ラッパー内でタブ項目コンポーネントを好きなだけ使用します。\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`水平タブ`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`垂直タブ`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`枠線付きのタブ項目`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**robo-wiki-tabs (ラッパー) のプロパティ**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**robo-wiki-tab (アイテム) のプロパティ**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### アンカー付きタイトル\\nアンカーを使用してカスタム タイトルを作成し、それに特定の値を与えることができます\\n\\n`アンカー付きタイトル`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nまたは\\n\\n`アンカーなしのタイトル`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**robo-wiki-title のプロパティ**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### 動画\\n\\nドキュメントにビデオを挿入するには 2 つの方法があります。\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\n組み込みタグ `<robo-wiki-video>` を使用してビデオを挿入することをお勧めしますが、Markdown ファイルの標準的な方法を使用することもできます。\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nビデオの形式を指定する必要があります\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### プロパティ\\n\\n- <span style=\\\"color:#af1c1c\\\">10MB</span> を超えるサイズのファイルを追加する場合は、リポジトリではなくサーバーにアップロードしてください。\\n\\n- [HTML5 ビデオ タグ](https://www.w3schools.com/tags/tag_video.asp) には任意のプロパティを使用できます。\\n\\n- 受け入れ可能な形式 - mp4、webm、ogg。\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\n引用符やタグを追加せずに、共有リンクを別の段落として挿入することで、ドキュメントに YouTube ビデオを埋め込むことができます (例: `https://youtu.be/kQaSwNYHJQ8`)\\n\\nただし、自動再生が必要な場合は、特別なコンポーネントを使用する必要があります。\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**robo-wiki-youtube のプロパティ**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## サイドバーのナビゲーションを編集する方法\\n\\nRobonomics Wiki のサイドバー ナビゲーションを編集する必要がある場合は、次の手順に従ってください。\\n\\n* ファイル `/data/sidebar_docs.yaml` を編集します。\\n\\n* ドキュメントを配置する場所を決定する\\n\\n* `/data/sidebar_docs.yaml` に有効な YAML を使用し、既存のファイル構造に依存します\\n\\n* **重要な注意:** 異なるセクション/サブセクションで同じドキュメントを使用している場合:\\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Raspberry Piのためのプリインストールイメージ\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\n次のように「topic」パラメータを必ず追加してください:\\n\\n(ナビゲーションが正常に動作するため)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## ドキュメントにカスタム ナビゲーションを追加する方法\\n\\n* ファイル「/data/sidebar_docs.yaml」を編集します。\\n\\n* 適切なドキュメントを見つけて、次のようにパラメータ `prev` と `next` を追加します。\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* `withoutNav` パラメータを追加するのではなく、ナビゲーションを完全に削除したい場合:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* `withoutPrev` または `withoutNext` パラメータを追加するのではなく、`前のページ` または `次のページ` ナビゲーションだけを削除したい場合:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nまたは\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"4b2a9049f79266d9a83316f71a3eb535\",\"title\":\"ドアが開いたときに通知を受け取る\",\"path\":\"/docs/ja/door-notification/\",\"content\":\"\\nこの記事では、Telegramボットの通知統合をインストールし、ドアが開いたときにTelegramアカウントに通知を送信する自動化を設定します。\\n\\n## Telegramボットの通知\\n\\n最初に、個人用のTelegramボットを作成する必要があります。これには、 [特別なTelegramボット @BotFather](https://t.me/botfather) にアクセスし、指示に従ってください。 \\nHTTP APIにアクセスするためのトークンを保存してください。\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nトークンを**安全に**保管し、**安全に**保してください。誰でもボットを制御するために使用できます \\n\\n</robo-wiki-note>\\n\\n次のステップは、***User Chat ID*** を見つけることです。 これには次のものを使用します [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\n次に、「Telegram broadcast」統合をインストールしましょう。 この統合により、メッセージが Telegram に送信されます。\\n\\nRobonomics のプリインストール イメージ、Home Assistant Docker または Home Assistant Core の場合は、`configuration.yaml` を編集する必要があります。 `ssh` 経由で Raspberry Pi に接続します。\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\n次の行をファイルの末尾に貼り付けます。 **bot API key**  と **your User Chat ID** を入力します。 通知サービスの名前も作成します。\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**設定を保存し、ホーム アシスタントをリロードします。**\\n\\nその結果、Home Assistant サービスに、あらゆるメッセージを Telegram チャットに送信するサービスが作成されます。\\nホーム アシスタント Web インターフェイスの 開発者ツール メニューで確認できます。\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n## ドアオープン通知\\n\\n今度は自動化を作成します。 まず、このリンクからブループリントをホーム アシスタントにインポートします:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nそして自動化を作成します:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nこれで、ドアが開くたびに Telegram ボットからメッセージを受信できるようになります。\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nこの自動化は、家のどのドア/窓でも使用できます。\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"91f1e31d34ac5156099a234d1a990966\",\"title\":\"データログ\",\"path\":\"/docs/ja/datalog/\",\"content\":\"\\n**アカウントにいくらかの資金があるので、外部機能を送信できます。 最初に試してみるのは Datalog です。 それはあなたを可能にします\\nデータをブロックチェーンに永続的に保存します。 データを暗号化で保護された分散ストレージを想像してみてください。これがまさにそれです。**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nこのチュートリアルと次のチュートリアルは、ロボノミクス ノードのローカル インスタンスでデモンストレーションされることに注意してください。 セットアップしてください [これらの指示](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Developer -> Extrinsics に移動します。\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. 可能な外部機能のドロップダウン リストから datalog -> record を選択します。\\n\\nまた、外部ファイルを送信するアカウントを選択します。 記録フィールドに記入します。\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog は、最大 512 バイトの文字列をサポートします。 大量のデータを保存するために使用される可能性がある [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. トランザクションを送信する\\n\\n拡張機能または DApp を使用して以前に作成したアカウントでトランザクションに署名し、送信します。\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  次の方法であなたの記録の**すべて**を消去することもできます *datalog -> erase* 呼び出し。\\n\\n</robo-wiki-note>\\n\\n## 4. ストレージ内のデータログを確認する\\n\\nこのためには、次の場所に移動してください *Developer -> Chain state*, 選択する *datalog -> datalogIndex*,アカウントを指定して、\\n「+」ボタンをクリックしてアカウントのレコードのインデックスを取得し、必要なレコードを検索します。 *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"探索するr\\\">\\n\\n  データログ レコードを含むすべてのイベントは、*Explorer* のイベント フローで確認できます。\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"6d6c0dd50b7ff09493a43cf62e6865d0\",\"title\":\"デジタルツイン\",\"path\":\"/docs/ja/digital-twins/\",\"content\":\"  \\n**複雑なデバイスやシステムを持ち、いくつかのモジュールを維持する必要があり、使用するためにいくつかのアカウントが必要な場合、それらをすべて1つの場所に保持するか、別々のアカウントでいくつかの機能をエンコードるか、例えば、異なる情報フローに対して異なるデータログソースを設定するために、デジタルツインモジュールを使用する必要があります。**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  このチュートリアルと次のチュートリアルは、ロボノミクス ノードのローカル インスタンスでデモンストレーションされることに注意してください。 セットアップしてください [これらの指示](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 理論の概要\\nどのアカウントでもデジタルツインを作成および管理することができます。ツインは以下の内容を持つテーブルのようなものと考えることができます:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nここで:\\n* **DT id** は符号なし整数で一意のデジタルツインインデックスです。\\n* **Topic name** は32バイトの長さの16進数の`H256`またはASCIIデータであり、 [`起動`](/docs/launch) 外部パラメータと同じです。 \\n例: `0x1234....FF`または`hello.parachain.robonomics.world`。\\n* **Source** - はいくつかのアカウントアドレスです。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  以前に起動外部パラメータの概要で説明したように、`H256`はエンコードされたIPFS CIDとして表現することができます（詳細は\\n  [Pythonツール](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) を参照）。\\n  したがって、トピックはデータストレージとしても使用できます。例えば、ツインのモジュールの説明です。\\n\\n</robo-wiki-note>\\n\\n\\n## デジタルツインの作成\\n\\n### 1. Developer -> Extrinsicsに移動します\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. digitalTwin -> create ドロップダウンリストからを選択します\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nトランザクションを送信します。ここではインを作成するためにパラメータは必要ありません。ツインにはインデックスが付与され、以降はデジタルツインの所有者のみがツインのトピックを追加/変更できます。\\n\\nツインIDはエクスプローラの概要ページで見つけることができます。\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## トピックの追加\\n\\n### digitalTwin -> setSource ドロップダウンリストからを選択します\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Explorer ページで取得した Digital Twin ID。\\n* `topic` - 以前に説明した`H256`トピック名。この画像では32文字の文字列です。\\n* `source` - トピックに関連付けるアカウントアドレスです。\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  必要に応じて、トピックは別のソースアドレスで上書きすることができますので、注意してください。\\n\\n</robo-wiki-note>\\n\\nエクストリンシックに署名して送信します。\\n\\n## Explore\\n\\n`Developer -> Chain state`ストレージモジュール`digitalTwin`には、既存のデジタルツインに関するすべての情報が含まれています。\\n\\n- ツインの総数 - `total()`;\\n- デジタルツインの所有者 - `owner(u32)`;\\n- デジタルツインのトピックに関する情報 - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"c1bcdea4ffa2219ae5c02a1962672477\",\"title\":\"ロボノミクスパラチェーンのアカウントを作成する\",\"path\":\"/docs/ja/create-account-in-dapp/\",\"content\":\"\\n**Robonomics Parachain と対話して操作するには、開発者とユーザーは Polkadot / Substrate Portal でアカウントを作成する必要があります。 アカウントはネットワークの基本的な機能を実行します: パブリック ネットワーク アドレス (公開キー)、アドレスと資金へのアクセス制御 (秘密キー)、ネットワークへのトランザクションの送信、トークンとその量の表示など。 ロボノミクス パラチェーンのアカウントを作成する 2 つの主な方法**\\n\\n## 1. Polkadot{.js}ブラウザ拡張機能を使用する\\n\\nPolkadot拡張機能は、Robonomicsパラチェーンを含むすべてのPolkadot / Kusamaプロジェクトとのアカウント生成とやり取りを提供します。これはアカウントを管理するための最も安全な方法ではありませんが、セキュリティ/使いやすさのバランスにおいて最も便利な方法です。\\n\\n## 1.1. ブラウザ拡張機能のインストール\\n\\nブラウザ拡張機能は、 [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) そして [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) （クロムベースのブラウザを含む）で利用できます。\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Robonomicsパラチェーンアプリを開く\\n\\nに移動し、 [RobonomicsパラチェーンアプリをPolkadot / Substrateポータルで開きます。ポータルに初めて入った場合、ブラウザ拡張機能へのアクセスを要求されるので、アクセスを許可してください。](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) アプリを開いたら、左上の角に注目してください。ネットワークの名前、アイコンおよび最後のブロックの番号が表示されます。この領域をクリックすると、テストネットワークやローカルノードを含むすべてのPolkadot / Kusamaネットワークのリストが表示されます。必要なネットワークを選択し、 \\n\\nアプリを開いたら、左上隅を見てください。 そこには、ネットワークの名前、そのアイコン、最後のブロックの番号が表示されます。 この領域をクリックすると、テスト ネットワークやローカル ノードを含む、すべての Polkadot/Kusama ネットワークのリストが開きます。 必要なネットワークを選択して `Switch`ボタンを押すと、ネットワークを切り替えることができます。 **今すぐ Robonomics Parachain に接続していることを確認してください**。 \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. 拡張機能のメタデータを更新する\\n\\nアプリは、接続しているチェーンに関する正しい情報を表示するために、拡張機能のメタデータを更新するように要求する可能性が高くなります。 **Settings -> Metadata** に移動し、「 `Update metadata` 」ボタンを押して、ポップアップ ウィンドウで拡張機能による更新を許可します。 \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. 拡張機能でアカウントを作成する \\n\\nPolkadot{.js} ブラウザ拡張機能を開きます。 大きなプラス ボタンをクリックするか、右上の小さなプラス アイコンから`Create new account` を選択します。 次のメニューが表示され、12 個の単語とアドレスの形式で生成されたニーモニック シードが表示されます。\\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nシードはアカウントへのキーです。 シードを知っていれば、あなた (またはシードを知っている他の人) がこのアカウントを制御できるようになり、パスワードを忘れた場合でもアカウントを再作成できるようになります。 **安全な場所に保存することが非常に重要です**。デジタル ストレージやコンピュータではなく、できれば紙やその他の非デジタル デバイスに保存してください。 \\n\\n種子を保存して押してください `Next step`. 次のメニューが表示されます。\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* このアカウントが専用に使用されるネットワークを選択することができます。同じアドレスを複数のネットワークで使用することもできますが、プライバシーのために、使用すネットワークごとに新しいアドレスを作成することをお勧めします。 \\nドロップダウンリストからRobonomicsネットワークを選択してください。Robonomicsネットワークが見つからない場合は、おそらくメタデータを更新していないためですので、戻って更新してください。\\n\\n    - アドレスの形式とアカウントアイコンが変わることに気付くでしょう。これは正常です。異なるネットワーク形式は、同じ公開鍵の他の表現に過ぎません。 \\n\\n- *Name* は、アカウントの名前であり、あなた自身のためだけのものです。ブロックチェーンには保存されず、他のユーザーには表示されません。 \\n\\n- *Password* は、アカウントの情報を暗号化するために使用されます。ポータルでトランザクションに署名する際に再入力する必要があります。作成して覚えておいてください。\\n\\nその結果、アカウントを作成した後、Polkadot{.js}拡張機能のアカウントリストに表示されます。3つの点をクリックすることで、アカウントの名前を変更したり、エクスポートしたり、拡張機能から削除したり、アカウントに使用するネットワークを変更したりすることができす。 \\n\\nまた、アカウントはポータルの **Accounts -> Accounts**  メニューに表示され、拡張機能を使用して挿入されたことがわかります。\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## ア2. ロボノミクスパラチェーンアプリ上で直接\\n\\nPolkadot / Substrate Portal のユーザー インターフェイスを使用してアカウントを作成できます。 開発やテストに使用できます。\\n\\n## 2.1. ロボノミクスパラチェーンアプリを開く\\n\\nに行く [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) Polkadot / Substrate Portal で。 **左上隅で、ロボノミクス パラチェーンに接続されていることを確認してください**。\\n\\nに行く **Accounts -> Accounts** そして`Add account` ボタンを押してください。\\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. アカウントを作成する\\n\\nアカウント シードを含む次のポップアップ メニューが表示されるはずです。\\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nそれには2つの形式があります： *Mnemonic* （人が読める形式）と *Raw* （数字と文字のシーケンス）。シードフレーズを安全に保存し、 `Next`.\\n\\n> ボタンを押してください。また、アカウントの作成に使用する暗号通貨のタイプを変更することもできます。そのたには、 `Advanced creation options` を開いて、 (`ed25519` を選択してください。).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\n次のメニューでは、アカウント名とパスワードを設定する必要があります。これは、拡張機能の指示に記載されている手順と同様です。\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\n`Next` ボタンをクリックすると、最後のウィンドウに移動します。 `Click` をクリックしてアカウントの作成を完了します。 また、安全に保存する必要があるバックアップ JSON ファイルも生成されます。 パスワードを覚えている場合は、後でこのファイルを使用してアカウントを回復できます。\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 ed25519アカウントをPolkadot拡張機能に追加する\\n\\n作成したアカウントを Polkadot.js 拡張機能に追加する必要がある場合があります (ed25519 アカウントの場合は、バックアップ JSON ファイルでのみ追加できます)。 そのためには、アカウントのバックアップファイルを作成する必要があります。 アカウントの 3 つの点を押して、「このアカウントのバックアップ ファイルを作成する」を選択し、パスワードを入力します。\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\n次に、拡張機能を開いて右上の「+」ボタンを押し、 `Restore account from backup JSON file` を選択します。\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\n 開いたウィンドウで保存したファイルをドロップし、パスワードを入力して`Restore`を押します。\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. アカウントの作成に成功しました \\n\\nこれで新しく作成したアカウントをフルに操作することができます。トークンの送受信、メッセージの送信、データログの書き込みなどが可能です。アプリのすべての機能を自由に探索してください。アカウントのアドレスをコピーするには、そのアイコンをクリックするだけで、アドレスがクリップボードにコピーされます。 \\n\\nPolkadot/Kusamaアカウントについてさらに詳しく知りたい場合や、それらを作成するための追加の方法については、詳細な情報が見つかります [ここ](https://wiki.polkadot.network/docs/learn-accounts) と [ここ](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"ecad3f4a1150c61fe472a4e455505c04\",\"title\":\"イーサリアムによって運営されるデジタルアイデンティティを作成する\",\"path\":\"/docs/ja/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nRobonomicsのサービスの1つは [デジタルパスポート登録](https://dapp.robonomics.network/#/passport/) 任意のデータに対して。このサービスでは、データのハッシュをパブリックブロックチェーンに保存し、ユニークアドレスを割り当てることでデジタルアイデンティティを作成することができます。\\n\\n「デジタルパスポート登録」サービスは [Robonomics DApp](https://dapp.robonomics.network/) 「サービス」セクションで見つけることができます。または、この [直接リンク](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## ビデオウォークスルー\\n\\n以下のビデオはRobonomicsホワイトペーパーの登録の進捗状況を示しています。\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## ステップバイステップの画像\\n\\n### 1. サービスを開く\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. 必要な情報とファイルを追加する\\n\\n複数の画像を追加することも可能です。\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. 要求に署名する\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. トークンを承認する\\n\\nこのサービスは小さな手数料がかかります。ただし、まずアカウントから支払われる必要なトークンの量を承認する必要があります。\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. オファーを受け入れて再度メッセージに署名する\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. 作成されたパスポートを確認する\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\n登録プロセスには時間がかかります。最後に作成されたアイデンティティへのリンクが表示されます。\\n\"}},{\"node\":{\"id\":\"a98a4b4c83ef0924a5d40a258ad6ac94\",\"title\":\"Robonomicsリソースへの貢献方法\",\"path\":\"/docs/ja/contributing/\",\"content\":\"\\nRobonomics Network はオープンソース プロジェクトであり、誰でも簡単に貢献できるようにしたいと考えています。 記事を作成したり、変更を提案したり、ドキュメントを改善したり、テストを実行したりできます。 貢献したい場合は、新しい問題を開くか、同じリポジトリでプル リクエストを作成してください。\\n\\n## 主要なRobonomicsリポジトリ \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — 主要なウィキプロジェクト\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  ロボノミクスネットワークの公式メインウェブサイト\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Robonomics Webサービスのホーム\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — 公式のdapp\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Robonomics Academyの公式ウェブサイト\\n\\n### 報告のルール\\n\\n新しい問題を開く際には、いくつかの基本的な報告ルールを忘れないでください:\\n\\n1. 提出する問題の正確なリポジトリを選択してください。\\n\\n2. バグを報告する場合は、既に報告されていないことを確認してください。\\n\\n3. タイトルと明確な説明を含め、可能な限り関連情報を含めてください。\\n\\n4. 問題の前に次のいずれかの接頭辞を付けてください: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## プルリクエスト\\n\\nRobonomics リポジトリは、追加または変更すべき価値のあるものがあると思われる場合、コントリビューターによるプル リクエストや変更の対象となる可能性があります。 投稿者向けの基本的なルールを忘れないようにしてください。\\n\\n### 貢献のルール\\n\\n1. 小さな変更（スペルミスなど）については、問題よりもプルリクエストが好まれます。\\n\\n2. PRの説明には、問題と解決策が明確に記載されていることを確認してください。該当する場合は、関連する問題番号も含めてください。\\n\\n3. スペースの修正、コードのフォーマット、または純粋に見た目の修正は行わないでください。\\n\\n4. Markdownスタイル、言語、レイアウトに従うようにしてください。\\n\\n\\n\"}},{\"node\":{\"id\":\"b930ddf9a834a0199d6dc86f12cd3021\",\"title\":\"センサーを接続する\",\"path\":\"/docs/ja/carbon-footprint-sensor/\",\"content\":\"\\n作業の例は次のビデオにあります：\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## 要件\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (または [サポートされている](https://www.zigbee2mqtt.io/オフセットサービスformation/supported_adapters.html))\\n\\nサービスは Raspberry Pi で実行されており、zigbee プロトコル経由でスマート プラグに接続します。\\n\\n## ジグビースティック\\n\\nJetHome USB JetStick Z2 をお持ちの場合は、必要なファームウェアがすでに含まれているため、フラッシュする必要はありません。 ただし、別のアダプタがある場合は、まず zigbee2MQTT ソフトウェアでフラッシュする必要があります。 お使いのデバイスの手順は [こちら](https://www.zigbee2mqtt.io/information/supported_adapters.html) でご覧いただけます。\\n\\nアダプターを接続し、アダプターのアドレスを確認します (`「/dev/ttyUSB1」` の場合もあります)。\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\n最初に USB ポートにアクセスする必要がある場合があります。 ユーザーを `「dialout」` グループに追加します (ubuntu では機能しますが、グループ名は他の OS では異なる場合があります)。\\n\\nubuntuの場合：\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\narchの場合：\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nその後、ログアウトしてログインするか、コンピューターを再起動します。\\n\\n## インストール\\n\\nリポジトリをクローンします：\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## 設定\\n\\nに移動し、 `data/configuration.yaml` を設定します。また、対応する情報でフィールドを入力することもできます。 `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nフィールドでは、接続を確立するために `server` and `port` ブリッジのIPを使用します： `server` ここではあなたのアドレスは `docker0`. \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nこちらがあなたの住所です `172.17.0.1`.\\n\\n次に、次の情報を含むconfig/config.yamlファイルを作成し、場所を設定します（3文字のISOコードについてはhttps://countrycode.org/を参照できます）： \\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## プラグを接続する\\n\\n最初の実行：\\n\\n```\\ndocker-compose up     \\n```\\n\\nプラグのペアリング モードに切り替えるには、ライトが青色に速く点滅し始めるまで、電源ボタンを数秒間長押しします。\\n\\nログには、プラグが mqtt への公開を開始したことが表示されます。\\n\\n\\n## ペアリング後\\n\\n他のデバイスをスティックとペアリングさせたくない場合は、「data/configuration.yaml」に移動して「permit_join: false」を設定する必要があります。 サービスを再起動します ( `「Ctrl+C」` を使用し、 \\n\\n```bash\\ndocker-compose up     \\n```\\nもう一度変更を送信してください)。\\n\\n## ランニング\\n最初にプラグイン用のアカウントが作成されます。\\n> すでにアカウントをお持ちの場合は、そのシードを `device_seed` セクションの `config.config.yaml` ファイルに追加する必要があります。\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nアカウントを作成すると、ログにアドレスが表示されます (シードは `config/config.yaml` に追加されます)。\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\n取引手数料のためにいくつかのトークンをこのアカウントに送金する必要があります [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nサービスは十分なトークンがあることを確認し、ログに次のように表示されます:\\n```\\nplug               | Balance is OK\\n```\\nサービスは、プラグからの mqtt メッセージと安全な電力使用量を確認します。 1 時間ごとに (` 「sending_timeout」`  セクションの `「config/config.yaml」` でタイムアウトを変更できます。タイムアウトは秒単位です)、次の情報を含むデータログが作成されます。\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"a43cd7939c73da48e1447e22e9c8cac4\",\"title\":\"バックアップサービス\",\"path\":\"/docs/ja/backup-services/\",\"content\":\"\\n**この記事では、Home Assistantの設定をバックアップし、必要な場合に復元する方法について説明します。バックアップを作成するためには、設定ファイルを含む安全なアーカイブを生成するサービスが呼び出されます。またサービスはMosquittoブローカーとZigbee2MQTTの設定をバックアップに追加します（存在する場合）。このサービスはアーカイブをIPFSに追加し、結果のCIDをRobonomics Digital Twinに保存します。**\\n## Home Assistantの設定のバックアップを作成する\\n\\nバックアップを作成することで、障害が発生した場合に簡単にHome Assistantの設定を復元することができます。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"警告\\\">\\n\\n設定のバックアップと復元を行うには、 **カスタムのIPFSゲートウェイ** （Pinataなど）を使用する必要があります。これがない場合、バックアップはローカルのIPFSノードにのみ保存されるため、ローカルノードの障害が発生した場合にHome Assistantの設定を復元することができなくなる可能性があります。\\n\\n</robo-wiki-note>\\n\\n1. Home AssistantのWebインターフェースに移動し、 `Developer Tools` -> `Services`. 検索して `Robonomics: Save Backup to Robonomics` を押します。 `CALL SERVICE`.\\n\\n2. 通知が表示されるまで待ちます。 `Backup was updated in Robonomics` 警告 `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"警告\\\">\\n\\nHome Assistant と Robonomics Integration をロードした直後に、バックアップを作成したり、設定を復元しようとしないでください。 初期セットアップが完了するまで、**約 5 分間お待ちください**。\\n\\n</robo-wiki-note>\\n\\nサービスの引数：\\n- **Mosquittoパスワードファイルへのパス**  (default: False) - Home Assistant CoreまたはDockerのインストール方法を使用し、デフォルトのMosquittoブローカーのパスがない場合は、このパラメータを変更する必要があります。\\n- **Home Assistant OSまたはSuperviserでは必要ありません。** (default: `/etc/mosquitto`) - バックアップからHome Assistantの設定を復元する *設定を復元するには、インストールされたHome AssistantとRobonomics Integrationが必要です。*.\\n\\n## ホームアシスタント設定をバックアップから復元する\\n\\n構成を復元するには、ホーム アシスタントとロボノミクス統合がインストールされている必要があります。 \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"警告\\\">\\n\\nHome Assistant Core および Docker のインストール方法で構成を正常に復元するには、ページの最後に説明されている追加のセットアップ手順を実行する必要があります。\\n\\n</robo-wiki-note>\\n\\n1. ホーム アシスタントと Robonomics 統合をインストールします (まだインストールされていない場合) [希望の取り付け方法](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2.  以前のロボノミクス構成で使用した **同じシード** を使用して、[ロボノミクス統合をセットアップ](https://wiki.robonomics.network/docs/robonomics-hass-integration)します。 サブスクリプションが終了した場合は、[再アクティブ化](https://wiki.robonomics.network/docs/sub-activate)してください。\\n\\n3. ホーム アシスタントの Web インターフェイスで、Developer Tools` -> `Services` に移動します。 `「Robonomics: Restore from the Backup in Robonomics` を検索し、`「CALL SERVICE」` を押します。 `「概要」` ページに移動して、バックアップのステータスを確認します。\\n\\n4. 復元後、ホーム アシスタントが自動的に再起動します。 何らかの理由で Home Assistant が再起動しない場合は、`robonomics.backup` エンティティの状態を監視することで復元ステータスを確認できます。 ステータスが `restored` の場合は、`Settings` > `System` に移動し、右上隅にある `RESTART` ボタンをクリックして、Home Assistant を手動で再起動する必要があります。\\n\\n5. バックアップに Zigbee2MQTT または Mosquitto 構成が含まれている場合は、これらのサービスを再起動して新しい構成を有効にする必要があります。 これは、サービスを個別に再起動して手動で行うことも、ホーム アシスタント コンピュータを再起動してすべてのサービスを確実に再起動することもできます。\\n\\nサービス引数:\\n- **mosquitto パスワード ファイルへのパス** (default: `/etc/mosquitto`) - Home Assistant Core または Docker インストール方法を使用し、Mosquitto ブロッカーへのデフォルトのパスがない場合は、このパラメータを変更する必要があります。 *ホーム アシスタント OS またはスーパーバイザーには必要ありません*。\\n- **Zigbee2MQTT 構成へのパス**  (default: `/opt/zigbee2mqtt`) - Home Assistant Core または Docker インストール方法を使用し、Zigbee2MQTT へのデフォルトのパスがない場合は、このパラメータを変更する必要があります。 *ホーム アシスタント OS またはスーパーバイザーには必要ありません*。\\n\\n## Home Assistant Core インストール用の Mosquitto および Zigbee2MQTT 構成を復元する方法\\n\\nバックアップに Mosquitto または Zigbee2MQTT の構成が含まれている場合、復元プロセス中にそれらはデフォルトのパスまたは引数で指定されたパスに配置されます。 ただし、既存の Home Assistant Core *(プリインストールされた Robonomics イメージからではなく)* に Robonomics 統合をインストールした場合、`「homeassistant` ユーザーはこのパスにアクセスできない可能性があります。\\n\\nしたがって、Mosquitto と Zigbee2MQTT の設定を復元するには、必要な読み取り権限をユーザー `homeassistant` に付与する必要があります。\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Home Assistant Docker インストール方法用のバックアップ Mosquitto および Zigbee2MQTT 構成\\n\\nMosquitto および Zigbee2MQTT 構成を Docker コンテナーからバックアップするには、それぞれの構成にボリュームを作成する必要があります。 これは、追加の引数を指定して Home Assistant コンテナを実行することで実現できます。\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nまたは、変更を加える `compose.yaml` ファイル：\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nなお、MosquittoとZigbee2MQTTのデフォルトのパスは `/etc/mosquitto` と `/opt/zigbee2mqtt`, です。ただし、これらのパスは特定のセットアップによって異なる場合があります。\\n\\n</robo-wiki-note>\\n\\n## バックアップボタン\\n\\nバックアップを行うためのサービスを使用するだけでなく、Robonomics統合のボタンを使用することでプロセスを簡素化することができます。これらのボタンは、デフォルトのパラメータ（バックアップボタンは履歴なしでバックアップを作成）で対応するサービスを呼び出します。 `button.create_backup` と `button.restore_from_backup` ダッシュボードにボタンを追加するには、次の手順に従ってください。\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\n1. ダッシュボードの右上隅にある3つの点をクリックします。\\n2. 選択します `Edit Dashboard`.\\n3. 右下隅にある `Add Card` ボタンをクリックします。\\n4. `Entities` カードを選択します。\\n5. `Entities` フィールドで、button.create_backup エンティティと button.restore_from_backup エンティティを検索します。\\n6. `Save` を押してエンティティをカードに追加します。\\n7. 右上隅の `Done` ボタンをクリックして編集を終了します。\"}},{\"node\":{\"id\":\"574afe46e71167a0ea6e984b005c4d30\",\"title\":\"オフセットサービス\",\"path\":\"/docs/ja/carbon-footprint-service/\",\"content\":\"\\n作業例はビデオにあります:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nStatemine ネットワークでトークンを燃やすことで CO2 排出量を相殺するサービス。\\n生成される CO2 は次のように計算されます。Wh 単位のデバイスからのデータに地域に応じた係数を掛けます。 1 トンの C02 が 1 トークンの消費でカバーされます [ここ](/docs/carbon-footprint-sensor) デバイスの接続手順です。\\n\\n## シナリオ\\n\\n1. ロボノミクスネットワークのデジタルツインに新しいデバイスを登録する\\n2. 一定間隔で 1 回、すべてのデバイスから最後のデータを取得し、地域に応じた係数を乗算します。\\n3. データを合計し、CO2 トンに変換します\\n4. 現在のデータから書き込み中のトークンの総数を減算します。\\n5. Statemine ネットワークで整数のトークンを書き込みます\\n6. ローカル DB とデータログに保存された書き込みトークンの総数 \\n\\n## インストール中\\n\\nリポジトリのクローンを作成し、構成ファイルを編集します。\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## 構成の説明\\n\\n編集しないでください `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network wでご確認いただけます。 Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\n非再生可能エネルギーの係数は、Eurostatから取得され、保存されています [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) および保存されています `utils/coefficients.py`. \\n\\n## 打ち上げ\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"11f43dd4c55f3ad47b2a3ba67bfc406d\",\"title\":\"ロボノミクス ポータルのアカウントに資金を追加する\",\"path\":\"/docs/ja/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Robonomicsポータルでアカウントを作成した後、それらに資金を追加してトランザクションを開始できるようにしましょう。**\\n\\n<robo-wiki-note type=\\\"warnオフセットサービスg\\\" title=\\\"Dev Node\\\">\\n\\nこのチュートリアルおよび以下のチュートリアルは、Robonomicsノードのローカルインスタンスでデモンストレーションされいることに注意してください。 [以下の手順で自分のものをセットアップしてください。 ](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Robonomicsポータルのアカウントセクションに移動します。  \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. 資金を送金したいアカウントを選択します。\\n\\n開発モードでは、開発ネットワークで作成された他のアカウントに資金を送金するために使用できる、それぞれ10000ユニットの資金を持つ複数のアカウントが存在します。これらのアカウントは、 <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> レンチのマークで示されています\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- 資金を送金したいアカウントの「送信」ボタンをクリックします。例えばBOBです。\\n\\n## 3. 資金を送金したいアカウントを選択します。\\n「送信」ボタンをクリックした後、「資金送信ウィンドウ」が表示されます。表示されたウィンドウで以下の操作を行います。 \\n\\n- 利用可能なアカウントのリストから、資金を送信したいアカウントを選択します\\n- 送信したいユニット数を入力します。\\n- 「送金を作成」ボタンを押します。\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. トランザクションを承認します。\\n\\n前のステージで「送金を作成」ボタンを押した後、「トランザクション承認ウィンドウ」が表示されます。<br/>\\nトランザクションの詳細を確認し、「署名と送信」ボタンをクリックします。\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nこの例では、「BOB」から「EMPLOYER」に500ユニットの資金を送金しました。EMPLOYERのアカウントは元々資金を持っていなかったため、現在500ユニットの資金があります.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**プレイグラウンドで使用するアカウントに十分な資金があることを確認してください.**\"}},{\"node\":{\"id\":\"ced97c1a4ebb37c549d923e127f0ef6f\",\"title\":\"Adattatore Zigbee con Zigbee2MQTT per immagine preinstallata\",\"path\":\"/docs/it/zigbee-to-mqtt-image/\",\"content\":\"\\n**In questo articolo accoppierai dispositivi intelligenti.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nApri un browser web e vai su `http://%RASPBERRY_IP_ADDRESS%:8099`. Puoi trovare l'indirizzo IP del Raspberry Pi utilizzando [l'app mobile Fing](https://www.fing.com/products) o [lo strumento CLI nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nVedrai l'interfaccia web di Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nÈ ora di collegare il tuo dispositivo intelligente. \\nPrima, premi il pulsante `Permit join (All)` in alto nell'interfaccia web di Zigbee2MQTT. \\n\\nQuindi, inizia ad accoppiare i dispositivi. Il modo più comune per mettere un dispositivo in modalità di connessione è tenere premuto il suo pulsante di accensione o accenderlo/spegnere 5 volte. Assicurati che Zigbee2MQTT sia in esecuzione.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nQuando il dispositivo si connette, li vedrai nell'interfaccia web:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nOra dovresti vedere questo sensore nella tua interfaccia web di Home Assistant. Vai su `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nDopo aver aggiunto tutti i sensori, puoi chiudere l'interfaccia web di Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"4371d47c31227713aacfdc8222f0c959\",\"title\":\"Substrate Cumulus Parachain Testsuite per il messaggio cross-chain\",\"path\":\"/docs/it/xcm-robobank/\",\"content\":\"\\n\\nL'obiettivo principale di questo progetto è semplificare lo sviluppo del runtime di parachain, quando vengono utilizzati messaggi cross-chain. \\nConsente lo sviluppo del codice di runtime con test di integrazione con un alto grado di ripetibilità e semplicità d'uso.\\nAutomatizza la costruzione, la configurazione predefinita della rete (ad esempio 1 relay chain + 2 parachain), l'installazione dei canali di passaggio dei messaggi tra le parachain e l'esecuzione dei test di messaggistica, l'invio di messaggi, utilizzando la chiamata al runtime, il tutto costruito e composto in Python.\\n\\nXCM Testsuite viene utilizzato per testare il ciclo di produzione di Robobank - l'insieme di pallette Substrate, che consentono ai robot di registrarsi su parachain esterne, ricevere ordini prepagati, eseguirli e ricevere pagamenti utilizzando token esterni. Ciò consente ai robot di operare all'interno della rete Robonomics con tutta l'infrastruttura necessaria, ma allo stesso tempo, offrire i loro servizi su qualsiasi altra parachain.\\n\\nUn video di esempio è disponibile su [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nI principali passaggi dello scenario di demo sono:\\n- lanciare la relay chain e due parachain in un pacchetto di 6 processi\\n- configurare i canali di messaggi XCM tra le parachain\\n- registrare un robot in entrambe le parachain\\n- creare un ordine per questo robot nella parachain client (riservando il pagamento per il completamento dell'ordine)\\n- inviare un messaggio XCM alla parachain Robonomics\\n- creare il record dell'ordine \\\"speculare\\\" sulla parachain Robonomics\\n- il robot accetta l'ordine sulla parachain Robonomics\\n- inviare un messaggio XCM sull'accettazione dell'ordine alla parachain client\\n- accettare l'ordine sulla parachain client (riservando una penale per mancato completamento dell'ordine fino alla scadenza dell'ordine)\\n- il robot completa l'ordine sulla parachain Robonomics\\n- inviare un messaggio XCM sul completamento dell'ordine alla parachain client\\n- regolare tutti i pagamenti (il pagamento del cliente viene trasferito al robot, così come la penale non utilizzata)\\n- chiudere l'ordine1\\n\\n\\n## Upstream\\nQuesto progetto è un fork del\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nContiene il codice dei pallette di runtime in fase di test.\\nCome nel codice originale del nodo, le parachain si trovano nelle cartelle \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nDifferenze con il modello originale di \\\"substrate-node-template\\\":\\n- questo runtime del collatore ha il modulo gestore HRMP e può gestire i messaggi dalle parachain fratelli\\n- test di simulazione del runtime pronto per i test XCM interni\\n\\n## Build & Run\\nSetup consigliato (molto): \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[NOTA] La prima compilazione può richiedere molto tempo, fino a diverse ore su macchine non ottimali.\\n\\n[NOTA] Lo script funziona con le versioni FISSE (commit hash) di Polkadot(Rococo) nella relay chain e nelle parachain.\\n\\n[NOTA] Per impostazione predefinita, lo script ricrea lo stesso ambiente ad ogni avvio, rimuovendo tutti gli stati precedenti. Questo comportamento può essere modificato in \\\"config.sh\\\" utilizzando il parametro \\\"PERSISTENT\\\".\\n\\n\\nEsegui lo script di compilazione e configurazione.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nAzioni di base dello script \\\"init.sh\\\":\\n - leggi la configurazione (file \\\"config.sh\\\" con numero di revisione, chiavi e identificatori iniziali del nodo, parametro di persistenza dei dati della catena, ecc.)\\n - configura i pacchetti del sistema operativo, Rust e Python\\n - compila binari separati per la relay chain e anche per entrambe le parachain\\n    - i binari verranno generati nella sottodirectory ./bin. \\n - (opzionale) rimuove tutti i dati precedenti della catena per tutte le catene\\n    - disabilitato se \\\"PERSISTENT=1\\\" è impostato in \\\"config.sh\\\"\\n - viene eseguito come processi separati (con PID e pipe I/O separati):\\n    - validatori della relay chain (ad esempio 4 validatori in esecuzione su una revisione stabile di Rococo)\\n    - collatori per la parachain-100 (ad esempio un singolo collatore per la prima parachain che si sta sviluppando)\\n    - collatori per la parachain-200 (ad esempio un singolo collatore per la seconda parachain che si sta sviluppando)\\n - stampa tutte le endpoint, le porte sulla console, consentendo di studiare qualsiasi catena utilizzando app frontend (esploratore, DApp)\\n - continua a stampare tutti i dati di output di tutte le catene sulla console\\n\\n[ATTENZIONE] Dopo il lancio, attendere che la rete sia attiva, assicurarsi che la finalizzazione del blocco sia iniziata e che le parachain siano registrate. Questi processi dovrebbero richiedere circa 5 minuti (50 blocchi x 6 secondi).\\n\\n## Verifica che la configurazione iniziale funzioni \\n\\nUtilizza il frontend standard di Polkadot e gli endpoint generati \\\"--ws-port\\\" per connettersi a ciascun nodo.\\nApri [Polkadot application](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) per monitorare le catene. \\n\\n### Esempio:\\nLocalhost, 4 validatori della relay chain, un collatore per la parachain-100, un collatore per la parachain-200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nSe tutto funziona e il consenso è iniziato, possiamo procedere ad eseguire i nostri casi di test (in un nuovo terminale).\\n\\n### Test di trasmissione dei messaggi UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nCrea un messaggio `Balance.transfer` in `parachain-100` e lo passa alla relay chain.\\nQuando la relay chain riceve il messaggio, trasferisce 15 token dall'account `para 100` all'account Charlie.\\n\\n\\n### Test di trasmissione dei messaggi HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nCrea un messaggio `Balance.transfer` in `parachain-100` e lo passa al `sibling 200`.\\nPrima di ciò, fornisce all'account `subl 100` 1000 token e stabilisce un canale di comunicazione tra le parachain.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nI messaggi successivi possono essere inviati eseguendo il sottocomando `hrmpm`. Non crea un canale e quindi viene eseguito più velocemente.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Altre opzioni\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Testnet locale\\n\\n### Crea una specifica di catena personalizzata\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nModifica rococo_local.json, sostituisci i parametri di bilancio e autorità con i tuoi.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nIndirizzo Polkadot per //Alice//stash (crittografia sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nChiave di sessione grandpa di Polkadot per //Alice (crittografia ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nIndirizzo Polkadot per //Alice (crittografia sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nConverti rococo_local.json nel formato raw.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nPer utilizzare la nuova specifica di catena, sostituisci il file rococo.json nella directory ./config/ con questo nuovo e riavvia la catena.\\n```bash\\n./scripts/init.sh run\\n```\\nPuoi modificare liberamente il codice. Il comando precedente ricostruirà il progetto e aggiornerà il nodo collator prima di avviarlo.\\nCumulus è un software pre-release ancora in fase di sviluppo intensivo.\\nStiamo utilizzando un commit specifico di polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15 18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nPuoi utilizzare versioni più recenti del software. Per farlo, modifica POLKADOT_COMMIT in ./scipt/config.sh\\nall'ultimo commit del ramo `rococo-v1`, elimina ./bin/polkadot e esegui \\n```bash\\n./scripts/init.sh run\\n```\\n\\nAggiorna le dipendenze del progetto collator \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nAlcune dipendenze probabilmente richiedono nuove funzionalità del toolchain di Rust. Questo progetto si basa su Rust `nightly-2021-01-26`\\nAggiorna la versione del toolchain di Rust in ./scripts/config.sh prima di compilare.\\n\\n## Hack parachain\\n[Aggiungi un pallet esterno](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - dovrebbe probabilmente essere in \\\"ulteriori informazioni\\\"?\\n## Learn More\\n\\nFai riferimento al [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template) per saperne di più sulla struttura di questo progetto, sulle capacità che incapsula e sul modo in cui tali capacità sono implementate. Puoi saperne di più su [Il percorso di un blocco di parachain](https://polkadot.network/the-path-of-a-parachain-block/) sul blog ufficiale di Polkadot. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"934abf1aa49c7710bd4bac890040b178\",\"title\":\"Come utilizzare le Blueprints\",\"path\":\"/docs/it/use-blueprints/\",\"content\":\"\\nIn questo articolo imparerai come aggiungere le automazioni blueprints al tuo Home Assistant e come configurarle.\\n\\n## Automazioni Blueprints\\n\\nAlcune blueprints sono già installate. Le automazioni basate su queste blueprints devono solo essere configurate. Nell'interfaccia web puoi trovare le blueprints pre-installate in `Settings/Automations & Scenes`. Apri `Blueprints` e trova la blueprint che desideri utilizzare. In questo esempio verrà utilizzata `Motion-activated Light`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nClicca su `Create Automation` per aprire l'editor di automazioni. Dai un nome, scegli una blueprint da utilizzare (`Motion-activated Light` nel nostro caso). Dopo di che devi scegliere il sensore di movimento e la lampada. Quando la configurazione è terminata, clicca su `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Configurazione\\\" />\\n\\nSe vuoi apportare modifiche, puoi trovarla andando su `Settings/Automations & Scenes` e poi`Automations`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Importazione delle Blueprints\\n\\nHome Assistant può importare blueprints dai forum di Home Assistant, GitHub e GitHub gists. L'elenco di tutte le Blueprints si trova su [Blueprints Exchange](https://community.home-assistant.io/c/blueprints-exchange/53). Dopo aver scelto, vai su `Settings/Automations & Scenes` e apri `Blueprints`. Clicca su `Import Blueprint` e inserisci l'URL della blueprint scelta. Quindi clicca su `PREVIEW BLUEPRINT`. In questo caso utilizzeremo [Rilevazione e notifica del livello di batteria basso per tutti i sensori di batteria](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nQuesto caricherà la blueprint e mostrerà un'anteprima nella finestra di importazione. Puoi cambiare il nome e completare l'importazione. Clicca su `Create Automation` per aprire l'editor di automazioni. Qui puoi configurare i parametri dell'automazione e aggiungere azioni per ricevere notifiche.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"347eee1411ecd5a22a8a9932bdadff17\",\"title\":\"Come inviare un lancio con sottoscrizione\",\"path\":\"/docs/it/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Fai attenzione che questo tutorial dimostra l'uso di una sottoscrizione su Robonomics Kusama parachain. Puoi eseguire tutti i passaggi anche sul tuo [nodo locale](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nSe il tuo indirizzo ha una sottoscrizione attiva, allora tutti i dispositivi configurati con il segreto di quell'account possono inviare estrinseci senza commissioni. \\nProviamo a inviare il comando `launch`.\\n\\nVai alla pagina `Developer/Extrinsics`, quindi scegli il tuo account (quello dalla lista dei dispositivi) e seleziona `rws -> call(subscriptionId, call)`. Poi nel campo `subscriptionId` incolla l'indirizzo del proprietario della sottoscrizione (colui che ha fatto l'offerta all'asta) e nel campo successivo scegli `launch -> launch(robot, param)`. Nel campo `robot` digita l'indirizzo a cui desideri inviare la transazione `launch` e inserisci il comando (per la descrizione del comando di lancio consulta [qui](/docs/launch)). Poi invia la transazione: \\n\\n![launch](../images/rws/launch.png)\\n\\n\\nOra vai alla pagina `Network/Explorer` e nell'area `Eventi Recenti` vedrai due eventi che hai creato: `rws.NewCall` e `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"e2561143f7d6330848c7c30304ffec81\",\"title\":\"Attiva sottoscrizione\",\"path\":\"/docs/it/sub-activate/\",\"content\":\"\\nIn questo articolo creerai account Robonomics parachain e acquisterai una sottoscrizione IoT. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nPer controllare Home Assistant con Robonomics, hai bisogno di 2 account sulla parachain Robonomics. Per uno degli account (`sub_owner`), acquisterai una sottoscrizione Robonomics. Il secondo account (`sub_controller`) controllerà tutti i processi di Home Assistant (come la telemetria) e darà accesso ad altri utenti. Questi account garantiranno la sicurezza per il tuo Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nEntrambi gli account devono essere creati con crittografia **ed25519**. Per questo motivo, è necessario creare un account utilizzando l'interfaccia utente di Polkadot-JS e selezionare la crittografia richiesta. \\n\\nQuesta funzionalità è disabilitata per impostazione predefinita nell'interfaccia utente di Polkadot-JS. Per abilitarla, vai su `Settings` -> `General` -> `account options` e seleziona `Allow local in-browser account storage` nel menu a discesa `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Crea account proprietario e controller\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Vai all'app [Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) su Polkadot / Substrate Portal. **Controlla l'angolo in alto a sinistra per assicurarti di essere connesso a Robonomics Parachain.**\\n\\n2. Vai su `Account` -> `Account` e premi il pulsante `Add account`. Vedrai il menu popup con il seed dell'account. Ha due forme: *Mnemonic* (leggibile dall'uomo) e *Raw* (una sequenza di cifre e lettere). \\n\\n3. Apri `Advanced creation options`, cambia il tipo di crittografia per la creazione dell'account in `Edwards - ed25519` e premi `Next`.\\n\\n\\n4. Salva in modo sicuro la frase seed mnemonica e premi `Next`.\\n\\n5. Nel menu successivo, devi impostare il nome dell'account e la password. Dà un nome `sub_owner` per comodità. Premi `Next`.\\n\\n6. Nell'ultima finestra clicca su `Save` per completare la creazione dell'account. Verranno generati anche file JSON di backup che dovresti conservare in modo sicuro. Puoi utilizzare successivamente questo file per recuperare il tuo account se ricordi la password.\\n\\n7. Ripeti questi passaggi per un account con il nome `sub_controller`.\\n\\n\\n## Aggiungi Account a Polkadot.js\\n\\nPer comodità, dovresti utilizzare l'[estensione Polkadot.js](https://polkadot.js.org/extension/) e aggiungere questi account appena creati. Per un account ed25519 puoi farlo solo con un file JSON di backup. Puoi utilizzare i file salvati quando hai creato gli account.\\n\\nPuoi ottenere nuovamente questi file creando un file di backup dell'account. Premi sui tre puntini sul tuo account, scegli `Create a backup file for this account` e inserisci la tua password.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Apri un'estensione e premi il pulsante `+` in alto a destra, quindi scegli `Restore account from backup JSON file`.\\n\\n2. In una finestra aperta carica il file JSON, inserisci la password e premi `Restore`.\\n\\n3. Assicurati che la rete Robonomics sia selezionata per gli account nell'estensione Polkadot.js. Su Polkadot / Substrate Portal vai su  `Setting` -> `Metadata` e clicca sul pulsante `Update metadata`.\\n\\n4. Conferma l'aggiornamento dei metadati nel popup. Ora l'estensione mostrerà l'etichetta della rete per cui viene utilizzato l'indirizzo.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Attiva la Sottoscrizione Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nPer questo passaggio, devi avere una quantità sufficiente di token XRT (minimo 2-3 XRT) nel tuo account `sub_owner`.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Vai alla dapp Robonomics alla [pagina di sottoscrizione](https://dapp.robonomics.network/#/subscription) e premi connetti account nella barra laterale destra.\\n\\n2. Nel menu popup successivo connetti l'estensione Polkadot.js. Vedrai il tuo indirizzo dell'account con il saldo.\\n\\n3. Prima di effettuare l'acquisto, verifica di aver scelto l'account `sub_owner`. Premi sull'icona del profilo dell'indirizzo, dovresti vedere l'account `sub_owner` sotto il campo `Check owner account`.\\n\\n4. Infine, premi il pulsante `SUBMIT` e inserisci la password del tuo account. Dopo di che, attendi il completamento del processo di attivazione. Vedrai lo stato della tua sottoscrizione dopo un po' di tempo.\\n\\n\\n## Aggiungi Account alla Sottoscrizione\\n\\nOra devi aggiungere un account `sub_controller` alla **lista di accesso**. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Apri l'estensione e fai clic sull'icona accanto al nome dell'account. Verrà copiato l'indirizzo dell'account.\\n\\n\\n2. Incolla questo indirizzo nel campo `Robonomics parachain address` nella parte **Gestisci accesso**. Dà un nome e premi il pulsante `+`. \\n\\n3. Ripeti i passaggi 1 e 2 per l'account `sub_owner`.\\n\\n4. Premi `Save`. Inserisci la password del tuo `sub_owner` nella finestra popup e attendi il completamento del processo di attivazione.\\n\"}},{\"node\":{\"id\":\"cc14ab239ddb45e184c9913debe85068\",\"title\":\"Ottieni Telemetria Smart Home\",\"path\":\"/docs/it/smart-home-telemetry/\",\"content\":\"\\n**In questo articolo, utilizzerai il servizio Robonomics, che interroga la telemetria dei dispositivi smart home.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Vai alla dapp e scegli il servizio [Telemetria Smart Home](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. Nel campo del controller inserisci l'indirizzo `SUB_CONTROLLER`. Inserisci la frase seed per crittografare i dati.\\n\\n3. Nel blocco `Get telemetry` scegli un timestamp dalla lista a discesa e premi il pulsante `DOWNLOAD TELEMETRY`.\\n\\n4. Il download della telemetria potrebbe richiedere del tempo. Dopo aver terminato, vedrai le informazioni dai tuoi dispositivi e sensori.\\n\\n\\n<!---\\n## Lancio devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Lancio\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"1c6d8913140fd996697888ea3fb2cdfb\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/it/sls-gateway/\",\"content\":\"\\n**In questo articolo configurerai Robonomics SLS Gateway. Installerai il software richiesto per il gateway, lo configurerai e lo collegherai a Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nPrima di tutto devi installare il firmware del microcontrollore del gateway. Prepara il gateway impostando gli interruttori `1` e `3` nella parte inferiore del SLS Gateway su `ON`, gli altri devono essere `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nCollega il gateway al tuo Raspberry Pi tramite la porta USB di tipo C sul gateway.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nClona il repository con il firmware sul tuo Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nVai a `robonomics-hass-utils/esp_firmware/linux`. Per flashare il gateway SLS devi eseguire gli script `Clear` e `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Risoluzione dei problemi\\n\\nSe riscontri problemi nell'aggiornamento del firmware del gateway, devi seguire ulteriori passaggi:\\n\\n1. Assicurati di avere installato il modulo pySerial:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Concedi all'utente i diritti di accesso alla porta USB e riavvia il computer:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. In alcuni casi, è necessario modificare l'impostazione della larghezza di banda nello script per aggiornare il firmware. Apri lo script `Flash_16mb.sh` con l'editor `nano` e cambia il parametro baud da `921600` a un valore più piccolo (ad esempio, `115200`).\\n\\n## Configurazione\\n\\n1. Scollega il SLS Gateway dal computer. Imposta gli interruttori sul retro del gateway nella posizione corretta. Gli interruttori `5` (RX Zigbee a ESP) e `6` (TX Zigbee a ESP) devono essere nella posizione `ON`, gli altri devono essere `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Collega il cavo di alimentazione di tipo C. La luce indicatrice al centro dovrebbe diventare verde.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. Al primo avvio, il gateway inizierà a condividere il Wi-Fi con l'SSID `zgw****`. Connettiti a questa rete. Tieni presente che il segnale potrebbe essere piuttosto debole, quindi è meglio tenere il gateway SLS più vicino al tuo computer. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Se la connessione è riuscita, si aprirà l'interfaccia web (o puoi trovarla all'indirizzo 192.168.1.1). \\n\\n5. Vedrai la pagina `Wi-Fi Settings`. Seleziona la tua rete Wi-Fi e inserisci la password. Premi il pulsante `Apply`. Il gateway si riavvierà e si collegherà alla tua rete Wi-Fi. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Trova l'IP locale del gateway SLS per accedere all'interfaccia web. Per trovarlo puoi utilizzare [l'app mobile Fing](https://www.fing.com/products) o [lo strumento CLI nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Il nome del gateway dovrebbe essere simile a questo: `zgw****`. Apri l'interfaccia web del gateway incollando l'IP del gateway nel browser.\\n\\n7. Vai a `Setting` -> `Hardware` e assicurati che le impostazioni siano simili all'immagine. Correggi le impostazioni se necessario e clicca sul pulsante `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nLa tabella con i valori richiesti:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Riavvia quindi il gateway. Scegli `Actions` -> `Reboot system` nell'angolo in alto a destra.\\n\\n9. Assicurati che il gateway funzioni correttamente nella finestra delle informazioni Zigbee. Lo stato del dispositivo dovrebbe essere `OK`.\\n\\n10. Configura l'aggiunta automatica dei dispositivi a Home Assistant. Vai a `Zigbee` -> `Config` quindi scegli `Home Assistant MQTT Discovery` e `Clear States`. Salva le modifiche e **riavvia** il gateway SLS.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSe hai già un gateway SLS attivo nella tua casa e stai configurando un altro, entreranno in conflitto tra loro. Per risolvere questo problema devi cambiare il canale sul nuovo dispositivo. Per farlo, vai a `Zigbee` -> `Config` e cambia il canale con un altro (ad esempio, canale 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Associazione SLS a MQTT\\n\\nDopo aver configurato il gateway SLS, devi collegare il gateway SLS a Home Assistant. Apri l'interfaccia web del gateway SLS e vai a `Settings/Link` -> `MQTT Setup`:\\n\\n\\nAggiungi l'indirizzo del tuo broker (indirizzo del Raspberry Pi con Home Assistant nella rete locale, puoi trovarlo con [l'app mobile Fing](https://www.fing.com/products) o [lo strumento CLI nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), la porta (predefinita è `1883`), il nome utente e la password del broker (che hai creato in precedenza) e il nome dell'argomento (puoi scegliere qualsiasi). Inoltre, l'indirizzo IP del Raspberry Pi deve essere statico. Fai clic su `Enable` e `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nSalva le modifiche. Ora i dispositivi verranno mostrati automaticamente in Home Assistant.\\n\\n## Collega i dispositivi\\n\\nCollega i tuoi dispositivi andando su `Zigbee` -> `Join`. Metti i tuoi sensori in modalità di accoppiamento, il modo più comune per passare a modalità di connessione è tenere premuto il pulsante di accensione o accenderli/spegnere per 5 volte. Premi il pulsante `Enable Join` per iniziare la ricerca dei dispositivi Zigbee. Vedrai i sensori attivi.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nOra puoi andare alla sezione [**Sottoscrizione IoT**](/docs/sub-activate) e iniziare ad attivare la sottoscrizione Robonomics.\\n\"}},{\"node\":{\"id\":\"38004ff8e9e1949392c70127f3d51499\",\"title\":\"Rete di sensori decentralizzata\",\"path\":\"/docs/it/sensors-network-introduction/\",\"content\":\"\\nGli articoli sulla Rete di sensori decentralizzata sono stati trasferiti all'Accademia Robonomics: https://robonomics.academy/it/corsi-online/corso-sulla-connettivita-dei-sensori/\"}},{\"node\":{\"id\":\"b93b831d5f8ef10bbcabf107f5443dfc\",\"title\":\"Come aggiungere il sensore SDS011 a Home Assistant\",\"path\":\"/docs/it/sds-sensor-hass/\",\"content\":\"\\nQuesto articolo spiega come collegare il sensore di qualità dell'aria SDS con il firmware [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) e [Robonomics](https://github.com/airalab/sensors-software) a Home Assistant.\\n\\n## Installazione \\nCi sono due opzioni di installazione disponibili:\\n\\n### Opzione 1: HACS\\n\\nIl modo più semplice per aggiungere un sensore Luftdaten locale è tramite HACS. [Qui](https://hacs.xyz/docs/setup/download/) puoi trovare una breve spiegazione su come configurare HACS.\\n\\nUna volta installato HACS, vai su HACS -> Integrations e cerca l'integrazione `Local Luftdaten Sensor`. Fai clic sul pulsante di download e riavvia Home Assistant una volta scaricata l'integrazione.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Opzione 2: Installazione manuale\\n\\nSotto l'utente homeassistant, clona il repository del progetto:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nSe hai già integrazioni personalizzate, copia la cartella `custom_components/local_luftdaten/` nella tua directory `custom_components`, ad esempio:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nSe non hai integrazioni personalizzate, copia l'intera directory `custom_components` nella directory di configurazione di Home Assistant, ad esempio:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Configurazione\\n\\nCrea una nuova voce del sensore nel tuo `configuration.yaml` e regola il nome host o l'indirizzo IP. Per trovare l'indirizzo IP locale del tuo sensore puoi utilizzare [l'app mobile Fing](https://www.fing.com/products) o lo strumento CLI [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Il nome può essere qualsiasi.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> L'elenco di tutti i sensori supportati può essere trovato nel [repository](https://github.com/lichtteil/local_luftdaten).\\n\\nRiavvia Home Assistant.\\nDopo di che puoi aggiungere il sensore al tuo cruscotto. Il nome dell'entità sarà il nome che hai aggiunto a `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"e5f4cd0899dcc488bf3449e33722307b\",\"title\":\"Collega in modo sicuro l'IA cloud al piano di lavoro della fabbrica\",\"path\":\"/docs/it/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nLe tecnologie Robonomics possono già risolvere le sfide che l'Industria 4.0 affronta e sono già applicate a scenari reali nell'ambiente industriale.\\n\\nUn gran numero di aziende di intelligenza artificiale sta costruendo soluzioni per ottimizzare i processi sul piano di lavoro della fabbrica, consentendo alle piante di produrre di più a costi inferiori. Tuttavia, la maggior parte delle piante è riluttante a collegare la propria infrastruttura direttamente al cloud poiché ciò comporta potenziali rischi per la sicurezza informatica, che potrebbero portare a perdite di milioni di dollari e persino alla perdita di vite umane.\\n\\n[MerkleBot](https://merklebot.com) ha utilizzato [Robonomics Network](https://robonomics.network) per creare una soluzione per i clienti industriali per collegare la loro fabbrica all'IA basata su cloud in modo sicuro.\\n\\nQuesto articolo è scritto in seguito a un esperimento che abbiamo condotto con [Veracity Protocol](https://www.veracityprotocol.org/) che utilizza algoritmi per creare una protezione non invasiva di qualsiasi oggetto fisico basata sulle fotografie da un dispositivo mobile.\\n\\nQuesto caso d'uso mostra il processo di scansione delle parti industriali utilizzando un braccio robotico.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Processo passo-passo\\n\\n### DApp come interfaccia utente\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp funge da interfaccia utente per l'operatore. Viene utilizzata per richiedere l'avvio del robot per raccogliere le fotografie e il suo scopo è consentire una comunicazione sicura tra l'ambiente della fabbrica e l'IA basata su cloud.\\n\\n### Avvio del robot\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nL'operatore avvia la scansione robotica firmando la transazione nella DApp. Questo passaggio garantisce che il processo sul piano di lavoro della fabbrica possa iniziare solo in base alla transazione nel blockchain pubblico.\\n\\nIl robot riceve un comando dal blockchain tramite la rete Robonomics e inizia la scansione. Le tecnologie della rete Robonomics ci consentono di colmare il divario tra l'obiettivo aziendale e l'operazione robotica.\\n\\n### Raccolta dati e invio all'IA basata su cloud\\n\\nNella DApp l'operatore vede la conferma e il robot inizia a scansionare gli oggetti posizionati sul tavolo, come in questo caso d'uso, o direttamente sulla linea di produzione della fabbrica se necessario.\\n\\n<!-- ![](../images/Veracity_Protocol_Lancio.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nQuando il robot raccoglie i dati, li memorizza localmente e li rende disponibili all'IA basata su cloud tramite il protocollo IPFS. Crittografando i dati e organizzando lo scambio di dati tramite una transazione blockchain, possiamo autorizzare l'accesso all'IA basata su cloud garantendo al contempo la sicurezza e l'integrità dei dati.\\n\\nIl meccanismo di sicurezza integrato in Robonomics basato sulla sicurezza condivisa dei blockchain pubblici consente di ottenere un livello di sicurezza che risulta proibitivamente costoso per la maggior parte delle fabbriche organizzare autonomamente.\\n\\n### Creazione di un passaporto digitale\\n\\nQuando l'IA basata su cloud analizza i dati, il file di registro e le raccomandazioni vengono registrati automaticamente come un [Passaporto Digitale](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/). Ogni operazione e scansione possono essere rintracciate poiché il record del blockchain ha l'hash di tutti questi file tramite il protocollo IPFS.\\n\\n## Commenti sul caso d'uso\\n\\nIn questo caso d'uso è stato utilizzato il braccio industriale Universal Robot UR3. Ma grazie al supporto di Robonomics per ROS, la maggior parte dei principali manipolatori industriali può essere utilizzata e collegata in modo sicuro all'IA basata su cloud, inclusi KUKA, Fanuc e Yaskawa.\\n\\nSe sei interessato a saperne di più sull'implementazione e l'integrazione di strumenti di intelligenza artificiale basati su cloud in modo sicuro, ti preghiamo di [contattarci](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"18a75129ab839af05f6fe1b6a6e60fef\",\"title\":\"Come collegare il sensore SDS011\",\"path\":\"/docs/it/sds-sensor-connect/\",\"content\":\"\\n** Ecco una guida passo-passo su come collegare il tuo sensore alla rete dei sensori Robonomics. I nostri sensori utilizzano il firmware Robonomics, che è una versione migliorata del firmware sensor.community. Include sensori aggiuntivi e ha un meccanismo di invio dati modificato. **\\n\\n1. Collega il sensore alla presa per alimentarlo.\\n2. La scheda creerà una rete Wi-Fi chiamata `RobonomicsSensor-xxxxxxxxx`. Connettiti ad essa dal tuo telefono o computer: vedrai la finestra di autorizzazione (se non la vedi, apri il browser e vai su `192.168.4.1`).\\n3. Seleziona la tua rete Wi-Fi dalla lista (o scrivila tu stesso se non è nella lista) e compila il campo password.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nIl sensore può essere collegato solo a una rete Wi-Fi a 2,4 GHz.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Scrivi le coordinate del luogo in cui verrà installato il sensore. Puoi ottenerle da qualsiasi mappa o ottenerle dall'indirizzo utilizzando [questo link.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nLe coordinate del sensore verranno quindi visualizzate su una mappa pubblicamente disponibile. Se non desideri mostrare le tue informazioni private, scrivi 'vicino', ma non le coordinate esatte.\\n</robo-wiki-note> \\n5. Fai clic su `Save configuration and restart`. La scheda si riavvierà e si connetterà alla rete Wi-Fi specificata.\\n6. Apri [Mappa dei sensori Robonomics](https://sensors.robonomics.network/#/) e trova il luogo in cui hai installato il sensore. In un paio di minuti sarai in grado di vedere il tuo sensore con i dati sulla mappa.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"8932283062fc2419a1e23850c33ea866\",\"title\":\"Come eseguire un nodo di sviluppo Robonomics\",\"path\":\"/docs/it/run-dev-node/\",\"content\":\"\\n**Per testare le tue applicazioni su Robonomics potresti volerlo eseguire in modalità di sviluppo. Questo articolo mostra passo dopo passo\\nistruzioni su come ottenere la tua istanza di test locale di Robonomics.**\\n\\n\\n## Ottieni il file binario del nodo\\n\\n1. Prima di tutto, hai bisogno di un file binario, scarica l'archivio da [release](https://github.com/airalab/robonomics/releases) più recente.\\n\\n2. Vai alla cartella dell'archivio, decomprimi il binario e cambia i permessi:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Esegui\\n\\nEsegui il nodo con:\\n\\n```bash\\n./robonomics --dev\\n```\\nVedrai il seguente output:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Se desideri eliminare i blocchi esistenti, puoi farlo rimuovendo RocksDB in `/tmp/substrate******/chains/dev/db/full`.\\n  Sostituisci `******` con un identificatore corrispondente visualizzato nei log all'avvio.\\n\\n  Se desideri avviare il nodo da zero ogni volta, utilizza l'opzione `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Connetti\\n\\nOra puoi connetterti al tuo nodo locale tramite il [Portale Polkadot](https://polkadot.js.org/apps/#/explorer).\\n\\nCambia la rete in `Locale Node` nell'angolo in alto a sinistra e premi `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nBenvenuto nell'istanza locale di Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"2b1c996be805300322f922775d70b2d9\",\"title\":\"Servizio video Robonomics\",\"path\":\"/docs/it/robonomics-video/\",\"content\":\"\\nQuesto articolo mostra come aggiungere una telecamera IP a Home Assistant e inviare video al servizio web Robonomics.\\n\\nPer collegare una telecamera a Home Assistant, è necessario conoscere il suo indirizzo IP e creare un account di telecamera locale per connettersi allo stream RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nPoiché questo viene fatto in modo diverso per ogni telecamera, questo processo non è considerato in questo articolo.\\n</robo-wiki-note>\\n\\nRequisiti:\\n- Telecamera IP\\n- Account di telecamera locale configurato\\n- Indirizzo IP della telecamera\\n- Home Assistant configurato\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nQuesto articolo assume che tu abbia una telecamera IP generale senza opzioni RTZ (ruota, inclina, zoom). \\nSe hai una telecamera RTZ, controlla l'articolo \\\"Telecamera RTZ\\\". E poi torna al secondo passaggio qui.\\n\\n</robo-wiki-note>\\n\\n## Collega la telecamera\\n\\nInnanzitutto, devi trovare l'URL per lo streaming RTSP della telecamera.\\nPer farlo, prova a inserire la seguente query su Internet: \\\"<NOME_TELECAMERA> flusso RTSP\\\".\\nL'URL dello stream deve iniziare con `rtsp://<INDIRIZZO_IP>...`. \\n\\nQuesto articolo utilizza una telecamera \\\"Tapo\\\" e il percorso dello stream è `rtsp://<INDIRIZZO_IP>/stream1`.\\n\\nApri Home Assistant e vai su \\\"Settings\\\"-> \\\"Devices & Services\\\". Premi il pulsante \\\"ADD INTEGRATION\\\" e\\ninizia a digitare \\\"Generic Camera\\\". Sceglila.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nNella finestra di configurazione fornisci le seguenti informazioni:\\n- Stream Source URL - L'URL dello stream RTSP della telecamera\\n- Username - scrivi un nome utente del tuo account di telecamera locale\\n- Password - scrivi una password per il tuo account di telecamera locale\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nScorri verso il basso le impostazioni e premi il pulsante \\\"Submit\\\".\\n\\nNella finestra di anteprima attiva la casella di controllo \\\"This image looks good.\\\" e premi il pulsante \\\"Submit\\\". Poi - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Aggiungi al dashboard\\n\\nInoltre, puoi aggiungere lo stream al tuo dashboard. Per farlo, vai al dashboard e crea una nuova scheda \\n\\\"Picture Glance\\\". Passaggi successivi:\\n- inserisci il \\\"Title\\\" desiderato\\n- elimina i dati da \\\"Image Path\\\"\\n- seleziona the camera in \\\"Camera Entity\\\"\\n- nella \\\"Camera View\\\", seleziona \\\"live\\\" in modo che ci sia meno ritardo\\n\\nE salvalo.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Controlla la cartella dei media\\n\\nBefore being sent to the Robonomics Video Service, the video must be saved in a folder, and Home Assistant must have access to this folder. \\nLa soluzione più semplice in questo caso è utilizzare un pacchetto multimediale, in cui Home Assistant memorizza tutti i media.\\n\\n- Se usi HAOS o un'immagine preinstallata, il tuo Home Assistant **ha già una cartella Media**.\\n- Se usi Home Assistant Core, dovresti andare nella cartella `.homeassistant` e creare una cartella `media` al suo interno.\\n- Se usi Home Assistant Docker, aggiungi la riga ` -v /PERCORSO_DEL_TUO_MEDIA:/media \\\\` al comando Docker.\\n\\nPer verificare che tutto sia stato configurato correttamente, vai alla scheda \\\"Media\\\" -> \\\"media locale\\\" nel tuo Home Assistant. \\nDovresti vedere una cartella vuota (nessun errore):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Chiamata di servizio\\n\\nPer inviare un video a Robonomics, devi chiamare un servizio dedicato in Home Assistant. \\nIn questo articolo viene fatto manualmente, ma puoi crearne un'automazione.\\n\\nPer farlo, vai su  \\\"Developer tools\\\" -> \\\"Services\\\" e trova \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nIn \\\"Targets\\\" scegli l'entità della tua telecamera.\\nIn \\\"Path to save the recording\\\" devi fornire un percorso assoluto alla cartella,\\ndove Home Assistant può salvare il video:\\n- Per immagine preinstallata - `/home/homeassistant/.homeassistant/media`;\\n- Per HA OS o Home Assistant Docker- `/media`;\\n- Per Home Assistant Core - Percorso alla cartella dei media precedentemente creata.\\n\\nInoltre, puoi scegliere la Durata della registrazione. \\n\\nCompila i dati e chiama il servizio con il pulsante \\\"CALL SERVICE\\\".\\n\\n## DAPP\\n\\nPer visualizzare il video risultante vai su [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nIncolla l'indirizzo del tuo account del controller e clicca sul pulsante sottostante. Aspetta il processo \\\"Search for Twins\\\". \\nCome risultato, otterrai un CID IPFS con tutti i video registrati.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nSuccessivamente, seleziona l'account del controller (o un altro) dall'elenco a discesa e firma un messaggio per l'autorizzazione in\\nil gateway Web3 IPFS per scaricare tutti i video. Come risultato, otterrai tutti i video registrati dalla tua smart home.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nPoiché tutti i video nella cartella sono criptati con la chiave del controller, è necessario inserirla per decrittare i video.\\nDopo ciò, il pulsante di riproduzione del video viene attivato. Cliccaci sopra per scaricare il video.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"3a6a38510ddc316a48cf639259646cf7\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/it/robonomics-prometheus-grafana/\",\"content\":\"\\n**L'istruzione seguente è fornita da [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**L'articolo originale si trova [qui](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Introduzione\\nPer monitorare e mantenere meglio il/i nodo/i Robonomics, è bene configurare un monitoraggio basato su Prometheus Server e Grafana. Questo documento mostrerà come configurare ciascuno di essi per monitorare completamente il tuo nodo.\\n\\n##  Prerequisiti\\n* [Configurazione del server con Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Collator parachain Robonomics installato](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Assicurati che robonomics.service funzioni sulla tua macchina e che la porta 9615 sia raggiungibile \\n\\n## Passo 1 - Creazione degli utenti di servizio\\n\\nPer motivi di sicurezza, inizieremo creando due nuovi account utente, prometheus e node_exporter. Crea questi due utenti e utilizza le opzioni _--no-create-home_ e _--shell /bin/false_ in modo che questi utenti non possano accedere al server.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nPrima di scaricare i binari di Prometheus, crea le directory necessarie per archiviare i file e i dati di Prometheus. Seguendo le convenzioni standard di Linux, creeremo una directory in _/etc_ per i file di configurazione di Prometheus e una directory in _/var/lib_ per i suoi dati.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nOra, imposta la proprietà dell'utente e del gruppo sulle nuove directory per l'utente prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Passo 2 - Download di Prometheus\\n\\nInnanzitutto, scarica e decomprimi la versione stabile corrente di Prometheus nella tua directory home. Puoi trovare gli ultimi binari sulla [pagina di download di Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nOra, decomprimi l'archivio scaricato.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nQuesto creerà una directory chiamata prometheus-2.21.0.linux-amd64 contenente due file binari (prometheus e promtool), le directory _consoles_ e _console_libraries_ contenenti i file dell'interfaccia web, una licenza, un avviso e diversi file di esempio.\\n\\nCopia i due binari nella directory _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nImposta la proprietà dell'utente e del gruppo sui binari per l'utente prometheus creato nel Passo 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nCopia le directory consoles e _console_libraries_ in _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nImposta la proprietà dell'utente e del gruppo sulle directory per l'utente prometheus. Utilizzando l'opzione -R garantirai che la proprietà venga impostata anche sui file all'interno della directory.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nOra che Prometheus è installato, creeremo i suoi file di configurazione e di servizio in preparazione del suo primo avvio.\\n\\n## Passo 3 - Configurazione di Prometheus\\n\\nNella directory _/etc/prometheus_, utilizza nano o il tuo editor di testo preferito per creare un file di configurazione chiamato _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nNelle impostazioni globali, definisci l'intervallo predefinito per il recupero delle metriche. Nota che Prometheus applicherà queste impostazioni a ogni esportatore a meno che le impostazioni proprie dell'esportatore stesso non sovrascrivano le impostazioni globali.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nQuesto valore di scrape_interval indica a Prometheus di raccogliere le metriche dai suoi esportatori ogni 15 secondi, che è sufficientemente lungo per la maggior parte degli esportatori.\\nOra, aggiungi Prometheus stesso all'elenco degli esportatori da cui effettuare il recupero con la seguente direttiva scrape_configs:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus utilizza il _job_name_ per etichettare gli esportatori nelle query e sui grafici, quindi assicurati di scegliere qualcosa di descrittivo qui.\\n\\nE poiché Prometheus esporta dati importanti su se stesso che puoi utilizzare per monitorare le prestazioni e il debug, abbiamo sovrascritto la direttiva globale scrape_interval da 15 secondi a 5 secondi per aggiornamenti più frequenti.\\n\\nInfine, Prometheus utilizza le direttive _static_configs_ e _targets_ per determinare dove vengono eseguiti gli esportatori. Poiché questo particolare esportatore viene eseguito sullo stesso server di Prometheus stesso, possiamo utilizzare localhost invece di un indirizzo IP insieme alla porta predefinita, 9090.\\n\\nIl tuo file di configurazione dovrebbe ora apparire così:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nSalva il file ed esci dal tuo editor di testo.\\n\\nOra, imposta la proprietà dell'utente e del gruppo sul file di configurazione per l'utente prometheus creato nel Passo 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nCon la configurazione completata, siamo pronti per testare Prometheus eseguendolo per la prima volta.\\n\\n## Passo 4 - Esecuzione di Prometheus\\n\\nAvvia Prometheus come utente _prometheus_, fornendo il percorso sia al file di configurazione che alla directory dei dati.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nL'output contiene informazioni sul progresso di caricamento di Prometheus, il file di configurazione e i servizi correlati. Conferma anche che Prometheus è in ascolto sulla porta _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nSe ricevi un messaggio di errore, controlla due volte di aver utilizzato la sintassi YAML nel tuo file di configurazione e segui le istruzioni visualizzate per risolvere il problema.\\n\\nOra, interrompi Prometheus premendo _CTRL+C_, e poi apri un nuovo file di servizio _systemd_.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nIl file di servizio dice a _systemd_ di eseguire Prometheus come utente prometheus, con il file di configurazione situato nella directory _/etc/prometheus/prometheus.yml_ e di memorizzare i dati nella directory _/var/lib/prometheus_. Copia il seguente contenuto nel file:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nInfine, salva il file e chiudi il tuo editor di testo. Per utilizzare il servizio appena creato, ricarica systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nOra puoi avviare Prometheus utilizzando il seguente comando:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nPer assicurarti che Prometheus sia in esecuzione, controlla lo stato del servizio.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nL'output ti indica lo stato di Prometheus, l'identificatore del processo principale (PID), l'utilizzo della memoria e altro ancora.\\n\\nSe lo stato del servizio non è attivo, segui le istruzioni visualizzate e ripercorri i passaggi precedenti per risolvere il problema prima di continuare il tutorial.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nQuando sei pronto per passare avanti, premi _Q_ per uscire dal comando di stato. Infine, abilita il servizio per l'avvio automatico.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nOra che Prometheus è in esecuzione, possiamo installare un exporter aggiuntivo per generare metriche sulle risorse del nostro server.\\n\\n## Passaggio 5 — Download di Node Exporter\\n\\nPer espandere Prometheus oltre le sole metriche su se stesso, installeremo un exporter aggiuntivo chiamato Node Exporter. Node Exporter fornisce informazioni dettagliate sul sistema, inclusi l'utilizzo della CPU, del disco e della memoria. Scarica la versione stabile più recente di Node Exporter nella tua directory home. Puoi trovare le ultime versioni binarie sulla [pagina di download di Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nOra, decomprimi l'archivio scaricato.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nQuesto creerà una directory chiamata _node_exporter-1.0.1.linux-amd64_ contenente un file binario chiamato _node_exporter_, una licenza e una nota.\\n\\nCopia il binario nella directory _/usr/local/bin_ e imposta l'utente e il gruppo di proprietà sull'utente node_exporter che hai creato nel Passaggio 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nOra che hai installato Node Exporter, testiamolo eseguendolo prima di creare un file di servizio in modo che parta all'avvio.\\n\\n## Passaggio 6 — Esecuzione di Node Exporter\\n\\nI passaggi per l'esecuzione di Node Exporter sono simili a quelli per l'esecuzione di Prometheus stesso. Inizia creando il file di servizio Systemd per Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nCopia il seguente contenuto nel file di servizio:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nSalva il file e chiudi il tuo editor di testo. Infine, ricarica systemd per utilizzare il servizio appena creato.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nOra puoi eseguire Node Exporter utilizzando il seguente comando:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nVerifica that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nCome prima, questo output ti indica lo stato di Node Exporter, l'identificatore del processo principale (PID), l'utilizzo della memoria e altro ancora. Se lo stato del servizio non è attivo, segui i messaggi visualizzati e ripercorri i passaggi precedenti per risolvere il problema prima di continuare.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nInfine, abilita Node Exporter per l'avvio automatico.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nCon Node Exporter completamente configurato e in esecuzione come previsto, diremo a Prometheus di iniziare a raccogliere le nuove metriche.\\n\\n## Passaggio 7 — Configurazione di Prometheus per raccogliere Node Exporter\\n\\nPoiché Prometheus raccoglie solo exporter definiti nella sezione scrape_configs del suo file di configurazione, dovremo aggiungere una voce per Node Exporter, proprio come abbiamo fatto per Prometheus stesso. Apri il file di configurazione.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nAlla fine del blocco scrape_configs, aggiungi una nuova voce chiamata node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nPoiché questo exporter viene eseguito anche sullo stesso server di Prometheus stesso, possiamo utilizzare localhost invece di un indirizzo IP insieme alla porta predefinita di Node Exporter, 9100. L'intero file di configurazione dovrebbe apparire così:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nSalva il file ed esci dal tuo editor di testo quando sei pronto a continuare. Infine, riavvia Prometheus per mettere in atto le modifiche.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nAncora una volta, verifica che tutto funzioni correttamente con il comando di stato.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nSe lo stato del servizio non è impostato su attivo, segui le istruzioni visualizzate e ripercorri i passaggi precedenti prima di procedere.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nOra abbiamo installato, configurato ed eseguito Prometheus e Node Exporter.\\n\\n## Passaggio 8 - Aggiunta di Robonomic build in node_exporter\\n\\nDopo aver installato correttamente Prometheus e node_exporter, dovremo utilizzare l'exporter integrato di Prometheus in ogni progetto di substrato. Per fare ciò, dobbiamo aggiungere una voce aggiuntiva a _/etc/prometheus/prometheus.yml_. \\nApri il file di configurazione.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nAlla fine del blocco scrape_configs, aggiungi una nuova voce chiamata robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nSalva il file ed esci dal tuo editor di testo. L'intero file di configurazione dovrebbe apparire così:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nInfine, riavvia Prometheus per rendere effettive le modifiche.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nAncora una volta, verifica che tutto funzioni correttamente con il comando di stato.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nOra abbiamo Prometheus, Node Exporter e Robonomic Exporter installati, configurati e in esecuzione. Ora passa a Grafana.\\n\\n## Passo 9 - Configurazione di Grafana\\n\\nUltimo passo: collegare Prometheus come origine dati in Grafana. Per questo tutorial utilizzeremo una versione cloud gratuita di Grafana che consente di avere fino a 5 dashboard e una dashboard dedicata a Robonomics. Vai semplicemente su grafana.com, crea un nuovo account e accedi alla tua istanza di Grafana appena creata.\\n\\nAll'inizio dobbiamo aggiungere a Grafana una nuova **origine dati** che nel nostro caso sarà il server Prometheus.\\nVai su Origine dati:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nQuindi clicca su **Aggiungi origine dati**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext seleziona _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nNella nuova schermata inserisci l'**indirizzo IP del server Prometheus con la porta 9090**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nDopo di che, clicca su **Salva e testa**. Se hai seguito tutti i passaggi, dovresti vedere il colore verde e essere pronto per importare la dashboard. Sulla pagina principale clicca su **+** e poi su **Importa** come mostrato nell'immagine qui sotto:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nSuccessivamente dovresti vedere la pagina di importazione:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nNel campo _URL o ID della dashboard di Grafana.com_ scrivi **13015** (questo è l'ID della dashboard di Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nDopo aver caricato la dashboard esterna, vedrai questa schermata:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nL'ultimo passo è scegliere la **Origine dati** precedentemente creata e cliccare su **Importa**\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nEcco fatto! A questo punto dovresti vedere la dashboard importata. \\n\\n\\n## Riferimenti\\n\\n* [Come installare Prometheus su Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Creare una dashboard di monitoraggio con Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Supporto di Grafana per Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Monitoraggio delle metriche di un host Linux con il node exporter](https://prometheus.io/docs/guides/node-exporter/)\\n* [Interrogare Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Visualizzare le metriche del nodo](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Exporter di Prometheus per Substrate](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Metriche del nodo Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [Node Exporter per Prometheus Dashboard](https://grafana.com/grafana/dashboards/11074)\\n* [Metriche ROBONOMICS (XRT) di Grafana](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"2edfa83c7ed0b41ec678842cbf0bbedd\",\"title\":\"Panoramica di Robonomics Smart Home\",\"path\":\"/docs/it/robonomics-smart-home-overview/\",\"content\":\"\\n## IoT sicuro con Blockchain \\n\\nPer la tua smart home, il moderno mercato IoT offre una vasta gamma di soluzioni. Ma di solito sei legato a fornitori di cloud centralizzati o costosi gateway proprietari. Di conseguenza, come utente sei sempre dipendente dal fornitore di hardware e infrastrutture per gestire il tuo sistema smart. Allo stesso tempo, la tua smart home non può essere veramente intelligente senza statistiche e analisi cloud.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Vediamo due problemi principali con le attuali smart home:**\\n\\n1. Non hai controllo su quali dati condividi con il fornitore o terze parti.\\n2. La tua smart home è vulnerabile a chiusure dei server cloud centralizzati. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nPer risolvere entrambi i problemi, ti suggeriamo di provare Robonomics, il nostro cloud decentralizzato **sicuro**, **senza server** e **futuristico**.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Passaggi per un cloud senza aziende\\n\\nEcco alcuni semplici passaggi per creare una smart home conveniente utilizzando Home Assistant come applicazione di comunicazione dei dispositivi e Robonomics come piattaforma cloud decentralizzata senza aziende. Robonomics sfrutta tecnologie Web3 moderne e sicure, garantendo una maggiore sicurezza durante tutto il processo..\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Inizia qui la tua smart home\\n\\nAbbiamo preparato guide dettagliate per configurare una smart home su Robonomics. I passaggi possono variare a seconda della tua situazione specifica: se hai già un Home Assistant operativo con dispositivi abbinati, o se stai partendo da zero per creare la tua smart home.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/it/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/it/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"3df6af4f428a9d40e9f44099b028adf2\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/it/robonomics-opengov/\",\"content\":\"\\n## Introduzione\\n\\nRobonomics ha spostato il modello di governance della parachain al sofisticato meccanismo OpenGov di Polkadot che consente alla catena di evolversi nel tempo, secondo la volontà dei detentori di token.\\nLa transizione di Robonomics verso OpenGov garantisce che il DAO dei detentori di token, che controlla la maggioranza delle quote, possa sempre comandare la direzione della parachain di Robonomics, attuando qualsiasi modifica alla rete che ritengano opportuna.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov si applica solo alla Robonomics Parachain, che è una catena basata su Substrate collegata alla Kusama Relay Chain. OpenGov non è applicabile all'implementazione di Robonomics Ethereum, poiché la mainnet di Ethereum attualmente non supporta sistemi di governance sofisticati come OpenGov.\\n</robo-wiki-note>\\n\\nOpenGov cambia il modo in cui vengono effettuate le operazioni quotidiane e le decisioni sulla parachain. Fornisce una maggiore chiarezza sulla portata dei referendum e ha il potenziale per aumentare drasticamente la velocità delle decisioni prese sulla parachain.\\n\\nOpenGov è stato attivo sulla Kusama relay chain per alcuni mesi al momento della stesura, e ha dimostrato di aumentare notevolmente il numero di decisioni (referendum individuali e discreti) che il DAO dei detentori di token può proporre, votare e, attraverso il voto, controllare in ultima analisi la direzione del protocollo.\\n\\n**Il contenuto seguente contenuto in questa sezione del wiki illustrerà i principi fondamentali di OpenGov sulla parachain di Robonomics e mira ad aiutarti a comprendere meglio i concetti alla base di OpenGov.**\\n\\n*È importante notare che la governance è un meccanismo in continua evoluzione nel protocollo, soprattutto nelle prime fasi di implementazione.*\\n\\nPer coloro interessati esclusivamente ai parametri di traccia di Robonomics OpenGov, vedere [qui](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## Informazioni sui referendum\\n\\nI referendum sono schemi di voto semplici, inclusivi e basati sulle quote. Ogni referendum ha una proposta specifica associata ad esso che assume la forma di una chiamata di funzione privilegiata nell'esecuzione della catena. Questo può includere anche la chiamata più potente `set_code``, che ha la capacità di sostituire l'intero codice del runtime delle catene: questo è unico per le catene basate su Substrato e rimuove il requisito di un \\\"hard fork\\\" della catena durante l'aggiornamento della logica di business delle catene ( tempo di esecuzione).\\n\\nI referendum sono eventi discreti che hanno un periodo di voto fisso (ulteriori informazioni sui diversi periodi durante il ciclo di vita di un referendum in seguito). I detentori di token individuali possono votare in tre modi diversi sui referendum: AYE (d'accordo/sì), NAY (disaccordo/no) o ASTENERSI dal voto completamente.\\n\\nTutti i referendum hanno un ritardo di attuazione associato. Questo è il periodo tra la fine del referendum e, assumendo che il referendum sia stato approvato, l'attuazione dei cambiamenti sulla rete. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Esiste un periodo di attuazione minimo specificamente stabilito per ogni tipo di Origine diverso, ma l'originatore di un determinato referendum può impostare le attività specifiche di quel referendum per essere eseguite molti blocchi nel futuro\\n\\n</robo-wiki-note>\\n\\nI referendum sono considerati \\\"cotti\\\" se sono chiusi e i voti sono conteggiati. Presumendo che il referendum sia stato approvato, verrà pianificato per l'attuazione (nel programma della catena). I referendum sono considerati \\\"non cotti\\\" se l'esito è in sospeso, ad esempio se il referendum è ancora in corso di votazione.\\n\\nCon l'aggiunta di OpenGov, chiunque può avviare un referendum in qualsiasi momento e può farlo quante volte desidera. OpenGov rimuove il limite di poter elaborare solo 1 referendum alla volta (si noti che, in Gov v1, è possibile votare solo su 1 referendum alla volta. L'unica eccezione è un referendum di emergenza aggiuntivo da parte del Comitato Tecnico accelerato che può essere votato contemporaneamente dalla comunità).\\n\\nOpenGov introduce diverse nuove funzionalità/concetti noti come Origini e Tracce, e questi sono introdotti per aiutare nel flusso e nell'elaborazione dei referendum nel protocollo.\\n\\nOgni Origine è associata a una singola classe di referendum e ogni classe è associata a una traccia. La traccia delinea il ciclo di vita del referendum ed è specifica per quella particolare Origine da cui il referendum ha origine. Avere tracce con i propri parametri specifici consente alla rete di modificare dinamicamente il ciclo di vita dei referendum in base al loro livello di privilegio (si può pensare al livello di privilegio come al potere di un referendum / ai tipi di modifiche che può apportare al protocollo).\\n\\n*Pensate alle Origini come al potere associato a un referendum e pensate alle Tracce come ai parametri di voto associati a un referendum, come la durata dei suoi periodi e i criteri di approvazione e supporto.*\\n\\nAd esempio, un aggiornamento del runtime non ha le stesse implicazioni per il protocollo come un piccolo suggerimento del tesoro, e quindi sono necessarie origini diverse in cui saranno predefiniti i turni, le approvazioni, i depositi e i periodi di attuazione specifici dei referendum (Tracce) nella pallet della catena.\\n\\n## Proposta di un Referendum e Ciclo di Vita del Referendum \\n\\n### Periodo di Preparazione\\n\\nIn OpenGov, quando un referendum viene creato inizialmente, può essere immediatamente votato dalla comunità dei detentori di token. Tuttavia, non è immediatamente in uno stato in cui può terminare o avere i suoi voti conteggiati, essere approvato e attuato sommariamente. Invece, i referendum devono soddisfare una serie di criteri prima di essere spostati nel Periodo Decisionale. Fino a quando i referendum non entrano nel Periodo Decisionale, rimarranno indecisi - e alla fine scadranno dopo il periodo di ciclo di vita complessivo specificato nella traccia individuale.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nI criteri per un referendum per entrare nel Periodo Decisionale sono i seguenti:\\n1. Un Periodo di Preparazione che indica la quantità di tempo che deve trascorrere prima che possa iniziare il Periodo Decisionale. Questo Periodo di Preparazione aiuta a mitigare la possibilità di \\\"decision sniping\\\" in cui un attaccante che controlla una quantità considerevole di potere di voto potrebbe cercare di utilizzare la propria grande quota per far approvare immediatamente un referendum dopo la proposta, eludendo la possibilità per gli altri membri del DAO detentori di token di avere il tempo adeguato per considerare il referendum e partecipare al voto. Ecco perché le Origini con livelli di privilegio più elevati hanno Periodi di Preparazione significativamente più lunghi.\\n\\n2. Deve esserci spazio per la decisione. Ogni traccia ha i propri limiti per la quantità di referendum che possono essere decisi contemporaneamente (max_deciding). Le tracce che hanno livelli di privilegio più elevati avranno limiti inferiori. Ad esempio, l'origine di livello Root avrà un numero significativamente inferiore di referendum che possono essere decisi contemporaneamente rispetto alle origini di livello di privilegio inferiore come l'origine Small Tipper.\\n\\n3. Il Deposito Decisionale deve essere presentato. Inizialmente la creazione di un referendum è piuttosto economica e il valore del Deposito di Presentazione (riservato quando il referendum viene creato inizialmente) è piuttosto basso e consiste principalmente del valore che costa per lo storage on-chain associato al referendum. I Depositi Decisionali sono significativamente più alti, il che è richiesto per contrastare lo spam e gioca nel gioco economico che OpenGov porta, che affronteremo in seguito.\\n\\nUna volta soddisfatti tutti e tre i criteri sopra indicati, il referendum passerà al Periodo Decisionale. I voti sul referendum verranno quindi conteggiati per il risultato.\\n\\n### Periodo Decisionale\\n\\n*Per una rapida dimostrazione video del Periodo Decisionale, guarda [questo video](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nUna volta che un referendum ha soddisfatto tutti i criteri come dettagliato nella sezione precedente, entrerà nel Periodo Decisionale.\\n\\nIl Periodo Decisionale ruota attorno a due concetti principali, ovvero i criteri di Approvazione e Supporto. \\n\\nL'Approvazione è definita come la quota del peso del voto di approvazione (AYEs vs NAYs) rispetto al peso totale del voto (tutti i voti AYE e NAY combinati). La convinzione di ogni voto contribuisce al peso complessivo dei voti AYE/NAY (ulteriori informazioni sulla votazione per convinzione / blocco volontario in una sezione successiva).\\n\\nIl Supporto è il numero totale di voti (token) che hanno partecipato al referendum (e non viene regolato per la convinzione) rispetto al totale dei voti possibili che potrebbero essere effettuati nel sistema (pensa a questo come all'emissione totale di XRT sulla parachain - notare che l'offerta circolante totale di XRT non è il fattore principale qui, a causa del fatto che una parte di quel numero esiste su Ethereum come token ERC-20).\\n\\n**I voti che sono nella direzione ABSTAIN NON contribuiscono ai criteri di Approvazione, ma sono inclusi / conteggiati verso i criteri di Supporto**\\n\\nUn referendum deve soddisfare i criteri di Supporto E Approvazione durante il Periodo Decisionale per progredire al Periodo di Conferma.\\n\\nPer i dettagli dei criteri di Supporto e Approvazione individuali per ogni traccia, consulta questo [foglio di calcolo](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Periodo di Conferma\\n\\nOgni traccia ha una durata specifica per il suo Periodo di Conferma. Le tracce che hanno livelli di privilegio più elevati (come Root) hanno Periodi di Conferma significativamente più lunghi rispetto a quelli con livelli di privilegio inferiori (come Small Tipper).\\n\\nI referendum devono continuare a soddisfare i criteri di Approvazione e Supporto per l'intera durata del Periodo di Conferma, altrimenti torneranno nuovamente nel Periodo Decisionale (nota: il Periodo Decisionale non viene messo in pausa durante il Periodo di Conferma, quindi è del tutto possibile che un Periodo Decisionale possa scadere durante il Periodo di Conferma, il che significa che se un referendum viene escluso dal Periodo di Conferma perché non soddisfa più i criteri di Approvazione e Supporto, sarà considerato un referendum fallito e non promulgato).\\n\\n**È possibile modificare i criteri di approvazione e supporto per i singoli brani tramite un referendum con privilegi di Root Origin.**\\n\\nLe origini con livelli di privilegio inferiori hanno criteri di approvazione e supporto molto più semplici (impostati dal percorso) da soddisfare rispetto a quelle con livelli di privilegio più elevati. Allo stesso modo, le origini con livelli di privilegio più elevati hanno curve meno ripide rispetto a quelle con meno privilegi (come definito nel tracciato), al fine di garantire che il detentore del token DAO approvi effettivamente il referendum ed evitare azioni referendarie per referendum sulle origini con privilegi elevati.\\n\\nIn OpenGov, i referendum che non vengono approvati dopo la scadenza del periodo decisionale sono considerati respinti per impostazione predefinita e sia il deposito per la presentazione che quello per la decisione vengono rimborsati ai loro originatori (nota: il deposito per la decisione può essere inviato da qualcuno diverso dall'originatore del referendum) .\\n\\nSe un referendum riesce a soddisfare costantemente i criteri di approvazione e sostegno per l'intero periodo di conferma, allora è considerato approvato e l'esecuzione verrà pianificata a partire dall'origine proposta, ma il referendum verrà eseguito solo dopo che è trascorso il periodo minimo di attuazione.\\n\\n### Periodo di emanazione\\n\\nIl Periodo di Emanazione è specificato dall'originatore al momento della proposta del referendum, ma è soggetto al Periodo Minimo di Emanazione specificato in ciascun brano. Le Origini più potenti hanno un periodo minimo di attuazione molto più elevato rispetto a quelle con minori privilegi. Ciò garantisce che la rete abbia tutto il tempo per prepararsi a eventuali cambiamenti che un potente referendum potrebbe imporre.\\n\\n## Blocco/Condanna volontaria\\n\\nLa Robonomics utilizza un concetto noto come blocco volontario o voto per convinzione. Ciò consente ai possessori di token di aumentare il proprio potere di voto decidendo per quanto tempo sono disposti a bloccare i propri token per un particolare referendum. Questo meccanismo influisce solo sui criteri di approvazione per ciascun referendum e il voto di convinzione non influisce sui criteri di sostegno.\\n\\nIl voto di convinzione può essere calcolato utilizzando questa formula:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nQuesta tabella mostra come ogni livello crescente di periodo di blocco moltiplica il tuo voto per i criteri di approvazione:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nL'importo massimo di convinzione che un detentore di token può utilizzare è 6x convinzione. Puoi impostare la convinzione solo secondo la tabella sopra e non puoi, ad esempio, utilizzare la convinzione 5,5x.\\n\\nMentre un token è bloccato a causa del voto, può comunque essere utilizzato per votare in altri referendum, tuttavia, non farà parte del tuo saldo trasferibile (non puoi inviarlo a un altro account) - e il saldo diventerà di nuovo trasferibile solo una volta l'intero periodo di blocco è scaduto.\\n\\n## Delegazione di voto\\n\\nIn OpenGov è stato aggiunto un meccanismo per consentire ai detentori di token che non hanno necessariamente abbastanza tempo per rivedere ogni referendum di continuare a utilizzare i propri token come parte del sistema di governance, questa è nota come delega di voto.\\n\\nI possessori di token possono scegliere di delegare il proprio potere di voto a un altro elettore nel sistema (un altro account). Gli elettori possono specificare di delegare il proprio potere di voto in modo agile, consentendo loro di assegnare il proprio potere di voto a un conto diverso per ogni singola Origine. Gli elettori possono anche impostare l'assegnazione di una quantità diversa di potere di voto per ciascuna Origine (numero di token e livello di convinzione).\\n\\nQuesta funzionalità di delega ha un obiettivo: aumentare l'affluenza alle urne e contribuire a garantire che l'affluenza alle urne richiesta per soddisfare i criteri di approvazione e supporto sia soddisfatta.\\n\\nPer delegare il tuo potere di voto puoi utilizzare la funzione \\\"Delega\\\" che puoi trovare nella sezione Governance -> Referendum del [Portale Robonomics](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). In alternativa, gli utenti possono inviare la convinzione Voto(Delega) estrinseca utilizzando la sezione Sviluppatore -> Estrinseci del Portale Robonomics, tuttavia utilizzare la funzione \\\"Delega\\\" della sezione Referendum del portale è molto più semplice.\\n\\n## Annullare/uccidere il referendum e il gioco economico della governance\\n\\nIn OpenGov ci sono Origins che si impegnano a respingere i referendum in corso, indipendentemente dal loro status. Questi sono conosciuti come percorsi Governance Canceller e Governance Killer.\\n\\nQueste Origini intervengono su un referendum già votato. Queste Origini, se il referendum da loro originato viene approvato, rifiuteranno immediatamente un referendum in corso indipendentemente dal suo status.\\n\\nLa cancellazione stessa è un tipo di referendum su cui devono essere votati i possessori di token per poter essere eseguito. La cancellazione arriva con la propria origine e traccia che hanno un lead time inferiore (periodo di decisione, ecc.) e hanno curve di approvazione e supporto con una curva più ripida/severa (il che significa che i loro criteri sono molto più facili da soddisfare nel tempo) rispetto ad altre origini. Ciò è dovuto al fatto che l’annullamento di un referendum di solito avviene con un senso di urgenza.\\n\\nGovernance Canceller mira a respingere immediatamente un referendum già in corso. Quando un referendum viene annullato da questa origine, sia la presentazione che il deposito decisionale vengono rimborsati ai loro originatori. Un esempio di quando un referendum potrebbe essere considerato annullato è se l'autore ha commesso qualche errore umano nei contenuti del referendum e non ha necessariamente tentato di fare qualcosa di dannoso.\\n\\nGovernance Killer mira a respingere immediatamente un referendum già in corso. È qui che entra in gioco il gioco economico della governance. Le origini con elevati livelli di privilegio, come Root, hanno un deposito decisionale che richiede la pubblicazione di una quantità elevata di capitale (token XRT) affinché il referendum entri nel periodo decisionale.\\n\\nSe un attore malintenzionato presenta un referendum, ad esempio un referendum con origini Root che mira a \\\"set_code\\\" del runtime delle catene su qualcosa che impedirà alla catena di produrre blocchi, allora il detentore del token DAO può lanciare un referendum contro Governance Killer per punire questa azione. Se il referendum dannoso viene rifiutato tramite l’origine Governance Killer, sia i depositi di Sottomissione che quelli di Decisione verranno tagliati, il che significa che l’originatore (il conto o i conti che hanno registrato questi depositi) perderà quei fondi.\\n\\nCiò significa che il tentativo di indire un referendum comporta gravi conseguenze economiche per gli attori malintenzionati, che avrebbero gravi ripercussioni negative sulla catena, cosa che in teoria impedirà a qualsiasi attore malintenzionato di tentare di farlo.\\n\\nIl deposito decisionale per il percorso Killer della governance è di per sé piuttosto elevato, questo per impedire ad attori altrettanto dannosi di tentare di tagliare i depositi di un referendum altrimenti buono. **Un referendum killer della governance esistente può essere eliminato da un successivo referendum killer della governance.**\\n\\n## Comitato tecnico Robonomics e origine autorizzata\\n\\nQuesto gruppo è un organismo di esperti autogovernato che ha l'obiettivo primario di rappresentare gli esseri umani che incarnano e possiedono la conoscenza tecnica del protocollo di rete Robonomics. \\n\\nQuesto gruppo (e solo questo gruppo) è in grado di originare referendum dal pallet Whitelist. Questo pallet fa una cosa, consente a un'origine di aumentare il livello di privilegio di un'altra origine per una determinata operazione. \\n\\nQuesto gruppo può autorizzare referendum da un'origine nota come Whitelisted-Root e questi referendum possono essere eseguiti con privilegi a livello di root, ma questi referendum funzioneranno con successo solo con determinati comandi specificati che sono stati autorizzati dal gruppo. Il pallet Whitelist verifica due cose:\\n1. L'Origine è realmente la Radice della Whitelist (ovvero quel referendum è passato attraverso il percorso di questa Origine).\\n2. La proposta è stata effettivamente inserita nella lista bianca dal gruppo.\\n\\nSe entrambe le condizioni sono vere, l'operazione verrà eseguita con privilegi a livello di root.\\n\\nQuesto sistema consente la possibilità di avere una nuova traccia parallela (Whitelisted-Root Origin), i cui parametri consentono un turno di votazione più breve (i criteri di approvazione e supporto sono leggermente più facili da soddisfare rispetto a Root). Questo processo aperto e trasparente consente a questo corpo di esperti del Protocollo di Rete Robonomics di proporre referendum che hanno ritenuto sicuri e con tempi critici.\\n\\nVa notato che i criteri di supporto per il referendum avviato con l'origine Whitelisted-Root non tendono verso 0 come molte altre origini/tracce. Ciò garantisce che questo gruppo non abbia di fatto il controllo sull'intero protocollo di rete Robonomics e richieda un livello minimo di supporto (affluenza alle urne) da parte del DAO detentore del token complessivo.\\n\\n\\n## Durata del referendum\\n\\nÈ importante capire che la durata di ogni singolo referendum non è una cosa concreta, non è fissata nella pietra. Alcuni periodi all'interno del ciclo di vita del referendum, come il periodo minimo di attuazione, hanno tuttavia una durata concreta, altri, compreso il periodo decisionale, no. Ad esempio, non è accurato sommare le durate massime per Preparazione, Decisione, Conferma e Min. Periodi di promulgazione e affermare che \\\"ogni referendum richiederà un numero X di giorni\\\", è molto più fluido di così.\\n\\nGuardiamo la cosa attraverso la lente di alcuni referendum separati, che hanno tutti origine dalla stessa Origine, in questo caso, l'origine Radice.\\n\\nL'Origine Radice ha il proprio tracciato, dove vengono impostate le durate per ciascun periodo, così come le curve di Approvazione e Supporto.\\n\\nÈ importante ricordare che i referendum potranno passare alla fase successiva del loro ciclo di vita solo se verranno soddisfatte determinate condizioni.\\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nNelle immagini seguenti si dovrebbe presumere che, affinché un referendum possa ascendere alla fase successiva del suo ciclo di vita, le condizioni descritte nell'immagine sopra avrebbero dovuto essere soddisfatte (se non diversamente indicato).\\n\\n\\n### Massima durata possibile con pochissima affluenza alle urne\\n\\nL'immagine qui sotto è una rappresentazione della massima tempistica possibile per un referendum, consideralo come un referendum che:\\n1. Ha registrato il deposito della decisione e quindi è entrato nel periodo di decisione.\\n2. Ha un singolo voto, ad esempio 1 XRT, nella direzione AYE – ciò significa che incontrerà il sostegno richiesto (affluenza alle urne) solo alla fine del periodo decisionale (poiché il sostegno complessivo è estremamente basso) , ma ha l'approvazione al 100%, quindi alla fine soddisferà i requisiti per accedere al Periodo di conferma.\\n3. Continua a soddisfare i criteri di cui sopra durante il Periodo di Conferma.\\n4. La proposta sollevata dal referendum sarà attuata esattamente nello stesso blocco in cui scade il Periodo Minimo di Emanazione – tecnicamente l’autore del referendum può impostare le modifiche alla rete come dettagliato nel referendum per attuare molti blocchi nel futuro, quindi realisticamente l’effettivo Il ciclo di vita di un singolo referendum potrebbe estendersi su molti giorni, settimane, mesi o anni.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nPossiamo vedere che in questo esempio il ciclo di vita del referendum sarebbe (approssimativamente) di 17 giorni.\\n\\n\\n### Durata con molta affluenza alle urne (con un numero elevato di voti AYE)\\n\\nOra diamo un'occhiata a un referendum in cui DAO, detentore del token XRT, ha espresso molto interesse. In questo esempio, supponiamo che si siano verificati circa 248.771 XRT nell'affluenza alle urne complessiva e che tutti gli elettori stiano votando nella direzione AYE (nota: tecnicamente in questa fase di un referendum root, come da traccia, solo il 60% dei voti deve essere nella direzione dell'AYE per un referendum per soddisfare i criteri di approvazione).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n  Consulta sempre le informazioni più aggiornate sulla traccia per informazioni precise su ciascuna traccia. Maggiori informazioni possono essere trovate in questo [foglio di calcolo](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nIn questo esempio:\\n1. Il deposito decisionale è stato registrato durante il periodo di preparazione e pertanto è stato possibile passare al periodo di decisione alla fine del periodo di preparazione.\\n2. Molti elettori hanno votato su questo referendum, ottenendo un’affluenza alle urne di circa 248.771 XRT in un periodo di tempo relativamente breve.\\n3. I voti sono stati a maggioranza nella direzione AYE (qualsiasi cosa superiore al 60% AYE).\\n4. Il referendum soddisfa continuamente i criteri del Periodo di Conferma per tutto il suo Periodo di Conferma (Nota: Se un referendum si ferma per soddisfare i criteriof the Confirmation Period, then it is bumped back to it's Decision Period).\\n5. La proposta sollevata dal referendum entrerà in vigore esattamente nello stesso periodo in cui scade il Periodo Minimo di Attuazione.\\n\\nDato che c'è stata un'affluenza alle urne di circa 248.771 XRT, il referendum soddisferà i criteri per entrare nel suo periodo di conferma dopo circa 168 ore (7 giorni).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nPossiamo vedere che in questo secondo esempio, a causa del fatto che c'è stata una buona affluenza alle urne, il Periodo Decisionale si è effettivamente concluso a metà del tempo massimo assegnato. Il risultato è un referendum che può essere emanato in circa 10 giorni.\\n\\n\\n### Periodo in cui il deposito della decisione non viene mai pubblicato\\n\\nOra, diamo un'occhiata a un referendum che è stato avviato, ma il suo deposito decisionale non è mai stato pubblicato. Tali referendum si trovano in una sorta di stato di \\\"limbo\\\", dove il loro periodo di preparazione è terminato, ma poiché il deposito decisionale non è stato pubblicato, il referendum rimane nello \\\"stato di preparazione\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nPossiamo vedere che in questo terzo esempio, poiché il deposito decisionale non è mai stato pubblicato, il referendum in realtà non entrerà mai nel periodo decisionale, ma rimarrà nello \\\"Stato preparatorio\\\". Ciò significa che alla fine, se non viene mai inviato alcun deposito decisionale, il referendum scadrà una volta trascorso il tempo specificato nella costante timeOut del pallet.\\n\\nCiò è già accaduto a Kusama in precedenza, quando è stato pubblicato un referendum con origini Root, ma a causa degli elevati requisiti patrimoniali per pubblicare il deposito decisionale, il referendum non è mai entrato nelle ultime fasi del suo ciclo di vita. Tali referendum si concludono con la bandiera del “time out”.\\n\\n\\n### Durata in cui il deposito della decisione viene pubblicato in ritardo\\n\\nInfine, diamo un'occhiata a un esempio in cui il Deposito Decisionale non è stato depositato per un bel po' di tempo dopo l'inizio del referendum. Ciò è accaduto in precedenza a Kusama, dove è stato pubblicato un referendum con l'origine Root, ma l'originatore ha dovuto dedicare del tempo a trovare qualcuno con un importo elevato di capitale per depositare il deposito decisionale per suo conto.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nIn questo ultimo esempio, poiché il deposito decisionale è stato versato dopo la fine del periodo di preparazione, ma prima che il referendum scadesse, il ciclo di vita del referendum è in realtà molto più lungo del normale, poiché entra nel periodo decisionale dopo un periodo di tempo più lungo.\\n\\nÈ importante notare che il detentore del token DAO può votare AYE/NAY sui referendum che si trovano nel periodo di preparazione o bloccati nello \\\"Stato di preparazione\\\".\\n\"}},{\"node\":{\"id\":\"0be99629d4e1d339d91143453930244b\",\"title\":\"Configurazione dell'integrazione di Robonomics\",\"path\":\"/docs/it/robonomics-hass-integration/\",\"content\":\"\\n**In questo articolo, aggiungerai Robonomics a Home Assistant. Ciò consente a Home Assistant di registrare i datalog con dati crittografati su Robonomics Parachain e di ascoltare i comandi di avvio dal parachain per controllare i dispositivi intelligenti. L'integrazione utilizza IPFS per archiviare i dati e inviare gli hash IPFS alle funzioni di datalog o avvio.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Nell'interfaccia web di Home Assistant vai su `Settings` -> `Device & Services` e premi `ADD INTEGRATION`. Cerca `Robonomics`.\\n\\n2. Fai clic su Robonomics e compila la configurazione: \\n\\n- Aggiungi il seed dall'account `SUB_CONTROLLER` al seed dell'account del controller.\\n- Aggiungi l'indirizzo pubblico dell'account `SUB_OWNER` all'indirizzo del proprietario della sottoscrizione.\\n- Imposta l'intervallo di invio dei dati (di default è di 10 minuti).\\n- (Opzionale) Puoi aggiungere le credenziali per il servizio di pinning Pinata o un altro gateway personalizzato per diffondere i tuoi dati in modo più ampio sulla rete IPFS.\\n\\n3. Premi `SUBMIT` dopo aver completato la configurazione. Se hai compilato tutto correttamente, vedrai la finestra di successo.\\n\\nEcco tutto! Hai configurato completamente l'integrazione di Robonomics in Home Assistant. Ora puoi utilizzare tutti i \\nServizi Web di Robonomics. Per saperne di più su di essi, vai alla sezione [\\\"Utilizzo\\\"](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"2a28c1f20769c31f36f5b437a54bc3b7\",\"title\":\"Robonomics su Ethereum\",\"path\":\"/docs/it/robonomics-ethereum/\",\"content\":\"\\nTutte le informazioni su robonomics su Ethereum sono state spostate nel repository GitHub. Tutte le informazioni necessarie possono essere trovate qui: https://github.com/airalab/Robonomics_on_Ethereum_Wiki\"}},{\"node\":{\"id\":\"46eede1ef17623c978c75e004d2f4511\",\"title\":\"Interfaccia Python e Robonomics IO\",\"path\":\"/docs/it/rinterface/\",\"content\":\"\\n**Alcune estrinseche implementate nei pallet Robonomics sono difficili da inviare dall'app Polkadot. Inoltre, \\nè necessario interagire con questa funzionalità utilizzando linguaggi di programmazione. A questo scopo è stato sviluppato uno strumento Python semplice\\nchiamato [interfaccia-robonomics](https://github.com/Multi-Agent-io/robonomics-interface). È un wrapper gestito da Polkascan\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). Di seguito è riportata una breve descrizione di questo pacchetto\\ne alcuni link utili ed esempi. Inoltre, viene discusso lo strumento CLI.**\\n\\n## robonomics-interface\\n\\nDisponibile su [PyPi](https://pypi.org/project/robonomics-interface/) il pacchetto è pronto per il download e l'installazione.\\nÈ disponibile anche una documentazione dettagliata generata da docstring [documentazione](https://multi-agent-io.github.io/robonomics-interface/).\\n\\nTutto sommato, si tratta di uno strumento per sviluppatori che desiderano interagire con la blockchain Robonomics tramite strumenti di programmazione. Quasi \\ntutti i progetti Python del team Robonomics che interagiscono con la parachain utilizzano questa interfaccia.\\n\\n### Installazione\\n\\nIl processo di installazione richiede che l'utente abbia almeno Python 3.8 installato. Né `x86`, né `arm7`, né `arm8`\\narchitetture richiedono un processo di compilazione. Tutte le ruote sono costruite e pubblicate dai manutentori delle dipendenze.\\n\\n`pip` viene utilizzato come strumento di installazione:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Esempio di utilizzo\\n\\nL'idea principale è creare un'istanza di `Account` e poi usarla per creare istanze dedicate ai pallet.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  È anche possibile utilizzare endpoint personalizzati (ad esempio un nodo locale per i test):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nÈ anche possibile inviare estrinseche:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Come detto, sono disponibili ulteriori esempi nella [documentazione](https://multi-agent-io.github.io/robonomics-interface/).\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` contiene anche strumenti CLI Python `click` da utilizzare per scopi di prototipazione e test rapidi. Viene installato\\ncon il pacchetto ed è disponibile nel Terminale:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nPuoi provare a usarlo con un nodo locale. Viene adottata la filosofia del pipeline:\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"ba501564af5586e3092ae5cf5f7eabc8\",\"title\":\"Controllo telecamera PTZ in Home Assistant\",\"path\":\"/docs/it/ptz-camera/\",\"content\":\"\\nQuesto articolo copre il processo di configurazione di una telecamera PTZ in Home Assistant. \\nVerrà utilizzato il protocollo ONVIF. Ciò richiede un account locale della telecamera.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nLa procedura per configurare l'account locale della telecamera non è coperta da questo articolo.\\n</robo-wiki-note>\\n\\nRequisiti:\\n- Telecamera PTZ\\n- Account locale della telecamera\\n- Indirizzo IP della telecamera\\n- Home Assistant configurato\\n\\n## Integrazione ONVIF\\n\\nIniziamo con l'installazione dell'integrazione **ONVIF**. \\n\\nVai su \\\"Devices & Services\\\" in \\\"Settings\\\" e premi il pulsante \\\"ADD INTEGRATION\\\".\\nDigita \\\"ONVIF\\\" e scegli l'integrazione. Vedrai la finestra successiva.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nPremi il pulsante \\\"Submit\\\". Proverà a cercare automaticamente la tua telecamera. Se avrà successo, \\nscegli la tua telecamera dalla lista e compila i campi vuoti. \\nIn caso contrario, dovrai compilare manualmente tutti i campi. Vedrai la seguente finestra.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nCompila gli spazi vuoti:\\n- Name - dai un nome alla tua telecamera\\n- Host - fornisci l'indirizzo IP della tua telecamera\\n- Port - di solito è comune nel 2020, ma il tuo fornitore di telecamere potrebbe cambiarlo\\n- Username - scrivi un nome utente dell'account locale della tua telecamera\\n  - Password - scrivi una password per l'account locale della tua telecamera\\n\\ne premi \\\"Submit\\\". Scegli un'area per la tua telecamera e clicca su \\\"Finish\\\".\\n\\n## Aggiungi il controllo della telecamera al cruscotto\\n\\nOra che hai configurato completamente la telecamera, puoi aggiungere il suo flusso e i pulsanti di controllo al cruscotto.\\n\\nVai al cruscotto e inizia creando una nuova scheda. Scegli quella di \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nCompila i dati:\\n- Title - scegli il titolo dell'immagine della telecamera\\n- Camera Entity - scegli un'entità della telecamera dal menu a discesa\\n- Camera View - scegli \\\"live\\\" per avere meno ritardo\\n\\nSuccessivamente, passa alla modalità \\\"Code Editor\\\" premendo il pulsante in basso a sinistra. Vedrai il seguente codice:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nSostituisci il contenuto di `entities: []` secondo l'esempio sottostante (`<YOUR_CAMERA_ENTITY>` è lo stesso del parametro `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nQuesto è tutto. Ora dovresti vedere la scheda della telecamera PTZ sul cruscotto insieme ai pulsanti di controllo.\\n\\n## Risoluzione dei problemi\\nSe stai usando Home Assistant Core e non vedi uno stream dalla telecamera, dovresti installare le integrazioni \\\"stream\\\" e \\\"FFMPEG\\\". \\nPer fare ciò, devi aggiungere le stringhe `stream: ` e `ffmpeg: ` alla fine di configuration.yaml.\"}},{\"node\":{\"id\":\"09b2d68aed18fdf75f046b9b6b77e540\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/it/notifications/\",\"content\":\"\\nPuoi ricevere notifiche sul tuo smartphone con [notify](https://notify.events/). Registrati prima lì e su `Control Panel` crea un nuovo canale:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nAggiungi un titolo e premi `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nQuindi premi `Add Source` e scegli `Home Assistant` nella scheda `IoT e Smart Home`:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nScrivi un titolo e premi `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nLì vedrai il token che devi aggiungere al tuo file di configurazione per Home Assistant. Salvalo da qualche parte e premi `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\npoi premi `Subscribe` per aggiungere abbonati:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nScegli qualsiasi abbonato desideri e segui le istruzioni.\\n\\nOra devi modificare la configurazione sul tuo computer con Home Assistant. Con l'utente `homeassistant` apri il file `configuration.yaml`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nE aggiungi queste righe:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nAggiungi anche una nuova automazione dopo la riga `automazione:`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nQuesta automazione invierà il messaggio `Door was changed to on/off` dopo che il sensore con ID entità `binary_sensor.contact_sensor_contact` cambia stato da `off` a `on`.\\n\\nE riavvia Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"8fe9246f9ca32f625ccd20130cd04350\",\"title\":\"Responsabilità\",\"path\":\"/docs/it/liability/\",\"content\":\"\\n**Per trasformare i robot in agenti economici è necessario uno strumento contrattuale per questo. Incontra Liability - Robonomics pallet che implementa contratti tra account parachain!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Si prega di prestare attenzione al fatto che questo tutorial viene dimostrato su un'istanza locale di Robonomics Node. Configura la tua con [queste istruzioni](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Panoramica della teoria\\n\\nTornando all'Ethereum c'era una struttura abbastanza complicata di interazione di responsabilità. Puoi conoscerla [qui](/docs/robonomics-how-it-works). Oggi le cose sono un po' più facili con Kusama!\\n\\n### Negoziazioni\\n\\nPer firmare un contratto le due parti devono prima negoziare. Questa operazione può essere eseguita in diversi modi, tra cui [IPFS PubSub](https://blog.ipfs.tech/25-pubsub/) o Robonomics PubSub. Un esempio di codice Python che utilizza Robonomics PubSub è\\npresentato [qui](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub). \\n\\nOfferta e domanda sono messaggi che contengono due caratteristiche principali di un contratto: **descrizione del lavoro** e **prezzo**. Il formato del messaggio deve essere progettato dall'utente per ogni applicazione specifica. Non è così importante nel processo di negoziazione seguire una regola di formato rigorosa. Il flusso possibile è presentato nell'immagine qui sotto.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Si noti che PubSub è un protocollo aperto, quindi non dovrebbero essere trasferiti dati sensibili. Per questo è necessario utilizzare altri protocolli.\\n\\n</robo-wiki-note>\\n\\n\\n### Firme\\n\\nUna volta che i negoziati si sono conclusi con successo, ciascuna parte deve firmare il cosiddetto accordo denominato firma. Questo è un messaggio contenente la descrizione del lavoro e il prezzo **in un formato specifico** firmato con una chiave privata dell'account.\\nEsiste anche uno [Strumento Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability) per questo.\\n - La descrizione del lavoro è chiamata **tecnica**. Si tratta di una stringa lunga 32 byte simile a un lancio che può essere un CID IPFS codificato.\\n - Il prezzo è chiamato **economia**. Si tratta di un decimale XRT - Weiner. 1 Weiner = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  È possibile ottenere un [CID IPFS](https://ipfs.tech/) formattato correttamente con la [libreria Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  Quando si utilizza la funzione `sign_liability`, non è necessario trasformare l'hash, verrà fatto automaticamente.\\n\\n</robo-wiki-note>\\n\\nSeguendo l'esempio del caffè:\\n\\n1. Il compito è un JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Il suo CID IPFS è `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Quindi la **tecnica** (CID trasformato) è `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **Economia** è `1,5 XRT`.\\n\\nQuando viene firmato, è il momento di creare una responsabilità! Questo può essere fatto da una delle parti (sia il promissario che il promittente) o da un account di terze parti di un cosiddetto fornitore.\\n\\n## Creare responsabilità\\n\\n### Preparativi\\n\\nCome accennato in precedenza, nel processo sono coinvolti almeno due parti. Per questo esempio, utilizziamo tre e creiamo un fornitore separato per questo. Supponiamo che le negoziazioni abbiano già avuto luogo in qualche modo.\\n\\n### 1. Crea tre account e aggiungi fondi ad essi\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nQui abbiamo fornito al fornitore 100 XRT per firmare le estrinseche di responsabilità, al promissario sono stati dati 2 XRT per pagare il lavoro.\\nAl promittente non sono stati concessi fondi (tranne un deposito esistenziale di almeno 1 mXRT).\\n\\n### 1. Vai su Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Scegli la liability -> create dal menu a discesa delle estrinseche possibili\\n\\nScegli anche un account con cui desideri inviare l'estrinseco. Compila tutti i parametri.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  Poiché qui viene utilizzato il fornitore, non è necessario conoscere i seed dei partecipanti. Sono necessarie solo le loro firme.\\n\\n</robo-wiki-note>\\n\\n### 3. Invia la transazione\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Esamina la tua responsabilità negli eventi\\n\\nPer fare ciò, vai su `Network -> Explorer` e trova un elenco di eventi sulla destra. Fai clic su un'icona a triangolo per espanderla.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  The hash may be transformed to an IPFS CID with the same [Python tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Esplorazione dello storage\\n\\nPuoi anche esplorare alcune caratteristiche delle responsabilità nel modulo di storage `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  La funzione di storage `Next Index` mostra l'ultimo indice di responsabilità +1, quindi anche se è `1`, la responsabilità `0` viene esplorata.\\n\\n</robo-wiki-note>\\n\\n## Rapporti\\n\\nImmagina che sia stato preparato un caffè e ora la macchina del caffè ha bisogno di segnalarlo in qualche modo. Ecco dove entrano in gioco i rapporti di responsabilità. Come prova di lavoro, l'account aggiunge un altro CID IPFS come contenuto del rapporto quando si finalizza la responsabilità esistente. Anche questo richiede una firma del promittente.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  Il messaggio firmato contiene l'indice di responsabilità esistente e l'IPFS CID del rapporto codificato in una rappresentazione di 32 byte. Ancora una volta, lo [strumento Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) può aiutare a firmare il rapporto.\\n\\n</robo-wiki-note>\\n\\nContinuando con l'esempio della macchina del caffè:\\n\\n1. Il rapporto è un JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Il suo IPFS CID è `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. Quindi il **carico utile** (CID trasformato) è \\\"0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2\\\"\\n4. **L'indice** è `0`, è l'indice di responsabilità esistente.\\n\\n### 1. Naviga su extrinsics, liability -> finalize(report)\\n\\nCompila i parametri e invia estrinseco. Ancora una volta, questo può essere fatto da un account di terze parti.\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Fai attenzione che l'account promettente non dovrebbe essere \\\"morto\\\" - dovrebbe avere un deposito esistenziale di almeno 1 mXRT.\\n\\n</robo-wiki-note>\\n\\nFirma e invia il rapporto. Quando hai finito, puoi esplorarlo negli eventi.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Esplora i rapporti\\n\\nPuoi anche osservare il rapporto nello storage. Vai su `Developer -> Storage` e scegli `liability` dalla lista a discesa.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Controlla i saldi\\n\\nNell'immagine è mostrato che ora il promettente ha ricevuto il \\\"salario\\\". È avvenuta una relazione economica!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  Al momento non c'è modo di verificare che il lavoro sia stato completato, quindi non appena il promettente segnala, i token vengono trasferiti sul suo account. \\n  La funzione di verifica verrà aggiunta in futuro.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"da89dba508e658a2b081caab0914dfd4\",\"title\":\"Lancio\",\"path\":\"/docs/it/launch/\",\"content\":\"\\n**Un'altra funzionalità di base di Robonomics parachain è il pallet di lancio. Ti consente di inviare comandi agli account/entità che si trovano dietro di essi. Questi comandi includono un parametro per specificare il compito da eseguire.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Fai attenzione che questo e i tutorial successivi vengono dimostrati su un'istanza locale di Robonomics Node. Configura la tua con [queste istruzioni](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Vai su Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Scegli launch -> launch dalla lista a discesa degli extrinsics possibili\\n\\nScegli anche un account con cui desideri inviare l'extrinsic. Compila il campo indirizzo di destinazione e il campo parametro.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  - Launch supporta stringhe lunghe 32 byte come comandi ([fonte](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)),\\n  quindi c'è spazio per improvvisare qui:\\n  - Per i comandi di base come la commutazione è possibile utilizzare \\\"0x000000000000000000000000000000000000000000000000000000000000001\\\" o\\n  \\\"0x00000000000000000000000000000000000000000000000000000000000000\\\".\\n  - Per comandi avanzati, inclusi quelli di tipo json, puoi utilizzare il CID [IPFS](https://ipfs.tech/) formattato in un\\n  [modo corretto](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Invia la transazione\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Rivedi il tuo lancio negli eventi\\n\\nPer fare ciò, vai su *Network -> Explorer* e trova un elenco di eventi sulla destra. Fai clic su un'icona a triangolo per espanderla.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"521c2a4795b5c4d4c4dfeaca82d9eb12\",\"title\":\"Come lanciare il collatore Robonomics\",\"path\":\"/docs/it/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  Nello screencast e negli screenshot di questo articolo, abbiamo utilizzato la versione 1.4.0 di Robonomics. È necessario utilizzare gli stessi comandi, ma sostituire la versione di Robonomics con quella attuale.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nAttualmente la rete Robonomics è principalmente mantenuta dagli sviluppatori iniziali, ma chiunque può supportare il progetto. Ogni nodo completo aggiuntivo della blockchain aiuta a renderla più sostenibile e tollerante agli errori. I binari del nodo Robonomics sono disponibili in [release](https://github.com/airalab/robonomics/releases) o possono essere [costruiti da zero](/docs/how-to-build-collator-node/).\\n\\n## Cos'è un collator\\n\\nUn Collator fa parte della parachain Robonomics. Questo tipo di nodo crea nuovi blocchi per la catena Robonomics.\\n\\n>I collator mantengono le parachain raccogliendo le transazioni delle parachain dagli utenti e producendo prove di transizione di stato per i validatori della Relay Chain. In altre parole, i collator mantengono le parachain aggregando le transazioni delle parachain in candidati di blocco delle parachain e producendo prove di transizione di stato per i validatori basate su quei blocchi.\\n\\nPuoi saperne di più sui collator nella relativa [pagina wiki di Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nNella paracatena Robonomics ogni raccoglitore riceve ricompense di (**0.001598184 XRT**) per ogni blocco costruito dal raccoglitore (le ricompense si verificano quando i blocchi sono sigillati alla catena).\\nInoltre, il collator che costruisce il blocco riceve **il 50% delle commissioni di transazione** contenute nel blocco che creano.\\n\\n## Requisiti\\n\\nSi consiglia di lanciare un collator utilizzando i **requisiti hardware standard** per i [validatori Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ Compatibile con x86-64.\\n+ Intel Ice Lake o successivo (serie Xeon o Core); AMD Zen3 o successivo (EPYC o Ryzen).\\n+ 4 core fisici @ 3.4GHz.\\n+ Multithreading simultaneo disabilitato (Hyper-Threading su Intel, SMT su AMD).\\n+ Archiviazione: un SSD NVMe da 1 TB (in quanto dovrebbe avere una dimensione ragionevole per gestire la crescita della blockchain).\\n+ Memoria: 32 GB DDR4 ECC\\n\\n\\nIn questo articolo utilizziamo le seguenti specifiche:\\n+ 4 vCPU\\n+ 700 GB di spazio NVMe per i database del collator. È necessaria la possibilità di espandere questo spazio su disco.\\n+ 8 GB di RAM\\n\\n\\n## Informazioni importanti\\n1. Utilizziamo alcune variabili in queste istruzioni e dovrai sostituire i valori con i tuoi in tutti i comandi:\\n    + **%NODE_NAME%** è il nome del nodo. Esempio: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** è il percorso del volume montato. Esempio: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** è l'indirizzo dell'account nell'ecosistema Polkadot nel formato SS58. Esempio: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Nota che è necessario includere *--state-cache-size=0* nel lancio del servizio del collator. Questo parametro è importante per la stabilità del collator.\\nPuoi vedere ulteriori informazioni nella relativa [issue](https://github.com/airalab/robonomics/issues/234) su github.\\n\\n## Per la prima volta, lancia facilmente un collator Robonomics\\n\\nPuoi lanciare facilmente un collator direttamente dalla riga di comando per verificare gli errori.\\nDopo aver fatto ciò, è vivamente consigliato lanciare il collator Robonomics come servizio (vedi il passaggio successivo).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Lancia il collator Robonomics come servizio\\n\\n1. Crea l'utente per il servizio con la directory home\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Scarica, estrai e sposta il binario Robonomics nella directory */usr/local/bin/*. Dovrai sostituire *$ROBONOMICS_VERSION* con la versione corrente di Robonomics nei comandi di questa sezione. Puoi trovare la versione corrente nella [pagina delle versioni del repository Robonomics su github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Crea il file di servizio systemd chiamato *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    E aggiungi le seguenti righe nel file di servizio:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Salva questo file, quindi abilita e avvia il servizio:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nURL di telemetria: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nI registri dei raccoglitori possono essere monitorati con: `journalctl -u robonomics.service -f`\\n\\nUna volta avviato, il raccoglitore Robonomics inizierà a sincronizzarsi con la Kusama Relay Chain, ciò può richiedere molto tempo, a seconda della velocità della rete e delle specifiche del sistema, quindi ti consigliamo di scaricare uno snapshot di Kusama.\\n\\n\\n## Accelerare il processo di sincronizzazione utilizzando uno snapshot di Kusama\\n\\nConsigliamo di fare ciò immediatamente dopo aver creato e avviato il servizio Robonomics. Puoi trovare ulteriori informazioni sugli snapshot e le istruzioni per l'uso nella seguente pagina: https://ksm-rocksdb.polkashots.io/\\n\\nIstruzioni:\\n\\n1. Arresta il servizio Robonomics e rimuovi la directory del database Kusama corrente:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Scarica lo snapshot attuale ed estrailo:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    È possibile rimuovere l'archivio scaricato dopo aver decompresso con successo:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Imposta la proprietà corretta per la cartella del database:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Avvia nuovamente il servizio Robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Verifica i log del servizio:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Risoluzione dei problemi\\n### Errore: \\\"State Database error: Too many sibling blocks inserted\\\"\\nPer correggere questo errore puoi semplicemente avviare il raccoglitore in modalità archivio:\\n\\n1) Prima di tutto, è necessario arrestare il servizio Robonomics: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Quindi aggiungi il parametro `--state-pruning=archive` alla parte parachain del file di servizio. Esempio del file di servizio modificato:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Ricarica la configurazione del gestore di sistema systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Rimuovi il database parachain esistente:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Avvia il servizio robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    Dopo di ciò è necessario attendere la sincronizzazione del database parahain.\\n\\n### Errore: \\\"\\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nQuesto errore è correlato ai parametri di virtualizzazione. È necessario utilizzare il tipo \\\"host-model\\\" del processore emulato. È possibile impostarlo sull'host di virtualizzazione.\\n\\nTuttavia, se si riscontra questo errore su qualsiasi hosting, è necessario chiedere supporto tecnico solo per questo problema.\\n\"}},{\"node\":{\"id\":\"65f6712075bd81257f5df60d8c68b566\",\"title\":\"Come aggiornare la versione del nodo collatore Robonomics\",\"path\":\"/docs/it/how-to-update-collator-node-version/\",\"content\":\"\\nSi consiglia di leggere i seguenti articoli prima di leggere questo post: [\\\"Come costruire un nodo collatore\\\"](/docs/how-to-build-collator-node) e [\\\"Come avviare il collatore Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nQuesto articolo contiene i comandi necessari per aggiornare un nodo collatore Robonomics (in esecuzione su Ubuntu) e fornisce anche un esempio successivo.\\n\\n## **Comandi richiesti**\\n\\n0. Prima di iniziare, si consiglia di accedere come `root`, se non lo si è, allora si consiglia di utilizzare:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Arrestare il servizio Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Rimuovere la versione precedente di Robonomics (assicurarsi di essere nella directory corretta):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Ottenere la [versione più recente](https://github.com/airalab/robonomics/releases) di Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Estrarre il file:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Spostare il file:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nÈ necessario spostare questo file nella directory corretta in cui è stato installato il nodo Robonomics)\\n\\n</robo-wiki-note>\\n\\n6. Avviare Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nEsempio per l'aggiornamento del nodo collatore a Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Modifica del database della catena di rilancio Kusama senza impostare un percorso di base**\\n\\nCi sono momenti in cui determinati snapshot della catena di rilancio Kusama causano errori al tuo nodo. Questo spesso provoca l'arresto del nodo. Esempio di errore causato da un database della catena di rilancio corrotto:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nPer risolvere questo errore, è necessario rimuovere il database esistente della catena di rilancio Kusama (probabilmente RocksDb) e sostituirlo con un altro Db come ParityDb. Eseguire i seguenti comandi:\\n\\n1. Trova la directory del nodo Robonomics e controlla i file:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Conferma di vedere la directory polkadot e quindi passa alla directory chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Elimina la directory \\\"ksmcc3\\\":\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Crea una nuova directory `ksmcc3`.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Ora è necessario scaricare un nuovo snapshot. Questo esempio utilizza uno snapshot della catena di rilancio fortemente potato, ma è possibile sostituirlo con qualsiasi snapshot preferito.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Mentre lo snapshot viene scaricato, apri una nuova sessione e modifica il tuo file di servizio:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nModifica le righe all'interno del file di servizio che si riferiscono al database e alla potatura:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nUtilizza `Ctrl + S` e poi `Ctrl + X` per salvare ed uscire dal file di servizio.\\n\\n7. Ora è necessario ricaricare il tuo demone.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. A questo punto, nella tua altra sessione, sperabilmente il nuovo Db è stato scaricato, quindi estrai il file:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. Dopo il completamento dell'estrazione, eseguire quanto segue:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Ora è possibile avviare il servizio, monitorarlo per eventuali errori e verificare che sia in collegamento sia con la catena di rilancio che con la parachain.\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"dee2605f6a0c08e2e477f5cfca4194b7\",\"title\":\"Aggiorna il tuo Home Assistant OS\",\"path\":\"/docs/it/hass-os-upgrade/\",\"content\":\"\\n**Questo articolo contiene istruzioni per aggiornare il tuo Home Assistant OS esistente con l'integrazione di Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Installa IPFS Add-on\\n\\n\\nL'integrazione di Robonomics memorizza i dati utilizzando il demone IPFS locale, quindi è necessario installarlo prima. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. C'è un [add-on IPFS per Home Assistant](https://github.com/airalab/ipfs-addon). Per installarlo vai su `Settings` -> `Add-ons`  e premi il pulsante `ADD-ON STORE` nell'angolo in basso a destra.\\n\\n2. Premi sui tre puntini nell'angolo in alto a destra e scegli `Repositories`. Aggiungi lì il seguente link:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Premi il pulsante `ADD`.\\n\\n4. Chiudi il gestore dei repository e aggiorna la pagina. Ora alla fine della pagina puoi vedere l'add-on IPFS Daemon.\\n\\n5. Apri l'add-on e premi `INSTALL`. Dopo l'installazione premi `START`.\\n\\n## Installa HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) ti permette di installare integrazioni personalizzate.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Prima di iniziare, è necessario installare l'add-on per connettersi al dispositivo Home Assistant tramite SSH. Nella ricerca dell'Add-on Store cerca `ssh`. Consigliamo di installare l'add-on `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Se l'add-on SSH non viene trovato, prova ad abilitare la modalità avanzata nelle impostazioni del tuo profilo utente. Per farlo, clicca sull'icona del profilo nell'angolo in basso a sinistra e trova l'opzione Modalità avanzata.\\n\\n</robo-wiki-note>\\n\\n2. Scegli l'add-on e premi `INSTALL`. Dopo aver completato l'installazione, vai alla scheda `Configurazione` e aggiungi `password` o `authorized_keys`. Non dimenticare di salvare questa parte della configurazione.\\n\\n3. Nella scheda `Info` premi `START`. Se vuoi vedere l'add-on nella barra laterale, non dimenticare di abilitare `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Apri l'add-on SSH e esegui il seguente comando:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Riavvia Home Assistant (puoi farlo in `Settings`->`System`). \\n\\n6. Ora l'integrazione HACS sarà disponibile per essere aggiunta nel menu `Integrations`. Vai su `Settings`->`Devices & Services`, premi `Add Integration` e trova HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Per utilizzare HACS è necessario un account Github.\\n\\n</robo-wiki-note>\\n\\n7. Clicca su di esso e segui le istruzioni di installazione. \\n\\n## Installa l'integrazione di Robonomics\\n\\nOra puoi installare l'integrazione di Robonomics utilizzando HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nApri HACS dal menu della barra laterale e vai su `Integrations`. Clicca su `Explore & Download Repositories`, quindi cerca `Robonomics` e clicca sul pulsante `Download` situato nell'angolo in basso a destra. Una volta completato il download, riavvia Home Assistant.\"}},{\"node\":{\"id\":\"fd3c9fc9f942caea79f93ef2ecaf45dc\",\"title\":\"Come costruire un nodo collator da sorgente\",\"path\":\"/docs/it/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  Nello screencast e negli screenshot di questo articolo, abbiamo utilizzato la versione 1.4.0 di Robonomics. È necessario utilizzare gli stessi comandi, ma sostituire la versione di Robonomics con quella attuale.\\n</robo-wiki-note>\\n\\n## Cos'è un collator\\n\\nIl collator fa parte della parachain di Robonomics. Questo tipo di nodo crea nuovi blocchi per la catena.\\n\\n>I collator mantengono le parachain raccogliendo le transazioni delle parachain dagli utenti e producendo prove di transizione di stato per i validatori della Relay Chain. In altre parole, i collator mantengono le parachain aggregando le transazioni delle parachain in candidati di blocco delle parachain e producendo prove di transizione di stato per i validatori basate su quei blocchi.\\n\\nPuoi saperne di più sul collator nella pagina wiki correlata di [Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nDans la parachain Robonomics, chaque assembleur reçoit des récompenses (**0,000380520 XRT**) pour chaque bloc qu'il a construit, si ce bloc a été scellé à la chaîne.\\nL'assembleur bénéficie également de **50 % de frais de transaction** sur ce bloc.\\n\\n## Processo di costruzione\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nAssicurati di avere Rust e il software di supporto installati. L'installatore di Rust ti chiederà le opzioni di installazione attuali, dovresti scegliere l'opzione `1) Procedi con l'installazione (predefinito)`.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Installa Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nInstalla la toolchain notturna richiesta e il target wasm.\\nI comandi successivi sono validi per Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nDovrai anche installare i seguenti pacchetti:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nOra puoi installare il nodo robonomics dalla sorgente git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nDopo questo comando, il binario robonomics compilato sarà nella directory `~/.cargo/bin`.\\n\\nIl passo successivo è come avviare il nodo collator. Puoi leggere al riguardo nell'articolo [\\\"Come avviare il collator Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"99398880e1b37616e77cf6c0ea3715ee\",\"title\":\"Inizializzazione di Home Assistant\",\"path\":\"/docs/it/hass-init/\",\"content\":\"\\n**Dopo aver installato Home Assistant, è necessario inizializzarlo.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nStai iniziando con la creazione dell'account proprietario di Home Assistant. Questo account è un amministratore e può apportare qualsiasi modifica. Apri il browser web e vai su `http://%RASPBERRY_IP_ADDRESS%:8123`. Puoi trovare l'indirizzo IP di Raspberry Pi utilizzando [l'app mobile Fing](https://www.fing.com/products) o [lo strumento CLI nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">L'indirizzo di Raspberry Pi potrebbe cambiare nel tempo, a causa delle impostazioni del router.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. Nella prima pagina, inserisci un nome, un nome utente, una password e fai clic sul pulsante `CREATE ACCOUNT`.\\n\\n2. Nella schermata successiva, inserisci un nome per la tua casa e imposta la tua posizione e il sistema di unità. Fai clic su `DETECT` per trovare la tua posizione e impostare il fuso orario e il sistema di unità in base a quella posizione. Se non vuoi inviare la tua posizione, puoi impostare manualmente questi valori.\\n\\n3. Dopo ciò, Home Assistant mostrerà tutti i dispositivi che ha scoperto nella tua rete. Non preoccuparti se vedi meno elementi rispetto a quelli mostrati di seguito; puoi sempre aggiungere manualmente i dispositivi in seguito. Per ora, fai clic su `FINISH` e sarai nella schermata principale di Home Assistant.\\n\\n4. Infine, vedrai l'interfaccia web di Home Assistant, che mostrerà tutti i tuoi dispositivi. \\n\\n\\n## Risoluzione dei problemi\\n\\n1. Se dimentichi il tuo nome utente o la tua password per l'utente locale, [controlla questo articolo](https://www.home-assistant.io/docs/locked_out/) per ripristinare le tue credenziali.\\n\"}},{\"node\":{\"id\":\"0eb623e8cf85c7f88a9220332a572cc8\",\"title\":\"Immagine preinstallata per Raspberry Pi\",\"path\":\"/docs/it/hass-image-install/\",\"content\":\"\\n**Benvenuti alla guida sull'installazione di Home Assistant con integrazione Robonomics su un Raspberry Pi. Home Assistant è un sistema di automazione domestica open-source che fornisce un hub centralizzato per il controllo dei dispositivi intelligenti nella rete domestica. Integrando con Robonomics, un servizio cloud decentralizzato, è possibile migliorare la funzionalità e la sicurezza della propria casa intelligente. In questo articolo, forniremo istruzioni passo-passo su come installare Home Assistant con Robonomics su un Raspberry Pi, dando la possibilità di automatizzare e controllare vari aspetti della propria casa utilizzando una soluzione sicura e decentralizzata. Iniziamo!**\\n\\n## Hardware necessario per l'installazione\\n\\nSe non hai ancora incorporato Home Assistant nella tua configurazione di casa intelligente, è importante essere consapevoli dell'attrezzatura necessaria per stabilire un sistema di casa intelligente completo da zero.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Scarica l'immagine preinstallata di Robonomics\\n\\nL'immagine preinstallata di Robonomics contiene:\\n- Home Assistant Core\\n- IPFS\\n- Broker MQTT e integrazione\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nPuoi controllare il codice sorgente e scaricare l'ultima versione dell'immagine su [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Configura l'immagine\\n\\nInstalla [Raspberry Pi Imager](https://www.raspberrypi.com/software/) sul tuo computer. Quindi, inserisci la scheda SD.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nEsegui il programma Raspberry Pi Imager. Scegli l'immagine richiesta come sistema operativo e assicurati di selezionare la scheda SD dal menu a discesa di archiviazione.\\nNelle impostazioni:\\n- Imposta nome utente e password (salva il nome utente predefinito \\\"pi\\\" per facilitarne il ricordo),  \\n- fornisci il nome e la password della tua rete Wi-Fi, \\n- scegli il tuo paese dall'elenco a discesa\\ne quindi `Scrivi` l'immagine. \\n                   \\n<robo-wiki-note type=\\\"note\\\">Salva attentamente nome utente e password, perché queste credenziali saranno necessarie in caso di risoluzione dei problemi</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nPuoi trovare i codici dei paesi [qui](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. Primo avvio\\n\\n**Espelli in modo sicuro la scheda SD**, inseriscila nel Raspberry Pi. Quindi **inserisci l'adattatore Zigbee** nel Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">È importante inserire l'adattatore Zigbee prima del primo avvio del Raspberry Pi! \\nÈ necessario per l'autoconfigurazione della rete Zigbee.</robo-wiki-note>\\n\\n**Se hai il [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (che ha tutti i firmware necessari), puoi semplicemente procedere con queste istruzioni. Tuttavia, se hai un altro adattatore, la prima cosa da fare è flasharlo con il software Zigbee2MQTT. Puoi trovare le istruzioni per il tuo dispositivo [qui](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nSuccessivamente, collega il cavo di alimentazione al tuo dispositivo. Dovrebbe connettersi alla tua rete Wi-Fi. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nUna volta collegato il tuo Raspberry Pi, il LED rosso si accenderà e il LED verde lampeggerà per qualche tempo. Attendi fino a 5 minuti affinché il Raspberry Pi si avvii e si registri sulla rete.\\n\\nOra trova l'indirizzo IP del Raspberry Pi. Per trovarlo puoi utilizzare l'app mobile [Fing](https://www.fing.com/products) o \\n[lo strumento CLI nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Trova il nome `robots-home` (il nome opzionale potrebbe essere `Home(homeassistant)`) \\ndella macchina host nell'elenco degli IP. \\n\\nIn questo esempio l'indirizzo è `192.168.43.56`. \\n\\nPer verificare che tutto funzioni, apri il browser web e vai alla pagina web `http://%INDIRIZZO_IP_RASPBERRY%:8123`. In questo esempio, sarà `192.168.43.56:8123`.\\nSe tutto è corretto, vedrai l'interfaccia web di Home Assistant. Se la pagina web non si apre, attendi fino a 5 minuti per l'avvio del Raspberry Pi e riprova. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Risoluzione dei problemi\\n\\n1. Per modificare le impostazioni Wi-Fi in seguito, devi accedere al tuo Raspberry Pi tramite il comando `ssh`. Per fare ciò, apri il terminale sul tuo computer\\ne digita il comando ssh con il tuo nome utente, che hai creato durante il passaggio \\\"Configurazione dell'immagine\\\" (quello predefinito è \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\ne quindi usa il comando `sudo raspi-config`. Trova ulteriori informazioni su questo comando sul [sito ufficiale.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"da9ec89a7404703a43c0e1c77cea4cf6\",\"title\":\"Aggiorna il tuo Home Assistant Core\",\"path\":\"/docs/it/hass-core-upgrade/\",\"content\":\"\\n**Questo articolo contiene istruzioni per aggiornare il tuo Home Assistant Core esistente con l'integrazione di Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Si presume che l'installazione del tuo Home Assistant Core sia stata completata in conformità alle [istruzioni ufficiali](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) e che ci sia un utente <u>homeassistant</u> e l'ambiente `venv`. Se non è il caso, segui le istruzioni di seguito, **ma modifica lo script di conseguenza**.\\n  2. IPFS verrà installato ed eseguito come un servizio <u>systemd</u> sulla macchina host.\\n  3. Si presuppone che tu abbia [Python 3.9](https://www.python.org/downloads/) o versione successiva installata.\\n\\n</robo-wiki-note>\\n\\n## Installaare\\n\\nScarica lo script di installazione ed eseguilo nel terminale:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nVedrai il seguente output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nDurante il processo, ti verrà chiesto di confermare il riavvio di diversi servizi. Navigando con `tab`, seleziona l'opzione `yes`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Potresti vedere un errore come `mkdir: can't create directory 'custom_components': File exists`. Questo significa che hai già questa cartella con alcuni componenti personalizzati installati. Ignora semplicemente questo messaggio.\\n\\n</robo-wiki-note>\\n  \\nDopo aver finito, riavvia il tuo Home Assistant.\\n\\n## Verificare\\n\\nVerifica che il servizio IPFS sia attivo e in esecuzione:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVedrai il seguente output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"3a18f96669a142a6f2ddb24b8ec9cff0\",\"title\":\"Aggiorna il tuo Home Assistant Docker per sistemi operativi simili a Unix\",\"path\":\"/docs/it/hass-docker-upgrade/\",\"content\":\"\\n**Questo articolo contiene istruzioni per aggiornare il tuo Home Assistant Docker esistente (su un sistema operativo simile a Unix) con l'integrazione di Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Si presume che vengano utilizzate le immagini e i contenitori Docker predefiniti di Home Assistant denominati <u>homeassistant</u>.\\n  2. IPFS verrà installato ed eseguito come un servizio <u>systemd</u> sulla macchina host.\\n  3. Si presume che tu abbia installato [Python3.9](https://www.python.org/downloads/) o una versione successiva.\\n\\n</robo-wiki-note>\\n\\n## Installa\\n\\nScarica lo script di installazione ed eseguilo nel terminale:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nVedrai il seguente output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Potresti vedere un errore come `mkdir: can't create directory 'custom_components': File exists`. Questo significa che hai già questa cartella con alcuni componenti personalizzati installati. Ignora semplicemente questo messaggio.\\n\\n</robo-wiki-note>\\n\\nRiavvia il contenitore:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Verifica\\n\\nVerifica che il servizio IPFS sia attivo e in esecuzione:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVedrai il seguente output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"a8e2ffdaac3f3c36f97cc79a4f8cdf62\",\"title\":\"Glossary\",\"path\":\"/docs/it/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\nuna congiunzione di una coppia di chiavi pubblico-private, la parte pubblica della quale è l'indirizzo pubblico dell'utente e la parte privata è la chiave segreta per accedere al controllo di questo indirizzo.\\n\\n\\n### Auction (of Parachains)\\nmeccanismo di leasing di slot per le parachain negli ecosistemi di Polkadot e Kusama; una parachain deve vincere un'asta a candela per ottenere uno slot.\\n\\n### Autonomous Agent\\nun sistema computazionale che riceve dati sensoriali dal suo ambiente e decide come rispondere agli stimoli esterni al fine di raggiungere i suoi obiettivi.\\n\\n### AIRA\\no Autonomous Intelligent Robot Agent - un software, sviluppato dal team Robonomics nel 2015, che implementa lo standard di interazione economica uomo-macchina e macchina-macchina attraverso un contratto di responsabilità intellettuale.\\n\\n\\n## B\\n\\n### Blockchain\\nin senso lato, una rete distribuita che utilizza la crittografia per consentire a un gruppo di partecipanti di raggiungere un consenso fidato sullo stato mutevole di un sistema.\\n\\n### Blockchain Esplorar\\nun'applicazione che consente di esplorare i diversi blocchi, transazioni e indirizzi su una blockchain (ad esempio Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\nuna logica di automazione predefinita che può essere facilmente aggiunta a un'istanza di Home Assistant.\\n\\n### Bridge\\nuna tecnologia e metodi con cui due catene economicamente sovrane e tecnologicamente diverse possono comunicare tra loro. \\n\\n\\n## C\\n\\n### Coase (XRT)\\no Cs — una milionesima quota di un token XRT, 1 XRT = 1 000 000 Cs; prende il nome da Ronald Coase, un economista britannico, uno dei fondatori dell'economia istituzionale, vincitore del Premio Nobel Memorial per le scienze economiche.\\n\\n### Collator\\nun nodo che mantiene una parachain raccogliendo transazioni di parachain e producendo prove di transizione di stato per i validatori.\\n\\n### Consensus\\nun processo in cui i nodi di una rete blockchain raggiungono un accordo sullo stato attuale dei dati nella rete (ad esempio Proof-of-Work, Proof-of-Stake).\\n\\n### Crowdloan\\nuna campagna di crowdfunding per la raccolta di token per fare un'offerta all'asta degli slot nell'ecosistema di Polkadot / Kusama.\\n\\n### Cybernetics\\nlo studio del controllo e della comunicazione nell'animale e nella macchina, secondo la definizione di N. Wiener.\\n\\n### Cyber-Physical System\\no CPS - una forte unificazione e integrazione reciproca di processi computazionali, di rete e fisici.\\n\\n\\n## D\\n\\n### DAO\\nun'organizzazione di proprietà collettiva e governata da blockchain, in cui la gestione delle risorse viene effettuata in conformità con un insieme di regole preaccordate e formalizzate, il cui rispetto viene effettuato automaticamente.\\n\\n### Datalog (Function)\\nuna funzione di parachain Robonomics che memorizza i dati del dispositivo sulla blockchain.\\n\\n### Dapp\\no applicazione decentralizzata - un'applicazione che funziona come parte di una rete distribuita e fornisce accesso alle sue funzioni in modo user-friendly.\\n\\n### Decentralized Cloud\\nun servizio di cloud computing basato su una rete peer-to-peer decentralizzata a cui gli utenti possono unirsi sia per utilizzare i servizi che per fornire le proprie risorse come calcolo, rete, archiviazione, ecc.\\n\\n### Digital Twin\\nuna versione digitale di un'attrezzatura reale che copia le sue caratteristiche tecniche e i dati storici.\\n\\n\\n## E\\n\\n### Edge-system\\nun dispositivo IoT che funge da collegamento tra sistemi embedded accessibili localmente e la rete globale, supportando tipicamente protocolli di comunicazione e trasmettendo telemetria e segnali di controllo.\\n\\n### Embedded System\\nun dispositivo IoT con risorse di calcolo e comunicazione limitate che fornisce funzioni di base (sensori, attuatori, pulsanti) al livello più basso, di solito senza interfacce utente.\\n\\n### Ethereum\\nun sistema blockchain open-source decentralizzato che funziona come piattaforma per numerose altre criptovalute, nonché per l'esecuzione di smart contract decentralizzati.\\n\\n### Ethereum Upgrade\\nprecedentemente noto come Ethereum 2.0 o Eth2 - un aggiornamento del protocollo Ethereum che dovrebbe rendere la rete più scalabile, sicura e sostenibile; a tal fine, si propone di cambiare il consenso a Proof-of-Stake e aggiungere un meccanismo di shard per aumentare la capacità di rete.\\n\\n### Exodus\\nprocesso di trasferimento dei token XRT dalla rete Ethereum alla parachain Robonomics.\\n\\n### Extrinsic\\nuna funzione sulla rete Polkadot e Kusama, che può innescare transizioni di stato di rete dall'esterno dello stato.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\no Gk - un millesimo di un token XRT, 1 XRT = 1 000 Gk; chiamato così in onore di Victor Glushkov, matematico sovietico, uno dei fondatori dell'informatica e della cibernetica nell'Unione Sovietica.\\n\\n\\n## H\\n\\n### Home Assistant\\no Hass: un software di sistema di controllo open source, progettato per essere un hub centrale per dispositivi intelligenti.\\n\\n### HRMP\\no Passaggio di messaggi con instradamento orizzontale: un messaggio sicuro che passa tra parachain, che memorizza tutti i messaggi nell'archivio della catena di inoltro prima di inviarli alle parachain.\\n\\n### HMI\\no Human-Machine Interface - un'interfaccia utente o dashboard che collega l'utente a una macchina, sistema o dispositivo.\\n\\n\\n## I\\n\\n### Industry 4.0\\no la Quarta Rivoluzione Industriale - l'automazione in corso delle pratiche manifatturiere e industriali tradizionali, utilizzando tecnologie intelligenti moderne.\\n\\n### IPFS\\no InterPlanetary File System - un software peer-to-peer per la memorizzazione e la condivisione di dati in un sistema di file distribuito.\\n\\n### IoT\\no Internet delle cose - una connessione a una rete globale di miliardi di dispositivi, in grado di raccogliere dati e integrati nell'ambiente.\\n\\n### IoT Gateway\\nun sistema di bordo che aggrega e trasmette dati dai dispositivi IoT alla rete e viceversa; spesso questi dispositivi sono una versione più complessa del router WiFi.\\n\\n### IoT Provider\\nun servizio esterno che fornisce agli utenti IoT accesso remoto ai dati e all'analisi, nonché il controllo dei dispositivi intelligenti tramite Internet.\\n\\n### IoT Subscription\\nuna funzione della parachain Robonomics che consente di utilizzare tutte le funzioni della parachain per un certo periodo senza commissioni.\\n\\n\\n## K\\n\\n### KSM\\nun token nativo per la rete Kusama.\\n\\n### Kusama\\nla \\\"rete canary\\\" per Polkadot che consiste in una versione di anteprima non verificata del software Polkadot.\\n\\n\\n## L\\n\\n### Lancio (Function)\\nuna funzione di parachain Robonomics che avvia o arresta un dispositivo inviando un comando attraverso la blockchain.\\n\\n### Lease Period\\nun periodo di tempo in cui una parachain può connettersi alla Relay Chain.\\n\\n### Libp2p\\nuna libreria open-source per la creazione di reti peer-to-peer criptate.\\n\\n### Lights-out Factory\\no Smart Factory - una fabbrica completamente automatizzata che non richiede presenza umana sul posto.\\n\\n### Lighthouse\\nun contratto intelligente, nel concetto di economia dei robot, che esegue una transazione quando il Provider stabilisce una corrispondenza di mercato tra il Promettente e il Promissario.\\n\\n### Responsabilità\\nun contratto intelligente, realizzato da sistemi cibernetici-fisici tra loro o con gli esseri umani, per eseguire un compito a pagamento.\\n\\n### Liability Market\\nuna piattaforma, nel concetto di economia dei robot, responsabile di abbinare offerte e richieste tra i nodi del sistema.\\n\\n\\n## M\\n\\n### MQTT\\no Message Queuing Telemetry Transport - un protocollo di pubblicazione-sottoscrizione progettato per reti a bassa larghezza di banda, alta latenza e non affidabili per l'operazione di grandi volumi di messaggi di dispositivi IoT.\\n\\n### MQTT Broker\\nun servizio che riceve tutti i messaggi dai client MQTT e quindi instrada i messaggi ai client sottoscritti appropriati.\\n\\n\\n## N\\n\\n### NFT\\no Non-Fungible Token - un token che non può essere scambiato e indistinguibile da altri token che consentono la tokenizzazione di oggetti unici e forniscono la proprietà esclusiva per quei token.\\n\\n### Node (of Robonomics)\\nun modulo blockchain basato su Substrate o Ethereum con estensioni Robonomics per la connessione a Robonomics Network.\\n\\n\\n## O\\n\\n### On-chain Governance\\nun processo per determinare quali modifiche alla rete sono permesse, come modifiche al codice o spostamento di fondi, che esiste nella rete stessa e può cambiarla direttamente.\\n\\n\\n## P\\n\\n### Pallet\\nun modulo Substrate scritto in Rust che raggruppa logica o algoritmo specifici per il runtime della blockchain basata su Substrate.\\n\\n### Parachain\\nuna struttura dati personalizzata e specifica dell'applicazione (di solito una blockchain) che è integrata nella Relay Chain e può essere convalidata dai validatori.\\n\\n### Parathread\\nuna parachain senza uno slot che può partecipare temporaneamente (su base blocco per blocco con una commissione) alla sicurezza della Relay Chain.\\n\\n### Polkadot\\nuna rete eterogenea e multi-chain che consente a varie blockchain di diverse caratteristiche di effettuare comunicazioni arbitrarie tra le catene condividendo la sicurezza.\\n\\n### Polkadot/Substrate Portal\\nun'interfaccia utente di base di Substrate per interagire con una rete Substrate come Polkadot, Kusama e altre.\\n\\n### Proposal (on Polkadot / Kusama)\\nuna potenziale chiamata funzionale su cui votare in un referendum su Polkadot, Kusama o paracatene.\\n\\n### Proof-of-Work\\nun meccanismo di consenso in cui, per raggiungere un accordo, i partecipanti alla rete sono tenuti a svolgere un lavoro computazionale.\\n\\n### Proof-of-Stake\\nun meccanismo di consenso in cui, per raggiungere un accordo, i partecipanti alla rete sono tenuti a impegnare capitale della criptovaluta associata che funge da garanzia.\\n\\n### Promisee\\nun nodo che effettua un ordine per l'esecuzione di un compito nel concetto di economia dei robot.\\n\\n### Promisor\\nun nodo che accetta di eseguire un compito in cambio di un pagamento nel concetto di economia dei robot.\\n\\n### Provider (Robonomics)\\nun nodo, nel concetto di economia robotica, che monitora i messaggi del mercato della responsabilità civile e abbina un'offerta e una domanda dietro un piccolo compenso.\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\nuna parte della governance on-chain, vota se una proposta deve essere accettata o meno dagli utenti della rete.\\n\\n### Relay Chain\\nla catena principale che coordina il consenso di Polkadot / Kusama e la comunicazione tra le parachain.\\n\\n### Robofirm\\nun'organizzazione in cui l'intero ciclo del processo aziendale è completamente automatizzato e non richiede la partecipazione umana.\\n\\n### Rococo\\nla testnet per testare le parachain su Kusama\\n\\n### robonomics-interface\\nuna libreria Python specializzata nell'interfacciarsi con Robonomics per una programmazione conveniente.\\n\\n### Robonomics su Ethereum\\nuna versione di Robonomics Network che funziona su Ethereum, rilasciata nel 2018.\\n\\n### Robot Economy\\nun sistema economico in cui i dispositivi agiscono come agenti indipendenti capaci di svolgere attività economiche chiave precedentemente uniche per gli esseri umani.\\n\\n### Robot-as-a-Service\\no RaaS - un modello di business in cui le aziende affittano le loro attrezzature robotiche a clienti per un uso a breve o lungo termine.\\n\\n### ROS\\no Robot Operating System - un framework per lo sviluppo di software per robot, che fornisce servizi progettati per un cluster di computer eterogeneo come astrazione dell'hardware, controllo dei dispositivi a basso livello, implementazione di funzionalità comunemente utilizzate, passaggio di messaggi tra processi e gestione dei pacchetti.\\n\\n### ROS 2\\nuna versione aggiornata e ricostruita di Robot Operating System con nuove funzionalità, come il supporto per sistemi multi-robot e piccoli sistemi embedded e l'integrazione con il tempo reale.\\n\\n### ROS 2 Middleware\\no RMW - un protocollo che fornisce funzionalità standard ROS 2 come scoperta, serializzazione e trasporto; ROS 2 supporta più implementazioni di middleware che possono essere scelte in base alle esigenze del progetto.\\n\\n### RWS\\no Robonomics Web Services - servizi di infrastruttura decentralizzati per robotica e IoT che consentono di connettere facilmente dispositivi e interagire in modo sicuro con applicazioni utente, servizi cloud e altri dispositivi; ha anche il proprio token chiamato RWS, che offre una sottoscrizione IoT a vita nella parachain di Robonomics.\\n\\n### Eseguitime\\nuna funzione di transizione di stato di una blockchain che definisce un algoritmo valido per determinare lo stato del blocco successivo dato lo stato precedente.\\n\\n\\n## S\\n\\n### Seed Phrase\\nuna chiave privata leggibile dall'uomo creata come sequenza di parole casuali e necessaria per accedere all'indirizzo della blockchain e ai suoi token.\\n\\n### Shared Security\\nil modello di sicurezza di Polkadot / Kusama in cui tutte le catene sono ugualmente protette inserendo prove di validità dei blocchi delle parachain nella Relay Chain in modo che un potenziale attaccante debba attaccare l'intero sistema.\\n\\n### SLS Gateway\\nun gateway IoT open source per dispositivi Zigbee basato sul microcontrollore ESP32 sviluppato da Smart Logic System.\\n\\n### Slot (of Parachain)\\nuna risorsa scarsa nell'ecosistema di Polkadot / Kusama che consente alle parachain di essere collegate alla Relay Chain senza commissioni per ogni blocco.\\n\\n### Smart Leasing\\nuna variante del modello Robot-as-a-Service, in cui il pagamento avviene non in base al tempo, ma per operazioni specifiche e il loro numero.\\n\\n### Smart Contract\\nun programma o algoritmo memorizzato su una blockchain che viene eseguito automaticamente quando vengono soddisfatte condizioni predefinite.\\n\\n### SSH\\no Secure Shell: un protocollo di rete per il funzionamento sicuro dei servizi di rete su una rete non protetta, che utilizza la crittografia a chiave pubblica per autenticare il computer remoto. \\n\\n### Staking\\nla parte del consenso Proof-of-Stake, un atto di vincolare i token depositandoli come garanzia per avere la possibilità di produrre un blocco valido e ottenere una ricompensa.\\n\\n### Substrate\\nun framework modulare per la creazione di blockchain come Polkadot e Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nun fondo di fondi raccolti attraverso una parte delle ricompense di produzione dei blocchi, commissioni di transazione, staking, ecc., che possono essere spesi mediante la presentazione di una proposta di spesa; se il Tesoro termina un periodo di spesa senza spendere tutti i suoi fondi, subisce una bruciatura di una percentuale dei fondi.\\n\\n### Transaction Costs\\nil costo di raccogliere ed elaborare informazioni a causa della razionalità limitata degli agenti economici e della complessità dei processi.\\n\\n\\n## V\\n\\n### Validator\\nun nodo che protegge la Relay Chain scommettendo i suoi token, convalidando le prove dei collatori sulle parachains e votando sul consenso insieme ad altri validatori.\\n\\n\\n## W\\n\\n### Web3\\nun'idea per una nuova iterazione del Web che incorpora concetti come la decentralizzazione, le tecnologie blockchain e l'economia basata sui token.\\n\\n### Wiener (XRT)\\no Wn - una miliardesima parte di un token XRT, 1 XRT = 1 000 000 000 Wn; chiamato così in onore di Norbert Wiener, un matematico americano, uno dei fondatori della cibernetica e della teoria dell'intelligenza artificiale.\\n\\n\\n## X\\n\\n### XCM\\no Cross-Consensus Message Format - un formato di messaggistica tra diversi sistemi blockchain in Polkadot / Kusama.\\n\\n\\n### XRT\\nun token nativo per Robonomics Network, che esiste indipendentemente sulle reti Ethereum e Kusama.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nun'implementazione di una rete sovrapposta di uno schema di routing completamente crittografato end-to-end per reti mesh.\\n\\n\\n## Z\\n\\n### Zigbee\\nun protocollo di comunicazione wireless, comunemente utilizzato per collegare dispositivi intelligenti a causa del basso consumo energetico, della facilità di configurazione e della flessibilità e del supporto della topologia di rete auto-organizzante e auto-recuperante.\\n\\n### Zigbee Adapter\\nun dispositivo che trasferisce dati tra la rete Zigbee e un'altra rete (ad esempio Wi-Fi) per il controllo dei dispositivi Zigbee.\\n\\n### Zigbee2MQTT\\nun software che consente di connettere Zigbee alle reti MQTT traducendo i messaggi da una rete all'altra. \"}},{\"node\":{\"id\":\"671b9d6cc6a9b0b5b22229fe524df48f\",\"title\":\"Amministrazione globale\",\"path\":\"/docs/it/global-administration/\",\"content\":\"\\n**Questo articolo ti mostrerà come configurare un nuovo utente per il tuo Home Assistant.**\\n\\n## Aggiunta di utenti alla sottoscrizione\\n\\nNon è possibile utilizzare account creati in precedenza perché `SUB_OWNER` e `SUB_CONTROLLER` forniscono sicurezza e il primo utente creato quando hai avviato per la prima volta Home Assistant non ha un account Robonomics Parachain.\\n\\n1. Crea un account su Robonomics parachain, come hai fatto nell'[articolo precedente](/docs/sub-activate/).\\n\\n2. Utilizzando l'account `SUB_OWNER`, aggiungi il nuovo account utente alla sottoscrizione nella [dapp](https://dapp.robonomics.network/#/subscription/devices). Ora dovrebbero esserci tre indirizzi nell'elenco degli accessi: `SUB_OWNER`, `SUB_CONTROLLER` e `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Concessione di accesso all'utente\\n\\n1. Vai al servizio dapp chiamato [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Scegli l'account che hai appena creato nella barra laterale destra (verifica di aver scelto l'account desiderato premendo l'icona del profilo).\\n\\n2. Inserisci il seed `USER` nel campo richiesto. Aggiungi gli indirizzi `SUB_OWNER` e `SUB_CONTROLLER` nei campi dei crediti degli amministratori. Se tutto è corretto, vedrai lo stato di verifica `VERIFIED`.\\n\\n3. Crea una password per il nuovo utente che hai appena registrato e conferma la transazione, che ora sarà senza commissioni a causa della sottoscrizione. In seguito potrai ripristinare la password nella scheda Ripristina.\\n\\n4. Dopo il processo di registrazione, accedi a Home Assistant con il tuo indirizzo utente come login e la password appena creata.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nOra puoi utilizzare la dapp per controllare la tua casa tramite Robonomics, consulta l'articolo [**\\\"Ottieni Telemetria per la Smart Home\\\"**](/docs/smart-home-telemetry/).\\n\\n## Risoluzione dei problemi\\n\\n1. Se dimentichi una password per Home Assistant dal tuo account Robonomics, [controlla la Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nVai alla sezione \\\"Your Home Assistant password\\\" e scegli la scheda \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"ad4043f84cbdd96455a514ee406d1e40\",\"title\":\"Iniziare\",\"path\":\"/docs/it/getting-started/\",\"content\":\"\\n## Cos'è Robonomics\\n\\nLa piattaforma Robonomics fornisce strumenti per lavorare con la rete economica dei robot. Robonomics consente ai progettisti di città intelligenti e zone industriali 4.0 di costruire fiducia tra i [servizi di robot autonomi](/docs/glossary#cyber-physical-system), fornire [accesso diretto dell'utente tramite dapp](/docs/glossary#dapp) per ordinare prodotti dalle fabbriche autonome e dai servizi delle reti di sensori urbani. Ciò permetterà di mettere in atto un sistema decentralizzato che monitora globalmente le attività dei sistemi fisici cibernetici.\\n\\nIl seguente grafico descrive il ruolo di Robonomics nello scenario:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nTrova altro in [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Avvio rapido della rete Robonomics\\n**Per la comodità dei nuovi arrivati, i principali sviluppatori di Robonomics hanno ideato una [curva di apprendimento di 6 lezioni](/docs/wschool2021-intro/)!**\\n\\nEsplorerai l'architettura IoT senza server! Robonomics Web Services (RWS) è il servizio infrastrutturale di base per la robotica e l'IoT su Polkadot && IPFS.\\n\\nI laureati del corso possono avviare una catena di rilancio locale e controllare un dispositivo compatibile con ROS tramite transazioni cross-chain.\\n\\n**[Unisciti a Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) per connetterti alla comunità e ottenere supporto tecnico.**\\n\\n### Vantaggi per i laureati dell'Accademia Robonomics\\n- Stage per i migliori studenti   Diventa un membro del team Robonomics e contribuisci allo sviluppo del prodotto scelto.\\n- Comunità attiva && eventi regolari   Fai parte della comunità di studenti, discuti i tuoi casi d'uso con esperti del settore. Unisciti e partecipa agli hackathon!\\n- Certificato di completamento   Aggiungi un certificato per aver completato il corso sulla creazione di DAPP per l'IoT al tuo portfolio.\\n- Assistenza nell'ammissione all'università ITMO. Che tu sia un laureato o un magistrato, riceverai assistenza nell'ammissione all'università.\\n- Opportunità di finanziamento && accelerazione: 1)Richiedi una sovvenzione di supporto fino a $50.000 per l'Accademia; 2)Partecipa al programma di accelerazione Robonomics builders supportato da Web3 Foundation; 3)Implementa la tua DAPP indipendente su Robonomics; 4)Monetizzala && ottieni supporto di marketing dal team Robonomics.\\n\\n\\n## Cosa contiene la documentazione\\n\\n### Sono uno sviluppatore di Dapp\\n\\n- [Robonomics-js su GitHub](https://github.com/airalab/robonomics-js) - semplice SDK Javascript per gli sviluppatori di dApp di Robonomics Network.\\n- [Modello di dApp](https://github.com/airalab/vue-dapp-robonomics-template) - utilizza Vue.js\\n- [Documentazione Wiki](/docs/robonomics-js/)\\n\\n### Sono un ingegnere robotico\\n\\nConsulta la sezione [casi](/docs/iot-sensors-connectivity/) e inizia a sviluppare tramite [esempi](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"8bd816dfae7b44bc35a9d8add6ed7278\",\"title\":\"Come acquistare una sottoscrizione\",\"path\":\"/docs/it/get-subscription/\",\"content\":\"\\n**Paghare commissioni per le transazioni sulla blockchain è fastidioso. Immagina un dispositivo IoT che invia telemetria ogni 5-10 minuti. Questo ti farà pagare parecchio durante il mese. Una delle caratteristiche principali di Robonomics Network è RWS - la sottoscrizione al servizio web di Robonomics. Paga mensilmente e dimentica i costi delle transazioni! Per informazioni teoriche consulta [questo](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) articolo.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Fai attenzione che questo tutorial illustra come acquistare una sottoscrizione su Robonomics Kusama parachain. Puoi eseguire tutti gli stessi passaggi anche sul tuo [nodo locale](/docs/run-dev-node).\\n\\n  Un'altra cosa prima di iniziare. Questo è un modo \\\"difficile\\\" per acquistare una sottoscrizione. Esiste un modo convenzionale per farlo tramite [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Fai un'offerta per un'asta\\n\\nLe sottoscrizioni su Robonomics vengono vendute con un modello di asta. Per ottenerne una, devi fare un'offerta per un'asta e vincerla (non preoccuparti, è veloce).\\n\\nIn `Developer/Chain state` puoi vedere le aste disponibili. \\nScegli `rws` e `auctionQueue` e premi il pulsante `+`, vedrai gli ID delle aste disponibili:\\n\\n![queue](../images/rws/queue.png)\\n\\nPuoi vedere le informazioni su qualsiasi sottoscrizione con `rws` `auction` e l'ID dell'asta (l'ID dell'asta nell'immagine è 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nNelle informazioni sull'asta puoi vedere il campo `winner`, al momento è `null` quindi nessuno ha questa sottoscrizione e tu puoi ottenerla. Per farlo vai su `Developer/Extrinsic`, scegli il tuo account e `rws -> bid`. Imposta anche l'ID dell'asta (79) e la quantità di unità da offrire (più di 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nInvia la transazione e controlla le informazioni sull'asta con ID 79 (in `Chain state` scegli `rws -> auction` e ID 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nOra nel campo `winner` vedrai l'indirizzo del tuo account, significa che questo account ha la sottoscrizione 79. Un'asta inizia con la prima offerta e dura alcuni blocchi, quindi se qualcuno offre più token di te nei prossimi blocchi, quella persona sarà il vincitore e otterrà la sottoscrizione.\\n\\nOra puoi aggiungere dispositivi. I dispositivi sono account che possono utilizzare questa sottoscrizione e inviare estrinseci senza commissioni.\\nPer testarlo crea un nuovo account senza token e aggiungilo ai dispositivi. \\n\\nPer aggiungere dispositivi scegli `rws -> setDevices` in `Developer/Extrinsic`. Quindi premi il pulsante `Aggiungi elemento` e scegli l'account creato di recente senza token:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nInvia la transazione. Ora puoi controllare l'elenco dei dispositivi in `Chain state` con `rws -> devices`. Lì vedrai l'indirizzo del tuo account senza token. Scegli l'account che ha acquistato la sottoscrizione e premi `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nOra puoi provare a [inviare un lancio](/docs/subscription-launch) estrinseco utilizzando la sottoscrizione.\"}},{\"node\":{\"id\":\"cff303df9c292ca567842cc9c1eaa4b0\",\"title\":\"Configurazione e installazione del software Gaka-Chu\",\"path\":\"/docs/it/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**In questo articolo passeremo attraverso alcuni passaggi di installazione e avvio per configurare un robot pittore. Requisiti:**\\n- KUKA KR6 R900 sixx con KRC4 e SmartPad;\\n- Intel NUC con [ROS melodic](http://wiki.ros.org/melodic/Installaation/Ubuntu) installato;\\n- Tavolo, vernice, pennello, acqua.\\n\\n## Installazione del software su KRC4\\nÈ necessaria l'interfaccia EKI sia su KRC4 che su NUC. Le informazioni dettagliate su come configurarla su KRC4 sono presentate [qui](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Avviala sul controller del robot.\\n\\n## Installazione del software su NUC\\nCrea uno spazio di lavoro catkin:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nScarica i pacchetti ROS. Tutti gli script sono archiviati [qui](https://github.com/airalab/robot_painter/tree/test_branch). Clona il repository:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nPotrebbe essere necessario scaricare alcuni file di intestazione e librerie per far funzionare tutto correttamente. Scaricali:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nAggiungi il comando di origine al file `.bashrc`:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nFinora dovresti essere in grado di avviare gli script. Se qualcosa va storto, prova a risolvere alcuni [problemi](https://github.com/airalab/robot_painter/issues)\\n\\n## Compilazione delle costanti\\nInnanzitutto, il robot deve conoscere la posizione e l'orientamento della tela e la posizione del barattolo di vernice. Tutto ciò è specificato in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Diamo un'occhiata.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nQueste sono le costanti dell'equazione del piano che specificano la posizione della tela nello spazio tridimensionale. Devono essere ottenute durante un processo di calibrazione descritto di seguito. Successivamente viene la vernice.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nQueste sono le coordinate del barattolo di vernice. Possono anche essere specificate durante la calibrazione. Le dimensioni della tela sono specificate in\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nAltre costanti importanti sono archiviate in `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nI loro nomi dicono tutto, quindi compilali in base alla situazione.\\n\\n## Calibrazione di Gaka-Chu\\nIl processo di calibrazione stesso è piuttosto semplice.\\n\\n1) Avvia l'interfaccia EKI su KRC4:\\n\\nAccedi in modalità 'AUT', accendi i driver e avvia lo script `eki_hw_interface`\\n\\n2) Avvia l'interfaccia EKI su NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nDovrebbe produrre log infiniti.\\n\\n3) Avvia RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nDovresti vedere quanto segue:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nProva a muovere l'effettore terminale e fare clic su 'Pianifica ed esegui'. Il robot dovrebbe muoversi. Sul SmartPad vai su **Visualizza -> Posizione effettiva** e osserva le coordinate dell'effettore terminale. Posiziona una tela in posizione orizzontale rispetto alla base del robot. Inserisci un pennello nel supporto del pennello e spostalo delicatamente fino a quando tocca appena la tela. In questa posizione, salva le coordinate dell'effettore terminale. Ripeti 12-15 volte. Salva anche le coordinate del centro della tela e del barattolo di vernice.\\nQuando hai un insieme di coordinate, utilizza [questi](https://github.com/nakata5321/Matlab_scripts_gaka-chu) script Matlab per risolvere le costanti e il quaternione mancanti. Incollali. Ricostruisci il tuo spazio di lavoro con\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Test della calibrazione di Gaka-Chu\\nQuando è calibrato, Gaka-Chu deve essere testato disegnando i bordi della tela. Per farlo, esegui ognuno in un nuovo terminale:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nDopo questo, dovresti vedere un contorno della tela in RViz:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nNel terminale premi \\\"S\\\" per eseguire il test. L'effettore terminale del robot dovrebbe muoversi proprio sopra i bordi della tela e il pennello dovrebbe toccare delicatamente la tela durante tutto il movimento. Se non è così, prova a ricalibrare. Se il modello della tela è ruotato in modo errato, puoi ruotarlo cambiando il quaternione in Matlab.\\n\\n## Creazione di arte\\nHai bisogno di 6 moduli di base per far funzionare tutto:\\n- Interfaccia EKI;\\n- MOVEit + RViz;\\n- Trasmissione dei frame dell'ambiente;\\n- Servizio di conversione delle immagini;\\n- Modulo di disegno delle traiettorie;\\n- Trigger di avvio.\\n\\nLanciamoli uno per uno.\\n\\n### Interfaccia Eki\\nSu KRC4 avvia `eki_hw_interface`, su NUC in un nuovo terminale fai:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz e MOVEit\\nHai bisogno di un pianificatore e di una simulazione. Avviali con\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Ambiente\\nIndica al robot dove si trovano il barattolo di vernice e la tela. Nota che non è necessario avviare il nodo `draw workspace`, il `tf_broadcaster` condivide le dimensioni della tela. Non le mostra solo in RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Processore di immagini\\nTutte le immagini in ingresso devono essere elaborate. Avvia il servizio.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nQuando riceve la chiamata, elabora un'immagine con un filtro HP e crea un file rosbag con le traiettorie.\\n\\n### Disegnatore di traiettorie\\nLo script principale qui è il disegnatore di traiettorie stesso. Aspetta l'immagine, chiama il servizio TextConverter e disegna il dipinto.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Invia al robot un'immagine da disegnare\\nIl robot ascolta un ROS-topic specifico dove devi passare il percorso di un'immagine desiderata. L'immagine dovrebbe essere quadrata (larghezza uguale altezza) e composta da linee. Invia il percorso:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nDopo di che, due finestre si aprono mostrando i contorni e le tracce. Chiudile e guarda Gaka-Chu disegnare. Stai attento alla sicurezza e sii sempre pronto a premere il pulsante di arresto di emergenza.\\nQuando Gaka-Chu finisce la sua arte, puoi inviare un altro percorso per l'immagine e il pittore ripete l'intero processo.\\n\"}},{\"node\":{\"id\":\"e3da16eeb809803d94f1f112f163fffe\",\"title\":\"Collega un dispositivo Amazon FreeRTOS a Robonomics tramite MQTT\",\"path\":\"/docs/it/freertos-mqtt/\",\"content\":\"\\nEcco la dimostrazione di come un microcontrollore che esegue [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) può essere collegato alla rete Robonomics tramite MQTT. Si prega di controllare [questo repository](http://github.com/khssnv/freertos_mqtt_robonomics_example) per il codice sorgente del progetto.\\n\\nUtilizziamo [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) con distribuzione FreeRTOS e implementazione MQTT fornita da [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) mentre Espressif è un fornitore del microcontrollore utilizzato.\\n\\nInoltre, c'è un sensore [PMS-3003](http://www.plantower.com/en/content/?107.html) a scopo dimostrativo. Il sensore misura la presenza di particolato nell'aria e può essere utilizzato per stimare la qualità dell'aria.\\n\\nLa qualità dell'aria non è un argomento dell'articolo, è possibile trovare ulteriori informazioni al sito web dell'OMS: [Inquinamento atmosferico ambientale (all'aperto)](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). L'obiettivo del sistema è pubblicare le misurazioni del sensore sulla rete Robonomics di Airalab.\\n\\n## Configurazione hardware\\n\\nColleghiamo il PIN5 TXD di PMS3003 a ESP32 DevKitC IO17 per trasferire le misurazioni tramite UART.\\nEntrambi i dispositivi richiedono anche alimentazione e massa comune.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Flusso dei dati\\n\\nAl fine di inviare le misurazioni del sensore alla rete Robonomics, a livello di firmware il nostro obiettivo è ottenere i dati da un sensore tramite il protocollo di comunicazione integrato che supporta (UART nel nostro caso) e passarli a un'istanza AIRA tramite MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nNel nostro esempio utilizziamo l'implementazione cloud di AIRA disponibile tramite indirizzo IP pubblico e nome di dominio assegnato.\\nNell'istanza AIRA configuriamo il broker MQTT `mosquitto` e ci iscriviamo al topic `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` per ricevere messaggi da MQTT.\\n\\nQuindi passiamo i messaggi al writer `robonomics io` tramite pipe.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nOra i dati sono disponibili nella rete Robonomics e possiamo leggerli nuovamente con `robonomics io`.\\n\\n## Firmware\\n\\nUtilizziamo l'applicazione di esempio [ESP-MQTT con trasporto TCP](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) come base.\\n\\nModifichiamo solo `main/app_main.c` per la connessione UART al sensore, la sincronizzazione dell'ora SNTP e la routine periodica di pubblicazione MQTT.\\n\\nSe stai cercando di ripetere il progetto e si tratta del tuo primo progetto basato su ESP IDF, ti preghiamo di seguire prima la guida di programmazione ESP-IDF di Espressif's ESP-IDF](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) per familiarizzare con le operazioni del firmware come configurazione, compilazione e caricamento con lo strumento `idf.py`.\\n\\n### Configurazione Wi-Fi\\n\\nAl fine di comunicare con l'istanza AIRA distribuita nel cloud, il nostro microcontrollore richiede una connessione Internet.\\nUtilizziamo il Wi-Fi di ESP32 per questo.\\nEspressif fornisce strumenti per configurare il Wi-Fi integrato.\\nNel nostro esempio utilizziamo un ambiente di sviluppo con Ubuntu 20.04 GNU/Linux.\\nPer configurare il Wi-Fi andiamo nella cartella del progetto e avviamo lo strumento di configurazione SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nQuindi impostiamo il nome SSID e la password del punto di accesso Wi-Fi nella sezione `Example Connettiion Configurazione`.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### Configurazione del punto di accesso MQTT\\n\\nCi sono due cose da configurare per MQTT.\\nLa prima è l'indirizzo del broker MQTT.\\nÈ configurabile con lo strumento di configurazione SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nImposta l'URL del broker nella sezione `Example Configurazione`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nLa seconda cosa è il topic MQTT.\\nLo impostiamo nel firmware con il prefisso del nome del progetto seguito dal nostro indirizzo MAC ESP32.\\nCiò ci dà `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` per il nostro particolare microchip.\\n\\n## Da MQTT a Robonomics\\n\\nIniziamo controllando se riceviamo dati tramite MQTT.\\nPossiamo iscriverci al topic del broker MQTT Mosquitto che il dispositivo pubblica.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nQui portiamo il pacchetto `mosquitto` nel nostro ambiente per utilizzare l'utilità `mosquitto_sub`.\\nPoi ci iscriviamo all'argomento impostato nel firmware.\\nAbbiamo ottenuto le nostre misurazioni, il che significa che AIRA riceve correttamente i dati tramite MQTT.\\nOra facciamo passare questi messaggi alla rete Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nQui utilizziamo l'utilità `robonomics` per pubblicare messaggi nel canale pubsub `/freertos_mqtt_robonomics_example`.\\nSpecifichiamo `bootnodes` per garantire almeno una connessione stabilita.\\n\\nOra stiamo leggendo questi messaggi dallo stesso canale pubsub.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Risorse originali utilizzate\\n\\n* Pinout ESP32 DevKitC da GoJimmy's blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* Struttura dati e decodificatore PSM3003 da OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Grazie a tutti!**\\n\"}},{\"node\":{\"id\":\"8caf5b97613983bb123e297a978cd478\",\"title\":\"Come modificare Wiki\",\"path\":\"/docs/it/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki è open source. Ogni correzione è benvenuta: correzione di errori, refusi, informazioni poco chiare o obsolete, traduzione in qualsiasi lingua. Avrai bisogno di un [GitHub](https://github.com/) account.**\\n\\n\\n## Come modificare\\n\\nSe hai bisogno di modificare i documenti di Robonomics Wiki, segui questi passaggi\\n\\nAssicurati di aver [Node.js](https://nodejs.org/en/download/package-manager/) e [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) installato.\\n\\n### 1. Clona il repository\\n\\nInnanzitutto, devi clonare il repository wiki:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nVai nella directory del repository e esegui i seguenti comandi:\\n\\n`usando npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`usando yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Servi localmente (sviluppo, sviluppo-m1)\\n\\nQuindi distribuisci il progetto in locale: \\n\\n```\\ngridsome develop\\n```\\n\\n> Se hai l'errore `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`, esegui il seguente comando:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Crea una PR\\n\\n[Crea una pull request](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) a [repo wiki](https://github.com/airalab/robonomics-wiki)\\n\\n## Componenti\\n\\n### Asciinema\\nRobonomics Wiki supporta Asciinema. Per inserire Asciinema, segui queste istruzioni:\\n* Importa il componente dopo il blocco frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* Inserisci come paragrafo separato `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, dove vid è l'ID di un asciicast specifico\\n\\n> Puoi ottenere lo script del widget per un asciicast specifico cliccando sul link “Embed” nella pagina dell'asciicast.\\n> Apparirà così:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Documentazione di Asciinema](https://asciinema.org/docs/embedding)\\n\\nNell'esempio sopra vid è 14.\\n\\n### Codice\\n\\nPuoi aggiungere extra utili al tuo codice:\\n\\n`codice con pulsante di copia`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\no \\\"codice con riga aggiuntiva\\\".\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Proprietà per code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nI documenti in Robonomics Wiki contengono un blocco frontmatter. Deve essere nella parte superiore del file Markdown e deve avere la forma di un valido set YAML racchiuso tra linee tratteggiate. Tra le linee tratteggiate, puoi impostare o modificare le seguenti opzioni:\\n\\n```YAML\\n---\\ntitle: How to contribute # Titolo della pagina, non è necessario duplicarlo nel testo\\ncontributors: [positivecrash] # Principali contributori (che curano attivamente questa pagina). È richiesto il nickname di GitHub, senza simboli aggiuntivi\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Installaation\\n    # Strumenti utilizzati per il test della tecnologia\\n---\\n```\\n\\n### Grid \\nAiuta ad aggiungere un layout a griglia agli elementi:\\n\\n- Usa prima il componente wrapper di griglia: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- E poi usa quanti componenti di elementi di griglia desideri all'interno del wrapper:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Proprietà per robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Immagini\\n\\n#### Come caricare \\nCarica l'immagine nella cartella `/docs/images/url-del-tuo-doc`\\n* Se l'immagine deve essere localizzata, inseriscile tutte in una cartella\\n* Usa l'appendice di localizzazione nel nome delle immagini se è localizzata, ad esempio `image_en.jpg`\\n* Assicurati che la tua immagine sia ottimizzata per il web e allo stesso tempo abbia un aspetto buono\\n\\n#### Come inserire \\n\\nCi sono due modi per inserire immagini nei tuoi documenti:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSi consiglia di inserire le immagini con il tag integrato `<robo-wiki-picture>`, tuttavia è possibile utilizzare anche il modo standard per i file Markdown.\\n\\n</robo-wiki-note>\\n\\n`con didascalia`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`o senza didascalia` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`o immagine semplice` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`o immagine semplice con didascalia`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`immagine con attributo alt`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Proprietà per robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Note e avvisi\\nPuoi aggiungere note e assegnare loro tipi specifici:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`nota con titolo`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`nota con contenuto`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`nota con titolo e contenuto`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Proprietà per robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nPuoi aggiungere schede al documento:\\n\\n- Usa il componente wrapper delle schede: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- E poi usa quanti componenti di elementi di schede desideri all'interno del wrapper:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`schede orizzontali`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`schede verticali`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`elemento di scheda con bordo`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Proprietà per robo-wiki-tabs (wrapper)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Proprietà per robo-wiki-tab (elemento)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Titolo con ancoraggio\\nPuoi creare titoli personalizzati con ancoraggi e assegnare loro un valore specifico\\n\\n`titolo con ancoraggio`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nO\\n\\n`titolo senza ancoraggio`.\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Proprietà per robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Video\\n\\nCi sono due modi per inserire video nei tuoi documenti:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSi consiglia di inserire i video con il tag integrato `<robo-wiki-video>`, tuttavia è possibile utilizzare anche il modo standard per i file Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nÈ necessario specificare il formato del video\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Proprietà\\n\\n- Se stai aggiungendo un file con una dimensione superiore a <span style=\\\"color:#af1c1c\\\">10MB</span>, per favore, caricalo sul server, non nel repository.\\n\\n- Puoi utilizzare qualsiasi proprietà per [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Formati accettabili - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nPuoi incorporare qualsiasi video di YouTube nel documento inserendo il link di condivisione come paragrafo separato senza virgolette o tag aggiuntivi, ad esempio: `https://youtu.be/kQaSwNYHJQ8`\\n\\nTuttavia, se hai bisogno di una riproduzione automatica devi utilizzare un componente speciale: \\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Proprietà per robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Come modificare la navigazione della barra laterale\\n\\nSe hai bisogno di modificare la navigazione della barra laterale di Robonomics Wiki, segui questi passaggi:\\n\\n* Modifica il file `/data/sidebar_docs.yaml`.\\n\\n* Decidi dove posizionare il tuo documento\\n\\n* Utilizza YAML valido per `/data/sidebar_docs.yaml` e fai affidamento sulla struttura del file esistente\\n\\n* **NOTA IMPORTANTE** se stai utilizzando lo stesso documento in diverse sezioni/sottosezioni ad esempio: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Immagine preinstallata per Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nASSICURATI DI AGGIUNGERE IL PARAMETRO `topic` COME SEGUE: \\n\\n(per il corretto funzionamento della navigazione)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## Come aggiungere una navigazione personalizzata per i documenti\\n\\n* Modifica il file `/data/sidebar_docs.yaml`.\\n\\n* Trova il documento giusto e aggiungi i parametri `prev` e `next` in questo modo:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Se desideri rimuovere completamente la navigazione, aggiungi il parametro `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Se desideri rimuovere solo la navigazione `pagina precedente` o `pagina successiva`, aggiungi il parametro `withoutPrev` o `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\no\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"6c4d079097412091b35022d808125efd\",\"title\":\"Get Notified When Door Opens\",\"path\":\"/docs/it/door-notification/\",\"content\":\"\\nIn this article you will install the Telegram bot notifier integration and configure an automation, which will send to your Telegram account notification when a door is open.\\n\\n## Telegram Bot Notifications\\n\\nFirst, you need to create a personal Telegram bot. For this go to the [special Telegram bot @BotFather](https://t.me/botfather) and follow instruction. \\nSave your token for accessing the HTTP API.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nKeep your token **secure** and store it **safely**, it can be used by anyone to control your bot \\n\\n</robo-wiki-note>\\n\\nNext step is find your ***User Chat ID***. For this use the next [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nNow let's install \\\"Telegram broadcast\\\" integration. This integration will send messages to your Telegram.\\n\\nFor Robonomics pre-installed image, Home Assistant Docker or Home Assistant Core you have to edit `configuration.yaml`. Connetti to your Raspberry Pi via `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nPaste next lines to the end of file. Insert your **bot API key** and **your User Chat ID**. Also create a name for your notify service:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Save configuration and reload Home Assistant.**\\n\\n\\nAs result, in your Home Assistant service will be created service, which will send any message to the Telegram chat with you. \\nYou can check it in Developer Tools menu on Home Assistant web interface. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Door Open Notification\\n\\nNow it's time to create automation. First, you import blueprint to your Home Assistant from this link:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nAnd create automation:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nNow you will receive message from Telegram bot every time the door is open.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nYou can use this automation with any doors/windows in your home.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"2bfac5c14992b8afd16290cd5232aec1\",\"title\":\"Gemelli digitali\",\"path\":\"/docs/it/digital-twins/\",\"content\":\"  \\n**Immagina di avere un dispositivo o un sistema complicato che ha diversi moduli da mantenere e richiede alcuni account per essere utilizzato. Per tenerli tutti in un unico posto o per codificare alcune funzionalità con account separati o, ad esempio, per impostare diverse origini di dati per diversi flussi di informazioni, viene utilizzato il modulo Gemello digitale.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Si prega di prestare attenzione al fatto che questi tutorial vengono dimostrati su un'istanza locale di Robonomics Node. Configura la tua con [queste istruzioni](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Panoramica della teoria\\nQualsiasi account può creare e gestire un Gemello digitale. Il Gemello può essere immaginato come una sorta di tabella con i seguenti contenuti:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nDove:\\n* **DT id** è un indice di Gemello digitale univoco non firmato.\\n* **Topic name** è un dato esadecimale `H256` o ASCII di lunghezza 32 byte, come [`Lancio`](/docs/launch) parametro estrinseco. \\nAd esempio: `0x1234....FF` o `hello.parachain.robonomics.world`.\\n* **Source** - è un indirizzo di Account.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Come discusso in precedenza nella panoramica dell'estrinseco di lancio, l'`H256` può essere rappresentato come un CID IPFS codificato (vedi\\n  [strumento Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) per questo).\\n  Pertanto, i topic possono essere utilizzati anche come archivio dati, ad esempio, una descrizione del modulo di un Gemello.\\n\\n</robo-wiki-note>\\n\\n\\n## Crea Gemello digitale\\n\\n### 1. Vai a Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Scegli digitalTwin -> create dal menu a discesa degli estrinseci possibili\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nInvia la transazione. Qui non sono necessari parametri per creare un Gemello. Sarà assegnato un indice e solo il proprietario del Gemello digitale sarà in grado di aggiungere/modificare i topic del Gemello da questo momento in poi.\\n\\nL'ID del Gemello può essere trovato nella pagina di panoramica dell'Esploratore.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Aggiungi Topic\\n\\n### Scegli digitalTwin -> setSource dal menu a discesa degli estrinseci possibili\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID, che è stato ottenuto sulla pagina Esplorar.\\n* `topic` - nome del topic `H256` precedentemente discusso. In questa immagine è una stringa di 32 simboli.\\n* `source` - indirizzo dell'account da associare al topic.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Fai attenzione che il topic può essere sovrascritto con un altro indirizzo di origine se necessario.\\n\\n</robo-wiki-note>\\n\\nFirma e invia l'estrinseco.\\n\\n## Explore\\n\\nPuoi trovare tutte le informazioni sui Gemelli digitali esistenti nel modulo di archiviazione `digitalTwin` dello stato della catena in `eveloper -> Chain state`.\\n\\n- Numero totale di Gemelli - `total()`;\\n- Proprietario del Gemello digitale - `owner(u32)`;\\n- Informazioni sui topic di un Gemello digitale - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"5b9b86cb68db13aae7f209f7a8bf6e5c\",\"title\":\"Datalog\",\"path\":\"/docs/it/datalog/\",\"content\":\"\\n**Ora che hai dei fondi sul tuo account, puoi inviare estrinseci. Il primo da provare è un Datalog. Ti consente di archiviare dati in modo persistente nella blockchain. Immagina uno storage distribuito e cripto-protetto per i tuoi dati e questo è proprio quello!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nSi prega di prestare attenzione al fatto che questi tutorial vengono dimostrati su un'istanza locale di Robonomics Node. Configura la tua con [queste istruzioni](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Vai su  Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Scegli datalog -> record dal menu a tendina degli extrinsics possibili\\n\\nScegli anche un account con cui desideri inviare l'extrinsic. Compila il campo record.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog supporta una stringa con un massimo di 512 byte. Per archiviare grandi quantità di dati è possibile utilizzare [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Invia la transazione\\n\\nFirma e invia la transazione con un account creato in precedenza utilizzando l'estensione o l'applicazione DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  È anche possibile cancellare **TUTTI** i tuoi record con *datalog -> erase* call.\\n\\n</robo-wiki-note>\\n\\n## 4. Verifica il tuo datalog nello storage\\n\\nPer fare ciò, vai su *Developer -> Chain state*, seleziona *datalog -> datalogIndex*, specifica il tuo account e premi il \\n\\\"+\\\" pulsante per ottenere gli indici dei record del tuo account e quindi esplora quello di cui hai bisogno con *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Esplorar\\\">\\n\\n  Tutti gli eventi, inclusi i record del datalog, possono essere visualizzati nel flusso degli eventi nell'*Explorer*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"75f07564f5d179a8142f57ed3a044334\",\"title\":\"Crea un'identità digitale gestita da Ethereum\",\"path\":\"/docs/it/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nUno dei servizi di Robonomics è [Registrazione del passaporto digitale](https://dapp.robonomics.network/#/passport/) per dati arbitrari. Il servizio ti permette di creare un'identità digitale salvando gli hash dei dati sulla blockchain pubblica e assegnando un indirizzo unico.\\n\\nPuoi trovare il servizio \\\"Registrazione del passaporto digitale\\\" in [Robonomics DApp](https://dapp.robonomics.network/) nella sezione \\\"Servizi\\\" o semplicemente segui questo [collegamento diretto](https://dapp.robonomics.network/#/passport/).\\n\\n## Videoguida\\n\\nIl video seguente mostra lo stato di avanzamento della registrazione del Robonomics Whitepaper:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Passo dopo passo nelle immagini\\n\\n### 1. Apri il servizio\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Aggiungi le informazioni e i file necessari\\n\\nTieni presente che è possibile aggiungere più immagini.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Firma la richiesta\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Approvare i token\\n\\nIl servizio prevede il pagamento di una piccola tariffa. Ma prima devi approvare la quantità richiesta di token da spendere dal tuo account.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Accetta l'offerta e firma nuovamente il messaggio\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Dai un'occhiata al passaporto creato\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nIl processo di registrazione richiede del tempo. Alla fine vedrai un collegamento all'identità creata.\\n\"}},{\"node\":{\"id\":\"443d8a8d13f25c29a4147d75623cbcef\",\"title\":\"Crea un account per Robonomics Parachain\",\"path\":\"/docs/it/create-account-in-dapp/\",\"content\":\"\\n**Per interagire e operare con Robonomics Parachain, gli sviluppatori e gli utenti devono creare un account sul portale Polkadot / Substrate. L'account esegue le funzioni di base della rete: il tuo indirizzo di rete pubblica (la chiave pubblica), il controllo dell'accesso all'indirizzo e ai fondi (la chiave privata), l'invio di transazioni alla rete, la visualizzazione dei token e il loro importo, ecc. Di seguito sono riportate due modi principali per creare un account per Robonomics Parachain**\\n\\n## 1. Utilizzando l'estensione del browser Polkadot{.js}\\n\\nL'estensione di Polkadot fornisce un meccanismo per generare l'account e interagire con tutti i progetti Polkadot / Kusama, inclusi Robonomics Parachain. Questo non è il modo più sicuro per gestire il tuo account, ma è il più conveniente in termini di equilibrio tra sicurezza e usabilità.\\n\\n## 1.1. Installaa l'estensione del browser\\n\\nL'estensione del browser è disponibile per [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) e [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (oltre ai browser basati su Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Apri l'app Robonomics Parachain\\n\\nVai a [App Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) su Polkadot / Substrate Portal. Se è la prima volta che accedi al portale, richiederà l'accesso all'estensione del browser, quindi consenti l'accesso. \\n\\nOnce you've opened the app, take a look at the top left corner. The name of the network, its icon and the number of the last block are displayed tqui. Clicking on this area will open a list of all Polkadot / Kusama networks, including test networks and local nodes. You can switch between networks by selezionaing the required one e premiing the `Switch` Assicurati di essere connesso a Robonomics Parachain ora **1.3. Aggiorna i metadati dell'estensione**. \\n\\nUna volta aperta l'app, dai un'occhiata all'angolo in alto a sinistra. Qui vengono visualizzati il nome della rete, la sua icona e il numero dell'ultimo blocco. Facendo clic su quest'area si aprirà un elenco di tutte le reti Polkadot/Kusama, incluse le reti di test e i nodi locali. È possibile passare da una rete all'altra selezionando quella richiesta e premendo il pulsante `Switch`. **Assicurati di essere connesso a Robonomics Parachain adesso**.\\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Aggiorna metadati dell'estensione\\n\\nÈ molto probabile che l'app ti chieda di aggiornare i metadati dell'estensione per visualizzare le informazioni corrette sulla catena a cui sei connesso. Vai su  **Settings -> Metadata**, premi il pulsante `Update metadata` e poi, nella finestra pop-up, consenti all'estensione di farlo.\\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Crea un account nell'estensione \\n\\nApri l'estensione del browser Polkadot{.js}. Fai clic sul pulsante più grande o seleziona `Create new account` dalla piccola icona più in alto a destra. Dovresti vedere il seguente menu, con il seme mnemonico generato sotto forma di dodici parole e l'indirizzo.\\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nIl seme è la tua chiave per l'account. Conoscere il seed consente a te (o a chiunque altro conosca il seed) di ottenere il controllo su questo account e persino di ricrearlo, se dimentichi la password. **È molto importante archiviarlo in un luogo sicuro**, preferibilmente su carta o altro dispositivo non digitale, non in un archivio digitale o su un computer. \\n\\nSalva il seed e premi `Next step`. Dovresti vedere il seguente menu.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* ti consente di scegliere quale delle reti verrà utilizzata esclusivamente per questo account. Puoi utilizzare lo stesso indirizzo su più reti, tuttavia, per motivi di privacy, è consigliabile creare un nuovo indirizzo per ogni rete che utilizzi. \\nSeleziona la rete Robonomics dal menu a discesa. Se non riesci a trovare la rete Robonomics, molto probabilmente non hai aggiornato i metadati, torna indietro e fallo.\\n\\n    - Noterai che il formato dell'indirizzo e dell'icona dell'account cambieranno - questo è normale. I diversi formati di rete sono semplicemente altre rappresentazioni della stessa chiave pubblica. \\n\\n- *Name* è solo il nome dell'account per il tuo uso personale. Non viene memorizzato nella blockchain e non sarà visibile ad altri utenti. \\n\\n- *Password* viene utilizzato per crittografare le informazioni del tuo account. Dovrai reinserirlo quando firmi transazioni sul portale. Creane uno e ricordatelo.\\n\\nDi conseguenza, dopo aver creato un account, lo vedrai nell'elenco degli account nell'estensione Polkadot{.js}. Cliccando sui tre puntini, puoi rinominare l'account, esportarlo, rimuoverlo dall'estensione e cambiare la rete utilizzata per l'account. \\n\\nInoltre, l'account verrà visualizzato nel menu **Account -> Account** del portale, dove verrà notato che è stato inserito utilizzando l'estensione.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Direttamente su Robonomics Parachain App\\n\\nPuoi utilizzare l'interfaccia utente sul Portale Polkadot / Substrate per creare un account. Può essere utilizzato per lo sviluppo e i test. \\n\\n## 2.1. Apri Robonomics Parachain App\\n\\nVai a [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) su Polkadot / Substrate Portal. **Controlla nell'angolo in alto a sinistra che sei connesso a Robonomics Parachain**.  \\n\\nVai a **Accounts -> Accounts** e premi il pulsante `Add account`.\\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Crea Account\\n\\nDovresti vedere il seguente menu popup con il seed dell'account. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nHa due forme: *Mnemonic* (leggibile dall'uomo) e *Raw* (una sequenza di cifre e lettere). Salva la frase di recupero in modo sicuro e premi `Next`.\\n\\n> Puoi anche cambiare il tipo di crittografia per la creazione dell'account, per farlo apri `Advanced creation options` e scegli il tipo (`ed25519` nella foto).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nNel menu successivo, devi impostare il nome dell'account e la password, simili alle istruzioni dell'estensione descritte sopra.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nCliccando sul pulsante `Next` ti porterà all'ultima finestra. Clicca `Save` per completare la creazione dell'account. Verranno generati anche dei file JSON di backup che dovresti conservare in modo sicuro. In seguito potrai utilizzare questo file per recuperare il tuo account se ricordi la password.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Aggiungi l'account ed25519 all'estensione Polkadot\\n\\nPotrebbe essere necessario aggiungere l'account creato all'estensione Polkadot.js (per l'account ed25519 puoi farlo solo con il file JSON di backup). Per farlo devi creare un file di backup dell'account. Premi sui tre puntini sul tuo account e scegli `Create a backup file for this account` e scrivi la tua password.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nQuindi apri un'estensione e premi il pulsante `+` in alto a destra, quindi scegli `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nNella finestra aperta rilascia il file salvato, inserisci la password e premi `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Account creato con successo \\n\\nOra puoi operare completamente con il tuo account appena creato. Invia e ricevi token, messaggi, scrivi datalog e altro ancora. Sentiti libero di esplorare tutte le funzionalità dell'app. Per copiare l'indirizzo del tuo account basta fare clic sulla sua icona, l'indirizzo verrà copiato negli appunti. \\n\\nSe desideri saperne di più sugli account Polkadot / Kusama e su ulteriori modi per crearli, puoi trovare ulteriori informazioni [qui](https://wiki.polkadot.network/docs/learn-accounts) e [qui](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"3dfd3991f780eaa297f69a9a59c53d64\",\"title\":\"Come contribuire alle risorse di Robonomics\",\"path\":\"/docs/it/contributing/\",\"content\":\"\\nRobonomics Network è un progetto open source e vogliamo che chiunque possa contribuire facilmente. Puoi creare articoli, suggerire modifiche, migliorare la documentazione o eseguire test. Se vuoi contribuire, per favore, apri un nuovo problema o crea una richiesta pull nello stesso repository.\\n\\n## Principali repository di Robonomics \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Progetto wiki principale\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Sito principale ufficiale di Robonomics Network\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Home per i servizi web di Robonomics\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Dapp ufficiale\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Sito web ufficiale di Robonomics Academy\\n\\n### Regole per la segnalazione\\n\\nQuando apri una nuova segnalazione, non dimenticare alcune regole di base per la segnalazione:\\n\\n1. Scegli la repository esatta a cui desideri inviare una segnalazione.\\n\\n2. Se stai segnalando un bug, assicurati che il bug non sia già stato segnalato.\\n\\n3. Assicurati di includere un titolo e una descrizione chiara, nonché tutte le informazioni rilevanti possibili.\\n\\n4. Per favore, aggiungi un prefisso alla tua segnalazione tra i seguenti: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Richieste di pull\\n\\nQualsiasi repository Robonomics può essere soggetto a richieste pull o modifiche da parte dei contributori, laddove ritieni di avere qualcosa di prezioso da aggiungere o modificare. Per favore, non dimenticare le regole di base per i contributori.\\n\\n### Regole per contribuire\\n\\n1. Le richieste di pull sono preferite alle segnalazioni, se hai delle correzioni, specialmente per piccoli cambiamenti come errori di battitura.\\n\\n2. Assicurati che la descrizione della richiesta di pull descriva chiaramente il problema e la soluzione. Includi il numero di segnalazione rilevante, se applicabile.\\n\\n3. Per favore, non correggere spazi bianchi, formattare il codice o apportare modifiche puramente estetiche.\\n\\n4. Per favore, cerca di aderire allo stile, al linguaggio e al layout predominanti di Markdown.\\n\\n\\n\"}},{\"node\":{\"id\":\"ef5a75f14cc2e2d772f91a0a2986985d\",\"title\":\"Servizio di compensazione\",\"path\":\"/docs/it/carbon-footprint-service/\",\"content\":\"\\nL'esempio di lavoro è nel video:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nServizio per compensare l'impronta di CO2 bruciando token nella rete di Statemine. \\nLa CO2 prodotta viene calcolata come segue: i dati provenienti dal dispositivo in Wh vengono moltiplicati per coefficienti che dipendono dalla regione. 1 tonnellata di CO2 è coperta dal consumo di 1 token. [Qui](/docs/carbon-footprint-sensor) sono le istruzioni per collegare il dispositivo.\\n\\n## Scenario\\n\\n1. Registra un nuovo dispositivo in Digital Twin nella rete Robonomics\\n2. Una volta ogni intervallo, ottenere gli ultimi dati da tutti i dispositivi e moltiplicarli per il coefficiente che dipende dalla regione\\n3. Sommare i dati e convertirli in tonnellate di CO2\\n4. Sottrarre il numero totale di token bruciati dai dati attuali \\n5. Bruciare un numero intero di token nella rete di Statemine \\n6. Salvare il numero totale di token bruciati nel database locale e nel Datalog \\n\\n\\n## Installaazione\\n\\nClonare il repository e modificare il file di configurazione.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Configurazione description\\n\\nNon modificare `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network wqui Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nI coefficienti per l'energia non rinnovabile sono stati presi da [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) e memorizzati in `utils/coefficients.py`. \\n\\n## Lancio\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"a2b4c6da4fb8ec93edca6f06122aa24e\",\"title\":\"Collega il sensore\",\"path\":\"/docs/it/carbon-footprint-sensor/\",\"content\":\"\\nL'esempio di lavoro è nel video:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Requisiti\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (o uno dei [supportati](https://www.zigbee2mqtt.io/information/supported_adapters.html))\\n\\nIl servizio è in esecuzione su Raspberry Pi e contatta la presa intelligente tramite protocollo zigbee.\\n\\n## Zigbee stick\\n\\nSe hai JetHome USB JetStick Z2, ha già il firmware necessario, quindi non è necessario flasharlo. Ma se hai un altro adattatore, devi prima flasharlo con il software zigbee2MQTT. Puoi trovare le istruzioni per il tuo dispositivo [qui](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nCollega l'adattatore e verifica l'indirizzo dell'adattatore (potrebbe anche essere `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nPotrebbe essere necessario prima accedere alla porta USB. Aggiungi il tuo utente a `dialout` gruppo (funziona per ubuntu, ma il nome del gruppo potrebbe essere diverso su altri sistemi operativi).\\nPer ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nPer arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nQuindi esci e accedi nuovamente o riavvia il computer.\\n\\n## Installaazione\\n\\nClona il repository:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Configurazione\\n\\nVai a `data/configuration.yaml` e imposta `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nPotresti anche voler compilare i campi `server` and `port` con le informazioni corrispondenti. Nel campo `server` utilizza l'IP del `docker0` bridge per stabilire la connessione: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nQui il tuo indirizzo è `172.17.0.1`.\\n\\nQuindi crea il file config/config.yaml con le seguenti informazioni e imposta la tua posizione (puoi cercare su https://countrycode.org/ per il codice ISO a 3 lettere):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Collega la spina\\n\\nPrima esecuzione:\\n\\n```\\ndocker-compose up     \\n```\\n\\nPer passare alla modalità di accoppiamento sulla spina, premere a lungo il pulsante di accensione per alcuni secondi fino a quando la luce inizia a lampeggiare rapidamente in blu.\\n\\nNei log dovresti vedere ora che il tuo plug ha iniziato a pubblicare su mqtt.\\n\\n\\n## Dopo l'accoppiamento\\n\\nSe non vuoi consentire ad altri dispositivi di accoppiarsi con la tua chiavetta, ora dovresti andare su `data/configuration.yaml` and set `permit_join: false`. Restart service (use 'Ctrl+C' and \\n\\n```bash\\ndocker-compose up     \\n```\\nancora una volta per inviare le modifiche).\\n\\n## In esecuzione\\nAll'avvio verrà creato l'account per la spina. \\n> Se hai già un account dovresti aggiungere il suo seme al file `config.config.yaml` nella sezione `device_seed`:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nDopo aver creato l'account, vedrai l'indirizzo nei log (il seed verrà aggiunto a `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nDevi trasferire alcuni token a questo account per le commissioni di transazione, puoi farlo su [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nIl servizio vedrà che hai abbastanza token, nei log vedrai:\\n```\\nplug               | Balance is OK\\n```\\nIl servizio vedrà i messaggi mqtt dalla spina e utilizzerà l'energia in modo sicuro. Ogni ora (puoi modificare il timeout in `config/config.yaml` in `sending_timeout` sezione, il timeout è in secondi) verrà creato un datalog con le seguenti informazioni:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"32bfc9a175b9fb7888d0d90ef9ef347e\",\"title\":\"Servizi di backup\",\"path\":\"/docs/it/backup-services/\",\"content\":\"\\n**In questo articolo, imparerai come generare backup della configurazione di Home Assistant e ripristinarla queo necessario. Per creare i backup, viene chiamato un servizio che genera un archivio sicuro con i file di configurazione. Inoltre, il servizio aggiunge la configurazione di Mosquitto brocker e Zigbee2MQTT al backup se esistono. Successivamente, il servizio aggiunge l'archivio a IPFS e memorizza l'ID risultante in Robonomics Digital Twin.**\\n## Creazione del backup della configurazione di Home Assistant\\n\\nCreare un backup consente di ripristinare facilmente la configurazione di Home Assistant in caso di guasto.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ATTENZIONE\\\">\\n\\nPer eseguire il backup e ripristinare la configurazione, è necessario utilizzare un **gateway IPFS personalizzato** come Pinata. Senza di esso, il backup verrà memorizzato solo sul nodo IPFS locale, il che potrebbe impedire il ripristino della configurazione di Home Assistant in caso di guasto del nodo locale.\\n\\n</robo-wiki-note>\\n\\n1. Nell'interfaccia web di Home Assistant vai su `Developer Tools` -> `Services`. Cerca `Robonomics: Save Backup to Robonomics` e premi `CALL SERVICE`.\\n\\n2. Aspetta finché non compare la notifica `Backup was updated in Robonomics` apparire in `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ATTENZIONE\\\">\\n\\nNon cercare di creare un backup o ripristinare la configurazione immediatamente dopo aver caricato Home Assistant e Robonomics Integration. Per favore, **aspetta circa 5 minuti** per consentire il completamento dell'installazione iniziale\\n\\n</robo-wiki-note>\\n\\nArgomenti del servizio:\\n- **Backup completo**  (default: False) - aggiungi il database al backup, in modo che venga memorizzato anche lo storico degli stati delle entità.\\n- **Percorso del file di password di mosquitto** (default: `/etc/mosquitto`) - Se hai utilizzato i metodi di installazione di Home Assistant Core o Docker e non hai il percorso predefinito per Mosquitto brocker, dovresti modificare questo parametro. *Non necessario per Home Assistant OS o Superviser*.\\n\\n## Ripristino della configurazione di Home Assistant da un backup\\n\\nPer ripristinare la configurazione, è necessario avere installato Home Assistant e Robonomics Integration. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ATTENZIONE\\\">\\n\\nPer garantire un ripristino corretto della configurazione nei metodi di installazione di Home Assistant Core e Docker, è necessario eseguire ulteriori passaggi di configurazione come descritto alla fine della pagina.\\n\\n</robo-wiki-note>\\n\\n1. Installaa Home Assisntant con Robonomics Integration (se non è ancora installato), seguendo i passaggi dell'articolo per il [metodo di installazione desiderato](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2. [Configurazione dell'integrazione Robonomics](https://wiki.robonomics.network/docs/robonomics-hass-integration) usando **gli stessi seed** che hai usato nella configurazione precedente di Robonomics. Se la tua sottoscrizione è scaduta, [riattivala](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. Nell'interfaccia web di Home Assistant vai alla `Developer Tools` -> `Services`. Search for `Robonomics: Restore from the Backup in Robonomics` and e quindi, nella finestra popup, permetti all'estensione di farlo. `CALL SERVICE`. Vai alla `Overview` pagina, per verificare lo stato del backup.\\n\\n4. Dopo il ripristino, Home Assistant si riavvierà automaticamente. Se per qualche motivo Home Assistant non si riavvia, puoi verificare lo stato del ripristino monitorando lo stato dell' `robonomics.backup` entità. Se lo stato è `restored` dovrai riavviare manualmente Home Assistant andando su `Settings` > `System` e cliccando sul pulsante `RESTART` posizionato nell'angolo in alto a destra.\\n\\n5. Se il tuo backup include la configurazione di Zigbee2MQTT o Mosquitto, è necessario riavviare questi servizi per abilitare la nuova configurazione. Puoi farlo manualmente riavviando i servizi singolarmente, oppure puoi semplicemente riavviare il computer di Home Assistant per assicurarti che tutti i servizi vengano riavviati.\\n\\nArgomenti del servizio:\\n- **Percorso del file delle password di Mosquitto** (default: `/etc/mosquitto`) - Se hai utilizzato i metodi di installazione di Home Assistant Core o Docker e non hai il percorso predefinito per il broker Mosquitto, dovresti modificare questo parametro. *NNon necessario per Home Assistant OS o Superviser*.\\n- **Percorso per la configurazione di Zigbee2MQTT**  (default: `/opt/zigbee2mqtt`) - Se hai utilizzato i metodi di installazione di Home Assistant Core o Docker e non hai il percorso predefinito per Zigbee2MQTT, dovresti modificare questo parametro. *Non necessario per Home Assistant OS o Superviser*.\\n\\n## Ripristina la configurazione di Mosquitto e Zigbee2MQTT per il metodo di installazione di Home Assistant Core\\n\\nSe il backup include la configurazione di Mosquitto o Zigbee2MQTT, durante il processo di ripristino, verranno posizionati nel percorso predefinito o nel percorso specificato negli argomenti. Tuttavia, se hai installato l'integrazione Robonomics in un Home Assistant Core esistente *(non dall'immagine preinstallata di Robonomics)*, `homeassistant` l'utente potrebbe non avere accesso a questo percorso.\\n\\nQuindi, per ripristinare la configurazione di Mosquitto e Zigbee2MQTT, è necessario concedere le necessarie autorizzazioni di lettura all'utente `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Backup della configurazione di Mosquitto e Zigbee2MQTT per il metodo di installazione di Home Assistant Docker\\n\\nPer eseguire il backup delle configurazioni di Mosquitto e Zigbee2MQTT da un container Docker, è necessario creare volumi per le rispettive configurazioni. Ciò può essere ottenuto eseguendo il tuo container Home Assistant con argomenti aggiuntivi:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\no apportare modifiche al tuo `compose.yaml` file:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nSi prega di notare che i percorsi predefiniti per le configurazioni di Mosquitto e Zigbee2MQTT sono `/etc/mosquitto` e `/opt/zigbee2mqtt`, rispettivamente. Tuttavia, questi percorsi possono variare a seconda della tua configurazione specifica.\\n\\n</robo-wiki-note>\\n\\n## Pulsanti di backup\\n\\nOltre all'utilizzo dei servizi per lavorare con i backup, puoi semplificare il processo utilizzando i `Assicurati di essere connesso a Robonomics Parachain oracreate_backup` and `button.restore_from_backup` pulsanti dell'integrazione Robonomics. Questi pulsanti invocano i rispettivi servizi con parametri predefiniti (il pulsante di backup crea un backup senza cronologia).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nPer aggiungere pulsanti al tuo dashboard, segui questi passaggi:\\n\\n1. Fai clic sui tre puntini nell'angolo in alto a destra del dashboard.\\n2. Seleziona `Edit Dashboard`.\\n3. Fai clic sul pulsante `Add Card` nell'angolo in basso a destra.\\n4. Scegli la carta `Entities`.\\n5. Nel campo `Entities` cerca le entità button.create_backup e button.restore_from_backup.\\n6. Premi `Save` per aggiungere le entità alla card.\\n7. Concludi la modifica facendo clic sul pulsante `Done` nell'angolo in alto a destra.\"}},{\"node\":{\"id\":\"38a72a0d36e90f5db03eb48d46dd66be\",\"title\":\"Ajouter des fonds à votre compte sur le portail Robonomics\",\"path\":\"/docs/it/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Dopo aver creato con successo i tuoi account sul portale Robonomics, è ora di aggiungere fondi ad essi in modo da poter avviare transazioni.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nFai attenzione che questi e i seguenti tutorial vengono dimostrati su un'istanza locale di Robonomics Node. Configura la tua con [queste istruzioni](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Vai alla sezione Account sul portale Robonomics \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Scegli l'account da cui desideri trasferire i fondi\\n\\nIn modalità di sviluppo, esistono diversi account, con un valore di 10000 Unità di fondi ciascuno, che possono essere utilizzati per trasferire fondi ad altri account creati nella rete di sviluppo. Questi account sono indicati da segni a chiave inglese <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> accanto a loro.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Clicca sul pulsante \\\"invia\\\" dell'account da cui desideri trasferire i fondi, ad esempio BOB\\n\\n## 3. Scegli l'account in cui desideri trasferire i fondi\\nDopo aver cliccato sul pulsante \\\"invia\\\", ti verrà richiesto la finestra \\\"invia fondi\\\". Nella finestra richiesta:\\n\\n- Dalla lista degli account disponibili, scegli l'account in cui desideri inviare i fondi.\\n- Inserisci il numero di Unità che desideri inviare.\\n- Premi \\\"effettua trasferimento\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Autorizza la transazione\\n\\nDopo aver premuto \\\"effettua trasferimento\\\" nella fase precedente, ti verrà richiesta la finestra \\\"autorizza transazione\\\".<br/>\\nRivedi i dettagli della transazione e infine clicca sul pulsante \\\"firma e invia\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nIn questo esempio, abbiamo trasferito 500 unità di fondi da \\\"BOB\\\" a \\\"EMPLOYER\\\". Puoi vedere che l'account di EMPLOYER, che inizialmente non aveva fondi, ora ha 500 Unità di fondi.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Assicurati di avere abbastanza fondi negli account che desideri utilizzare nel playground.**\"}},{\"node\":{\"id\":\"cc9931a6e1b32568c05ce3514875ad64\",\"title\":\"Adaptateur Zigbee avec Zigbee2MQTT pour l'image préinstallée\",\"path\":\"/docs/fr/zigbee-to-mqtt-image/\",\"content\":\"\\n**Dans cet article, vous allez associer des appareils intelligents.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nOuvrez un navigateur Web et allez à l'adresse `http://%RASPBERRY_IP_ADDRESS%:8099`. Vous pouvez trouver l'adresse IP du Raspberry Pi en utilisant l'application mobile [Fing](https://www.fing.com/products) ou l'outil en ligne de commande [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nVous verrez l'interface Web de Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nIl est temps de connecter votre appareil intelligent. \\nTout d'abord, appuyez sur le bouton `Permit join (All)` en haut de l'interface Web de Zigbee2MQTT. \\n\\nEnsuite, commencez à associer les appareils. La manière la plus courante de passer un appareil en mode de connexion est de maintenir enfoncé son bouton d'alimentation ou de les allumer/éteindre 5 fois. Assurez-vous que Zigbee2MQTT est en cours d'exécution.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nLorsque l'appareil se connecte, vous les verrez dans l'interface Web:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nMaintenant, vous devriez voir ce capteur dans votre interface utilisateur Web Home Assistant. Allez dans `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nAprès avoir ajouté tous les capteurs, vous pouvez fermer l'interface Web de Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"7f0d3c60431f5fb4be95ecb697c467d7\",\"title\":\"Substrat Cumulus Parachain Testsuite pour la messagerie inter-chaînes\",\"path\":\"/docs/fr/xcm-robobank/\",\"content\":\"\\n\\nL'objectif principal de ce projet est la simplification du développement de l'exécution de parachain, lorsque des messages inter-chaînes sont utilisés. \\nIl permet le développement de code d'exécution avec des tests d'intégration avec un degré élevé de répétabilité et une utilisation simple.\\nIl automatise la construction, la construction d'une configuration de réseau prédéfinie (c'est-à-dire 1 chaîne de relais + 2 parachains), la configuration de canaux de transmission de messages entre les parachains et l'exécution de tests de messagerie, l'envoi de messages, en utilisant l'appel à l'exécution, le tout construit et composé en Python.\\n\\nXCM Testsuite est utilisé pour tester le cycle de production de Robobank - l'ensemble de palettes Substrate, qui permettent aux robots de s'enregistrer sur des parachains externes, de recevoir des commandes prépayées, de les exécuter et de recevoir des paiements en utilisant des jetons externes. Cela permet aux robots de fonctionner à l'intérieur du réseau Robonomics avec toute l'infrastructure requise, mais en même temps, d'offrir leurs services sur n'importe quel autre parachain.\\n\\nUne vidéo d'exemple est disponible sur [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nLes principales étapes du scénario de démonstration sont:\\n- lancer une chaîne de relais et deux parachains dans un pack de 6 processus\\n- configurer les canaux de messages XCM entre les parachains\\n- enregistrer un robot dans les deux parachains\\n- créer une commande pour ce robot dans le parachain client (réservation du paiement pour l'achvement de la commande)\\n- envoyer un message XCM au parachain Robonomics\\n- créer l'enregistrement de commande \\\"mirrored\\\" sur le parachain Robonomics\\n- le robot accepte la commande sur le parachain Robonomics\\n- envoyer un message XCM sur l'acceptation de la commande au parachain client\\n- accepter la commande sur le parachain client (réservation d'une pénalité en cas de non-achèvement de la commande jusqu'à la date limite de la commande)\\n- le robot achève la commande sur le parachain Robonomics\\n- envoyer un message XCM sur l'achèvement de la commande au parachain client\\n- régler tous les paiements (le paiement du client est transféré au robot, ainsi que la pénalité non utilisée)\\n- fermer la commande1\\n\\n\\n## Amont\\nCe projet est un fork du\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nIl contient le code des palettes d'exécution en cours de test.\\nComme dans le code d'origine du nœud, les parachains se trouvent dans les catalogues \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nDifférences avec le modèle de nœud \\\"substrate-node-template\\\" d'origine:\\n- cette exécution de collecteur a un module de gestionnaire HRMP et peut gérer les messages des parachains frères\\n- exécution de test fictive prête pour les tests internes XCM\\n\\n## Build & Run\\nConfiguration recommandée (fortement recommandée): \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[NOTE] La première construction peut prendre beaucoup de temps, jusqu'à plusieurs heures sur des machines suboptimales.\\n\\n[NOTE] Le script fonctionne avec les versions FIXÉES (hachages de validation) de Polkadot(Rococo) dans la chaîne de relais et les parachains.\\n\\n[NOTE] Par défaut, le script recrée le même environnement à chaque lancement, en supprimant tous les états précédents. Ce comportement peut être modifié dans \\\"config.sh\\\" en utilisant le paramètre \\\"PERSISTENT\\\".\\n\\n\\nExécutez le script de construction et de configuration.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nActions de base du script \\\"init.sh\\\":\\n - lire la configuration (fichier \\\"config.sh\\\" avec le numéro de révision, les clés et identifiants de nœud initiaux, le paramètre de persistance des données de chaîne, etc.)\\n - configuration des paquets OS, Rust et Python\\n - génère des binaires séparés pour la chaîne de relais et également pour les deux parachains\\n    - les binaires seront générés dans le sous-répertoire ./bin. \\n - (facultatif) supprime toutes les données de chaîne précédentes pour toutes les chaînes\\n    - désactivé si \\\"PERSISTENT=1\\\" est défini dans \\\"config.sh\\\"\\n - s'exécute en tant que processus séparés (avec des PID et des tuyaux d'E/S séparés):\\n    - validateurs de la chaîne de relais (c'est-à-dire 4 validateurs d'une révision Rococo stable en cours d'exécution)\\n    - collecteurs pour le parachain-100 (c'est-à-dire un seul collecteur pour le premier parachain que vous développez)\\n    - collecteurs pour le parachain-200 (c'est-à-dire un seul collecteur pour le deuxième parachain que vous développez)\\n - imprime tous les points de terminaison, les ports sur la console, vous permettant d'étudier n'importe quelle chaîne à l'aide d'applications frontales (explorateur, DApp)\\n - continue d'imprimer toutes les données de sortie de toutes les chaînes sur la console\\n\\n[WARNING] Après le lancement, attendez que le réseau soit opérationnel, assurez-vous que la finalisation des blocs a commencé et que les parachains sont enregistrés. Ces processus devraient prendre environ 5 minutes (50 blocs x 6 secondes).\\n\\n## Vérification du bon fonctionnement de la configuration initiale \\n\\nUtilisez l'interface Polkdot standard et les points de terminaison \\\"--ws-port\\\" générés pour vous connecter à chaque nœud.\\nOuvrez [l'application Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) pour surveiller les chaînes. \\n\\n### Exemple:\\nLocalhost, 4 validateurs de chaîne de relais, un collecteur de parachain-100, un collecteur de parachain-200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nSi tout fonctionne et que le consensus a commencé, nous pouvons procéder à l'exécution de nos cas de test (dans un nouveau terminal).\\n\\n### Test de passage de message UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nIl crée un message `Balance.transfer` dans `parachain-100` et le transmet à la chaîne de relais.\\nLorsque la chaîne de relais reçoit le message, elle transfère 15 jetons du compte `para 100` vers le compte Charlie.\\n\\n\\n### Test de passage de message HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nIl crée un message `Balance.transfer` dans `parachain-100` et le transmet à la chaîne `sibling 200`.\\nAvant cela, il dote le compte `subl 100` de 1000 jetons et établit un canal de communication entre les parachaines.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nLes messages suivants peuvent être envoyés en exécutant la sous-commande `hrmpm`. Cela ne crée pas de canal et permet donc une exécution plus rapide.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Plus d'options\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Testnet local\\n\\n### Créer une spécification de chaîne personnalisée\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nModifier rococo_local.json, remplacer les paramètres de solde et d'autorités par les vôtres.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nAdresse Polkadot pour le compte //Alice//stash (cryptographie sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nClé de session grandpa Polkadot pour //Alice (cryptographie ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nAdresse Polkadot pour le compte //Alice (cryptographie sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nConvertir rococo_local.json au format brut.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nPour utiliser une nouvelle spécification de chaîne, remplacez le fichier rococo.json dans le répertoire ./config/ par celui-ci et relancez la chaîne.\\n```bash\\n./scripts/init.sh run\\n```\\nVous pouvez librement modifier le code. La commande ci-dessus reconstruira le projet et mettra à jour le nœud collecteur avant de démarrer.\\nCumulus est un logiciel préliminaire encore en cours de développement intensif.\\nNous utilisons un commit spécifique de polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nVous pouvez utiliser des versions plus récentes du logiciel. Pour ce faire, modifiez POLKADOT_COMMIT dans ./scipt/config.sh\\npar le dernier commit de la branche `rococo-v1`, supprimez ./bin/polkadot et exécutez \\n```bash\\n./scripts/init.sh run\\n```\\n\\nMettre à jour les dépendances du projet collecteur \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nCertaines dépendances nécessitent probablement de nouvelles fonctionnalités de la chaîne d'outils Rust. Ce projet est basé sur Rust `nightly-2021-01-26`\\nMettez à jour la version de la chaîne d'outils Rust dans ./scripts/config.sh avant de construire.\\n\\n## Pirater la parachaine\\n[Ajouter une palette externe](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - devrait probablement être dans \\\"en savoir plus\\\"?\\n## Learn More\\n\\nConsultez le [Modèle de nœud du hub de développeurs Substrate](https://github.com/substrate-developer-hub/substrate-node-template) en amont pour en savoir plus sur la structure de ce projet, les capacités qu'il encapsule et la manière dont ces capacités sont mises en œuvre. Vous pouvez en savoir plus sur [Le chemin d'un bloc de parachaine](https://polkadot.network/the-path-of-a-parachain-block/) sur le blog officiel de Polkadot. [Atelier Parity Cumulus](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"25c4e8e8fb60461fc425520b65194805\",\"title\":\"Comment utiliser les plans\",\"path\":\"/docs/fr/use-blueprints/\",\"content\":\"\\nDans cet article, vous apprendrez comment ajouter des plans d'automatisation à votre Home Assistant et les configurer.\\n\\n## Automatisations de plan\\n\\nCertains plans sont déjà installés. Les automatisations basées sur de tels plans doivent simplement être configurées. Dans l'interface web, vous pouvez trouver des plans préinstallés dans `Settings/Automations & Scenes`. Ouvrez `Blueprints` et trouvez le plan que vous souhaitez utiliser. Dans cet exemple, `Motion-activated Light` sera utilisée. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nCliquez sur `Create Automation` pour ouvrir l'éditeur d'automatisation. Donnez un nom, choisissez un plan à utiliser (`Motion-activated Light` dans notre cas). Ensuite, vous devez choisir un capteur de mouvement et une lampe. Lorsque la configuration est terminée, cliquez sur `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Configuration\\\" />\\n\\nSi vous souhaitez apporter des modifications, vous pouvez le trouver en allant dans `Settings/Automations & Scenes`, puis `Automations`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Importation de plans\\n\\nHome Assistant peut importer des plans à partir des forums Home Assistant, de GitHub et de GitHub gists. La liste de tous les plans se trouve sur [Blueprints Exchange](https://community.home-assistant.io/c/blueprints-exchange/53). Après avoir fait votre choix, allez dans `Settings/Automations & Scenes` et ouvrez `Blueprints`. Cliquez sur `Import Blueprint` et insérez l'URL du plan choisi. Ensuite, cliquez sur `PREVIEW BLUEPRINT`. Dans ce cas, nous utiliserons [Détection et notification du niveau de batterie faible pour tous les capteurs de batterie](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nCela chargera le plan et affichera un aperçu dans la boîte de dialogue d'importation. Vous pouvez changer le nom et terminer l'importation. Cliquez sur `Create Automation` pour ouvrir l'éditeur d'automatisation. Ici, vous pouvez configurer les paramètres de l'automatisation et ajouter des actions pour recevoir des notifications.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"b94342cc0d6e8dd9c6577249abc87ab2\",\"title\":\"Comment envoyer un lancement avec abonnement\",\"path\":\"/docs/fr/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Faites attention, ce tutoriel démontre l'utilisation d'un abonnement sur la parachain Robonomics Kusama. Vous pouvez également effectuer toutes les mêmes étapes sur votre [nœud local](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nSi votre adresse dispose d'un abonnement actif, alors tous les appareils configurés avec le secret de ce compte peuvent envoyer des extrinsèques sans frais. \\nEssayons d'envoyer la commande `launch`.\\n\\nAllez sur la page `Developer/Extrinsics`, puis choisissez votre compte (celui de la liste des appareils) et sélectionnez `rws -> call(subscriptionId, call)`.  \\nEnsuite, dans le champ `subscriptionId`, collez l'adresse du propriétaire de l'abonnement (celui qui a fait une offre lors de l'enchère) et dans le champ suivant, choisissez `launch -> launch(robot, param)`. Dans le champ `robot`, saisissez l'adresse à laquelle vous souhaitez envoyer la transaction `launch` et insérez la commande (pour la description de la commande de lancement, consultez [ici](/docs/launch)). Ensuite, soumettez la transaction:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\nMaintenant, allez sur la page `Network/Explorer`, et dans la zone `Recent Events`, vous verrez deux événements que vous avez créés : `rws.NewCall` et `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"9407c7454d8aeac5c5fd4afe3a0eea4e\",\"title\":\"Obtenir la télémétrie de la maison intelligente\",\"path\":\"/docs/fr/smart-home-telemetry/\",\"content\":\"\\n**Dans cet article, vous utiliserez le service Robonomics, qui interroge la télémétrie des appareils de la maison intelligente.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Allez sur dapp et choisissez le service [Télémétrie de la maison intelligente](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. Dans le champ du contrôleur, entrez l'adresse `SUB_CONTROLLER`. Insérez la phrase de récupération pour crypter les données.\\n\\n3. Dans le bloc `Get telemetry`, choisissez un horodatage dans la liste déroulante et appuyez sur le bouton `DOWNLOAD TELEMETRY`.\\n\\n4. Le téléchargement de la télémétrie peut prendre un certain temps. Après avoir terminé, vous verrez les informations de vos appareils et capteurs.\\n\\n\\n<!---\\n## Lancement devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Launch\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"24c2c14e85e3f1e284a86c76272c7a73\",\"title\":\"Activer l'abonnement\",\"path\":\"/docs/fr/sub-activate/\",\"content\":\"\\nDans cet article, vous allez créer des comptes Robonomics parachain et acheter un abonnement IoT. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nPour contrôler Home Assistant avec Robonomics, vous avez besoin de 2 comptes sur le parachain Robonomics. Pour l'un des comptes (`sub_owner`), vous allez acheter un abonnement Robonomics. Le deuxième compte (`sub_controller`) contrôlera tous les processus de Home Assistant (comme la télémétrie) et donnera accès à d'autres utilisateurs. Ces comptes assureront la sécurité de votre Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nLes deux comptes doivent être créés avec le cryptage **ed25519**. Pour cette raison, vous devez créer un compte à l'aide de l'interface utilisateur Polkadot-JS et sélectionner le cryptage requis.\\n\\nCette fonctionnalité est désactivée par défaut sur l'interface Polkadot-JS UI. Pour l'activer, accédez à `Settings` -> `General` -> `account options` et sélectionnez `Allow local in-browser account storage` dans le menu déroulant `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Créer des comptes de propriétaire et de contrôleur\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Rendez-vous sur [l'application Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) sur le portail Polkadot / Substrate. **Vérifiez le coin supérieur gauche pour vous assurer que vous êtes connecté à Robonomics Parachain.**\\n\\n2. Allez dans `Accounts` -> `Accounts` et cliquez sur le bouton `Add account`. Vous verrez le menu contextuel avec la graine du compte. Il existe deux formes : *Mnemonic* (lisible par l'homme) et *Raw* (une séquence de chiffres et de lettres). \\n\\n3. Ouvrez les `Advanced creation options`, changez le type de cryptographie de création de compte en `Edwards - ed25519` et cliquez sur `Next`.\\n\\n\\n4. Enregistrez la phrase de graine mnémonique en toute sécurité et cliquez sur `Next`.\\n\\n5. Dans le menu suivant, vous devez définir le nom du compte et le mot de passe. Donnez-lui le nom `sub_owner` pour plus de commodité. Cliquez sur `Next`.\\n\\n6. Sur la dernière fenêtre, cliquez sur `Save` pour terminer la création du compte. Il générera également des fichiers JSON de sauvegarde que vous devez conserver en sécurité. Vous pourrez utiliser ce fichier ultérieurement pour récupérer votre compte si vous vous souvenez du mot de passe.\\n\\n7. Répétez ces étapes pour un compte portant le nom `sub_controller`.\\n\\n\\n## Ajouter des comptes à Polkadot.js\\n\\nPour plus de commodité, vous devriez utiliser l'[extension Polkadot.js](https://polkadot.js.org/extension/) et y ajouter ces comptes nouvellement créés. Pour un compte ed25519, vous ne pouvez le faire qu'avec un fichier JSON de sauvegarde. Vous pouvez utiliser les fichiers enregistrés lorsque vous avez créé les comptes.\\n\\nVous pouvez obtenir à nouveau ces fichiers en créant une sauvegarde du compte. Cliquez sur les trois points à côté de votre compte, choisissez `Create a backup file for this account` et saisissez votre mot de passe.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Ouvrez une extension et cliquez sur le bouton `+` en haut à droite, puis choisissez `Restore account from backup JSON file`.\\n\\n2. Dans la fenêtre ouverte, téléchargez le fichier JSON, saisissez le mot de passe et cliquez sur `Restore`.\\n\\n3. Assurez-vous que le réseau Robonomics est sélectionné pour les comptes dans l'extension Polkadot.js. Sur le portail Polkadot / Substrate, accédez à  `Setting` -> `Metadata` et cliquez sur le bouton `Update metadata`. \\n\\n4. Confirmez la mise à jour des métadonnées dans la fenêtre contextuelle. Maintenant, l'extension affichera l'étiquette du réseau pour lequel l'adresse est utilisée.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Activer l'abonnement Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nPour cette étape, vous devez disposer d'une quantité suffisante de jetons XRT (minimum 2-3 XRT) sur votre compte `sub_owner`.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Rendez-vous sur la page d'abonnement de Robonomics dans [l'application](https://dapp.robonomics.network/#/subscription) et cliquez sur `Connecter un compte` dans la barre latérale droite.\\n\\n2. Dans le menu contextuel suivant, connectez l'extension Polkadot.js. Vous verrez l'adresse de votre compte avec le solde.\\n\\n3. Avant d'acheter, vérifiez que vous avez choisi le compte `sub_owner`. Cliquez sur l'icône de profil d'adresse, vous devriez voir le compte `sub_owner` sous le champ `Check owner account`.\\n\\n4. Enfin, cliquez sur le bouton `SUBMIT` et saisissez le mot de passe de votre compte. Ensuite, attendez que le processus d'activation soit terminé. Vous verrez l'état de votre abonnement après un certain temps.\\n\\n\\n## Ajouter des comptes à l'abonnement\\n\\nVous devez maintenant ajouter un compte `sub_controller` à la **liste d'accès**.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Ouvrez l'extension et cliquez sur l'icône à côté du nom du compte. Cela copiera l'adresse du compte.\\n\\n\\n2. Collez cette adresse dans le champ `Robonomics parachain address` dans la partie **Gérer l'accès**. Donnez-lui un nom et cliquez sur le bouton `+`. \\n\\n3. Répétez les étapes 1 et 2 pour le compte `sub_owner`.\\n\\n4. Cliquez sur `Save`. Saisissez le mot de passe de votre `sub_owner` dans la fenêtre contextuelle et attendez que le processus d'activation soit terminé.\\n\"}},{\"node\":{\"id\":\"ac0cb661b989c92ba3d79caacae27949\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/fr/sls-gateway/\",\"content\":\"\\n**Dans cet article, vous configurerez la passerelle Robonomics SLS. Vous installerez le logiciel requis pour la passerelle, le configurerez et le connecterez à Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nTout d'abord, vous devez installer le micrologiciel du microcontrôleur de la passerelle. Préparez la passerelle en réglant les commutateurs `1` et `3` dans la partie inférieure de la passerelle SLS sur `ON`, les autres doivent être `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nConnectez la passerelle à votre Raspberry Pi via le port USB de type C sur la passerelle.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nClonez le référentiel avec le micrologiciel sur votre Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nAccédez à `robonomics-hass-utils/esp_firmware/linux`. Pour flasher la passerelle SLS, vous devez exécuter les scripts `Clear` et `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Dépannage\\n\\nSi vous rencontrez des problèmes lors de la mise à jour du micrologiciel de la passerelle, vous devez effectuer des étapes supplémentaires:\\n\\n1. Assurez-vous d'avoir installé le module pySerial:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Accordez à votre utilisateur les droits d'accès au port USB et redémarrez l'ordinateur:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. Dans certains cas, il est nécessaire de modifier le paramètre de bande passante dans le script pour mettre à jour le micrologiciel. Ouvrez le script `Flash_16mb.sh` avec l'éditeur `nano` et modifiez le paramètre de baud de `921600` à une valeur plus petite (par exemple, `115200`).\\n\\n## Configuration\\n\\n1. Déconnectez la passerelle SLS de l'ordinateur. Réglez les commutateurs à l'arrière de la passerelle sur la position appropriée. Les commutateurs `5` (RX Zigbee vers ESP) et `6` (TX Zigbee vers ESP) doivent être en position `ON`, les autres doivent être `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Connectez le câble d'alimentation de type C. Le voyant lumineux au centre doit devenir vert.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. Au premier démarrage, la passerelle commencera à partager le Wi-Fi avec le SSID `zgw****`. Connectez-vous à ce réseau. Gardez à l'esprit que le signal peut être assez faible, il est donc préférable de garder la passerelle SLS plus près de votre ordinateur. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Si la connexion est réussie, l'interface Web s'ouvrira (ou vous pouvez la trouver à l'adresse 192.168.1.1). \\n\\n5. Vous verrez la page `Wi-Fi Settings`. Sélectionnez votre Wi-Fi et entrez le mot de passe. Appuyez sur le bouton `Apply`. La passerelle redémarrera et se connectera à votre réseau Wi-Fi. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Trouvez l'adresse IP locale de la passerelle SLS pour accéder à l'interface Web. Pour le trouver, vous pouvez utiliser l'application mobile [Fing](https://www.fing.com/products) ou l'outil en ligne de commande [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Le nom de la passerelle doit ressembler à ceci: `zgw****`. Ouvrez l'interface Web de la passerelle en collant l'adresse IP de la passerelle dans un navigateur.\\n\\n7. Allez dans `Setting` -> `Hardware` et assurez-vous que les paramètres ressemblent à l'image. Corrigez les paramètres si nécessaire et cliquez sur le bouton `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nLe tableau avec les valeurs requises:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Ensuite, redémarrez la passerelle. Choisissez `Actions` -> `Reboot system` dans le coin supérieur droit.\\n\\n9. Assurez-vous que la passerelle fonctionne correctement dans la fenêtre d'informations Zigbee. L'état de l'appareil doit être `OK`.\\n\\n10. Configurez l'ajout automatique des appareils à Home Assistant. Allez dans `Zigbee` -> `Config`, puis choisissez `Home Assistant MQTT Discovery` et `Clear States`. Enregistrez les modifications et **redémarrez** la passerelle SLS.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSi vous avez déjà une passerelle SLS active chez vous et que vous configurez maintenant une autre passerelle, elles entreront en conflit. Pour résoudre ce problème, vous devez changer le canal sur le nouveau périphérique. Pour ce faire, allez dans `Zigbee` -> `Config` et changez le canal pour un autre (par exemple, le canal 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Association de SLS à MQTT\\n\\nAprès avoir configuré la passerelle SLS, vous devez connecter la passerelle SLS à Home Assistant. Ouvrez l'interface Web de la passerelle SLS et allez dans `Settings/Link` -> `MQTT Setup`:\\n\\n\\nAjoutez l'adresse de votre courtier (adresse du Raspberry Pi avec Home Assistant dans le réseau local, vous pouvez la trouver avec l'application mobile [Fing](https://www.fing.com/products) ou l'outil en ligne de commande [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), le port (par défaut est `1883`), votre nom d'utilisateur et mot de passe du courtier (que vous avez créé précédemment) et le nom du sujet (vous pouvez choisir n'importe lequel). De plus, l'adresse IP du Raspberry Pi doit être statique. Cliquez sur `Enable` et `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nEnregistrez les modifications. Maintenant, les appareils seront automatiquement affichés dans Home Assistant.\\n\\n## Connectez les appareils\\n\\nConnectez vos appareils en allant dans `Zigbee` -> `Join`. Mettez vos capteurs en mode d'appairage, la manière la plus courante de passer un appareil en mode de connexion est de maintenir enfoncé son bouton d'alimentation ou de les allumer/éteindre 5 fois. Appuyez sur le bouton `Enable Join` pour commencer la recherche des appareils Zigbee. Vous verrez les capteurs actifs.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nMaintenant, vous pouvez vous rendre dans la section [**Abonnement IoT**](/docs/sub-activate) et commencer à activer l'abonnement Robonomics.\\n\"}},{\"node\":{\"id\":\"86dee1fec959759bcceeeb25dd234963\",\"title\":\"Réseau de capteurs décentralisé\",\"path\":\"/docs/fr/sensors-network-introduction/\",\"content\":\"\\nLes articles sur le réseau de capteurs décentralisés ont été transférés à Robonomics Academy: https://robonomics.academy/fr/cours-en-ligne/cours-de-connectivite-des-capteurs/\"}},{\"node\":{\"id\":\"7a62565f3ef5750bb236a82bcb64a6bb\",\"title\":\"Connectez de manière sécurisée l'IA cloud au sol de l'usine\",\"path\":\"/docs/fr/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nLes technologies Robonomics peuvent déjà résoudre les défis auxquels l'industrie 4.0 est confrontée et elles sont déjà appliquées à des scénarios réels dans l'environnement industriel.\\n\\nUn grand nombre d'entreprises d'IA construisent des solutions pour optimiser les processus sur le sol de l'usine, permettant aux usines de produire plus à moindre coût. Cependant, la plupart des usines hésitent à connecter leur infrastructure directement au cloud car cela entraîne des risques potentiels en matière de cybersécurité, pouvant entraîner des pertes de plusieurs millions de dollars et même la perte de vies humaines.\\n\\n[MerkleBot](https://merklebot.com) a utilisé [Robonomics Network](https://robonomics.network) pour développer une solution permettant aux clients industriels de connecter leur usine à l'IA basée sur le cloud de manière sécurisée.\\n\\nCet article est rédigé à la suite d'une expérience que nous avons menée avec [Veracity Protocol](https://www.veracityprotocol.org/) qui utilise des algorithmes pour créer une protection non invasive de tout objet physique basée sur les photographies prises depuis un appareil mobile.\\n\\nCe cas d'utilisation montre le processus de numérisation des pièces industrielles à l'aide d'un bras robotique.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Processus étape par étape\\n\\n### DApp en tant qu'interface utilisateur\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp agit en tant qu'interface utilisateur pour l'opérateur. Elle est utilisée pour demander le lancement du robot afin de collecter les photographies et son objectif est de permettre une communication sécurisée entre l'environnement de l'usine et l'IA base sur le cloud.\\n\\n### Lancement du robot\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nL'opérateur lance la numérisation robotique en signant la transaction dans la DApp. Cette étape garantit que le processus sur le sol de l'usine ne peut commencer que sur la base de la transaction dans la blockchain publique.\\n\\nLe robot reçoit une commande de la blockchain via le réseau Robonomics et commence la numérisation. Les technologies du réseau Robonomics nous permettent de combler le fossé entre l'objectif commercial et l'opération robotique.\\n\\n### Collecte de données et envoi à l'IA basée sur le cloud\\n\\nDans la DApp, l'opérateur voit la confirmation et le robot commence à numériser les objets placés sur la table, comme dans ce cas d'utilisation, ou directement sur la ligne de production de l'usine si nécessaire.\\n\\n<!-- ![](../images/Veracity_Protocol_Launch.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nLorsque le robot collecte les données, il les stocke localement et les rend disponibles à l'IA basée sur le cloud via le protocole IPFS. En cryptant les données et en organisant l'échange de données via une transaction blockchain également, nous pouvons autoriser l'accès à l'IA basée sur le cloud tout en veillant à ce que les données restent sécurisées et en place.\\n\\nLe mécanisme de sécurité intégré à Robonomics, basé sur la sécurité partagée des blockchains publiques, permet d'obtenir le niveau de sécurité qui est prohibitif pour la plupart des usines à organiser par elles-mêmes.\\n\\n### Création de passeport numérique\\n\\nLorsque l'IA basée sur le cloud analyse les données, le fichier journal et les recommandations sont enregistrés automatiquement en tant que [Passeport Numérique](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/). Chaque opération et numérisation peuvent être retracées car l'enregistrement blockchain contient le hachage de tous ces fichiers via le protocole IPFS.\\n\\n## Commentaires sur le cas d'utilisation\\n\\nDans ce cas d'utilisation, le bras industriel Universal Robot UR3 a été utilisé. Mais grâce au support de Robonomics pour ROS, la plupart des principaux manipulateurs industriels peuvent être utilisés et connectés de manière sécurisée à l'IA basée sur le cloud, y compris KUKA, Fanuc et Yaskawa.\\n\\nSi vous souhaitez en savoir plus sur le déploiement et l'intégration d'instruments d'IA basés sur le cloud de manière sécurisée, veuillez [nous contacter](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"b5686e7ac1b54d52a229688db9207d5e\",\"title\":\"Comment ajouter le capteur SDS011 à Home Assistant\",\"path\":\"/docs/fr/sds-sensor-hass/\",\"content\":\"\\nCet article explique comment connecter le capteur de qualité de l'air SDS avec le micrologiciel [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) & [Robonomics](https://github.com/airalab/sensors-software) à Home Assistant.\\n\\n## Installation \\nIl existe deux options d'installation disponibles:\\n\\n### Option 1: HACS\\n\\nLa manière la plus simple d'ajouter un capteur local Luftdaten est via HACS. [Ici](https://hacs.xyz/docs/setup/download/) vous pouvez trouver une brève explication sur la façon de configurer HACS.\\n\\nUne fois HACS installé, accédez à HACS -> Intégrations et recherchez l'intégration `Local Luftdaten Sensor`. Cliquez sur le bouton de téléchargement et redémarrez Home Assistant une fois l'intégration téléchargée.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Option 2: Installation manuelle\\n\\nSous l'utilisateur homeassistant, clonez le dépôt du projet:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nSi vous avez déjà des intégrations personnalisées, copiez le dossier `custom_components/local_luftdaten/` dans votre répertoire `custom_components`, par exemple:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nSi vous n'avez pas d'intégrations personnalisées, copiez tout le répertoire `custom_components` dans votre répertoire de configuration de Home Assistant, par exemple:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Configuration\\n\\nCréez une nouvelle entrée de capteur dans votre `configuration.yaml` et ajustez le nom d'hôte ou l'adresse IP. Pour trouver l'adresse IP locale de votre capteur, vous pouvez utiliser [l'application mobile Fing](https://www.fing.com/products) ou [l'outil de ligne de commande nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Le nom peut être n'importe lequel.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> La liste de tous les capteurs pris en charge peut être trouvée dans le [dépôt](https://github.com/lichtteil/local_luftdaten).\\n\\nRedémarrez votre Home Assistant.\\nAprès cela, vous pouvez ajouter le capteur à votre tableau de bord. Le nom de l'entité sera le nom que vous avez ajouté à `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"65feb2b818a9b443dc1144eed4cc9c21\",\"title\":\"Comment connecter le capteur SDS011\",\"path\":\"/docs/fr/sds-sensor-connect/\",\"content\":\"\\n** Voici un guide étape par étape sur la façon de connecter votre capteur au réseau de capteurs Robonomics. Nos capteurs utilisent le micrologiciel Robonomics, qui est une version améliorée du micrologiciel sensor.community. Il comprend des capteurs supplémentaires et dispose d'un mécanisme de transmission de données modifié. **\\n\\n1. Branchez le capteur dans la prise pour l'alimenter.\\n2. La carte créera un réseau Wi-Fi nommé `RobonomicsSensor-xxxxxxxxx`. Connectez-vous à partir de votre téléphone ou de votre ordinateur: vous verrez la fenêtre d'autorisation (si ce n'est pas le cas, ouvrez le navigateur et allez à `192.168.4.1`).\\n3. Sélectionnez votre réseau Wi-Fi dans la liste (ou écrivez-le vous-même s'il n'est pas dans la liste) et remplissez le champ du mot de passe.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nLe capteur ne peut être connecté qu'à un réseau Wi-Fi 2,4 GHz.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Écrivez les coordonnées de l'endroit où le capteur sera installé. Vous pouvez les obtenir à partir de n'importe quelle carte ou les obtenir à partir de l'adresse en utilisant [ce lien.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nLes coordonnées du capteur seront ensuite affichées sur une carte publiquement disponible. Si vous ne souhaitez pas afficher vos informations privées, écrivez proche, mais pas des coordonnées exactes.\\n</robo-wiki-note> \\n5. Cliquez sur `Save configuration and restart`. La carte redémarrera et se connectera au réseau Wi-Fi spécifié.\\n6. Ouvrez [la carte des capteurs Robonomics](https://sensors.robonomics.network/#/) et trouvez l'endroit où vous avez installé le capteur. En quelques minutes, vous pourrez voir votre capteur avec des données sur la carte.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"e5149f1b8935f670d654669f539b6baa\",\"title\":\"Comment exécuter un nœud de développement Robonomics\",\"path\":\"/docs/fr/run-dev-node/\",\"content\":\"\\n**Pour tester vos applications sur Robonomics, vous voudrez peut-être l'exécuter en mode développement. Cet article montre étape par étape\\nles instructions pour obtenir votre propre instance de test locale de Robonomics.**\\n\\n\\n## Obtenir le binaire du nœud\\n\\n1. Tout d'abord, vous avez besoin d'un fichier binaire, téléchargez l'archive correspondante depuis la dernière [version](https://github.com/airalab/robonomics/releases).\\n\\n2. Accédez au dossier de l'archive, décompressez le binaire et modifiez les autorisations :\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Exécution\\n\\nExécutez le nœud avec :\\n\\n```bash\\n./robonomics --dev\\n```\\nVous verrez la sortie suivante:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Si vous souhaitez purger les blocs existants, vous pouvez le faire en supprimant RocksDB à l'emplacement `/tmp/substrate******/chains/dev/db/full`.\\n  Remplacez `******` par un identifiant correspondant affiché dans les journaux lors du lancement.\\n\\n  Si vous souhaitez démarrer le nœud à partir de zéro à chaque fois, utilisez l'option `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Connexion\\n\\nMaintenant, vous pouvez vous connecter à votre nœud local via le [Portail Polkadot](https://polkadot.js.org/apps/#/explorer).\\n\\nChangez le réseau en `Local Node` dans le coin supérieur gauche et appuyez sur `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nBienvenue dans l'instance locale de Robonomics !\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"0d4ade092903621a6b1aac0899688a18\",\"title\":\"Service vidéo Robonomics\",\"path\":\"/docs/fr/robonomics-video/\",\"content\":\"\\nCet article montre comment ajouter une caméra IP à Home Assistant et envoyer des vidéos au service Web Robonomics.\\n\\nPour connecter une caméra à Home Assistant, vous devez connaître son adresse IP et créer un compte de caméra local pour vous connecter au flux RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nComme cela est fait différemment pour chaque caméra, ce processus n'est pas considéré dans cet article.\\n</robo-wiki-note>\\n\\nExigences:\\n- Caméra IP\\n- Compte de caméra local configuré\\n- Adresse IP de la caméra\\n- Home Assistant configuré\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nCet article suppose que vous avez une caméra IP générale sans options de rotation, d'inclinaison et de zoom (RTZ). \\nSi vous avez une caméra RTZ, consultez l'article \\\"Caméra RTZ\\\" (/docs/ptz-camera). Ensuite, revenez à la deuxième étape ici.\\n\\n</robo-wiki-note>\\n\\n## Connexionez la caméra\\n\\nTout d’abord, vous devez connaître l’URL du flux RTSP de la caméra. \\nPour ce faire, essayez d'entrer la requête suivante sur Internet : \\\"<NOM_DE_LA_CAMÉRA> flux RTSP\\\".\\nL'URL du flux doit commencer par `rtsp://<ADRESSE_IP>...`. \\n\\nCet article utilise une caméra \\\"Tapo\\\" et le chemin du flux est `rtsp://<ADRESSE_IP>/stream1`.\\n\\nOuvrez Home Assistant et allez dans \\\"Settings\\\"-> \\\"Devices & Services\\\". Appuyez sur le bouton \\\"ADD INTEGRATION\\\" et\\ncommencez à taper \\\"Generic Camera\\\". Choisissez-la.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nDans la fenêtre de configuration, fournissez les informations suivantes :\\n- Stream Source URL - L'URL du flux RTSP de la caméra\\n- Username - écrivez le nom d'utilisateur de votre compte de caméra local\\n- Password - écrivez un mot de passe pour votre compte de caméra local\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nFaites défiler les paramètres vers le bas et appuyez sur le bouton \\\"Submit\\\".\\n\\nDans la fenêtre d'aperçu, activez la case à cocher \\\"This image looks good.\\\" et appuyez sur le bouton \\\"Submit\\\". Ensuite - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Ajoutez au tableau de bord\\n\\nDe plus, vous pouvez ajouter le flux à votre tableau de bord. Pour ce faire, accédez au tableau de bord et créez une nouvelle carte \\n\\\"Vue d'ensemble de l'image\\\". Étapes supplémentaires :\\n- entrez le \\\"Titre\\\" souhaité\\n- supprimez les données du \\\"Image Path\\\"\\n- sélectionnez the camera in \\\"Camera Entity\\\"\\n- dans la \\\"Camera View\\\", sélectionnez \\\"live\\\" pour réduire le délai\\n\\nEt enregistrez-le.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Vérifiez le dossier des médias\\n\\nAvant d'être envoyée au service vidéo Robonomics, la vidéo doit être enregistrée dans un dossier et Home Assistant doit avoir accès à ce dossier.\\nLa solution la plus simple dans ce cas est d'utiliser un pack multimédia, dans lequel Home Assistant stocke tous les médias.\\n\\n- Si vous utilisez HAOS ou une image préinstallée, votre Home Assistant **a déjà un dossier Media**.\\n- Si vous utilisez Home Assistant Core, vous devez accéder au dossier `.homeassistant` et y créer un dossier `media`.\\n- Si vous utilisez Home Assistant Docker, ajoutez la ligne ` -v /CHEMIN_VERS_VOTRE_MEDIA:/media \\\\` à la commande Docker.\\n\\nPour vérifier que tout est configuré correctement, accédez à l'onglet  “Media” -> “local media” de votre Home Assistant. \\nVous devriez voir un dossier vide (sans erreurs) :\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Appel de service\\n\\nPour envoyer une vidéo à Robonomics, vous devez appeler un service dédié dans Home Assistant. \\nDans cet article, cela est fait manuellement, mais vous pouvez créer une automatisation pour cela.\\n\\nPour ce faire, allez dans \\\"Developer tools\\\" -> \\\"Services\\\" et recherchez \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nIn \\\"Targets\\\", choisissez l'entité de votre caméra.\\nDans \\\"Path to save the recording\\\" , vous devez fournir un chemin absolu vers le dossier,\\noù Home Assistant peut enregistrer la vidéo :\\n- Pour l'image préinstallée - `/home/homeassistant/.homeassistant/media`;\\n- Pour HA OS ou Home Assistant Docker- `/media`;\\n- Pour Home Assistant Core - Chemin vers le dossier des médias précédemment créé.\\n\\nDe plus, vous pouvez choisir la durée de l'enregistrement. \\n\\nRemplissez les données et appelez le service avec le bouton \\\"CALL SERVICE\\\".\\n\\n## DAPP\\n\\nPour visualiser la vidéo résultante, accédez à [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nCollez l'adresse de compte de votre contrôleur et cliquez sur le bouton ci-dessous. Attendez le processus \\\"Search for Twins\\\". \\nEn résultat, vous obtiendrez un CID IPFS avec toutes les vidéos enregistrées.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nEnsuite, sélectionnez le compte du contrôleur (ou un autre) dans la liste déroulante et signez un message pour l'autorisation dans\\nla passerelle Web3 IPFS afin de télécharger toutes les vidéos. En résultat, vous obtiendrez toutes les vidéos enregistrées par votre maison intelligente.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nComme toutes les vidéos du dossier sont chiffrées avec la clé du contrôleur, vous devez l'insérer pour déchiffrer les vidéos.\\nAprès cela, le bouton de lecture de la vidéo est activé. Cliquez dessus pour télécharger la vidéo.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"75efa57ea805e766443d05a4ca7de1ca\",\"title\":\"Aperçu de la maison intelligente Robonomics\",\"path\":\"/docs/fr/robonomics-smart-home-overview/\",\"content\":\"\\n## IoT sécurisé avec la blockchain \\n\\nPour votre maison intelligente, le marché moderne de l'IoT propose une large gamme de solutions. Mais vous êtes généralement lié à des fournisseurs de cloud centralisés ou à des passerelles propriétaires coûteuses. En conséquence, en tant qu'utilisateur, vous dépendez toujours du matériel et de l'infrastructure du fournisseur pour exécuter votre système intelligent. En même temps, votre maison intelligente ne peut pas être vraiment intelligente sans statistiques et analyses cloud.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Nous identifions deux problèmes principaux avec les maisons intelligentes actuelles :**\\n\\n1. Vous n'avez aucun contrôle sur les données que vous partagez avec le fournisseur ou un tiers.\\n2. Votre maison intelligente est vulnérable aux arrêts des serveurs cloud centralisés. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nPour résoudre ces deux problèmes, nous vous suggérons d'essayer Robonomics, notre cloud décentralisé **sécurisé**, **sans serveur** et **futuriste**.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Étapes pour un cloud sans entreprise\\n\\nVoici quelques étapes simples pour créer une maison intelligente abordable en utilisant Home Assistant comme application de communication des appareils et Robonomics comme plateforme cloud décentralisée sans entreprise. Robonomics exploite les technologies Web3 modernes et sécurisées, garantissant une sécurité renforcée tout au long du processus..\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Commencez ici votre maison intelligente\\n\\nNous avons préparé des guides détaillés sur la configuration d'une maison intelligente sur Robonomics. Les étapes peuvent varier en fonction de votre situation spécifique : que vous ayez déj un Home Assistant opérationnel avec des appareils associés, ou si vous partez de zéro pour établir votre maison intelligente.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/fr/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/fr/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"0b9ec26b2522c126af367ae289ac85b5\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/fr/robonomics-prometheus-grafana/\",\"content\":\"\\n**L'instruction suivante est fournie par [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**L'article original se trouve [ici](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Introduction\\nPour mieux surveiller et maintenir le(s) nœud(s) Robonomics, il est bon de configurer une surveillance basée sur Prometheus Server et Grafana. Ce document vous montrera comment configurer chacun d'entre eux pour surveiller pleinement votre nœud.\\n\\n##  Prérequis\\n* [Configuration du serveur avec Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Collateur parachain Robonomics installé](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Assurez-vous que robonomics.service fonctionne sur votre machine et que le port 9615 est accessible \\n\\n## Étape 1 - Création des utilisateurs de service\\n\\nPour des raisons de sécurité, nous commencerons par créer deux nouveaux comptes d'utilisateur, prometheus et node_exporter. Créez ces deux utilisateurs et utilisez les options _--no-create-home_ et _--shell /bin/false_ afin que ces utilisateurs ne puissent pas se connecter au serveur.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nAvant de télécharger les binaires de Prometheus, créez les répertoires nécessaires pour stocker les fichiers et les données de Prometheus. Suivant les conventions standard de Linux, nous créerons un répertoire dans _/etc_ pour les fichiers de configuration de Prometheus et un répertoire dans _/var/lib_ pour ses données.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nMaintenant, définissez la propriété de l'utilisateur et du groupe sur les nouveaux répertoires pour l'utilisateur prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Étape 2 - Téléchargement de Prometheus\\n\\nTout d'abord, téléchargez et décompressez la version stable actuelle de Prometheus dans votre répertoire personnel. Vous pouvez trouver les derniers binaires sur la [page de téléchargement de Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nMaintenant, décompressez l'archive téléchargée.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nCela créera un répertoire appelé prometheus-2.21.0.linux-amd64 contenant deux fichiers binaires (prometheus et promtool), des répertoires _consoles_ et _console_libraries_ contenant les fichiers d'interface web, une licence, une notice et plusieurs fichiers d'exemple.\\n\\nCopiez les deux binaires dans le répertoire _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nDéfinissez la propriété de l'utilisateur et du groupe sur les binaires pour l'utilisateur prometheus créé à l'étape 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nCopiez les répertoires consoles et _console_libraries_ dans _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nDéfinissez la propriété de l'utilisateur et du groupe sur les répertoires pour l'utilisateur prometheus. L'utilisation du drapeau -R garantira que la propriété est définie sur les fichiers à l'intérieur du répertoire également.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nMaintenant que Prometheus est installé, nous allons créer sa configuration et ses fichiers de service en préparation de sa première exécution.\\n\\n## Étape 3 - Configuration de Prometheus\\n\\nDans le répertoire _/etc/prometheus_, utilisez nano ou votre éditeur de texte préféré pour créer un fichier de configuration nommé _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nDans les paramètres globaux, définissez l'intervalle par défaut pour la collecte des métriques. Notez que Prometheus appliquera ces paramètres à chaque exportateur à moins que les paramètres propres de chaque exportateur ne remplacent les paramètres globaux.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nCette valeur scrape_interval indique à Prometheus de collecter les métriques de ses exportateurs toutes les 15 secondes, ce qui est suffisamment long pour la plupart des exportateurs.\\nMaintenant, ajoutez Prometheus lui-même à la liste des exportateurs à collecter avec la directive scrape_configs suivante:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus utilise le _job_name_ pour étiqueter les exportateurs dans les requêtes et sur les graphiques, assurez-vous donc de choisir quelque chose de descriptif ici.\\n\\nEt, comme Prometheus exporte des données importantes sur lui-même que vous pouvez utiliser pour surveiller les performances et le débogage, nous avons remplacé la directive globale scrape_interval de 15 secondes à 5 secondes pour des mises à jour plus fréquentes.\\n\\nEnfin, Prometheus utilise les directives _static_configs_ et _targets_ pour déterminer où les exportateurs s'exécutent. Étant donn que cet exportateur particulier s'exécute sur le même serveur que Prometheus lui-même, nous pouvons utiliser localhost au lieu d'une adresse IP avec le port par défaut, 9090.\\n\\nVotre fichier de configuration devrait maintenant ressembler à ceci:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nEnregistrez le fichier et quittez votre éditeur de texte.\\n\\nMaintenant, définissez la propriété de l'utilisateur et du groupe sur le fichier de configuration pour l'utilisateur prometheus créé à l'étape 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nAvec la configuration terminée, nous sommes prêts à tester Prometheus en l'exécutant pour la première fois.\\n\\n## Étape 4 - Exécution de Prometheus\\n\\nDémarrez Prometheus en tant qu'utilisateur _prometheus_, en fournissant le chemin vers le fichier de configuration et le répertoire de données.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nLa sortie contient des informations sur la progression du chargement de Prometheus, le fichier de configuration et les services associés. Il confirme également que Prometheus écoute sur le port _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nSi vous obtenez un message d'erreur, vérifiez que vous avez utilisé la syntaxe YAML dans votre fichier de configuration, puis suivez les instructions à l'écran pour résoudre le problème.\\n\\nMaintenant, arrêtez Prometheus en appuyant sur _CTRL+C_, puis ouvrez un nouveau fichier de service _systemd_.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nLe fichier de service indique à _systemd_ d'exécuter Prometheus en tant qu'utilisateur prometheus, avec le fichier de configuration situé dans le répertoire _/etc/prometheus/prometheus.yml_ et de stocker ses données dans le répertoire _/var/lib/prometheus_. Copiez le contenu suivant dans le fichier:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nEnfin, enregistrez le fichier et fermez votre éditeur de texte. Pour utiliser le service nouvellement créé, rechargez systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nVous pouvez maintenant démarrer Prometheus en utilisant la commande suivante:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nPour vous assurer que Prometheus fonctionne, vérifiez l'état du service.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nLa sortie vous indique l'état de Prometheus, l'identifiant du processus principal (PID), l'utilisation de la mémoire, et plus encore.\\n\\nSi l'état du service n'est pas actif, suivez les instructions à l'écran et retracez les étapes précédentes pour résoudre le problème avant de continuer le tutoriel.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nLorsque vous êtes prêt à passer à l'étape suivante, appuyez sur _Q_ pour quitter la commande d'état. Enfin, activez le service pour qu'il démarre au démarrage.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nMaintenant que Prometheus est opérationnel, nous pouvons installer un exportateur supplémentaire pour générer des métriques sur les ressources de notre serveur.\\n\\n## Étape 5 - Téléchargement de Node Exporter\\n\\nPour étendre Prometheus au-delà des métriques sur lui-même uniquement, nous installerons un exportateur supplémentaire appelé Node Exporter. Node Exporter fournit des informations détaillées sur le système, y compris l'utilisation du CPU, du disque et de la mémoire. Téléchargez la version stable actuelle de Node Exporter dans votre répertoire personnel. Vous pouvez trouver les derniers binaires sur [la page de téléchargement de Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nMaintenant, décompressez l'archive téléchargée.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nCela créera un répertoire appelé _node_exporter-1.0.1.linux-amd64_ contenant un fichier binaire nommé _node_exporter_, une licence et un avis.\\n\\nCopiez le binaire dans le répertoire _/usr/local/bin_ et définissez l'utilisateur et le groupe propriétaires sur l'utilisateur node_exporter que vous avez créé à l'étape 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nMaintenant que vous avez installé Node Exporter, testez-le en l'exécutant avant de créer un fichier de service pour qu'il démarre au démarrage.\\n\\n## Étape 6 - Exécution de Node Exporter\\n\\nLes étapes pour exécuter Node Exporter sont similaires à celles pour exécuter Prometheus lui-même. Commencez par créer le fichier de service Systemd pour Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nCopiez le contenu suivant dans le fichier de service:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nEnregistrez le fichier et fermez votre éditeur de texte. Enfin, rechargez systemd pour utiliser le service nouvellement créé.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nVous pouvez maintenant exécuter Node Exporter en utilisant la commande suivante:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nVérifier that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nComme précédemment, cette sortie vous indique l'état de Node Exporter, l'identifiant du processus principal (PID), l'utilisation de la mémoire, et plus encore. Si l'état du service n'est pas actif, suivez les messages à l'écran et retracez les étapes précédentes pour résoudre le problème avant de continuer.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nEnfin, activez Node Exporter pour qu'il démarre au démarrage.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nAvec Node Exporter entièrement configuré et fonctionnant comme prévu, nous allons dire à Prometheus de commencer à collecter les nouvelles métriques.\\n\\n## Étape 7 - Configuration de Prometheus pour collecter Node Exporter\\n\\nParce que Prometheus ne collecte que les exportateurs qui sont définis dans la partie scrape_configs de son fichier de configuration, nous devrons ajouter une entrée pour Node Exporter, tout comme nous l'avons fait pour Prometheus lui-même. Ouvrez le fichier de configuration.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nÀ la fin du bloc scrape_configs, ajoutez une nouvelle entrée appelée node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nComme cet exportateur s'exécute également sur le même serveur que Prometheus lui-même, nous pouvons utiliser localhost au lieu d'une adresse IP, ainsi que le port par défaut de Node Exporter, 9100. Votre fichier de configuration complet devrait ressembler à ceci:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nEnregistrez le fichier et quittez votre éditeur de texte lorsque vous êtes prêt à continuer. Enfin, redémarrez Prometheus pour mettre les modifications en œuvre.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nVérifiez une fois de plus que tout fonctionne correctement avec la commande d'état.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nSi l'état du service n'est pas défini sur actif, suivez les instructions à l'écran et retracez vos étapes précédentes avant de passer à la suite.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nNous avons maintenant installé, configuré et exécuté Prometheus et Node Exporter.\\n\\n## Étape 8 - Ajout de Robonomic build in node_exporter\\n\\nAprès avoir installé avec succès Prometheus et node_exporter, nous devrons utiliser l'exportateur Prometheus intégré dans chaque projet de substrat. Pour cela, nous devons ajouter une entrée supplémentaire à _/etc/prometheus/prometheus.yml_. \\nOuvrez le fichier de configuration.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nÀ la fin du bloc scrape_configs, ajoutez une nouvelle entrée appelée robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nEnregistrez le fichier et quittez votre éditeur de texte. Your whole configuration file should look like this:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nEnfin, redémarrez Prometheus pour appliquer les modifications.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nVérifiez une fois de plus que tout fonctionne correctement avec la commande d'état.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nNous avons maintenant _Prometheus_ et _Node Exporter_ ainsi que _Robonomic Exporter_ installés, configurés et exécutés. Passons maintenant à Grafana\\n\\n## Étape 9 - Configuration de Grafana\\n\\nLa dernière étape consiste à connecter Prometheus en tant que source de données dans Grafana. Pour les besoins de ce didacticiel, nous utiliserons un grafana gratuit basé sur le cloud qui permet d'avoir jusqu'à 5 tableaux de bord ainsi qu'un [tableau de bord Robonomics](https://grafana.com/grafana/dashboards/13015). Allez simplement sur [grafana.com](https://grafana.com/), créez un nouveau compte et connectez-vous à votre instance grafana nouvellement créée.\\n\\nAu début, nous devons ajouter à Grafana une nouvelle _**Data Source**_ qui dans notre cas sera le serveur Prometheus.\\nAccédez à la source de données :\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nCliquez ensuite sur **Ajouter une source de données**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext sélectionnez _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nDans le nouvel écran, indiquez votre **adresse IP du serveur Prometheus avec le port 9090**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nAprès cela _**Enregistrer et tester**_, si vous avez suivi toutes les étapes, vous devriez être vert et prêt à importer le tableau de bord. Sur le site principal, cliquez sur **+** puis sur **Importer** comme indiqué sur la photo ci-dessous :\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nEnsuite, vous devriez voir la page Importer :\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nDans l'URL ou l'identifiant du tableau de bord _Grafana.com, écrivez _**13015**_ (car il s'agit de l'ID du tableau de bord Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nAprès avoir chargé le tableau de bord externe, vous obtiendrez cet écran :\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nLa dernière étape consiste à choisir la **_Source de données_** créée précédemment et à cliquer sur _**Importer**_.\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nC'EST ÇA ! À ce stade, vous devriez voir le tableau de bord importé.\\n\\n\\n## Les références\\n\\n\\n* [Comment installer Prometheus sur Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Créer un tableau de bord de surveillance par Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Prise en charge de Grafana pour Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Surveillance des métriques de l'hôte Linux avec l'exportateur de nœuds](https://prometheus.io/docs/guides/node-exporter/)\\n* [Interrogation de Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Visualisation des métriques de nœud](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Exportateur de substrat Prometheus](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Métrique du nœud Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [Exportateur de nœuds pour le tableau de bord Prometheus](https://grafana.com/grafana/dashboards/11074)\\n* [Métriques Grafana ROBONOMICS (XRT)](https://grafana.com/grafana/dashboards/13015)\\n\"}},{\"node\":{\"id\":\"e76569d47426301b6c4a39932f92f9d5\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/fr/robonomics-opengov/\",\"content\":\"\\n## Introduction \\n\\nRobonomics a transféré le modèle de gouvernance de la parachain vers le mécanisme sophistiqué OpenGov de Polkadot qui permet à la chaîne d'évoluer avec le temps, selon la volonté ultime des détenteurs de jetons.\\nLa transition de Robonomics vers OpenGov garantit que le DAO détenteur de jetons, qui contrôle la majorité des parts, peut toujours commander la direction de la parachain Robonomics, en mettant en œuvre tout changement du réseau qu'il juge approprié.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov s'applique uniquement à la parachain Robonomics, qui est une chaîne basée sur Substrate connectée à la chaîne de relais Kusama. OpenGov ne s'applique pas à la mise en œuvre Ethereum de Robonomics, car le réseau principal Ethereum ne prend pas en charge actuellement des systèmes de gouvernance sophistiqués tels que OpenGov.\\n</robo-wiki-note>\\n\\nOpenGov modifie la manière dont les opérations quotidiennes et la prise de décision sont effectuées sur la parachain. Il offre une plus grande clarté quant à la portée des référendums et a le potentiel d'augmenter considérablement le débit des décisions prises sur la parachain.\\n\\nOpenGov est en direct sur la chaîne de relais Kusama depuis quelques mois au moment de la rédaction, et il a prouvé qu'il augmente considérablement le nombre de décisions (référendums individuels et distincts) que le DAO détenteur de jetons peut proposer, voter et, grâce au vote, contrôler ultimement la direction du protocole.\\n\\n**Le contenu suivant contenu dans cette section du wiki présentera les principes fondamentaux d'OpenGov sur la parachain Robonomics et vise à vous aider à mieux comprendre les concepts derrière OpenGov.**\\n\\n*Il est important de noter que la gouvernance est un mécanisme en constante évolution dans le protocole, en particulier aux premiers stades de la mise en œuvre.*\\n\\nPour ceux qui s'intéressent uniquement aux paramètres de la piste Robonomics OpenGov, voir [ici](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## À propos des référendums\\n\\nLes référendums sont des schémas de vote simples, inclusifs et basés sur les parts. Chaque référendum est associé à une proposition spécifique qui prend la forme d'un appel de fonction privilégiée dans l'exécution de la chaîne. Cela peut également inclure l'appel le plus puissant `set_code``, qui a la capacité de désactiver l'intégralité du code du runtime des chaînes - ceci est unique aux chaînes basées sur un substrat et supprime l'exigence d'un \\\"hard fork\\\" de la chaîne lors de la mise à jour de la logique métier des chaînes ( Durée).\\n\\nLes référendums sont des événements distincts qui ont une période de vote fixe (plus d'informations sur les différentes périodes au cours du cycle de vie d'un référendum plus tard). Les détenteurs de jetons individuels peuvent voter de trois manières sur les référendums - AYE (d'accord/oui), NAY (désaccord/non) ou ABSTAIN (s'abstenir de voter entièrement).\\n\\nTous les référendums ont un délai d'application qui leur est associé. Il s'agit de la période entre la fin du référendum et, en supposant que le référendum ait été approuvé, la mise en œuvre des changements sur le réseau. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Il existe une période d'application **minimum** spécifiquement définie pour chaque type d'Origine, mais l'initiateur d'un référendum particulier peut définir les tâches spécifiques de ce référendum pour qu'elles soient exécutées plusieurs blocs à l'avenir.\\n\\n</robo-wiki-note>\\n\\nLes référendums sont considérés comme \\\"cuits\\\" s'ils sont clos et que les votes sont comptabilisés. En supposant que le référendum ait été approuvé, il sera programmé pour être mis en œuvre (dans le planificateur de la chaîne). Les référendums sont considérés comme \\\"non cuits\\\" si le résultat est en attente - par exemple, si le référendum est toujours en cours de vote.\\n\\nAvec l'ajout d'OpenGov, n'importe qui peut lancer un référendum à tout moment, et il peut le faire autant de fois qu'il le souhaite. OpenGov supprime la limitation d'un seul référendum pouvant être traité à la fois (notez que, dans Gov v1, un seul référendum peut être voté à la fois. La seule exception étant un référendum d'urgence supplémentaire par le comité technique accéléré qui peut également être voté simultanément par la communauté).\\n\\nOpenGov introduit plusieurs nouvelles fonctionnalités / concepts appelés Origines et Pistes, et ceux-ci sont introduits pour aider à faciliter le flux et le traitement des référendums dans le protocole.\\n\\nChaque Origine est associée à une seule classe de référendum, et chaque classe est associée à une piste. La piste décrit le cycle de vie du référendum et est spécifique à cette Origine particulière à partir de laquelle le référendum provient. Le fait d'avoir des pistes avec leurs propres paramètres spécifiques permet au réseau de modifier dynamiquement le cycle de vie des référendums en fonction de leur niveau de privilège (vous pouvez considérer le niveau de privilège comme étant la puissance d'un référendum / les types de changements qu'il peut apporter au protocole).\\n\\n*Pensez aux Origines comme au pouvoir associé à un référendum, et pensez aux Pistes comme aux paramètres de vote associés à un référendum, tels que la durée de ses périodes et les critères d'approbation et de soutien.*\\n\\nPar exemple, une mise à niveau de l'exécution n'a pas les mêmes implications pour le protocole qu'un petit pourboire du trésor, et donc différentes origines sont nécessaires dans lesquelles différents taux de participation, approbations, dépôts et périodes d'application (Pistes) seront prédéterminés dans la palette de la chaîne.\\n\\n## Proposition d'un référendum et cycle de vie du référendum \\n\\n### Période de préparation\\n\\nDans OpenGov, lorsqu'un référendum est créé initialement, il peut être immédiatement soumis au vote de la communauté des détenteurs de jetons. Cependant, il n'est pas immédiatement dans un état où il peut se terminer, ou avoir ses votes comptabilisés, être approuvé et promulgué sommairement. Au lieu de cela, les référendums doivent remplir un certain nombre de critères avant d'être déplacés dans la période de décision. Jusqu'à ce que les référendums entrent dans la période de décision, ils resteront indécis - et finiront par expirer après la période de cycle de vie globale spécifiée dans la piste individuelle.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nLes critères pour qu'un référendum entre dans la période de décision sont les suivants:\\n1. Une période de préparation qui précise le laps de temps qui doit s'écouler avant que la période de décision puisse commencer. Cette période de préparation aide à atténuer la possibilité de \\\"décision sniper\\\" où un attaquant contrôlant une quantité importante de pouvoir de vote pourrait chercher à utiliser sa grande participation pour faire adopter un référendum immédiatement après sa proposition, contournant ainsi la possibilité pour les autres membres du DAO détenteur de jetons d'avoir suffisamment de temps pour examiner le référendum et participer au vote. C'est pourquoi les origines avec des niveaux de privilège plus élevés ont des périodes de préparation significativement plus longues.\\n\\n2. Il doit y avoir de la place pour la décision. Chaque piste a ses propres limites pour le nombre de référendums qui peuvent être décidés simultanément (max_deciding). Les pistes qui ont des niveaux de privilège plus élevés auront des limites plus basses. Par exemple, l'origine de niveau Root aura un nombre significativement plus faible de référendums qui peuvent être décidés simultanément par rapport aux origines de niveau de privilège inférieur comme l'origine Small Tipper.\\n\\n3. Le dépôt de décision doit être soumis. La création initiale d'un référendum est assez bon marché, et la valeur du dépôt de soumission (réservé lors de la création initiale du référendum) est assez faible, et est principalement constituée de la valeur qu'il coûte pour le stockage sur chaîne associé au référendum. Les dépôts de décision sont beaucoup plus élevés, ce qui est nécessaire pour lutter contre le spam, et joue dans le jeu économique qu'OpenGov apporte, que nous verrons plus tard.\\n\\nUne fois que ces trois critères ci-dessus ont été remplis, le référendum passera à la période de décision. Les votes sur le référendum seront alors comptabilisés pour le résultat.\\n\\n### Période de décision\\n\\n*Pour une démonstration vidéo rapide de la période de décision, voir [cette vidéo](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nUne fois qu'un référendum a rempli tous les critères détaillés dans la section ci-dessus, il entrera dans la période de décision.\\n\\nLa période de décision tourne autour de deux concepts principaux, à savoir les critères d'approbation et de soutien. \\n\\nL'approbation est définie comme la part du poids du vote d'approbation (OUI contre NON) par rapport au poids total du vote (tous les votes OUI et NON combinés). La conviction de chaque vote compte pour le poids global des votes OUI/NON (plus d'informations sur le vote de conviction / blocage volontaire dans une section ultérieure).\\n\\nLe soutien est le nombre total de votes (jetons) qui ont participé au référendum (et n'est pas ajusté en fonction de la conviction) par rapport au total des votes possibles qui pourraient être effectués dans le système (pensez à cela comme l'émission totale de XRT sur la parachain - notamment, l'offre totale en circulation de XRT n'est pas le facteur principal ici, en raison du fait qu'une partie de ce nombre existe sur Ethereum sous forme de jetons ERC-20).\\n\\n**Les votes qui sont dans la direction ABSTENTION ne contribuent PAS aux critères d'approbation, mais sont inclus / comptent pour les critères de soutien**\\n\\nUn référendum doit remplir les critères de soutien ET d'approbation pendant la période de décision afin de progresser vers la période de confirmation.\\n\\nPour plus de détails sur les critères de soutien et d'approbation individuels pour chaque piste, consultez cette [feuille de calcul](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Période de confirmation\\n\\nChaque piste a sa propre durée spécifique pour sa période de confirmation. Les pistes qui ont des niveaux de privilège plus élevés (comme Root) ont des périodes de confirmation significativement plus longues que celles avec des niveaux de privilège inférieurs (comme Small Tipper).\\n\\nLes référendums doivent continuer à remplir les critères d'approbation et de soutien pendant toute la durée de la période de confirmation, sinon ils retourneront une fois de plus dans la période de décision (note: la période de décision n'est pas suspendue pendant la période de confirmation, il est donc tout à fait possible qu'une période de décision puisse expirer pendant la période de confirmation, ce qui signifie que si un référendum est exclu de la période de confirmation parce qu'il ne remplit plus les critères d'approbation et de soutien, il sera alors considéré comme un référendum échoué et non promulgué).\\n\\n**Il est possible d'ajuster les critères d'approbation et de soutien pour chaque piste individuelle grâce à un référendum avec les privilèges d'origine racine.**\\n\\nLes origines avec des niveaux de privilège inférieurs ont des critères d'approbation et de soutien considérablement plus faciles (fixés par la piste) à remplir que ceux avec des niveaux de privilège plus élevés. De même, les origines avec des niveaux de privilège plus élevés ont des courbes moins abruptes que celles avec moins de privilèges (tel que défini dans la piste), afin de garantir que le DAO détenteur de jetons approuve effectivement le référendum et d'éviter les attaques de référendum pour les origines à privilèges élevés.\\n\\nDans OpenGov, les référendums qui ne sont pas approuvés après l'expiration de la période de décision sont considérés comme rejetés par défaut, et les dépôts de soumission et de décision sont remboursés à leurs auteurs (note : le dépôt de décision peut être effectué par quelqu'un d'autre que l'auteur du référendum).\\n\\nSi un référendum parvient à remplir continuellement les critères d'approbation et de soutien pendant toute la période de confirmation, alors il est considéré comme approuvé et sera programmé pour s'exécuter à partir de l'origine proposée, mais le référendum ne s'exécutera qu'après que la période minimale de mise en vigueur se soit écoulée.\\n\\n### Période de mise en vigueur\\n\\nLa période de mise en vigueur est spécifiée par l'auteur lorsque le référendum est proposé, mais elle est soumise à la période minimale de mise en vigueur qui est spécifiée dans chaque piste. Les origines plus puissantes ont une période minimale de mise en vigueur beaucoup plus longue que celles avec moins de privilèges. Cela garantit que le réseau dispose d'un temps suffisant pour se préparer à d'éventuels changements que le référendum puissant peut imposer.\\n\\n## Verrouillage volontaire / Conviction\\n\\nRobonomics utilise un concept appelé verrouillage volontaire, ou vote par conviction. Cela permet aux détenteurs de jetons d'augmenter leur pouvoir de vote en décidant pendant combien de temps ils sont prêts à verrouiller leurs jetons pour un référendum particulier. Ce mécanisme n'affecte que les critères d'approbation de chaque référendum, et le vote par conviction n'affecte pas les critères de soutien.\\n\\nLe vote par conviction peut être calculé à l'aide de cette formule :\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nCe tableau vous montre comment chaque niveau croissant de période de verrouillage multiplie votre vote pour les critères d'approbation :\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nLe montant maximum de conviction qu'un détenteur de jetons peut utiliser est de 6x conviction. Vous ne pouvez définir la conviction que selon le tableau ci-dessus, et vous ne pouvez pas, par exemple, utiliser une conviction de 5,5x.\\n\\nPendant que les jetons sont verrouillés en raison d'un vote, ils peuvent toujours être utilisés pour voter dans d'autres référendums, cependant, ils ne feront pas partie de votre solde transférable (vous ne pouvez pas les envoyer à un autre compte) - et le solde ne redeviendra transférable que lorsque la période de verrouillage entière aura expiré.\\n\\n## Délégation de vote\\n\\nDans OpenGov, un mécanisme a été ajouté pour permettre aux détenteurs de jetons qui n'ont pas nécessairement assez de temps pour examiner chaque référendum de faire quand même utiliser leurs jetons dans le système de gouvernance, cela s'appelle la délégation de vote.\\n\\nLes détenteurs de jetons peuvent choisir de déléguer leur pouvoir de vote à un autre électeur du système (un autre compte). Les électeurs peuvent spécifier de déléguer leur pouvoir de vote de manière agile, ce qui leur permet d'attribuer leur pouvoir de vote à un compte différent pour chaque Origine individuelle. Les électeurs peuvent également choisir d'attribuer une quantité différente de pouvoir de vote pour chaque Origine (nombre de jetons et niveau de conviction).\\n\\nCette fonction de délégation a un objectif, augmenter la participation des électeurs et aider à garantir que les critères d'approbation et de soutien requis sont respectés.\\n\\nPour déléguer votre pouvoir de vote, vous pouvez utiliser la fonction \\\"Déléguer\\\" que vous pouvez trouver dans la section Gouvernance -> Référendum du [Portail Robonomics](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). Alternativement, les utilisateurs peuvent soumettre l'extrinsèque convictionVoting(Déléguer) en utilisant la section Développeur -> Extrinsèques du Portail Robonomics, cependant, utiliser la fonction \\\"Déléguer\\\" de la section référendum du portail est beaucoup plus facile.\\n\\n## Annulation / Suppression de référendum et jeu économique de gouvernance\\n\\nDans OpenGov, il existe des Origines qui sont dédiées à la suppression des référendums en cours, quel que soit leur statut. Il s'agit des pistes de l'Annulateur de gouvernance et du Tueur de gouvernance.\\n\\nCes Origines interviennent sur un référendum qui a déjà été voté. Ces Origines, si le référendum provenant d'elles est approuvé, rejetteront immédiatement un référendum en cours, quel que soit son statut. \\n\\nL'annulation elle-même est un type de référendum qui doit être voté par les détenteurs de jetons pour être exécuté. L'annulation a sa propre origine et piste qui ont un délai de mise en œuvre plus court (période de décision, etc.), et ont des courbes d'approbation et de soutien avec une courbe plus raide (ce qui signifie que leurs critères sont beaucoup plus faciles à atteindre au fil du temps) que les autres Origines. Cela est dû au fait que l'annulation d'un référendum est généralement accompagnée d'un sentiment d'urgence.\\n\\nL'Annulateur de gouvernance vise à rejeter instantanément un référendum en cours. Lorsqu'un référendum est annulé par cette origine, le dépôt de soumission et de décision est remboursé à leurs auteurs. Un exemple de situation où un référendum pourrait être considéré comme annulé est si l'auteur a commis une erreur humaine dans le contenu de son référendum, sans nécessairement avoir cherché à faire quelque chose de malveillant.\\n\\nLe Tueur de gouvernance vise à rejeter instantanément un référendum en cours. C'est là que le jeu économique de gouvernance entre en jeu. Les Origines avec des niveaux de privilège élevés, tels que Root, ont un dépôt de décision qui nécessite un montant élevé de capital (jetons XRT) à déposer pour que le référendum entre dans la période de décision. \\n\\nSi un acteur malveillant soumet un référendum, tel qu'un référendum avec des origines Root qui vise à `set_code` du runtime de la chaîne pour quelque chose qui arrêtera la production de blocs de la chaîne, alors le DAO des détenteurs de jetons peut soulever un contre-référendum du Tueur de gouvernance pour punir cette action. Si le référendum malveillant est rejeté via l'origine du Tueur de gouvernance, alors les dépôts de soumission et de décision sont confisqués, ce qui signifie que l'auteur (le(s) compte(s) qui ont posté ces dépôts) perdra ces fonds. \\n\\nCela signifie qu'il y a une conséquence économique grave pour les acteurs malveillants qui tentent de soulever un référendum qui aurait des impacts négatifs graves pour la chaîne, ce qui théoriquement empêchera tout acteur malveillant de tenter de le faire.\\n\\nLe dépôt de décision pour la piste Governance Killer elle-même est assez élevé, cela afin d'empêcher les acteurs tout aussi malveillants de tenter de réduire les dépôts d'un référendum par ailleurs bon. **Un référendum existant de Governance Killer peut être tué par un référendum ultérieur de Governance Killer.**\\n\\n## Comité technique Robonomics & Origine autorisée\\n\\nCe groupe est un organisme d'experts autonome dont le but principal est de représenter les humains qui incarnent et possèdent les connaissances techniques du protocole réseau Robonomics. \\n\\nCe groupe (et seulement ce groupe) est capable d'initier des référendums à partir de la palette Whitelist. Cette palette ne fait qu'une chose, elle permet à une Origine d'augmenter le niveau de privilège d'une autre Origine pour une certaine opération. \\n\\nCe groupe peut autoriser un référendum à partir d'une origine connue sous le nom de Whitelisted-Root, et ces référendums peuvent être exécutés avec des privilèges de niveau Root, mais ces référendums ne fonctionneront avec succès qu'avec certaines commandes spécifiées qui ont été autorisées par le groupe. La palette Whitelist vérifie deux choses :\\n1. L'Origine est vraiment la Whitelisted-Root (c'est-à-dire que le référendum est passé par cette piste d'Origine).\\n2. La proposition a effectivement été ajoutée à la liste blanche par le groupe.\\n\\nSi les deux conditions sont vraies, alors l'opération s'exécutera avec des privilèges de niveau Root.\\n\\nCe système permet d'avoir une nouvelle piste parallèle (Origine Whitelisted-Root), dont les paramètres permettent un délai de vote plus court (les critères d'approbation et de soutien sont légèrement plus faciles à atteindre que pour Root). Ce processus ouvert et transparent permet à ce groupe d'experts du protocole réseau Robonomics de proposer des référendums qu'ils ont jugés sûrs et urgents.\\n\\nIl convient de noter que les critères de soutien pour les référendums initiés avec l'origine Whitelisted-Root ne tendent pas vers 0 comme beaucoup d'autres origines/pistes. Cela garantit que ce groupe n'a pas le contrôle de facto sur l'ensemble du protocole réseau Robonomics et nécessite un niveau minimum de soutien (participation des électeurs) de l'ensemble des détenteurs de jetons.\\n\\n\\n## Durée des référendums \\n\\nIl est important de comprendre que la durée de chaque référendum individuel n'est pas une chose concrète, elle n'est pas gravée dans le marbre. Certaines périodes du cycle de vie du référendum, telles que la période minimale de mise en œuvre, ont effectivement une durée concrète, mais d'autres, y compris la période de décision, ne l'ont pas. Par exemple, il n'est pas exact d'additionner les durées maximales des périodes de préparation, de décision, de confirmation et de mise en œuvre minimale et de déclarer que « chaque référendum prendra X jours », c'est beaucoup plus fluide que cela.\\n\\nPrenons cela à travers le prisme de quelques référendums distincts, tous originaires de la même Origine, dans ce cas, l'origine Root. \\n\\nL'Origine Root a sa propre piste, où les durées de chaque période sont fixées, ainsi que les courbes d'approbation et de soutien.\\n\\nIl est important de se rappeler que les référendums ne passeront à la prochaine étape de leur cycle de vie que si certaines conditions sont remplies. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nVous devriez supposer dans les images suivantes que, pour qu'un référendum passe à la prochaine étape de son cycle de vie, les conditions décrites dans l'image ci-dessus doivent avoir été remplies (sauf indication contraire).\\n\\n\\n### Durée maximale possible avec très peu de participation des électeurs\\n\\nL'image ci-dessous représente la chronologie maximale possible pour un référendum, pensez à cela comme à un référendum qui :\\n1. A eu son dépôt de décision publié, et est donc entré dans la période de décision.\\n2. A un seul vote, par exemple, 1 XRT, dans la direction AYE - cela signifie qu'il ne répondra aux exigences de soutien requises (participation des électeurs) qu'à la fin de la période de décision (puisque le soutien global est extrêmement faible), mais a une approbation de 100 %, donc finira par répondre aux exigences pour entrer dans la période de confirmation.\\n3. Continue à répondre aux critères mentionnés pendant la période de confirmation.\\n4. La proposition soulevée par le référendum sera promulguée exactement au même bloc que la fin de la période de mise en œuvre minimale - techniquement, l'initiateur du référendum peut fixer les changements réseau tels que détaillés dans le référendum pour promulguer de nombreux blocs dans le futur, donc en réalité, le cycle de vie réel d'un référendum individuel pourrait s'étendre sur plusieurs jours, semaines, mois ou années.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nNous pouvons voir que dans cet exemple, le cycle de vie du référendum serait (approximativement) de 17 jours.\\n\\n\\n### Durée avec beaucoup de participation des électeurs (avec un grand nombre de votes AYE)\\n\\nJetons maintenant un coup d'œil à un référendum au cours duquel le détenteur du jeton XRT, DAO, a exprimé beaucoup d'intérêt. Dans cet exemple, nous supposerons qu'environ 248 771 XRT de participation électorale globale ont eu lieu et que tous les électeurs votent dans la direction AYE (remarque : techniquement, à ce stade d'un référendum racine, selon la piste, seuls 60 % des votes doivent être dans la direction AYE pour qu'un référendum réponde aux critères d'approbation).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Consultez toujours les informations les plus récentes sur les pistes pour obtenir des informations précises sur chaque piste. Plus d'informations peuvent être trouvées sur cette [feuille de calcul](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nDans cet exemple :\\n1. Le dépôt de décision a été affiché pendant la période de préparation et a donc pu passer à la période de décision à la fin de la période de préparation.\\n2. De nombreux électeurs ont voté lors de ce référendum, obtenant un taux de participation d'environ 248 771 XRT dans un laps de temps relativement court.\\n3. Les votes étaient majoritaires dans le sens AYE (tout ce qui dépasse 60 % AYE).\\n4. Le référendum répond continuellement aux critères de la période de confirmation pendant toute sa période de confirmation (Remarque : si un référendum s'arrête pour répondre aux critères de la période de confirmation, il est alors renvoyé à sa période de décision).\\n5. La proposition soulevée par le référendum sera adoptée exactement sur le même bloc que celui où se termine la période minimale de promulgation.\\n\\nÉtant donné qu'il y a eu environ 248 771 XRT, le référendum remplira les critères pour entrer dans sa période de confirmation après environ 168 heures (7 jours).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nNous pouvons voir que dans ce deuxième exemple, en raison d'une forte participation électorale, la période de décision s'est en fait terminée à mi-chemin de son temps maximum imparti. Il en résulte un référendum qui peut être promulgué dans environ 10 jours.\\n\\n\\n### Durée pendant laquelle le dépôt de décision n'est jamais affiché\\n\\nJetons maintenant un coup d'œil à un référendum qui a été organisé, mais dont le dépôt de décision n'a jamais été publié. De tels référendums se trouvent dans une sorte de « limbes », où leur période de préparation est terminée, mais comme le dépôt de décision n'a pas été déposé, le référendum reste dans « l'État de préparation ».\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nNous pouvons voir que dans ce troisième exemple, du fait que le dépôt de décision n'a jamais été affiché, le référendum n'entrera en réalité jamais dans la période de décision, mais restera dans « l'état de préparation ». Cela signifie qu'à terme, si aucun dépôt de décision n'est jamais enregistré, le référendum expirera une fois la durée spécifiée dans la constante timeOut de la palette écoulée.\\n\\nCela s'est déjà produit à Kusama, où un référendum a été publié avec des origines racines, mais en raison des exigences élevées en capital pour publier le dépôt de décision, le référendum n'est jamais entré dans les dernières étapes de son cycle de vie. Un tel référendum se termine par le drapeau « expiration du délai ».\\n\\n\\n### Durée pendant laquelle le dépôt de décision est posté en retard\\n\\nEnfin, examinons un exemple dans lequel le dépôt de décision n'a pas été affiché pendant un certain temps après le déclenchement du référendum. Cela s'est déjà produit à Kusama, où un référendum a été publié avec l'origine racine, mais l'initiateur a dû passer du temps à trouver quelqu'un disposant d'un capital élevé pour publier le dépôt de décision en son nom.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nDans ce dernier exemple, étant donné que le dépôt de décision a été publié après la fin de la période de préparation, mais avant la fin du référendum, le cycle de vie du référendum est en réalité beaucoup plus long que la normale, car il entre dans la période de décision après une durée plus longue.\\n\\nIl est important de noter que le détenteur du jeton DAO est en mesure de voter AYE/NAY sur les référendums qui sont en période de préparation, ou bloqués dans « l'État de préparation ».\\n\"}},{\"node\":{\"id\":\"8cd6d22091d3f759e06921be73dcbe0e\",\"title\":\"Robonomics sur Ethereum\",\"path\":\"/docs/fr/robonomics-ethereum/\",\"content\":\"\\nToutes les informations sur Robonomics sur Ethereum ont été déplacées vers le référentiel GitHub. Toutes les informations nécessaires peuvent être trouvées [ici.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"1d42f9267c1559cf97b65b44ce0916cc\",\"title\":\"Configuration de l'intégration Robonomics\",\"path\":\"/docs/fr/robonomics-hass-integration/\",\"content\":\"\\n**Dans cet article, vous ajouterez Robonomics à Home Assistant. Cela permet à Home Assistant d'enregistrer des journaux de données avec des données chiffrées sur Robonomics Parachain et d'écouter les commandes de lancement du parachain pour contrôler les appareils intelligents. L'intégration utilise IPFS pour stocker les données et envoyer des hachages IPFS aux fonctions de journalisation ou de lancement.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Dans l'interface web de Home Assistant, allez dans `Settings` -> `Device & Services`  et cliquez sur `ADD INTEGRATION`. Recherchez `Robonomics`.\\n\\n2. Cliquez sur Robonomics et remplissez la configuration : \\n\\n- Ajoutez la graine du compte `SUB_CONTROLLER` à la graine du compte du contrôleur.\\n- Ajoutez l'adresse publique du compte `SUB_OWNER` à l'adresse du propriétaire de l'abonnement.\\n- Définissez l'intervalle d'envoi des données (par défaut, il est de 10 minutes).\\n- (Facultatif) Vous pouvez ajouter des informations d'identification pour le service de mise en mémoire tampon Pinata ou une autre passerelle personnalisée pour diffuser vos données plus largement sur le réseau IPFS.\\n\\n3. Cliquez sur `SUBMIT` après avoir terminé la configuration. Si vous avez rempli correctement toutes les informations, vous verrez la fenêtre de réussite.\\n\\nC'est tout ! Vous avez entièrement configuré l'intégration Robonomics dans Home Assistant. Maintenant, vous pouvez utiliser tous les \\nservices Web Robonomics. Pour en savoir plus à leur sujet, rendez-vous dans la section [\\\"Utilisation\\\"](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"4f4409250d352125341ec5107595c87b\",\"title\":\"Interface Python et Robonomics IO\",\"path\":\"/docs/fr/rinterface/\",\"content\":\"\\n**Certaines extrinsèques implémentées dans les palettes Robonomics sont difficiles à soumettre depuis l'application Polkadot. De plus, il est \\nnécessaire d'interagir avec cette fonctionnalité en utilisant des langages de programmation. Dans ce but, un outil Python simple a été développé\\nappelé [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface). C'est un emballage entretenu par Polkascan\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). Voici une brève description de ce package\\net quelques liens et exemples utiles. De plus, les outils CLI sont discutés.**\\n\\n## robonomics-interface\\n\\nDisponible sur [PyPi](https://pypi.org/project/robonomics-interface/), le package est prêt à être téléchargé et installé.\\nUne documentation détaillée générée par docstring est également disponible.\\n\\nEn fin de compte, il s'agit d'un outil destiné aux développeurs souhaitant interagir avec la blockchain Robonomics via des outils de programmation. Presque \\ntous les projets Python de l'équipe Robonomics qui interagissent avec la parachain utilisent cette interface.\\n\\n### Installation\\n\\nLe processus d'installation nécessite que l'utilisateur ait au moins Python 3.8 installé. Ni `x86`, ni `arm7`, ni `arm8`\\narchitectures ne nécessitent de processus de compilation. Toutes les roues sont construites et publiées par les mainteneurs des dépendances.\\n\\n`pip` est utilisé comme outil d'installation :\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Utilisation d'exemple\\n\\nL'idée principale est de créer une instance `Account` puis de l'utiliser pour créer des instances dédiées aux palettes.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  Il est également possible d'utiliser des points de terminaison personnalisés (par exemple, un nœud local pour les tests) :\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nIl est également possible de soumettre des extrinsèques :\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Comme mentionné précédemment, plus d'exemples sont disponibles sur la page de la [documentation](https://multi-agent-io.github.io/robonomics-interface/).\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` contient également des outils CLI Python `click` à utiliser pour des fins de prototypage et de tests rapides. Il est installé\\navec le package et disponible dans le Terminal :\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nVous pouvez essayer de l'utiliser avec un nœud local. La philosophie de pipeline est adoptée :\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"d4b3c1ee5ada91f0fbcd64d69119fcb3\",\"title\":\"Contrôle de caméra PTZ dans Home Assistant\",\"path\":\"/docs/fr/ptz-camera/\",\"content\":\"\\nCet article couvre le processus de configuration d'une caméra PTZ dans Home Assistant. \\nLe protocole ONVIF sera utilisé. Cela nécessite un compte de caméra local.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nLe processus de configuration du compte de caméra local n'est pas couvert dans cet article.\\n</robo-wiki-note>\\n\\nExigences:\\n- Caméra PTZ\\n- Compte de caméra local\\n- Adresse IP de la caméra\\n- Home Assistant configuré\\n\\n## Intégration ONVIF\\n\\nCommençons par l'installation de l'intégration **ONVIF**. \\n\\nAllez dans \\\"Devices & Services\\\" dans \\\"Settings\\\" et appuyez sur le bouton \\\"ADD INTEGRATION\\\".\\nTapez \\\"ONVIF\\\" et choisissez l'intégration. Vous verrez la fenêtre suivante.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nAppuyez sur le bouton \\\"Submit\\\". Il essaiera de rechercher automatiquement votre caméra. Si cela réussit, \\nchoisissez votre caméra dans la liste et remplissez les champs vides. \\nSinon, vous devrez remplir tous les champs manuellement. Vous verrez la fenêtre suivante.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nRemplissez les espaces vides:\\n- Name - donnez un nom à votre caméra\\n- Host - fournissez l'adresse IP de votre caméra\\n- Port - le plus courant est 2020, mais votre fournisseur de caméra peut le changer\\n- Username - écrivez le nom d'utilisateur de votre compte de caméra local\\n  - Password - écrivez un mot de passe pour votre compte de caméra local\\n\\net appuyez sur \\\"Submit\\\". Choisissez une zone pour votre caméra et cliquez sur \\\"Finish\\\".\\n\\n## Ajoutez le contrôle de la caméra au tableau de bord\\n\\nMaintenant que vous avez entièrement configuré la caméra, vous pouvez ajouter son flux et ses boutons de contrôle au tableau de bord.\\n\\nAccédez au tableau de bord et commencez par créer une nouvelle carte. Choisissez \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nRemplissez les données:\\n- Title - choisissez le titre de l'image de la caméra\\n- Camera Entity - choisissez une entité de caméra dans la liste déroulante\\n- Camera View - choisissez \\\"live\\\" pour obtenir moins de retard\\n\\nEnsuite, passez en mode \\\"Code Editor\\\" en appuyant sur le bouton en bas à gauche. Vous verrez le code suivant:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nRemplacez le contenu de `entities: []` selon l'exemple ci-dessous (`<VOTRE_ENTITÉ_DE_CAMÉRA>` est identique au paramètre `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nC'est tout. Maintenant, vous devriez voir la carte de caméra PTZ sur le tableau de bord avec les boutons de contrôle.\\n\\n## Dépannage\\nSi vous utilisez Home Assistant Core et que vous ne voyez pas de flux provenant de la caméra, vous devriez installer les intégrations \\\"stream\\\" et \\\"FFMPEG\\\". \\nPour cela, vous devez ajouter les chaînes `stream: ` et `ffmpeg: ` à la fin de configuration.yaml.\"}},{\"node\":{\"id\":\"367a9bb8bc24b0300f774f13cf6191c3\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/fr/notifications/\",\"content\":\"\\nVous pouvez recevoir des notifications sur votre smartphone avec [notify](https://notify.events/). Inscrivez-vous d'abord là-bas et créez un nouveau canal sur le `Control Panel`:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nAjoutez un titre et appuyez sur `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nEnsuite, appuyez sur `Add Source` et choisissez `Home Assistant` dans l'onglet `IoT et Smart Home`:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nÉcrivez un titre et appuyez sur `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nVous verrez alors le jeton dont vous avez besoin pour ajouter à votre fichier de configuration pour Home Assistant. Enregistrez-le quelque part et appuyez sur `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\npuis appuyez sur `Subscribe` pour ajouter des abonnés:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nChoisissez n'importe quel abonné que vous voulez et suivez les instructions.\\n\\nMaintenant, vous devez modifier la configuration sur votre ordinateur avec Home Assistant. Sous l'utilisateur `homeassistant`, ouvrez le fichier `configuration.yaml`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nEt ajoutez ces lignes:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nAjoutez également une nouvelle automatisation après la ligne `automation:`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nCette automatisation enverra le message `Door was changed to on/off` après que le capteur avec l'ID d'entité `binary_sensor.contact_sensor_contact` change d'état de `off` à `on`.\\n\\nEt redémarrez Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"29f147e72d25de684f61c663643edd49\",\"title\":\"Responsabilité\",\"path\":\"/docs/fr/liability/\",\"content\":\"\\n**Pour transformer les robots en agents économiques, il faut un outil de contrat pour cela. Découvrez Responsabilité - Robonomics pallet qui met en œuvre des contrats entre les comptes parachain!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Veuillez noter que ce tutoriel est présenté sur une instance locale de Robonomics Node. Configurez la vôtre avec [ces instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Aperçu de la théorie\\n\\nSur Ethereum, il y avait une structure assez compliquée d'interaction de responsabilité. Vous pouvez vous familiariser avec celle-ci [ici](/docs/robonomics-how-it-works). De nos jours, les choses sont un peu plus faciles avec Kusama!\\n\\n### Négociations\\n\\nPour signer un contrat, les deux parties doivent d’abord négocier. Cela peut être effectué de plusieurs manières, notamment [IPFS PubSub](https://blog.ipfs.tech/25-pubsub/) ou Robonomics PubSub. Un exemple de code Python utilisant Robonomics PubSub est\\nprésenté [ici](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub).\\n\\nL'offre et la demande sont des messages contenant deux caractéristiques principales d'un contrat: **description du travail** et **prix**. Le format du message doit être conçu par l'utilisateur pour chaque application spécifique. Il n'est pas si important dans le processus de négociation de suivre une règle de format strict. Le flux possible est présenté dans l'image ci-dessous.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Notez que PubSub est un protocole ouvert, donc aucune donnée sensible ne doit être transférée. Pour cela, vous devez utiliser d'autres protocoles.\\n\\n</robo-wiki-note>\\n\\n\\n### Signatures\\n\\nUne fois les négociations terminées avec succès, chaque partie doit signer son soi-disant accord appelé signature. C'est un\\nmessage contenant la description du poste et le prix **dans un format spécifique** signé avec une clé privée du compte. Il y a un\\n[Outil Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability) pour cela également.\\n - La description du travail est appelée **technics**. Il s'agit d'une chaîne de 32 octets de longueur similaire à un lancement qui peut être un CID IPFS encodé.\\n - Le prix est appelé **économie**. Il s'agit d'un décimal XRT - Weiner. 1 Weiner = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  On peut obtenir un [CID IPFS](https://ipfs.tech/) formaté de manière appropriée avec la [bibliothèque Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  Lors de l'utilisation de la fonction `sign_liability`, il n'est pas nécessaire de transformer le hachage, cela se fera automatiquement.\\n\\n</robo-wiki-note>\\n\\nEn suivant l'exemple du café:\\n\\n1. La tâche est un JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Son CID IPFS est `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Donc les **techniques** (CID transformé) sont `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **L'économie** est `1,5 XRT`.\\n\\nUne fois signé, il est temps de créer une responsabilité! Cela peut être fait par l'une des parties (soit le promettant, soit le promettant) ou par un compte tiers d'un fournisseur.\\n\\n## Créer une responsabilité\\n\\n### Préparatifs\\n\\nComme cela a été mentionné précédemment, au moins deux parties sont impliquées dans le processus. Pour cet exemple, utilisons trois parties et créons un fournisseur séparé pour cela. Supposons que les négociations aient déjà eu lieu d'une manière ou d'une autre.\\n\\n### 1. Créez trois comptes et ajoutez des fonds à ceux-ci\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nIci, nous avons fourni au fournisseur 100 XRT pour signer les extrinsèques de responsabilité, le promettant a reçu 2 XRT pour payer le travail.\\nLe promettant n'a reçu aucun fonds (à l'exception d'un dépôt existentiel d'au moins 1 mXRT).\\n\\n### 1. Accédez à Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Choisissez la liability -> create-la dans la liste déroulante des extrinsèques possibles\\n\\nChoisissez également le compte avec lequel vous souhaitez soumettre l'extrinsèque. Remplissez tous les paramètres.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  Étant donné que le fournisseur est utilisé ici, il n'est pas nécessaire de connaître les graines des participants. Seules leurs signatures sont nécessaires.\\n\\n</robo-wiki-note>\\n\\n### 3. Soumettez la transaction\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Examinez votre responsabilité dans les événements\\n\\nPour cela, accédez à `Network -> Explorer` et trouvez une liste d'événements à droite. Cliquez sur une icône de triangle pour l'agrandir.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  Le hachage peut être transformé en un CID IPFS avec le même [outil Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Exploration du stockage\\n\\nVous pouvez également explorer certaines caractéristiques des responsabilités dans le module de stockage `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  La fonction de stockage `Next Index` montre le dernier index de responsabilité +1, donc même si c'est `1`, la responsabilité `0` est explorée.\\n\\n</robo-wiki-note>\\n\\n## Rapports\\n\\nImaginez qu'un café a été préparé et que la machine à café doit le signaler d'une manière ou d'une autre. C'est là que les rapports de responsabilité entrent en jeu. En tant que preuve de travail, le compte ajoute un autre CID IPFS en tant que contenu du rapport lors de la finalisation de la responsabilité existante. Cela nécessite à nouveau une signature du promettant.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  Le message signé contient l'indice de responsabilité existant et l'identifiant IPFS du rapport encodé en représentation de 32 octets. Une fois de plus, l'outil Python peut aider à signer le rapport.\\n\\n</robo-wiki-note>\\n\\nEn restant avec l'exemple de la machine à café:\\n\\n1. Le rapport est un JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Son identifiant IPFS est `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. Ainsi, la **charge utile** (CID transformé) est `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2` \\n4. **L'indice** est `0`, c'est l'indice de responsabilité existant.\\n\\n### 1. Accédez aux extrinsics, liability -> finalize(report)\\n\\nFill in the parameters and submit extrinsic. Again, this may be done by a 3rd-party account. \\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Faites attention à ce que le compte prometteur ne soit pas \\\"mort\\\" - il doit avoir un dépôt existentiel d'au moins 1 mXRT.\\n\\n</robo-wiki-note>\\n\\nSignez et soumettez le rapport. Une fois terminé, vous pouvez l'explorer dans les événements.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Explorer les rapports\\n\\nVous pouvez également observer le rapport dans le stockage. Allez à `Developer -> Storage` et choisissez `liability` dans la liste déroulante.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Vérifier les soldes\\n\\nSur l'image, il est montré que le prometteur a maintenant reçu le \\\"salaire\\\". La relation économique s'est produite!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  Pour l'instant, il n'y a aucun moyen de vérifier si le travail est terminé, donc dès que le prometteur fait un rapport, les jetons sont transférés sur son compte. \\n  La fonction de vérification sera ajoutée à l'avenir.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"e168544248bf5a0d391f076d673ab4cf\",\"title\":\"Lancement\",\"path\":\"/docs/fr/launch/\",\"content\":\"\\n**Une autre fonctionnalité de base de Robonomics parachain est la palette de lancement. Elle vous permet d'envoyer des commandes aux comptes/entités qui se trouvent derrière eux. Ces commandes comprennent un paramètre pour spécifier la tâche à exécuter.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Veuillez noter que ce tutoriel et les suivants sont démontrés sur une instance locale de Robonomics Node. Configurez le vôtre avec [ces instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Accédez à Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Choisissez launch -> launch dans la liste déroulante des extrinsèques possibles\\n\\nChoisissez également un compte avec lequel vous souhaitez soumettre l'extrinsèque. Remplissez le champ de l'adresse cible et du paramètre.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Launch prend en charge les chaînes de 32 octets en tant que commandes ([source](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)),\\n  il y a donc de la place pour improviser ici :\\n  - Pour les commandes de base comme le basculement, vous pouvez utiliser \\\"0x00000000000000000000000000000000000000000000000000000000000000001\\\" ou\\n  \\\"0x0000000000000000000000000000000000000000000000000000000000000000000\\\".\\n  - Pour les commandes avancées, notamment de type json, vous pouvez utiliser [IPFS](https://ipfs.tech/) CID formaté dans un\\n  [de la bonne manière](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Soumettre la transaction\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Vérifiez votre lancement dans les événements\\n\\nPour cela, accédez à *Network -> Explorer* et trouvez une liste d'événements à droite. Cliquez sur une icône de triangle pour l'agrandir.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"76eddb4aa0e02cf4d82d3b612562765e\",\"title\":\"Comment mettre à jour la version du nœud Robonomics Collator\",\"path\":\"/docs/fr/how-to-update-collator-node-version/\",\"content\":\"\\nIl est recommandé de lire les articles suivants avant de lire ce post: [\\\"Comment construire un nœud Collator\\\"](/docs/how-to-build-collator-node) & [\\\"Comment lancer le Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nCet article contient les commandes nécessaires pour mettre à jour un nœud collator Robonomics (fonctionnant sous Ubuntu), et donne également un exemple par la suite.\\n\\n## **Commandes requises**\\n\\n0. Avant de commencer, il est recommandé d'être connecté en tant que `root`, sinon, je vous recommande d'utiliser:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Arrêtez le service Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Supprimez la version précédente de Robonomics (assurez-vous d'être dans le répertoire correct):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Obtenez la [dernière version](https://github.com/airalab/robonomics/releases) de Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Extrayez le fichier:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Déplacez le fichier:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nVous devez déplacer ce fichier dans le répertoire correct où vous avez installé le nœud Robonomics)\\n\\n</robo-wiki-note>\\n\\n6. Démarrez Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nExemple de mise à niveau du nœud collator vers Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Modification de la base de données de la chaîne de relais Kusama sans chemin de base défini**\\n\\nIl arrive parfois que certains instantanés de la chaîne de relais Kusama provoquent des erreurs sur votre nœud. Cela entraîne souvent l'arrêt de votre nœud. Exemple d'erreur causée par une base de données de chaîne de relais corrompue:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nPour résoudre cette erreur, vous devez supprimer votre base de données de chaîne de relais Kusama existante (probablement RocksDb) et la remplacer par une autre base de données telle que ParityDb. Exécutez les commandes suivantes:\\n\\n1. Trouvez le répertoire du nœud Robonomics et vérifiez les fichiers:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Vérifiez que vous voyez le répertoire polkadot, puis accédez au répertoire chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Supprimez le répertoire `ksmcc3` :\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Créez un nouveau répertoire `ksmcc3`.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Maintenant, vous devez télécharger un nouvel instantané. Cet exemple utilise un instantané de chaîne de relais fortement élagué, mais vous pouvez le remplacer par n'importe quel instantané de votre choix.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Pendant que l'instantané se télécharge, ouvrez une nouvelle session et modifiez votre fichier de service:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nModifiez les lignes du fichier de service qui concernent la base de données et l'élagage:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nUtilisez `Ctrl + S` puis `Ctrl + X` pour enregistrer et quitter le fichier de service.\\n\\n7. Maintenant, vous devez recharger votre démon.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. À ce stade, dans votre autre session, espérons que la nouvelle base de données a été téléchargée, donc extrayez le fichier:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. Après la fin du déballage, exécutez ce qui suit:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Maintenant, vous pouvez démarrer le service, le surveiller pour détecter d'éventuelles erreurs et vérifier qu'il est en liaison à la fois avec la chaîne de relais et la parachaine:\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"878d3c27279e7535965b8e1d3d8012e4\",\"title\":\"Comment lancer le collateur Robonomics\",\"path\":\"/docs/fr/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  Dans la vidéo et les captures d'écran de cet article, nous avons utilisé la version 1.4.0 de Robonomics. Vous devez utiliser les mêmes commandes, mais remplacer la version de Robonomics par la version actuelle.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nActuellement, le réseau Robonomics est principalement maintenu par les développeurs initiaux, mais n'importe qui peut soutenir le projet. Chaque nœud complet supplémentaire de la blockchain contribue à sa durabilité et à sa tolérance aux erreurs. Les binaires des nœuds Robonomics sont disponibles dans les ressources de [version](https://github.com/airalab/robonomics/releases) ou peuvent être [construits à partir des sources](/docs/how-to-build-collator-node/).\\n\\n## Qu'est-ce qu'un collecteur\\n\\nUn collateur fait partie de la parachain Robonomics. Ce type de nœud crée de nouveaux blocs pour la chaîne Robonomics.\\n\\n>Les collecteurs maintiennent les parachains en collectant les transactions de parachain des utilisateurs et en produisant des preuves de transition d'état pour les validateurs de la chaîne de relais. En d'autres termes, les collecteurs maintiennent les parachains en agrégeant les transactions de parachain en candidats de bloc de parachain et en produisant des preuves de transition d'état pour les validateurs basées sur ces blocs.\\n\\nVous pouvez en savoir plus sur les collateurs sur la page wiki [Polkadot](https://wiki.polkadot.network/docs/learn-collator) associée.\\n\\nDans la parachain Robonomics, chaque assembleur reçoit des récompenses de (**0,001598184 XRT**) pour chaque bloc construit par l'assembleur (les récompenses se produisent lorsque les blocs sont scellés à la chaîne).\\nDe plus, le collateur qui construit le bloc reçoit **50% des frais de transaction** contenus dans le bloc qu'il crée.\\n\\n## Exigences\\n\\nIl est recommandé de lancer un collateur en utilisant les **exigences matérielles standard** pour les [validateurs Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware) :\\n+ Compatible x86-64.\\n+ Intel Ice Lake, ou plus récent (série Xeon ou Core) ; AMD Zen3, ou plus récent (EPYC ou Ryzen).\\n+ 4 cœurs physiques @ 3,4 GHz.\\n+ Multithreading simultané désactivé (Hyper-Threading sur Intel, SMT sur AMD).\\n+ Stockage - Un SSD NVMe de 1 To (car il doit être de taille raisonnable pour faire face à la croissance de la blockchain).\\n+ Mémoire - 32 Go DDR4 ECC\\n\\n\\nDans cet article, nous utilisons les spécifications suivantes :\\n+ 4 vCPU\\n+ 700 Go d'espace NVMe pour les bases de données du collateur. La capacité d'étendre cet espace disque est requise.\\n+ 8 Go de RAM\\n\\n\\n## Informations importantes\\n1. Nous utilisons certaines variables dans ces instructions, et vous devrez remplacer les valeurs par les vôtres dans toutes les commandes :\\n    + **%NODE_NAME%** est le nom du nœud. Exemple : *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** est le chemin vers le volume monté. Exemple : */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** est l'adresse du compte dans l'écosystème Polkadot au format SS58. Exemple : *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Notez que vous devez inclure *--state-cache-size=0* dans le lancement du service du collateur. Ce paramètre est important pour la stabilité du collateur.\\nVous pouvez voir plus d'informations dans l'[issue](https://github.com/airalab/robonomics/issues/234) associée sur github.\\n\\n## Lancer facilement un collateur Robonomics pour la première fois\\n\\nVous pouvez facilement lancer un collateur directement dans la ligne de commande pour vérifier les erreurs.\\nAprès cela, il est fortement recommandé de lancer le collateur Robonomics en tant que service (voir l'étape suivante).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Lancer le collateur Robonomics en tant que service\\n\\n1. Créez l'utilisateur pour le service avec un répertoire personnel\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Téléchargez, extrayez et déplacez le binaire Robonomics dans le répertoire */usr/local/bin/*. Vous devez remplacer *$ROBONOMICS_VERSION* par la version actuelle de Robonomics dans les commandes de cette section. Vous pouvez trouver la version actuelle sur la [page des versions du référentiel Robonomics sur github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Créez le fichier de service systemd nommé *robonomics.service* :\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    Et ajoutez les lignes suivantes dans le fichier de service :\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Enregistrez ce fichier, puis activez et démarrez le service :\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nURL de télémétrie : https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nLes journaux des assembleurs peuvent être surveillés avec : `journalctl -u robonomics.service -f`\\n\\nUne fois l'assembleur Robonomics lancé, il commencera à se synchroniser avec la chaîne de relais Kusama. Cela peut prendre un temps considérable, en fonction de la vitesse de votre réseau et des spécifications du système. Nous vous recommandons donc de télécharger un instantané Kusama.\\n\\n\\n## Accélérer le processus de synchronisation en utilisant un instantané Kusama\\n\\nNous recommandons de le faire immédiatement après avoir créé et démarré le service Robonomics. Vous pouvez trouver plus d'informations sur les instantanés et les instructions d'utilisation sur la page suivante : https://ksm-rocksdb.polkashots.io/\\n\\nInstructions :\\n\\n1. Arrêtez le service Robonomics et supprimez le répertoire de base de données Kusama actuel :\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Téléchargez l'instantané actuel et extrayez-le :\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    Vous pouvez supprimer l'archive téléchargée après un déballage réussi :\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Définissez la bonne propriété pour le dossier de la base de données :\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Redémarrez le service Robonomics :\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Vérifiez les journaux du service :\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Dépannage\\n### Erreur : \\\"State Database error: Too many sibling blocks inserted\\\"\\nPour corriger cette erreur, vous pouvez simplement lancer votre assembleur en mode archive :\\n\\n1) Tout d'abord, il faut arrêter le service Robonomics : \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Ensuite, ajoutez le paramètre `--state-pruning=archive` à la partie parachain du fichier de service. Exemple du fichier de service modifié:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Rechargez la configuration du gestionnaire systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Supprimez la base de données parachain existante:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Lancez le service robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    Après cela, il faut attendre la synchronisation de la base de données parachain.\\n\\n### Erreur : \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nCette erreur est liée aux paramètres de virtualisation. Il faut utiliser le type \\\"host-model\\\" du processeur émulé. Vous pouvez le configurer sur l'hôte de virtualisation.\\n\\nMais si vous rencontrez cette erreur sur n'importe quel hébergement, vous devez contacter le support technique uniquement pour ce problème.\\n\"}},{\"node\":{\"id\":\"f79abb616632af02ca5bf631cc8bb8e6\",\"title\":\"Comment construire un nœud de collecteur à partir de la source\",\"path\":\"/docs/fr/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  Dans la vidéo et les captures d'écran de cet article, nous avons utilisé la version 1.4.0 de Robonomics. Vous devez utiliser les mêmes commandes, mais remplacer la version de Robonomics par la version actuelle.\\n</robo-wiki-note>\\n\\n## Qu'est-ce qu'un collecteur\\n\\nLe collecteur fait partie de la parachain Robonomics. Ce type de nœud crée de nouveaux blocs pour la chaîne..\\n\\n>Les collecteurs maintiennent les parachains en collectant les transactions de parachain des utilisateurs et en produisant des preuves de transition d'état pour les validateurs de la chaîne de relais. En d'autres termes, les collecteurs maintiennent les parachains en agrégeant les transactions de parachain en candidats de bloc de parachain et en produisant des preuves de transition d'état pour les validateurs basées sur ces blocs.\\n\\nVous pouvez en savoir plus sur le collecteur sur la page wiki [Polkadot](https://wiki.polkadot.network/docs/learn-collator) associée.\\n\\nDans la parachain Robonomics, chaque assembleur reçoit des récompenses (**0,000380520 XRT**) pour chaque bloc qu'il a construit, si ce bloc a été scellé à la chaîne.\\nL'assembleur bénéficie également de **50 % de frais de transaction** sur ce bloc.\\n\\n## Processus de construction\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nAssurez-vous d'avoir Rust et les logiciels de support installés. L'installateur Rust vous demandera des options d'installation actuelles, vous devez choisir l'option `1) Continuer l'installation (par défaut)`.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Installer Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nInstallez la chaîne d'outils nocturne requise et la cible wasm.\\nLes commandes suivantes sont valables pour Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nVous devrez également installer les packages suivants:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nMaintenant, vous pouvez installer le nœud robonomics à partir de la source git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nAprès cette commande, le binaire robonomics compilé se trouvera dans le répertoire `~/.cargo/bin`.\\n\\nL'étape suivante consiste à lancer le nœud collecteur. Vous pouvez en lire plus à ce sujet dans l'article [\\\"Comment lancer le collecteur Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"1af94819862b9d5e193799003dfd84dd\",\"title\":\"Mettez à niveau votre Home Assistant OS\",\"path\":\"/docs/fr/hass-os-upgrade/\",\"content\":\"\\n**Cet article contient des instructions pour mettre à niveau votre Home Assistant OS existant avec l'intégration Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Installer IPFS Add-on\\n\\n\\nL'intégration Robonomics stocke les données à l'aide d'un démon IPFS local, vous devez donc l'installer d'abord. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. Il existe un [add-on IPFS pour Home Assistant](https://github.com/airalab/ipfs-addon). Pour l'installer, allez dans `Settings` -> `Add-ons` et appuyez sur le bouton `ADD-ON STORE` dans le coin inférieur droit.\\n\\n2. Appuyez sur les trois points dans le coin supérieur droit et choisissez `Repositories`. Ajoutez-y le lien suivant:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Appuyez sur le bouton `ADD`.\\n\\n4. Fermez le gestionnaire de dépôts et actualisez la page. Maintenant, à la fin de la page, vous pouvez voir l'add-on IPFS Daemon.\\n\\n5. Ouvrez l'add-on et appuyez sur `INSTALL`. Après l'installation, appuyez sur `START`.\\n\\n## Installer HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) vous permet d'installer des intégrations personnalisées.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Avant de commencer, vous devez installer un add-on pour vous connecter à l'appareil Home Assistant avec SSH. Dans le magasin d'add-ons, recherchez `ssh`. Nous vous recommandons d'installer l'add-on `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Si l'add-on SSH n'est pas trouvé, essayez d'activer le mode avancé dans les paramètres de votre profil utilisateur. Pour ce faire, cliquez sur l'icône de profil dans le coin inférieur gauche et trouvez l'option Mode avancé.\\n\\n</robo-wiki-note>\\n\\n2. Choisissez l'add-on et appuyez sur `INSTALL`. Une fois l'installation terminée, allez dans l'onglet `Configuration` et ajoutez un `password` ou des `authorized_keys`. N'oubliez pas d'enregistrer cette partie de la configuration.\\n\\n3. Dans l'onglet `Info`, appuyez sur `START`. Si vous souhaitez voir l'add-on dans la barre latérale, n'oubliez pas d'activer `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Ouvrez l'add-on SSH et exécutez la commande suivante:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Redémarrez Home Assistant (vous pouvez le faire dans `Settings`->`System`). \\n\\n6. Maintenant, l'intégration HACS sera disponible à ajouter dans le menu `Integrations`. Allez dans `Settings`->`Devices & Services`, appuyez sur `Add Integration` et recherchez HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Pour utiliser HACS, vous avez besoin d'un compte Github.\\n\\n</robo-wiki-note>\\n\\n7. Cliquez dessus et suivez les instructions d'installation. \\n\\n## Installer l'intégration Robonomics\\n\\nMaintenant, vous pouvez installer l'intégration Robonomics en utilisant HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nOuvrez HACS dans le menu de la barre latérale et accédez à `Integrations`. Cliquez sur ``Explore & Download Repositories`, puis recherchez `Robonomics` et cliquez sur le bouton `Download` situé dans le coin inférieur droit. Une fois le téléchargement terminé, redémarrez Home Assistant.\"}},{\"node\":{\"id\":\"3264de850004fd5c8d021baa4f56b86f\",\"title\":\"Initialisation de Home Assistant\",\"path\":\"/docs/fr/hass-init/\",\"content\":\"\\n**Après avoir installé Home Assistant, il doit être initialisé.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nVous commencez par la création du compte propriétaire de Home Assistant. Ce compte est un administrateur et peut apporter toutes les modifications nécessaires. Ouvrez un navigateur web et allez à l'adresse `http://%RASPBERRY_IP_ADDRESS%:8123`. Vous pouvez trouver l'adresse IP du Raspberry Pi en utilisant l'application mobile [Fing](https://www.fing.com/products) ou l'outil en ligne de commande [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">L'adresse du Raspberry Pi peut changer avec le temps en fonction des paramètres du routeur.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. Sur la première page, saisissez un nom, un nom d'utilisateur, un mot de passe et cliquez sur le bouton `CREATE ACCOUNT`.\\n\\n2. À l'écran suivant, saisissez un nom pour votre domicile, définissez votre emplacement et votre système d'unités. Cliquez sur `DETECT` pour trouver votre emplacement et définir votre fuseau horaire et votre système d'unités en fonction de cet emplacement. Si vous ne souhaitez pas envoyer votre emplacement, vous pouvez définir ces valeurs manuellement.\\n\\n3. Ensuite, Home Assistant affichera tous les appareils qu'il a découverts sur votre réseau. Ne vous inquiétez pas si vous en voyez moins que ce qui est indiqué ci-dessous ; vous pouvez toujours ajouter des appareils manuellement ultérieurement. Pour l'instant, cliquez simplement sur `FINISH` et vous serez sur l'écran principal de Home Assistant.\\n\\n4. Enfin, vous verrez l'interface web de Home Assistant, qui affichera tous vos appareils. \\n\\n\\n## Dépannage\\n\\n1. Si vous oubliez votre nom d'utilisateur ou votre mot de passe pour l'utilisateur local, [consultez cet article](https://www.home-assistant.io/docs/locked_out/) pour restaurer vos informations d'identification.\\n\"}},{\"node\":{\"id\":\"52ade452a432eaad7562dab74e1dd87d\",\"title\":\"Image pré-installée pour Raspberry Pi\",\"path\":\"/docs/fr/hass-image-install/\",\"content\":\"\\n**Bienvenue dans le guide d'installation de Home Assistant avec l'intégration Robonomics sur un Raspberry Pi. Home Assistant est un système domotique open-source qui fournit un hub centralisé pour contrôler les appareils intelligents de votre réseau domestique. En intégrant Robonomics, un service cloud décentralisé, vous pouvez améliorer les fonctionnalités et la sécurité de votre maison intelligente. Dans cet article, nous vous fournirons des instructions étape par étape sur l'installation de Home Assistant avec Robonomics sur un Raspberry Pi, vous permettant d'automatiser et de contrôler différents aspects de votre maison à l'aide d'une solution sécurisée et décentralisée. Commençons !**\\n\\n## Matériel nécessaire pour l'installation\\n\\nSi vous n'avez pas encore intégré Home Assistant à votre configuration de maison intelligente, il est important de connaître l'équipement dont vous aurez besoin pour établir un système domotique complet à partir de zéro.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Télécharger l'image pré-installée de Robonomics\\n\\nL'image pré-installée de Robonomics contient :\\n- Home Assistant Core\\n- IPFS\\n- Courtier MQTT et intégration\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nVous pouvez vérifier le code source et télécharger la dernière version de l'image sur [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Configurer l'image\\n\\nInstallez [Raspberry Pi Imager](https://www.raspberrypi.com/software/) sur votre ordinateur. Ensuite, insérez la carte SD.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nExécutez le programme Raspberry Pi Imager. Choisissez l'image requise comme système d'exploitation et assurez-vous de sélectionner votre carte SD dans le menu déroulant de stockage.\\nDans les paramètres :\\n- Définissez un nom d'utilisateur et un mot de passe (enregistrez le nom d'utilisateur par défaut \\\"pi\\\" pour qu'il soit facile à retenir),  \\n- fournissez le nom et le mot de passe de votre Wi-Fi, \\n- choisissez votre pays dans la liste déroulante\\npuis `Écrire` l'image. \\n                   \\n<robo-wiki-note type=\\\"note\\\">Gardez précieusement le nom d'utilisateur et le mot de passe, car ces informations seront nécessaires en cas de dépannage</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nVous pouvez trouver les codes de pays [ici](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. Premier démarrage\\n\\n**Éjectez en toute sécurité la carte SD**, insérez-la dans le Raspberry Pi. Ensuite, **insérez l'adaptateur Zigbee** dans le Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">Il est important d'insérer l'adaptateur Zigbee avant le premier démarrage du Raspberry Pi ! \\nIl est nécessaire pour l'auto-configuration du réseau Zigbee.</robo-wiki-note>\\n\\n**Si vous avez le [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (qui dispose de tous les micrologiciels nécessaires), vous pouvez simplement suivre ces instructions. Cependant, si vous avez un autre adaptateur, la première chose à faire est de le flasher avec le logiciel Zigbee2MQTT. Vous pouvez trouver des instructions pour votre appareil [ici](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nEnsuite, connectez le câble d'alimentation à votre appareil. Il devrait se connecter à votre réseau Wi-Fi. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nUne fois votre Raspberry Pi connecté, la LED rouge s'allumera et la LED verte clignotera pendant un certain temps. Attendez jusqu'à 5 minutes que le Raspberry Pi démarre et s'enregistre sur le réseau.\\n\\nMaintenant, trouvez l'adresse IP du Raspberry Pi. Pour la trouver, vous pouvez utiliser l'application mobile [Fing](https://www.fing.com/products) ou \\nl'outil en ligne de commande [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Trouvez le nom `robots-home` (le nom optionnel peut être `Home(homeassistant)`) \\nde la machine hôte dans la liste des adresses IP. \\n\\nDans cet exemple, l'adresse est `192.168.43.56`. \\n\\nPour vérifier que tout fonctionne, ouvrez un navigateur web et accédez à la page web `http://%RASPBERRY_IP_ADDRESS%:8123`. Dans cet exemple, ce sera `192.168.43.56:8123`.\\nSi tout va bien, vous verrez l'interface web de Home Assistant. Si la page web ne s'ouvre pas, attendez jusqu'à 5 minutes que le Raspberry Pi démarre et réessayez. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Dépannage\\n\\n1. Pour modifier les paramètres Wi-Fi ultérieurement, vous devez vous connecter à votre Raspberry Pi via la commande `ssh`. Pour cela, ouvrez un terminal sur votre ordinateur\\net saisissez la commande ssh avec votre nom d'utilisateur, que vous avez créé à l'étape \\\"Configuration de l'image\\\" (le nom par défaut est \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\npuis utilisez la commande `sudo raspi-config`. Trouvez plus d'informations sur cette commande sur [le site officiel.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"b170327f1a4abf86dd08a321a01ec7a2\",\"title\":\"Mettez à niveau votre Docker Home Assistant pour les systèmes d'exploitation de type Unix\",\"path\":\"/docs/fr/hass-docker-upgrade/\",\"content\":\"\\n**Cet article contient des instructions pour mettre à niveau votre Docker Home Assistant existant (sur un système d'exploitation de type Unix) avec l'intégration Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Il est supposé que les images et les conteneurs Docker par défaut de Home Assistant nommés <u>homeassistant</u> sont utilisés.\\n  2. IPFS sera installé et exécuté en tant que service <u>systemd</u> sur la machine hôte.\\n  3. Il est supposé que vous avez [Python3.9](https://www.python.org/downloads/) ou une version supérieure installée.\\n\\n</robo-wiki-note>\\n\\n## Installer\\n\\nTéléchargez le script d'installation et exécutez-le dans le terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nVous verrez la sortie suivante:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Vous pouvez voir une erreur comme `mkdir: can't create directory 'custom_components': File exists`. Cela signifie que vous avez déjà ce dossier avec certains composants personnalisés installés. Ignorez simplement ce message.\\n\\n</robo-wiki-note>\\n\\nRedémarrez le conteneur:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Vérifier\\n\\nVérifiez que le service IPFS est en cours d'exécution:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVous verrez la sortie suivante:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"a4fab76a874ebc045c4c1b53e0e470e1\",\"title\":\"Mettez à niveau votre Home Assistant Core\",\"path\":\"/docs/fr/hass-core-upgrade/\",\"content\":\"\\n**Cet article contient des instructions pour mettre à niveau votre Home Assistant Core existant avec l'intégration Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Il est supposé que l'installation de votre Home Assistant Core a été effectuée conformément aux [instructions officielles](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) et qu'il existe un utilisateur <u>homeassistant</u> et l'environnement `venv`. Si ce n'est pas le cas, suivez les instructions ci-dessous, **mais modifiez le script en conséquence**.\\n  2. IPFS sera installé et exécuté en tant que service <u>systemd</u> sur la machine hôte.\\n  3. Il est supposé que vous avez installé [Python3.9](https://www.python.org/downloads/) ou une version ultérieure.\\n\\n</robo-wiki-note>\\n\\n## Installerer\\n\\nTéléchargez le script d'installation et exécutez-le dans le terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nVous verrez la sortie suivante:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nAu cours du processus, il vous sera demandé de confirmer le redémarrage de plusieurs services. En naviguant avec `tab`, sélectionnez l'option `yes`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Vous pouvez voir une erreur comme `mkdir: can't create directory 'custom_components': File exists`. Cela signifie que vous avez déjà ce dossier avec certains composants personnalisés installés. Ignorez simplement ce message.\\n\\n</robo-wiki-note>\\n  \\nAprès avoir terminé, redémarrez votre Home Assistant.\\n\\n## Vérifier\\n\\nVérifiez que le service IPFS est en cours d'exécution:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVous verrez le résultat suivant :\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"6bb79302c33b3488b72f9007a4544eb3\",\"title\":\"Glossary\",\"path\":\"/docs/fr/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\nune conjonction d'une paire de clés publique-privée, dont la partie publique est l'adresse publique de l'utilisateur et la partie privée est la clé secrète permettant d'accéder au contrôle de cette adresse.\\n\\n\\n### Auction (of Parachains)\\nmécanisme de location de slots pour les parachains dans les écosystèmes Polkadot et Kusama ; un parachain doit remporter une enchère aux chandelles pour obtenir un slot.\\n\\n### Autonomous Agent\\nun système informatique qui reçoit des données sensorielles de son environnement et décide comment réagir aux stimuli externes afin d'atteindre ses objectifs.\\n\\n### AIRA\\nou Agent Robotique Intelligent Autonome — un logiciel développé par l'équipe Robonomics en 2015, qui met en œuvre la norme d'interaction économique homme-machine et machine-machine grâce à un contrat de responsabilité intellectuelle.\\n\\n\\n## B\\n\\n### Blockchain\\ndans un sens large, un réseau distribué qui utilise la cryptographie pour permettre à un groupe de participants de parvenir à un consensus de confiance sur l'état changeant d'un système.\\n\\n### Blockchain Explorerr\\nune application qui permet d'explorer les différents blocs, transactions et adresses sur une blockchain (par exemple Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\nune logique d'automatisation préfabriquée qui peut être facilement ajoutée à une instance de Home Assistant.\\n\\n### Bridge\\nune technologie et des méthodes permettant à deux chaînes économiquement souveraines et technologiquement diverses de communiquer entre elles. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nou Cs — une millionième part d'un jeton XRT, 1 XRT = 1 000 000 Cs ; du nom de Ronald Coase, économiste britannique, l'un des fondateurs de l'économie institutionnelle, lauréat du prix Nobel commémoratif des sciences économiques.\\n\\n### Collator\\nun nœud qui maintient un parachain en collectant les transactions de parachain et en produisant des preuves de transition d'état pour les validateurs.\\n\\n### Consensus\\nun processus dans lequel les nœuds d'un réseau blockchain parviennent à un accord sur l'état actuel des données dans le réseau (par exemple, preuve de travail, preuve de participation).\\n\\n### Crowdloan\\nune campagne de financement participatif visant à collecter des jetons pour enchérir sur les slots aux enchères dans l'écosystème Polkadot / Kusama.\\n\\n### Cybernetics\\nl'étude du contrôle et de la communication dans l'animal et la machine, selon la définition de N. Wiener.\\n\\n### Cyber-Physical System\\nou CPS — une unification forte et une intégration mutuelle de plusieurs processus computationnels, de mise en réseau et physiques.\\n\\n\\n## D\\n\\n### DAO\\nune organisation décentralisée et détenue collectivement, dans laquelle la gestion des ressources est effectuée conformément à un ensemble de règles préalablement convenues et formalisées, dont l'application est effectuée automatiquement.\\n\\n### Datalogue (Function)\\nune fonction de parachain Robonomics, qui stocke les données des appareils sur la blockchain.\\n\\n### Dapp\\nou application décentralisée — une application qui s'exécute dans le cadre d'un réseau distribué et permet d'accéder à ses fonctions de manière conviviale.\\n\\n### Decentralized Cloud\\nun service d'informatique en nuage basé sur un réseau pair à pair décentralisé auquel les utilisateurs peuvent se joindre soit pour utiliser des services, soit pour fournir leurs ressources telles que le calcul, la mise en réseau, le stockage, etc.\\n\\n### Digital Twin\\nune version numérique d'un équipement réel qui copie ses caractéristiques techniques et ses données historiques.\\n\\n\\n## E\\n\\n### Edge-system\\nun appareil IoT qui fait le lien entre les systèmes embarqués accessibles localement et le réseau mondial, prenant généralement en charge les protocoles de communication et transmettant des signaux de télémétrie et de contrôle.\\n\\n### Embedded System\\nun appareil IoT avec des ressources de calcul et de communication limitées qui fournit des fonctions de base (capteurs, actionneurs, boutons) au niveau le plus bas, généralement sans interfaces utilisateur.\\n\\n### Ethereum\\nun système blockchain décentralisé et open-source qui fonctionne comme une plateforme pour de nombreuses autres cryptomonnaies, ainsi que pour l'exécution de contrats intelligents décentralisés.\\n\\n### Ethereum Upgrade\\nanciennement connu sous le nom d'Ethereum 2.0 ou Eth2 — une mise à niveau du protocole Ethereum qui devrait rendre le réseau plus évolutif, sécurisé et durable ; à cette fin, il est proposé de changer le consensus en Preuve d'Enjeu et d'ajouter un mécanisme de sharding pour augmenter la capacité du réseau.\\n\\n### Exodus\\nprocessus de transfert de jetons XRT du réseau Ethereum vers le parachain Robonomics.\\n\\n### Extrinsic\\nune fonction sur le réseau Polkadot et Kusama, qui peut déclencher des transitions d'état du réseau depuis l'extérieur de l'état.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nou Gk — un millième d'un jeton XRT, 1 XRT = 1 000 Gk ; nommé d'après Victor Glushkov, mathématicien soviétique, l'un des fondateurs de l'informatique et de la cybernétique en Union soviétique.\\n\\n\\n## H\\n\\n### Home Assistant\\nou Hass – un logiciel de système de contrôle open source, conçu pour être une plaque tournante centrale pour les appareils intelligents.\\n\\n### HRMP\\nou Horizontal Relay-routed Message Passing – un message sécurisé passant entre les parachains, qui stocke tous les messages dans le stockage de la chaîne de relais avant de l'envoyer aux parachains.\\n\\n### HMI\\nou Interface Homme-Machine — une interface utilisateur ou un tableau de bord qui connecte l'utilisateur à une machine, un système ou un appareil.\\n\\n\\n## I\\n\\n### Industry 4.0\\nou la Quatrième Révolution Industrielle — l'automatisation continue des pratiques de fabrication traditionnelles et industrielles, en utilisant des technologies intelligentes modernes.\\n\\n### IPFS\\nou Système de Fichiers InterPlanétaire — un logiciel pair à pair pour stocker et partager des données dans un système de fichiers distribué.\\n\\n### IoT\\nou Internet des Objets — une connexion à un réseau mondial de milliards d'appareils, capable de collecter des données et intégré dans l'environnement.\\n\\n### IoT Gateway\\nun système de bord qui agrège et transmet des données des appareils IoT vers le réseau et vice versa ; souvent, ces appareils sont une version plus complexe du routeur WiFi.\\n\\n### IoT Provider\\nun service externe qui offre aux utilisateurs IoT un accès distant aux données et aux analyses, ainsi que le contrôle des appareils intelligents via Internet.\\n\\n### IoT Subscription\\nfonctionnalité du parachain Robonomics, qui permet d'utiliser toutes les fonctions du parachain pendant une certaine période sans frais.\\n\\n\\n## K\\n\\n### KSM\\nun jeton natif pour le réseau Kusama.\\n\\n### Kusama\\nle \\\"réseau canari\\\" pour Polkadot qui se compose d'une version préliminaire non audité du logiciel Polkadot.\\n\\n\\n## L\\n\\n### Lancement (Function)\\nune fonction de parachain Robonomics qui démarre ou arrête un appareil en envoyant une commande via la blockchain.\\n\\n### Lease Period\\nune durée pendant laquelle un parachain peut se connecter à la Relay Chain.\\n\\n### Libp2p\\nune bibliothèque open-source pour la création de réseaux pair-à-pair chiffrés.\\n\\n### Lights-out Factory\\nou Smart Factory - une usine entièrement automatisée et ne nécessitant aucune présence humaine sur place.\\n\\n### Lighthouse\\nun contrat intelligent, dans le concept d'économie des robots, qui effectue une transaction lorsque le Fournisseur établit une correspondance de marché entre le Prometteur et le Bénéficiaire.\\n\\n### Responsabilité\\nun contrat intelligent, réalisé par des systèmes cyber-physiques entre eux ou avec des humains, pour exécuter une tâche contre paiement.\\n\\n### Responsabilité Market\\nune plateforme, dans le concept d'économie des robots, chargée de mettre en correspondance les offres et les demandes entre les nœuds du système.\\n\\n\\n## M\\n\\n### MQTT\\nou Message Queuing Telemetry Transport - un protocole de publication-abonnement conçu pour les réseaux à faible bande passante, à latence élevée et peu fiables pour le fonctionnement de volumes élevés de messages de dispositifs IoT.\\n\\n### MQTT Broker\\nun service qui reçoit tous les messages des clients MQTT, puis achemine les messages vers les clients abonnés appropriés.\\n\\n\\n## N\\n\\n### NFT\\nou Token non fongible - un jeton qui ne peut pas être échangé et indifférenciable des autres jetons, ce qui permet la tokenisation d'articles uniques et fournit une propriété exclusive pour ces jetons.\\n\\n### Node (of Robonomics)\\nun module de blockchain basé sur Substrate ou Ethereum avec des extensions Robonomics pour se connecter au réseau Robonomics.\\n\\n\\n## O\\n\\n### On-chain Governance\\nun processus de détermination des modifications autorisées sur le réseau, telles que les modifications du code ou le déplacement des fonds, qui existe dans le réseau lui-même et peut le modifier directement.\\n\\n\\n## P\\n\\n### Pallet\\nun module Substrate écrit en Rust qui regroupe une logique ou un algorithme spécifique pour l'exécution de la blockchain basée sur le substrat.\\n\\n### Parachain\\nune structure de données personnalisée spécifique à une application (généralement une blockchain) intégrée à la chaîne de relais et pouvant être validée par les validateurs.\\n\\n### Parathread\\nune parachain sans emplacement qui peut participer temporairement (sur une base bloc par bloc avec des frais) à la sécurité de la chaîne de relais.\\n\\n### Polkadot\\nun réseau hétérogène à chaînes multiples permettant à diverses blockchains de caractéristiques différentes d'effectuer une communication inter-chaînes arbitraire sous une sécurité partagée.\\n\\n### Polkadot/Substrate Portal\\nune interface utilisateur Substrate de base pour interagir avec un réseau Substrate Polkadot, Kusama et autres.\\n\\n### Proposal (on Polkadot / Kusama)\\na potential function call to be voted on in a Polkadot, Kusama or parachains referendum. \\n\\n### Proof-of-Work\\nun mécanisme de consensus selon lequel, pour parvenir à un accord, les participants du réseau doivent effectuer un travail de calcul.\\n\\n### Proof-of-Stake\\nun mécanisme de consensus selon lequel, pour parvenir à un accord, les participants du réseau doivent miser des capitaux de la cryptomonnaie associée qui agit comme garantie.\\n\\n### Promisee\\nun nœud qui passe une commande pour l'exécution d'une tâche dans le concept d'économie des robots.\\n\\n### Promisor\\nun nœud qui accepte d'exécuter une tâche en échange d'un paiement dans le concept d'économie des robots.\\n\\n### Provider (Robonomics)\\na node, in the robot economy concept, that monitors the messages of the Responsabilité Market and matches an offer and a demand for a small fee. \\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\ndans le cadre de la gouvernance en chaîne, votez pour savoir si une proposition doit être acceptée ou non par les utilisateurs du réseau.\\n\\n### Relay Chain\\nla chaîne principale qui coordonne le consensus de Polkadot / Kusama et la communication entre les parachains.\\n\\n### Robofirm\\nune organisation dans laquelle l'ensemble du cycle du processus commercial est entièrement automatisé et ne nécessite pas la participation humaine.\\n\\n### Rococo\\nle testnet pour tester les parachains sur Kusama\\n\\n### robonomics-interface\\nune bibliothèque Python spécialisée dans l'interface avec Robonomics pour une programmation pratique.\\n\\n### Robonomics sur Ethereum\\nune version de Robonomics Network fonctionnant sur Ethereum, sortie en 2018.\\n\\n### Robot Economy\\nun système économique dans lequel les appareils agissent en tant qu'agents indépendants capables d'effectuer des activités économiques clés auparavant uniques aux humains.\\n\\n### Robot-as-a-Service\\nou RaaS - un modèle commercial dans lequel les entreprises louent leur équipement robotique à des clients pour une utilisation à court ou long terme.\\n\\n### ROS\\nou Robot Operating System - un cadre de développement de logiciels pour robots, qui fournit des services conçus pour un cluster informatique hétérogène tels que l'abstraction matérielle, le contrôle de périphériques de bas niveau, la mise en œuvre de fonctionnalités couramment utilisées, la communication entre processus et la gestion de packages.\\n\\n### ROS 2\\nune version mise à jour et reconstruite de Robot Operating System avec de nouvelles fonctionnalités, telles que la prise en charge de systèmes multi-robots et de petits systèmes embarqués, et l'intégration en temps réel.\\n\\n### ROS 2 Middleware\\nou RMW - un protocole qui fournit des fonctionnalités ROS 2 standard telles que la découverte, la sérialisation et le transport ; ROS 2 prend en charge plusieurs implémentations de middleware qui peuvent être choisies en fonction des besoins du projet.\\n\\n### RWS\\nou Robonomics Web Services - services d'infrastructure décentralisée pour la robotique et l'IoT qui permettent de connecter facilement des appareils et d'interagir en toute sécurité avec des applications utilisateur, des services cloud et d'autres appareils ; il possède également son propre jeton appelé RWS, qui offre un abonnement IoT à vie dans la parachain Robonomics.\\n\\n### Exécutiontime\\nune fonction de transition d'état d'une blockchain qui définit un algorithme valide pour déterminer l'état du bloc suivant en fonction de l'état précédent.\\n\\n\\n## S\\n\\n### Seed Phrase\\nune clé privée lisible par l'homme créée comme une séquence de mots aléatoires et nécessaire pour accéder à l'adresse de la blockchain et à ses jetons.\\n\\n### Shared Security\\nle modèle de sécurité de Polkadot / Kusama selon lequel toutes les chaînes sont également sécurisées en plaçant des preuves de la validité des blocs de parachain dans la chaîne de relais de sorte qu'un attaquant potentiel devrait attaquer l'ensemble du système.\\n\\n### SLS Gateway\\nune passerelle IoT open source pour les appareils Zigbee basée sur le microcontrôleur ESP32 développé par Smart Logic System.\\n\\n### Slot (of Parachain)\\nune ressource rare dans l'écosystème Polkadot / Kusama, qui permet à une parachain d'être connectée à la chaîne de relais sans frais pour chaque bloc.\\n\\n### Smart Leasing\\nune variante du modèle Robot-as-a-Service, dans laquelle le loyer est payé non pas par temps, mais pour des opérations spécifiques et leur nombre.\\n\\n### Smart Contract\\nun programme ou un algorithme stocké sur une blockchain qui s'exécute automatiquement lorsque des conditions prédéterminées sont remplies.\\n\\n### SSH\\nor Secure Shell — a network protocol for operating network services securely over an unsecured network, that uses public-key cryptography to authenticate the remote computer. \\n\\n### Staking\\nla partie du consensus Proof-of-Stake, un acte de mise en jeu de jetons en les déposant comme garantie pour avoir une chance de produire un bloc valide et d'obtenir une récompense.\\n\\n### Substrate\\nun cadre modulaire pour la construction de blockchains telles que Polkadot et Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nun fonds collecté grâce à une partie des récompenses de production de blocs, des frais de transaction, du jalonnement, etc., qui peut être dépensé en faisant une proposition de dépense ; si le Trésor termine une période de dépense sans dépenser tous ses fonds, il subit une destruction d'un pourcentage des fonds.\\n\\n### Transaction Costs\\nle coût de collecte et de traitement des informations en raison de la rationalité limitée des agents économiques et de la complexité des processus.\\n\\n\\n## V\\n\\n### Validator\\nun nœud qui sécurise la chaîne de relais en misant ses jetons, en validant les preuves des collecteurs sur les parachaines et en votant sur le consensus avec d'autres validateurs.\\n\\n\\n## W\\n\\n### Web3\\nune idée pour une nouvelle itération du Web qui intègre des concepts tels que la décentralisation, les technologies de la blockchain et l'économie basée sur les jetons.\\n\\n### Wiener (XRT)\\nou Wn - une milliardième part d'un jeton XRT, 1 XRT = 1 000 000 000 Wn ; nommé d'après Norbert Wiener, un mathématicien américain, l'un des fondateurs de la cybernétique et de la théorie de l'intelligence artificielle.\\n\\n\\n## X\\n\\n### XCM\\nou Format de message de consensus croisé - un format de messagerie entre différents systèmes de blockchain dans Polkadot / Kusama.\\n\\n\\n### XRT\\nun jeton natif pour le réseau Robonomics, qui existe indépendamment sur les réseaux Ethereum et Kusama.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nune implémentation de réseau superposé d'un schéma de routage entièrement chiffré de bout en bout pour les réseaux maillés.\\n\\n\\n## Z\\n\\n### Zigbee\\nun protocole de communication sans fil, très couramment utilisé pour connecter des appareils intelligents en raison de sa faible consommation d'énergie, de sa facilité d'utilisation et de sa flexibilité de configuration, ainsi que de son support de la topologie de réseau auto-organisatrice et autoréparatrice.\\n\\n### Zigbee Adapter\\nun appareil qui transfère des données entre le réseau Zigbee et un autre réseau (par exemple, Wi-Fi) pour contrôler les appareils Zigbee.\\n\\n### Zigbee2MQTT\\nun logiciel qui permet de connecter Zigbee aux réseaux MQTT en traduisant les messages d'un réseau à un autre.\"}},{\"node\":{\"id\":\"52c6f069113b4379bf6c4f01982de630\",\"title\":\"Administration globale\",\"path\":\"/docs/fr/global-administration/\",\"content\":\"\\n**Cet article vous montrera comment configurer un nouvel utilisateur pour votre Home Assistant.**\\n\\n## Ajout d'utilisateurs à l'abonnement\\n\\nVous ne pouvez pas utiliser des comptes déjà créés car `SUB_OWNER` et `SUB_CONTROLLER` fournissent une sécurité, et le premier utilisateur que vous avez créé lorsque vous avez commencé Home Assistant n'a pas de compte Robonomics Parachain.\\n\\n1. Créez un compte sur Robonomics parachain, comme vous l'avez fait dans l'[article précédent](/docs/sub-activate/).\\n\\n2. Utilisez le compte `SUB_OWNER` pour ajouter un nouveau compte utilisateur à l'abonnement dans le [dapp](https://dapp.robonomics.network/#/subscription/devices). Maintenant, il devrait y avoir trois adresses dans la liste d'accès : `SUB_OWNER`, `SUB_CONTROLLER` et `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Accorder l'accès à l'utilisateur\\n\\n1. Accédez au service dapp appelé [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Choisissez le compte que vous venez de créer dans la barre latérale droite (vérifiez que vous avez choisi le compte souhaité en appuyant sur l'icône de profil).\\n\\n2. Entrez la clé `USER` dans le champ requis. Ajoutez les adresses `SUB_OWNER` et `SUB_CONTROLLER` dans les champs de crédits administrateurs. Si tout est correct, vous verrez l'état de vérification `VÉRIFIÉ`.\\n\\n3. Créez un mot de passe pour un nouvel utilisateur que vous venez d'enregistrer, puis confirmez la transaction, qui sera maintenant sans frais en raison de l'abonnement. Plus tard, vous pourrez restaurer le mot de passe dans l'onglet Restaurer.\\n\\n4. Après le processus d'inscription, connectez-vous à Home Assistant avec votre adresse utilisateur comme identifiant et un mot de passe nouvellement créé.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nMaintenant, vous pouvez utiliser le dapp pour contrôler votre maison via Robonomics, consultez l'article [**\\\"Obtenir la télémétrie de la maison intelligente\\\"**](/docs/smart-home-telemetry/).\\n\\n## Dépannage\\n\\n1. Si vous oubliez un mot de passe pour Home Assistant depuis votre compte Robonomics, [vérifiez le Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nAccédez à la partie \\\"Your Home Assistant password\\\" et choisissez l'onglet \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"1e0ce42ca507e44418b689f2fb4b4cdf\",\"title\":\"Commencer\",\"path\":\"/docs/fr/getting-started/\",\"content\":\"\\n## Qu'est-ce que Robonomics\\n\\nLa plateforme Robonomics fournit des outils pour travailler avec le réseau économique des robots. Robonomics permet aux concepteurs de villes intelligentes et de zones industrielles 4.0 de créer de la confiance parmi les [services de robots autonomes](/docs/glossary#cyber-physical-system), de fournir un [accès direct aux utilisateurs via dapp](/docs/glossary#dapp) pour commander des produits auprès d'usines autonomes et de services de réseaux de capteurs urbains. Cela permettra à son tour de mettre en place un système décentralisé qui surveille globalement les activités des systèmes cyber-physiques.\\n\\nLe graphique suivant décrit la place qu'occupe Robonomics dans le scénario:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nTrouvez plus d'informations dans [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Démarrage rapide du réseau Robonomics\\n**Pour faciliter l'intégration des nouveaux venus, les développeurs principaux de Robonomics ont mis au point une [courbe d'apprentissage en 6 leçons](/docs/wschool2021-intro/)!**\\n\\nVous explorerez l'architecture IoT sans serveur ! Robonomics Web Services (RWS) est le service infrastructurel de base pour la robotique et l'IoT sur Polkadot && IPFS.\\n\\nLes diplômés du cours peuvent lancer une chaîne de relais locale et contrôler un appareil compatible ROS grâce à une transaction inter-chaînes.\\n\\n**[Rejoignez Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) pour vous connecter à la communauté et obtenir un support technique.**\\n\\n### Avantages pour les diplômés de Robonomics Academy\\n- Stage pour les meilleurs étudiants   Devenez membre de l'équipe Robonomics et contribuez au développement du produit choisi.\\n- Communauté active && événements réguliers   Faites partie de la communauté d'apprenants, discutez de vos cas d'utilisation avec des experts de l'industrie. Faites équipe et participez à des hackathons !\\n- Certificat de fin de formation   Ajoutez un certificat de fin de cours sur la création de DAPPs pour l'IoT à votre portfolio.\\n- Aide à l'admission à l'université ITMO. Que vous soyez en licence ou en master, vous bénéficierez d'une assistance pour votre admission à l'université.\\n- Opportunités de financement && d'accélération : 1)Demandez une subvention de soutien Academia pouvant aller jusqu'à 50 000 $ ; 2)Participez au programme d'accélération Robonomics builders soutenu par la Web3 Foundation ; 3)Déployez votre DAPP autonome sur Robonomics ; 4)Monétisez-le && bénéficiez du soutien marketing de l'équipe Robonomics.\\n\\n\\n## Contenu de la documentation\\n\\n### Je suis un développeur de Dapp\\n\\n- [Robonomics-js sur GitHub](https://github.com/airalab/robonomics-js) - simple SDK Javascript pour les développeurs d'applications Robonomics Network.\\n- [Modèle de Dapp](https://github.com/airalab/vue-dapp-robonomics-template) - utilise Vue.js\\n- [Documentation Wiki](/docs/robonomics-js/)\\n\\n### Je suis un ingénieur en robotique\\n\\nConsultez la section [cas](/docs/iot-sensors-connectivity/) et commencez à développer grâce aux [exemples](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"93ea9b28a4a9b0500e86d8bb4bac34c7\",\"title\":\"Comment acheter un abonnement\",\"path\":\"/docs/fr/get-subscription/\",\"content\":\"\\n**Payer des commissions pour les transactions sur la blockchain est ennuyeux. Imaginez un appareil IoT qui envoie des données de télémétrie toutes les 5 à 10 minutes. Cela vous fera payer beaucoup chaque mois. L'une des principales caractéristiques du réseau Robonomics est le RWS - l'abonnement au service Web Robonomics. Payez mensuellement et oubliez les frais de transaction ! Pour des informations théoriques, consultez [cet](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) article.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Veuillez noter que ce tutoriel montre comment acheter un abonnement sur la parachain Robonomics Kusama. Vous pouvez également effectuer les mêmes étapes sur votre [nœud local](/docs/run-dev-node).\\n\\n  Une dernière chose avant de commencer. Il s'agit d'une façon \\\"difficile\\\" d'acheter un abonnement. Il existe une méthode conventionnelle pour le faire via [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Faire une offre aux enchères\\n\\nLes abonnements sur Robonomics sont vendus selon un modèle d'enchères. Pour en obtenir un, vous devez faire une offre aux enchères et la remporter (ne vous inquiétez pas, c'est rapide).\\n\\nDans `Developer/Chain state`, vous pouvez voir les enchères disponibles. \\nChoisissez `rws` et `auctionQueue` et appuyez sur le bouton `+`, vous verrez les identifiants des enchères disponibles :\\n\\n![queue](../images/rws/queue.png)\\n\\nVous pouvez obtenir des informations sur n'importe quel abonnement avec `rws` `auction` et l'identifiant de l'enchère (l'identifiant de l'enchère sur l'image est 79) :\\n\\n![auction](../images/rws/auction.png)\\n\\nDans les informations sur l'enchère, vous pouvez voir le champ `winner`, pour le moment il est `null`, ce qui signifie que personne n'a cet abonnement et que vous pouvez l'obtenir. Pour cela, allez dans `Developer/Extrinsic`, choisissez votre compte et `rws -> bid`. Définissez également l'identifiant de l'enchère (79) et le montant d'unités à enchérir (plus de 1000000000 Wn) :\\n\\n![bid](../images/rws/bid.png)\\n\\nSoumettez la transaction et vérifiez les informations sur l'enchère avec l'identifiant 79 (dans `Chain state`, choisissez `rws -> auction` et l'identifiant 79) :\\n\\n![win](../images/rws/auc_win.png)\\n\\nMaintenant, dans le champ `winner`, vous verrez l'adresse de votre compte, ce qui signifie que ce compte possède l'abonnement 79. Une enchère commence avec la première offre et dure quelques blocs, donc si quelqu'un offre plus de jetons que vous dans les prochains blocs, cette personne sera le gagnant et obtiendra l'abonnement.\\n\\nMaintenant, vous pouvez ajouter des appareils. Les appareils sont des comptes qui peuvent utiliser cet abonnement et soumettre des extrinsèques sans frais.\\nPour le tester, créez un nouveau compte sans jetons et ajoutez-le aux appareils\\n\\nPour ajouter des appareils, choisissez `rws -> setDevices` dans `Developer/Extrinsic`. Ensuite, appuyez sur le bouton `Ajouter un élément` et choisissez le compte récemment créé sans jetons :\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nSoumettez la transaction. Maintenant, vous pouvez vérifier la liste des appareils dans `Chain state` avec `rws -> devices`. Vous verrez l'adresse de votre compte sans jetons. Choisissez le compte qui a acheté l'abonnement et appuyez sur `+` :\\n\\n![devices](../images/rws/devices.png)\\n\\nMaintenant, vous pouvez essayer d'envoyer une extrinsèque de [lancement](/docs/subscription-launch) en utilisant l'abonnement.\"}},{\"node\":{\"id\":\"abc700fc65e6c02ff3b06d820f08dfdd\",\"title\":\"Configuration et installation du logiciel Gaka-Chu\",\"path\":\"/docs/fr/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**Dans cet article, nous passerons en revue quelques étapes d'installation et de lancement pour configurer un robot-peintre. Exigences :**\\n- KUKA KR6 R900 sixx avec KRC4 et un SmartPad ;\\n- Intel NUC avec [ROS melodic](http://wiki.ros.org/melodic/Installeration/Ubuntu) installé ;\\n- Table, peinture, pinceau, eau.\\n\\n## Installation du logiciel sur KRC4\\nL'interface EKI est requise à la fois sur KRC4 et NUC. Des informations détaillées sur la façon de la configurer sur KRC4 sont présentées [ici](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Lancez-la sur le contrôleur du robot.\\n\\n## Installation du logiciel sur NUC\\nCréez un espace de travail catkin :\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nTéléchargez les packages ROS. Tous les scripts sont stockés [ici](https://github.com/airalab/robot_painter/tree/test_branch). Clonez le référentiel :\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nVous devrez peut-être télécharger certains fichiers d'en-tête et bibliothèques pour que tout fonctionne correctement. Téléchargez-les :\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nAjoutez la commande source au fichier `.bashrc` :\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nJusqu'à présent, vous devriez pouvoir lancer les scripts. Si quelque chose ne va pas, essayez quelques [solutions de dépannage](https://github.com/airalab/robot_painter/issues)\\n\\n## Remplissage des constantes\\nTout d'abord, le robot doit connaître l'emplacement et l'orientation de la toile ainsi que la position de la boîte de peinture. Tout cela est spécifié dans `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Jetons-y un coup d'œil.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nCe sont les constantes de l'équation du plan qui spécifient la position de la toile dans l'espace en 3D. Elles doivent être obtenues lors d'un processus de calibration décrit ci-dessous. Ensuite vient la peinture.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nCe sont les coordonnées de la boîte de peinture. Elles peuvent également être spécifiées lors de la calibration. La taille de la toile est spécifiée dans\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nPlusieurs autres constantes importantes sont stockées dans `local_task_planner/src/Drawing.cpp` :\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nLeurs noms en disent long, alors remplissez-les en fonction de la situation.\\n\\n## Calibration de Gaka-Chu\\nLe processus de calibration lui-même est assez simple.\\n\\n1) Démarrez l'interface EKI sur le KRC4 :\\n\\nConnexionez-vous en mode 'AUT', activez les pilotes et lancez le script `eki_hw_interface`\\n\\n2) Démarrez l'interface EKI sur le NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nIl devrait afficher des journaux sans fin.\\n\\n3) Démarrez RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nVous devriez voir ce qui suit :\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nEssayez de déplacer l'effecteur final et cliquez sur 'Plan and Execute'. Le robot devrait bouger. Sur le SmartPad, allez dans **Display -> Actual position** et observez les coordonnées de l'effecteur final. Placez une toile horizontalement sur la base du robot. Branchez un pinceau dans le support de pinceau et déplacez-le soigneusement jusqu'à ce qu'il touche à peine la toile. À cette position, enregistrez les coordonnées de l'effecteur final. Répétez 12 à 15 fois. Enregistrez également les coordonnées du centre de la toile et de la boîte de peinture.\\nLorsque vous avez un ensemble de coordonnées, utilisez [ces](https://github.com/nakata5321/Matlab_scripts_gaka-chu) scripts Matlab pour résoudre les constantes et le quaternion manquants. Collez-les. Reconstruisez votre espace de travail avec\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Calibration de Gaka-Chu\\nLorsque Gaka-Chu est calibré, il doit être testé en dessinant les contours de la toile. Pour le faire, exécutez chacun dans un nouveau terminal :\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nAprès cela, vous devriez voir un contour de toile dans RViz :\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nAppuyez sur \\\"S\\\" dans le terminal pour effectuer le test. L'effecteur final du robot devrait se déplacer juste au-dessus des contours de la toile et le pinceau devrait effleurer délicatement la toile pendant tout le mouvement. Si ce n'est pas le cas, essayez de recalibrer. Si le modèle de la toile est mal orienté, vous pouvez le faire pivoter en changeant le quaternion dans Matlab.\\n\\n## Création d'art\\nVous avez besoin de 6 modules de base pour que tout fonctionne :\\n- Interface EKI ;\\n- MOVEit + RViz;\\n- Diffusion des cadres de l'environnement ;\\n- Service de conversion d'images ;\\n- Module de dessin de trajectoires ;\\n- Déclencheur de démarrage.\\n\\nLançons-les un par un.\\n\\n### Interface Eki\\nSur KRC4, lancez `eki_hw_interface`, sur NUC dans un nouveau terminal, faites :\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz et MOVEit\\nVous avez besoin d'un planificateur et d'une simulation. Lancez-les avec\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Environnement\\nIndiquez au robot où se trouvent la boîte de peinture et la toile. Notez qu'il n'est pas nécessaire de lancer le nœud `draw workspace`, le `tf_broadcaster` partage la taille de la toile. Il ne l'affiche simplement pas dans RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Traitement des images\\nToutes les images entrantes doivent être traitées. Lancez le service.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nLorsqu'il reçoit l'appel, il traite une image avec un filtre HP et crée un fichier rosbag avec des trajectoires.\\n\\n### Tiroir de trajectoires\\nLe script principal ici est le tiroir de trajectoires lui-même. Il attend l'image, appelle le service TextConverter et dessine la peinture.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Envoyez au robot une image à dessiner\\nLe robot écoute un topic ROS spécifique où vous devez transmettre le chemin vers une image souhaitée. L'image doit être carrée (largeur égale à la hauteur) et composée de lignes. Envoyez le chemin:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nAprès cela. Deux fenêtres apparaissent montrant les contours et les pistes. Fermez-les et observez Gaka-Chu dessiner. Faites attention à la sécurité et soyez toujours prêt à appuyer sur le bouton d'arrêt d'urgence.\\nLorsque Gaka-Chu termine son art, vous pouvez envoyer un autre chemin vers une image et le peintre répète tout le processus.\\n\"}},{\"node\":{\"id\":\"6bf731557945c06ed54f0a701f88df95\",\"title\":\"Comment modifier le wiki\",\"path\":\"/docs/fr/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki est open source. Toutes les corrections sont les bienvenues : correction des erreurs, des fautes de frappe, des informations peu claires ou obsolètes, traduction dans n'importe quelle langue. Vous aurez besoin d'un [GitHub](https://github.com/) compte.**\\n\\n\\n## Comment éditer\\n\\nSi vous avez besoin de modifier la documentation de Robonomics Wiki, veuillez suivre ces étapes\\n\\nMake sure, you have [Node.js](https://nodejs.org/en/download/package-manager/) et [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) installé.\\n\\n### 1. Cloner le dépôt\\n\\nTout d'abord, vous devez cloner le dépôt wiki :\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nAllez dans le répertoire du dépôt et exécutez les commandes suivantes :\\n\\n`à l'aide de npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`à l'aide de yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Servez localement (develop, develop-m1)\\n\\nEnsuite, déployez le projet localement : \\n\\n```\\ngridsome develop\\n```\\n\\n> Si vous avez l'erreur `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`, exécutez la commande suivante :\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Faire une demande de tirage\\n\\n[Faire une demande de tirage](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) à [dépôt wiki](https://github.com/airalab/robonomics-wiki)\\n\\n## Composants\\n\\n### Asciinema\\nRobonomics Wiki prend en charge Asciinema. Pour insérer Asciinema, veuillez suivre ces instructions :\\n* Importer le composant après le bloc frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* Insérer en tant que paragraphe séparé `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, où vid est l'ID de l'asciicast spécifique\\n\\n> Vous pouvez obtenir le script du widget pour un asciicast spécifique en cliquant sur le lien \\\"Intégrer\\\" sur la page de l'asciicast.\\n> Cela ressemble à ceci :\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Documentation Asciinema](https://asciinema.org/docs/embedding)\\n\\nDans l'exemple ci-dessus, vid est 14.\\n\\n### Code\\n\\nVous pouvez ajouter des extras utiles à votre code :\\n\\n`code avec bouton de copie`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nou `code avec ligne supplémentaire`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Propriétés pour code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nLa documentation de Robonomics Wiki contient un bloc frontmatter. Il doit être en haut du fichier Markdown et doit prendre la forme d'un ensemble YAML valide entre des lignes en pointillés. Entre les lignes en pointillés, vous pouvez définir ou modifier les options suivantes :\\n\\n```YAML\\n---\\ntitle: How to contribute # Titre de la page, vous n'avez pas besoin de le dupliquer dans le texte\\ncontributors: [positivecrash] # Principaux contributeurs (qui gèrent activement cette page). Pseudo GitHub requis, sans aucun symbole supplémentaire\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Installeration\\n    # Outils qui ont été utilisés pour les tests de technologie\\n---\\n```\\n\\n### Grid \\nAide à ajouter une mise en page en grille aux éléments :\\n\\n- Utilisez d'abord le composant wrapper de grille : \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- Et utilisez ensuite autant de composants d'éléments de grille que vous le souhaitez à l'intérieur du wrapper :\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Propriétés pour robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Images\\n\\n#### Comment télécharger \\nTéléchargez l'image dans le dossier `/docs/images/url-de-votre-doc`\\n* Si l'image doit être localisée, insérez-les toutes dans un seul dossier\\n* Utilisez l'appendice de localisation dans le nom des images s'il est localisé, par exemple `image_en.jpg`\\n* Assurez-vous que votre image est optimisée pour le web et qu'elle ait une bonne apparence\\n\\n#### Comment insérer \\n\\nIl existe deux façons d'insérer des images dans vos documents :\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nIl est recommandé d'insérer des images avec la balise intégrée `<robo-wiki-picture>`, mais vous pouvez également utiliser la méthode standard pour les fichiers Markdown.\\n\\n</robo-wiki-note>\\n\\n`avec légende`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`ou sans légende` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`ou simple image` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`ou image simple avec légende`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`image avec alt`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Propriétés pour robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Notes et avertissements\\nVous pouvez ajouter des notes et leur donner des types spécifiques :\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`note avec titre`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`note avec contenu`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`note avec titre et contenu`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Propriétés pour robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nVous pouvez ajouter des onglets à la documentation :\\n\\n- Utilisez le composant wrapper d'onglets : \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- Et utilisez ensuite autant de composants d'éléments d'onglets que vous le souhaitez à l'intérieur du wrapper :\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`onglets horizontaux`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`onglets verticaux`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`élément d'onglet avec bordure`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Propriétés pour robo-wiki-tabs (wrapper)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Propriétés pour robo-wiki-tab (item)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Titre avec ancres\\nVous pouvez créer des titres personnalisés avec des ancres et leur donner une certaine valeur\\n\\n`titre avec ancre`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nou\\n\\n`titre sans ancre`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Propriétés pour robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Vidéos\\n\\nIl existe deux façons d'insérer des vidéos dans vos documents :\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nIl est recommandé d'insérer des vidéos avec la balise intégrée `<robo-wiki-video>`, mais vous pouvez également utiliser la méthode standard pour les fichiers Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nVous devez spécifier le format de la vidéo\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Propriétés\\n\\n- Si vous ajoutez un fichier d'une taille supérieure à <span style=\\\"color:#af1c1c\\\">10MB</span>, please, upload it on server, not in repo.\\n\\n- Vous pouvez utiliser n'importe quelle propriété pour [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Formats acceptables - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nVous pouvez intégrer n'importe quelle vidéo YouTube dans la documentation en insérant le lien de partage en tant que paragraphe séparé sans guillemets ni balises supplémentaires, par exemple : `https://youtu.be/kQaSwNYHJQ8`\\n\\nCependant, si vous avez besoin d'une lecture automatique, vous devez utiliser un composant spécial : \\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Propriétés pour robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Comment modifier la navigation de la barre latérale\\n\\nSi vous devez modifier la navigation de la barre latérale de Robonomics Wiki, veuillez suivre ces étapes :\\n\\n* Modifier le fichier `/data/sidebar_docs.yaml`.\\n\\n* Décider où placer votre document\\n\\n* Utilisez un YAML valide pour `/data/sidebar_docs.yaml` et comptez sur la structure de fichier existante\\n\\n* **NOTE IMPORTANTE:** si vous utilisez le même document dans différentes sections/sous-sections, par exemple: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Image pré-installée pour Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nASSUREZ-VOUS D'AJOUTER LE PARAMÈTRE `topic` COMME CECI: \\n\\n(pour que la navigation fonctionne correctement)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Image pré-installée pour Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## Comment ajouter une navigation personnalisée pour les documents\\n\\n* Modifier le fichier `/data/sidebar_docs.yaml`.\\n\\n* FTrouvez le bon document et ajoutez les paramètres `prev` et `next` comme ceci :\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Si vous souhaitez supprimer complètement la navigation, ajoutez le paramètre `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Si vous souhaitez supprimer uniquement la navigation `page précédente` ou `page suivante`, ajoutez le paramètre `withoutPrev` ou `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nor\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"4a998ac3d8f782e50fbfdc92ff48dcc4\",\"title\":\"Connexionez un appareil Amazon FreeRTOS à Robonomics via MQTT\",\"path\":\"/docs/fr/freertos-mqtt/\",\"content\":\"\\nVoici la démonstration de la façon dont un microcontrôleur exécutant [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) peut être connecté au réseau Robonomics via MQTT. Veuillez consulter [ce référentiel](http://github.com/khssnv/freertos_mqtt_robonomics_example) pour le code source du projet.\\n\\nNous utilisons [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) avec la distribution FreeRTOS et la mise en œuvre MQTT fournies par [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) tandis qu'Espressif est un fournisseur du microcontrôleur utilisé.\\n\\nIl y a aussi un capteur [PMS-3003](http://www.plantower.com/en/content/?107.html) à des fins de démonstration. Le capteur mesure la présence de particules dans l'air et on peut l'utiliser pour estimer la qualité de l'air.\\n\\nLa qualité de l'air n'est pas un sujet de l'article, vous pouvez en savoir plus à ce sujet sur le site web de l'OMS: [Pollution de l'air ambiant (extérieur)](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). L'objectif du système est de publier les mesures du capteur sur le réseau Robonomics d'Airalab.\\n\\n## Configuration matérielle\\n\\nNous connectons la broche TXD du PMS3003 à l'IO17 de l'ESP32 DevKitC pour transférer les mesures par UART.\\nLes deux appareils nécessitent également une alimentation et une masse commune.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Flux de données\\n\\nAfin de transmettre les mesures du capteur au réseau Robonomics, notre objectif au niveau du micrologiciel est d'obtenir les données d'un capteur par le protocole de communication intégré qu'il prend en charge (UART dans notre cas) et de les transmettre à une instance AIRA par MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nDans notre exemple, nous utilisons le déploiement cloud AIRA disponible par une adresse IP publique et un nom de domaine attribué.\\nSur l'instance AIRA, nous configurons le courtier MQTT `mosquitto` et nous nous abonnons au sujet `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` pour recevoir des messages de MQTT.\\n\\nEnsuite, nous transmettons les messages à l'écrivain `robonomics io` par un tuyau.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nMaintenant, les données sont disponibles dans le réseau Robonomics et nous pouvons les lire à nouveau avec `robonomics io`.\\n\\n## Micrologiciel\\n\\nNous utilisons l'application d'exemple [ESP-MQTT avec transport TCP](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) comme base.\\n\\nNous modifions uniquement `main/app_main.c` pour la connexion UART au capteur, la synchronisation de l'heure SNTP et la routine de publication MQTT périodique.\\n\\nSi vous essayez de reproduire le projet et que c'est votre premier projet basé sur ESP IDF, veuillez d'abord suivre le guide de programmation [ESP-IDF d'Espressif](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) pour vous familiariser avec les opérations du micrologiciel telles que la configuration, la compilation et le téléchargement avec l'outil `idf.py`.\\n\\n### Configuration Wi-Fi\\n\\nAfin de communiquer avec l'instance AIRA déployée dans le cloud, notre microcontrôleur nécessite une connexion Internet.\\nNous utilisons le Wi-Fi de l'ESP32 pour cela.\\nEspressif fournit des utilitaires pour configurer le Wi-Fi intégré.\\nDans notre exemple, nous utilisons un environnement de développement avec Ubuntu 20.04 GNU/Linux.\\nPour configurer le Wi-Fi, nous allons dans le dossier du projet et exécutons l'outil de configuration SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nEnsuite, nous définissons le SSID et le mot de passe du point d'accès Wi-Fi dans la section `Example Connection Configuration`.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### Configuration du point de terminaison MQTT\\n\\nIl y a deux choses à configurer pour MQTT.\\nLa première est l'adresse du courtier MQTT.\\nElle est configurable avec l'outil de configuration SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nDéfinissez l'URL du courtier dans la section `Example Configuration`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nLa deuxième chose est le sujet MQTT.\\nNous le définissons dans le micrologiciel avec le préfixe du nom du projet suivi de l'adresse MAC de notre ESP32.\\nCela nous donne `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` pour notre microprocesseur particulier.\\n\\n## De MQTT à Robonomics\\n\\nCommençons par vérifier si nous recevons des données par MQTT.\\nNous pouvons nous abonner au sujet du courtier MQTT Mosquitto pour recevoir les publications de l'appareil.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nIci, nous importons le package `mosquitto` dans notre environnement pour utiliser l'utilitaire `mosquitto_sub`.\\nEnsuite, nous nous abonnons au sujet défini dans le micrologiciel.\\nNous avons obtenu nos mesures, ce qui signifie que AIRA reçoit correctement les données via MQTT.\\nMaintenant, laissons passer ces messages vers le réseau Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nIci, nous utilisons l'utilitaire `robonomics` pour publier des messages dans le canal pubsub `/freertos_mqtt_robonomics_example`.\\nNous spécifions les `bootnodes` pour garantir au moins une connexion établie.\\n\\nMaintenant, nous lisons ces messages à partir du même canal pubsub.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Ressources originales utilisées\\n\\n* Schéma des broches ESP32 DevKitC provenant du blog de GoJimmy https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* Structure de données et décodeur PSM3003 provenant du projet OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Merci à tous !**\\n\"}},{\"node\":{\"id\":\"549974e4f78f3a0ea28ea6ffbf8f17c6\",\"title\":\"Recevez une notification lorsque la porte s'ouvre\",\"path\":\"/docs/fr/door-notification/\",\"content\":\"\\nDans cet article, vous installerez l'intégration du bot de notification Telegram et configurerez une automatisation qui enverra une notification à votre compte Telegram lorsque la porte est ouverte.\\n\\n## Notifications du bot Telegram\\n\\nTout d'abord, vous devez créer un bot Telegram personnel. Pour cela, allez sur le [bot Telegram spécial @BotFather](https://t.me/botfather) et suivez les instructions. \\nEnregistrez votre jeton pour accéder à l'API HTTP.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nGardez votre jeton **en sécurité** et stockez-le **en toute sécurité**, il peut être utilisé par n'importe qui pour contrôler votre bot. \\n\\n</robo-wiki-note>\\n\\nL'étape suivante consiste à trouver votre ***User Chat ID***. Pour cela, utilisez le [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nMaintenant, installons l'intégration \\\"Telegram broadcast\\\". Cette intégration enverra des messages à votre Telegram.\\n\\nPour l'image préinstallée Robonomics, Docker Home Assistant ou Home Assistant Core, vous devez modifier `configuration.yaml`. Connexionez-vous à votre Raspberry Pi via `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nCollez les lignes suivantes à la fin du fichier. Insérez votre **bot API key** et **your User Chat ID**. Créez également un nom pour votre service de notification:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Enregistrez la configuration et rechargez Home Assistant.**\\n\\n\\nEn conséquence, un service sera créé dans votre service Home Assistant, qui enverra n'importe quel message au chat Telegram avec vous. \\nVous pouvez le vérifier dans le menu Outils de développement de l'interface Web de Home Assistant. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Notification d'ouverture de porte\\n\\nMaintenant, il est temps de créer une automatisation. Tout d'abord, importez le modèle dans votre Home Assistant à partir de ce lien:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nEt créez une automatisation:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nMaintenant, vous recevrez un message du bot Telegram chaque fois que la porte est ouverte.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nVous pouvez utiliser cette automatisation avec n'importe quelle porte/fenêtre de votre maison.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"4054e7b72f1342fae1f4fb4de2f8112e\",\"title\":\"Jumeaux numériques\",\"path\":\"/docs/fr/digital-twins/\",\"content\":\"  \\n**Imaginez avoir un appareil ou un système compliqué qui comporte plusieurs modules à entretenir et nécessite quelques comptes pour être utilisé. Pour les regrouper tous au même endroit ou pour coder certaines fonctionnalités avec des comptes séparés ou, par exemple, pour définir différentes sources de données pour différents flux d'informations, le module Jumeau numérique doit être utilisé.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Veuillez noter que ces tutoriels et les suivants sont démontrés sur une instance locale de Robonomics Node. Configurez le vôtre avec [ces instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Aperçu théorique\\nN'importe quel compte peut créer et gérer un Jumeau numérique. Le Jumeau peut être imaginé comme une sorte de tableau avec le contenu suivant:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nOù:\\n* **DT id** est un index de Jumeau numérique unique non signé.\\n* **Topic name** est une donnée hexadécimale `H256` ou ASCII de 32 octets de longueur, identique à [`Lancement`](/docs/launch) paramètre extrinsèque. \\nPar exemple: `0x1234....FF` ou `hello.parachain.robonomics.world`.\\n* **Source** - est une adresse de compte.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Comme discuté précédemment dans l'aperçu de l'extrinsèque de lancement, le `H256` peut être représenté sous la forme d'un CID IPFS encodé (voir\\n  [outil Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) pour cela).\\n  Par conséquent, les sujets peuvent également être utilisés comme un stockage de données, par exemple, une description de module d'un Jumeau.\\n\\n</robo-wiki-note>\\n\\n\\n## Créer un Jumeau numérique\\n\\n### 1. Accédez à Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Choisissez digitalTwin -> create dans la liste déroulante des extrinsèques possibles\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nSoumettez la transaction. Ici, aucun paramètre n'est nécessaire pour créer un Jumeau. Il se verra attribuer un index et seul le propriétaire du Jumeau numérique pourra désormais ajouter/modifier les sujets du Jumeau.\\n\\nL'ID du Jumeau peut être trouvé sur la page d'aperçu de l'explorateur.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Ajouter un sujet\\n\\n### Choisissez digitalTwin -> setSource dans la liste déroulante des extrinsèques possibles\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID, qui a été obtenu sur la page Explorer.\\n* `topic` - nom du sujet `H256` précédemment discuté. Dans cette image, il s'agit d'une chaîne de 32 symboles.\\n* `source` - adresse du compte à associer au sujet.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Notez que le sujet peut être écrasé par une autre adresse source si nécessaire.\\n\\n</robo-wiki-note>\\n\\nSignez et soumettez l'extrinsèque.\\n\\n## Explore\\n\\nVous pouvez trouver toutes les informations sur les Jumeaux numériques existants dans le module de stockage `Developer -> Chain state` `digitalTwin`.\\n\\n- Nombre total de Jumeaux - `total()`;\\n- Propriétaire du Jumeau numérique - `owner(u32)`;\\n- Informations sur les sujets d'un Jumeau numérique - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"29769613c55fc49b87331d1a6b3d7343\",\"title\":\"Datalogue\",\"path\":\"/docs/fr/datalog/\",\"content\":\"\\n**Maintenant que vous avez des fonds sur votre compte, vous pouvez soumettre des extrinsèques. Le premier à essayer est un Datalog. Il vous permet de stocker des données de manière persistante dans la blockchain. Imaginez un stockage distribué et cryptoprotégé pour vos données, et c'est ça !**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nVeuillez noter que ces tutoriels et les suivants sont démontrés sur une instance locale de Robonomics Node. Configurez le vôtre avec [ces instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Accédez à Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Choisissez  datalog -> record  dans la liste déroulante des extrinsèques possibles\\n\\nChoisissez également un compte avec lequel vous souhaitez soumettre l'extrinsèque. Remplissez le champ d'enregistrement.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalogue prend en charge une chaîne de caractères d'un maximum de 512 octets. Pour stocker une grande quantité de données, vous pouvez utiliser [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Soumettre la transaction\\n\\nSignez et soumettez la transaction avec un compte créé précédemment à l'aide de l'extension ou de l'application décentralisée.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  Vous pouvez également effacer **TOUTES** vos données avec *datalog -> erase* appel.\\n\\n</robo-wiki-note>\\n\\n## 4. Vérifiez votre datalogue dans le stockage\\n\\nPour cela, accédez à *Developer -> Chain state*, sélectionnez *datalog -> datalogIndex*, spécifiez votre compte et appuyez sur le \\n\\\"+\\\" bouton pour obtenir les index des enregistrements de votre compte, puis explorez celui dont vous avez besoin avec *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Explorerr\\\">\\n\\n  Tous les événements, y compris l'enregistrement du datalogue, peuvent être consultés dans le flux d'événements de l'*Explorer*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"bb8cfb8f8783d611babc982730760a4c\",\"title\":\"Créer une identité numérique gérée par Ethereum\",\"path\":\"/docs/fr/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nL'un des services Robonomics est [Enregistrement du passeport numérique](https://dapp.robonomics.network/#/passport/) pour des données arbitraires. Le service vous permet de créer une identité numérique en enregistrant les hachages des données sur la blockchain publique et en attribuant une adresse unique.\\n\\nVous pouvez trouver le service \\\"Enregistrement du passeport numérique\\\" dans [Robonomics DApp](https://dapp.robonomics.network/) la section \\\"Services\\\" ou simplement suivre ce [lien direct](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Vidéo explicative\\n\\nLa vidéo suivante montre l'avancement de l'enregistrement du livre blanc de Robonomics:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Étapes en images\\n\\n### 1. Ouvrez le service\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Ajoutez les informations et les fichiers nécessaires\\n\\nVeuillez noter qu'il est possible d'ajouter plusieurs images.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Signez la demande\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Approuvez les jetons\\n\\nLe service facture des frais minimes. Mais d'abord, vous devez approuver la quantité de jetons requise à dépenser depuis votre compte.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Acceptez l'offre et signez à nouveau le message\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Jetez un coup d'œil au passeport créé\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nLe processus d'enregistrement prend un certain temps. À la fin, vous verrez un lien vers l'identité créée.\\n\"}},{\"node\":{\"id\":\"4f6d0c454d62d0f6a40844526f4c3597\",\"title\":\"Créer un compte pour Robonomics Parachain\",\"path\":\"/docs/fr/create-account-in-dapp/\",\"content\":\"\\n**Afin d'interagir et de fonctionner avec Robonomics Parachain, les développeurs et les utilisateurs doivent créer un compte sur le portail Polkadot / Substrate. Le compte remplit les fonctions de base du réseau : votre adresse de réseau public (la clé publique), le contrôle d'accès à l'adresse et aux fonds (la clé privée), l'envoi de transactions au réseau, l'affichage de vos tokens et de leur montant, etc. Vous trouverez ci-dessous deux façons principales de créer un compte pour Robonomics Parachain**\\n\\n## 1. Utilisation de l'extension de navigateur Polkadot{.js}\\n\\nL'extension Polkadot offre un mécanisme pour générer le compte et interagir avec tous les projets Polkadot / Kusama, y compris Robonomics Parachain. Ce n'est pas la manière la plus sûre de gérer votre compte, mais c'est la plus pratique en termes d'équilibre sécurité / facilité d'utilisation.\\n\\n## 1.1. Installerer l'extension de navigateur\\n\\nL'extension de navigateur est disponible pour [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) et [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (ainsi que les navigateurs basés sur Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Ouvrir l'application Robonomics Parachain\\n\\nAllez à [L'application Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) sur le portail Polkadot / Substrate. Si c'est la première fois que vous entrez dans le portail, il demandera l'accès à l'extension de navigateur, donc autorisez l'accès. \\n\\nUne fois que vous avez ouvert l'application, jetez un œil au coin supérieur gauche. Le nom du réseau, son icône et le numéro du dernier bloc y sont affichés. En cliquant sur cette zone, vous ouvrirez une liste de tous les réseaux Polkadot/Kusama, y compris les réseaux de test et les nœuds locaux. Vous pouvez basculer entre les réseaux en sélectionnant celui requis et en appuyant sur le bouton `Switch`. **Assurez-vous d'être connecté à Robonomics Parachain maintenant**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Mettre à jour les métadonnées de l'extension\\n\\nIl est très probable que l'application vous demande de mettre à jour les métadonnées de l'extension pour afficher les informations correctes sur la chaîne à laquelle vous êtes connecté. Allez sur **Settings -> Metadata**, appuyez sur le bouton `Update metadata` et ensuite, dans la fenêtre contextuelle, autorisez l'extension à le faire. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Créer un compte dans l'extension\\n\\nOuvrez l'extension de navigateur Polkadot{.js}. Cliquez sur le gros bouton plus ou sélectionnez `Create new account` à partir de la petite icône plus en haut à droite. Vous devriez voir le menu suivant, avec une graine mnémonique générée sous la forme de douze mots et l'adresse. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nLa graine est votre clé pour le compte. Connaître la graine vous permet (ou à toute autre personne qui connaît la graine) de prendre le contrôle de ce compte et même de le recréer, si vous oubliez le mot de passe. **Il est très important de la stocker en lieu sûr**, de préférence sur papier ou sur un autre support non numérique, pas dans un stockage numérique ou sur un ordinateur. \\n\\nEnregistrez la graine et appuyez sur `Next step`. Vous devriez voir le menu suivant.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* vous permet de choisir sur quel réseau ce compte sera exclusivement utilisé. Vous pouvez utiliser la même adresse sur plusieurs réseaux, cependant, pour des raisons de confidentialité, il est recommandé de créer une nouvelle adresse pour chaque réseau que vous utilisez. \\nSélectionnez le réseau Robonomics dans la liste déroulante. Si vous ne trouvez pas le réseau Robonomics, il est probable que vous n'ayez pas mis à jour les métadonnées, revenez en arrière et faites-le.\\n\\n    - Vous remarquerez que le format de l'adresse et l'icône du compte changeront - c'est normal. Les formats de réseau différents ne sont que d'autres représentations de la même clé publique. \\n\\n- *Name* n'est que le nom du compte à usage personnel. Il n'est pas stocké sur la blockchain et ne sera pas visible par les autres utilisateurs. \\n\\n- *Password* est utilisé pour chiffrer les informations de votre compte. Vous devrez le saisir à nouveau lors de la signature des transactions sur le portail. Créez-en un et souvenez-vous-en.\\n\\nEn conséquence, après avoir créé un compte, vous le verrez dans la liste des comptes dans l'extension Polkadot{.js}. En cliquant sur les trois points, vous pouvez renommer le compte, l'exporter, le supprimer de l'extension et changer le réseau utilisé pour le compte. \\n\\nDe plus, le compte apparaîtra dans le menu  **Accounts -> Accounts** du portail, où il sera noté qu'il a été injecté à l'aide de l'extension.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n## 2. Directement sur l'application Robonomics Parachain\\n\\nVous pouvez utiliser l'interface utilisateur sur le portail Polkadot / Substrate pour créer un compte. Il peut être utilisé pour le développement et les tests. \\n\\n## 2.1. Ouvrez l'application Robonomics Parachain\\n\\nAller à [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) sur le portail Polkadot / Substrate. **Vérifiez en haut à gauche que vous êtes connecté à Robonomics Parachain**.  \\n\\nAller à **Accounts -> Accounts** et appuyez sur le bouton`Add account`.\\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Créer un compte\\n\\nVous devriez voir le menu contextuel suivant avec la graine du compte. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nIl a deux formes: *Mnemonic* (lisible par l'homme) et *Raw* (une séquence de chiffres et de lettres). Sauvegardez la phrase de récupération en toute sécurité et appuyez sur `Next`.\\n\\n> Vous pouvez également changer le type de cryptographie pour la création de compte, pour cela ouvrez `Advanced creation options` et choisissez le type (`ed25519` sur l'image).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nDans le menu suivant, vous devez définir le nom du compte et le mot de passe, de manière similaire aux instructions de l'extension décrites ci-dessus.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nEn cliquant sur le bouton `Next` vous amènera à la dernière fenêtre. Cliquez sur `Save` pour terminer la création du compte. Il générera également des fichiers JSON de sauvegarde que vous devez conserver en toute sécurité. Vous pouvez ensuite utiliser ce fichier pour récupérer votre compte si vous vous souvenez du mot de passe.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Ajouter un compte ed25519 à l'extension Polkadot\\n\\nVous devrez peut-être ajouter le compte créé à l'extension Polkadot.js (pour un compte ed25519, vous ne pouvez le faire qu'avec le fichier JSON de sauvegarde). Pour cela, vous devez créer une sauvegarde du compte. Appuyez sur les trois points sur votre compte et choisissez `Create a backup file for this account` et écrivez votre mot de passe.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nEnsuite, ouvrez une extension et appuyez sur le bouton `+` en haut à droite, puis choisissez `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nDans la fenêtre ouverte, déposez le fichier enregistré, saisissez le mot de passe et appuyez sur `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Compte créé avec succès \\n\\nMaintenant, vous pouvez pleinement utiliser votre compte fraîchement créé. Envoyez et recevez des jetons, des messages, écrivez des journaux de données et plus encore. N'hésitez pas à explorer toutes les fonctionnalités de l'application. Pour copier l'adresse de votre compte, cliquez simplement sur son icône, l'adresse sera copiée dans le presse-papiers. \\n\\nSi vous souhaitez en savoir plus sur les comptes Polkadot / Kusama et les autres moyens de les créer, vous trouverez plus d'informations [ici](https://wiki.polkadot.network/docs/learn-accounts) et [ici](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"9b5d5ef07e4b7a24e6b125fa462a8fde\",\"title\":\"Connexioner le capteur\",\"path\":\"/docs/fr/carbon-footprint-sensor/\",\"content\":\"\\nUn exemple de travail est dans la vidéo:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Exigences\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (ou l'un des [pris en charge](https://www.zigbee2mqtt.io/dansformation/supported_adapters.html))\\n\\nLe service fonctionne sur Raspberry Pi et contacte la prise intelligente via le protocole zigbee.\\n\\n## Clé Zigbee\\n\\nSi vous avez le JetHome USB JetStick Z2, il possède déjà le micrologiciel nécessaire, vous n'avez donc pas besoin de le flasher. Mais si vous avez un autre adaptateur, vous devez d'abord le flasher avec le logiciel zigbee2MQTT. Vous pouvez trouver des instructions pour votre appareil [ici](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nConnectez l'adaptateur et vérifiez l'adresse de l'adaptateur (cela peut aussi être `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nVous devrez peut-être d'abord accéder au port USB. Ajoutez votre utilisateur à `dialout` groupe (cela fonctionne pour Ubuntu, mais le nom du groupe peut être différent sur d'autres systèmes d'exploitation).\\nPour Ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nPour Arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nEnsuite, déconnectez-vous et reconnectez-vous ou redémarrez l'ordinateur.\\n\\n## Installeration\\n\\nClonez le référentiel:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Configuration\\n\\nAllez à `data/configuration.yaml` et définissez `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nVous voudrez peut-être également remplir les champs `server` et `port` avec les informations correspondantes. Dans le champ `server` utilisez l'adresse IP du `docker0` pont pour établir la connexion: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nIci, votre adresse est `172.17.0.1`.\\n\\nEnsuite, créez le fichier config/config.yaml avec les informations suivantes et définissez votre emplacement (vous pouvez vous référer à https://countrycode.org/ pour le code ISO à 3 lettres):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Connectez la prise\\n\\nPremière exécution:\\n\\n```\\ndocker-compose up     \\n```\\n\\nPour passer au mode d'appairage sur la prise, appuyez longuement sur le bouton d'alimentation pendant quelques secondes jusqu'à ce que le voyant commence à clignoter rapidement en bleu.\\n\\nDans les journaux, vous devriez voir maintenant que votre plug a commencé à publier sur mqtt.\\n\\n\\n## Après l'appariement\\n\\nSi vous ne souhaitez pas autoriser d'autres appareils à s'associer à votre clé, vous devez maintenant aller à `data/configuration.yaml` et mettre `permit_join: false`. Redémarrez le service (utilisez 'Ctrl+C' et\\n\\n```bash\\ndocker-compose up     \\n```\\nencore une fois pour soumettre les modifications).\\n\\n## En cours d'exécution\\nLors du premier démarrage, un compte pour la prise sera créé. \\n> Si vous avez déjà un compte, vous devez ajouter sa graine au fichier `config.config.yaml` dans la section `device_seed` :\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nAprès la création du compte, vous verrez l'adresse dans les journaux (la graine sera ajoutée à `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nVous devez transférer quelques jetons sur ce compte pour les frais de transaction, vous pouvez le faire sur [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nLe service verra que vous avez suffisamment de jetons, dans les journaux vous verrez:\\n```\\nplug               | Balance is OK\\n```\\nLe service verra les messages MQTT de la prise et assurera une utilisation sûre de l'énergie. Toutes les heures (vous pouvez modifier le délai d'attente dans la section `config/config.yaml` in `sending_timeout` , le délai d'attente est en secondes), il créera un journal de données avec les informations suivantes:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"5cafc13af3dab054e23e35d6e5f27105\",\"title\":\"Comment contribuer aux ressources de Robonomics\",\"path\":\"/docs/fr/contributing/\",\"content\":\"\\nRobonomics Network est un projet open source et nous souhaitons permettre à chacun de contribuer facilement. Vous pouvez créer des articles, suggérer des modifications, améliorer la documentation ou exécuter des tests. Si vous souhaitez contribuer, veuillez ouvrir un nouveau numéro ou créer une pull request dans le même référentiel.\\n\\n## Principaux référentiels Robonomics \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Projet wiki principal\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Site Web principal officiel de Robonomics Network\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Accueil des services Web Robonomics\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Dapp officielle\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Site Web officiel de Robonomics Academy\\n\\n### Règles de signalement\\n\\nLors de l'ouverture d'un nouveau problème, n'oubliez pas quelques règles de base pour le signalement :\\n\\n1. Choisissez le référentiel exact dans lequel vous souhaitez soumettre un problème.\\n\\n2. Si vous signalez un bogue, assurez-vous que le bogue n'a pas déjà été signalé.\\n\\n3. Assurez-vous d'inclure un titre et une description claire, ainsi que toutes les informations pertinentes possibles.\\n\\n4. Veuillez préfixer votre problème avec l'un des éléments suivants : `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Demandes de tirage\\n\\nTout référentiel Robonomics peut être soumis à des demandes d'extraction ou à des modifications de la part des contributeurs, lorsque vous pensez avoir quelque chose de précieux à ajouter ou à modifier. S'il vous plaît, n'oubliez pas les règles de base pour les contributeurs.\\n\\n### Règles de contribution\\n\\n1. Les demandes de tirage sont préférées aux problèmes, si vous avez des corrections, en particulier pour de petites modifications telles que des fautes de frappe.\\n\\n2. Assurez-vous que la description de la demande de tirage décrit clairement le problème et la solution. Incluez le numéro de problème pertinent le cas échéant.\\n\\n3. Veuillez ne pas corriger les espaces vides, formater le code ou apporter une modification purement esthétique.\\n\\n4. Veuillez essayer de respecter le style, la langue et la mise en page Markdown prédominants.\\n\\n\\n\"}},{\"node\":{\"id\":\"c849358bb4519148ec93f1b004a9d3e3\",\"title\":\"Services de sauvegarde\",\"path\":\"/docs/fr/backup-services/\",\"content\":\"\\n**Dans cet article, vous apprendrez comment générer des sauvegardes de votre configuration Home Assistant et la restaurer en cas de besoin. Pour créer des sauvegardes, un service est appelé pour générer une archive sécurisée avec les fichiers de configuration. Ce service ajoute également la configuration de Mosquitto brocker et Zigbee2MQTT à la sauvegarde si elle existe. Ce service ajoute ensuite l'archive à IPFS et stocke le CID résultant dans Robonomics Digital Twin.**\\n## Création d'une sauvegarde de la configuration Home Assistant\\n\\nLa création d'une sauvegarde vous permet de restaurer facilement votre configuration Home Assistant en cas de panne.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"AVERTISSEMENT\\\">\\n\\nPour sauvegarder et restaurer votre configuration, il est nécessaire d'utiliser une **passerelle IPFS personnalisée** comme Pinata. Sans cela, votre sauvegarde sera stockée uniquement sur votre nœud IPFS local, ce qui peut vous empêcher de restaurer votre configuration Home Assistant en cas de défaillance du nœud local.\\n\\n</robo-wiki-note>\\n\\n1. Dans l'interface web de Home Assistant, allez à `Developer Tools` -> `Services`. Recherchez `Robonomics: Save Backup to Robonomics` et appuyez sur `CALL SERVICE`.\\n\\n2. Attendez de voir la notification `Backup was updated in Robonomics` apparaître dans `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"AVERTISSEMENT\\\">\\n\\nN'essayez pas de créer une sauvegarde ou de restaurer la configuration immédiatement après avoir chargé Home Assistant et Robonomics Integration. Veuillez **attendre environ 5 minutes** pour permettre la configuration initiale de se terminer.\\n\\n</robo-wiki-note>\\n\\nArguments du service:\\n- **Sauvegarde complète**  (default: False) - ajoute la base de données à la sauvegarde, de sorte que l'historique des états des entités soit également stocké.\\n- **Chemin vers le fichier de mot de passe de Mosquitto** (default: `/etc/mosquitto`) - Si vous avez utilisé les méthodes d'installation Home Assistant Core ou Docker et que vous n'avez pas le chemin par défaut vers Mosquitto brocker, vous devez modifier ce paramètre. *Non nécessaire pour Home Assistant OS ou Superviser*.\\n\\n## Restauration de la configuration Home Assistant à partir de la sauvegarde\\n\\nPour restaurer votre configuration, vous aurez besoin d'un Home Assistant installé et de Robonomics Integration. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"AVERTISSEMENT\\\">\\n\\nPour assurer une restauration réussie de votre configuration dans Home Assistant Core et les méthodes d'installation Docker, vous devez effectuer des étapes de configuration supplémentaires comme décrit à la fin de la page.\\n\\n</robo-wiki-note>\\n\\n1. Installerez Home Assisntant avec Robonomics Integration (si ce n'est pas encore installé), en suivant les étapes de l'article pour la [méthode d'installation souhaitée](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2. [Configurer l'intégration Robonomics](https://wiki.robonomics.network/docs/robonomics-hass-integration) en utilisant **les mêmes clés** que celles utilisées dans la configuration précédente de Robonomics. Si votre abonnement est terminé, [réactivez-le](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. Dans l'interface web de Home Assistant, allez à `Developer Tools` -> `Services`. Search for `Robonomics: Restore from the Backup in Robonomics` et appuyez sur le bouton `CALL SERVICE`. Accédez à la `Overview` page, pour vérifier l’état de votre sauvegarde.\\n\\n4. Après la restauration, Home Assistant redémarrera automatiquement. Si pour une raison quelconque Home Assistant ne redémarre pas, vous pouvez vérifier l'état de la restauration en surveillant l'état de l' `robonomics.backup` entité. Si l'état est `restored` vous devrez redémarrer manuellement Home Assistant en accédant à `Settings` > `System` et en cliquant sur le `RESTART` bouton situé dans le coin supérieur droit.\\n\\n5. Si votre sauvegarde inclut la configuration Zigbee2MQTT ou Mosquitto, vous devez redémarrer ces services pour activer la nouvelle configuration. Vous pouvez le faire manuellement en redémarrant les services individuellement, ou vous pouvez simplement redémarrer l'ordinateur Home Assistant pour vous assurer que tous les services sont redémarrés.\\n\\nArguments du service :\\n- **Chemin d'accès au fichier de mots de passe Mosquito** (default: `/etc/mosquitto`) - Si vous avez utilisé les méthodes d'installation Home Assistant Core ou Docker et que vous n'avez pas le chemin par défaut vers le courtier Mosquitto, vous devez modifier ce paramètre. *Non nécessaire pour Home Assistant OS ou Superviser*.\\n- **Chemin vers la configuration Zigbee2MQTT**  (default: `/opt/zigbee2mqtt`) - Si vous avez utilisé les méthodes d'installation Home Assistant Core ou Docker et que vous n'avez pas le chemin par défaut vers Zigbee2MQTT, vous devez modifier ce paramètre. *Non nécessaire pour Home Assistant OS ou Superviser*.\\n\\n## Restaurer la configuration Mosquitto et Zigbee2MQTT pour la méthode d'installation Home Assistant Core\\n\\nSi la sauvegarde inclut la configuration de Mosquitto ou Zigbee2MQTT, lors du processus de restauration, elles seront placées dans le chemin par défaut ou dans le chemin spécifié dans les arguments. Cependant, si vous avez installé l'intégration Robonomics dans un Home Assistant Core existant *(pas à partir de l'image Robonomics préinstallée)*, `homeassistant` l'utilisateur peut ne pas avoir accès à ce chemin.\\n\\nDonc, pour restaurer la configuration de Mosquitto et Zigbee2MQTT, vous devez accorder les permissions de lecture nécessaires à l'utilisateur `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Sauvegarder la configuration Mosquitto et Zigbee2MQTT pour la méthode d'installation Home Assistant Docker\\n\\nPour sauvegarder les configurations Mosquitto et Zigbee2MQTT à partir d'un conteneur Docker, vous devez créer des volumes pour leurs configurations respectives. Cela peut être réalisé en exécutant votre conteneur Home Assistant avec des arguments supplémentaires:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nou apportez des modifications à votre `compose.yaml` fichier:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nVeuillez noter que les chemins par défaut pour les configurations Mosquitto et Zigbee2MQTT sont respectivement `/etc/mosquitto` et `/opt/zigbee2mqtt`, Cependant, ces chemins peuvent varier en fonction de votre configuration spécifique.\\n\\n</robo-wiki-note>\\n\\n## Boutons de sauvegarde\\n\\nEn plus d'utiliser des services pour travailler avec les sauvegardes, vous pouvez simplifier le processus en utilisant les `button.create_backup` and `button.restore_from_backup` boutons de l'intégration Robonomics. Ces boutons invoquent les services respectifs avec les paramètres par défaut (le bouton de sauvegarde crée une sauvegarde sans historique).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nPour ajouter des boutons à votre tableau de bord, suivez ces étapes:\\n\\n1. Cliquez sur les trois points dans le coin supérieur droit du tableau de bord.\\n2. Sélectionnez `Edit Dashboard`.\\n3. Cliquez sur le `Add Card` bouton dans le coin inférieur droit.\\n4. Choisissez la carte `Entities`.\\n5. Dans le champ `Entities` recherchez les entités button.create_backup et button.restore_from_backup.\\n6. Appuyez sur `Save` pour ajouter les entités à la carte.\\n7. Terminez l'édition en cliquant sur le `Done` bouton dans le coin supérieur droit.\"}},{\"node\":{\"id\":\"596a39b3ed719907206328d0d356b19c\",\"title\":\"Service de compensation\",\"path\":\"/docs/fr/carbon-footprint-service/\",\"content\":\"\\nUn exemple de travail est dans la vidéo:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nService de compensation de l'empreinte CO2 en brûlant des jetons dans le réseau Statemine. \\nLe CO2 produit est calculé comme suit : les données provenant de l'appareil en Wh sont multipliées par des coefficients qui dépendent de la région. 1 tonne de CO2 est compensée par la consommation d'1 jeton. [Voici](/docs/carbon-footprint-sensor) les instructions pour connecter l'appareil.\\n\\n## Scénario\\n\\n1. Enregistrez un nouvel appareil dans Digital Twin dans le réseau Robonomics\\n2. Une fois par intervalle, récupérez les dernières données de tous les appareils et multipliez par le coefficient en fonction de la région\\n3. Additionner les données et les convertir en tonnes de CO2\\n4. Soustraire le nombre total de jetons brûlés des données actuelles \\n5. Brûler un nombre entier de jetons dans le réseau Statemine \\n6. Enregistrer le nombre total de jetons brûlés dans la base de données locale et dans Datalogue \\n\\n\\n## Installeration\\n\\nCloner le dépôt et modifier le fichier de configuration.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Description de la configuration\\n\\nNe pas modifier `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network wici Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nLes coefficients pour l'énergie non renouvelable ont été pris à partir d'Lancement et stockés dans [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) et stocké dans `utils/coefficients.py`. \\n\\n## Lancement\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"434564d4a177b2bb224b09a4e1dd6a10\",\"title\":\"Ajouter des fonds à votre compte sur le portail Robonomics\",\"path\":\"/docs/fr/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Après avoir créé avec succès vos comptes sur le portail Robonomics, il est temps d'y ajouter des fonds afdans de pouvoir initier des transactions.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nVeuillez noter que ces tutoriels, ainsi que les suivants, sont démontrés sur une instance locale de Robonomics Node. Configurez la vôtre avec [ces instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Accédez à la section Comptes sur le portail Robonomics \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Choisissez le compte à partir duquel vous souhaitez transférer des fonds\\n\\nEn mode développement, il existe plusieurs comptes, avec 10000 unités de fonds chacun, qui peuvent être utilisés pour transférer des fonds vers d'autres comptes créés dans le réseau de développement. Ces comptes sont indiqués par des icônes de clé anglaise <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> à côté d'eux.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Cliquez sur le bouton \\\"envoyer\\\" du compte à partir duquel vous souhaitez transférer des fonds, par exemple BOB\\n\\n## 3. Choisissez le compte dans lequel vous souhaitez transférer des fonds\\nAprès avoir cliqué sur le bouton \\\"envoyer\\\", vous serez invité avec la fenêtre \\\"envoyer des fonds\\\". Dans la fenêtre affichée :\\n\\n- Choisissez le compte dans la liste des comptes disponibles vers lequel vous souhaitez envoyer des fonds.\\n- Saisissez le nombre d'unités que vous souhaitez envoyer.\\n- Appuyez sur \\\"effectuer le transfert\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Autorisez la transaction\\n\\nAprès avoir appuyé sur \\\"effectuer le transfert\\\" à l'étape précédente, vous serez invité avec la fenêtre \\\"autoriser la transaction\\\".<br/>\\nVérifiez les détails de la transaction et cliquez enfin sur le bouton \\\"signer et soumettre\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nDans cet exemple, nous avons transféré 500 unités de fonds de \\\"BOB\\\" à \\\"EMPLOYER\\\". Vous pouvez voir que le compte de EMPLOYER, qui n'avait initialement aucun fonds, dispose maintenant de 500 unités de fonds.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Assurez-vous d'avoir suffisamment de fonds dans les comptes que vous souhaitez utiliser dans l'aire de jeu.**\"}},{\"node\":{\"id\":\"7dd7d02dae2f13f4ad8a1796ec8ab999\",\"title\":\"Adaptador Zigbee con Zigbee2MQTT para imagen preinstalada\",\"path\":\"/docs/es/zigbee-to-mqtt-image/\",\"content\":\"\\n**En este artículo emparejarás dispositivos inteligentes.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nAbre un navegador web y ve a `http://%DIRECCIÓN_IP_DE_RASPBERRY%:8099`. Puedes encontrar la dirección IP de Raspberry Pi usando la [aplicación móvil Fing](https://www.fing.com/products) o la [herramienta de línea de comandos nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nVerás la interfaz web de Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nEs hora de conectar tu dispositivo inteligente. \\nPrimero, presiona el botón `Permit join (All)` en la parte superior de la interfaz web de Zigbee2MQTT. \\n\\nLuego, comienza a emparejar los dispositivos. La forma más común de poner un dispositivo en modo de conexión es mantener presionado su botón de encendido o encender/apagarlo 5 veces. Asegúrate de que Zigbee2MQTT esté en ejecución.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nCuando el dispositivo se conecte, los verás en la interfaz web:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nAhora deberías ver este sensor en tu interfaz web de Home Assistant. Ve a `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nDespués de agregar todos los sensores, puedes cerrar la interfaz web de Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"8e4c1822294854b399f0d4ead09b29c7\",\"title\":\"Cómo usar los planos\",\"path\":\"/docs/es/use-blueprints/\",\"content\":\"\\nEn este artículo aprenderás cómo agregar planos de automatización a tu Asistente de Hogar y configurarlo.\\n\\n## Automatizaciones de planos\\n\\nAlgunos planos ya están instalados. Las automatizaciones basadas en estos planos solo necesitan ser configuradas. En la interfaz web puedes encontrar planos preinstalados en `Settings/Automations & Scenes`. Abre `Blueprints` y encuentra el plano que deseas usar. En este ejemplo se utilizará `Motion-activated Light`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nHaz clic en `Create Automation` para abrir el editor de automatización. Dale un nombre, elige un plano para usar (`Motion-activated Light` en nuestro caso). Después de eso, debes elegir el sensor de movimiento y la lámpara. Cuando la configuración esté terminada, haz clic en `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Configuración\\\" />\\n\\nSi deseas realizar cambios, puedes encontrarlo yendo a `Settings/Automations & Scenes` y luego `Automations`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Importación de planos\\n\\nHome Assistant puede importar planos desde los foros de Home Assistant, GitHub y GitHub gists. La lista de todos los planos se encuentra en [Blueprints Exchange](https://community.home-assistant.io/c/blueprints-exchange/53). Después de elegir, ve a `Settings/Automations & Scenes` y abre `Blueprints`. Haz clic en `Import Blueprint` e inserta la URL del plano elegido. Luego haz clic en `PREVIEW BLUEPRINT`. En este caso, utilizaremos [Detección y notificación de nivel de batería baja para todos los sensores de batería](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nEsto cargará el plano y mostrará una vista previa en el cuadro de dilogo de importación. Puedes cambiar el nombre y finalizar la importación. Haz clic en `Create Automation` para abrir el editor de automatización. Aquí puedes configurar los parámetros de la automatización y agregar acciones para recibir notificaciones.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"1b533560b287a6c6093104a9a094b45a\",\"title\":\"Activar suscripción\",\"path\":\"/docs/es/sub-activate/\",\"content\":\"\\nEn este artículo crearás cuentas de parachain de Robonomics y comprarás una suscripción de IoT. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nPara controlar Home Assistant con Robonomics, necesitas 2 cuentas en la parachain de Robonomics. Para una de las cuentas (`sub_owner`), comprarás una suscripción de Robonomics. La segunda cuenta (`sub_controller`) controlará todos los procesos de Home Assistant (como la telemetría) y dará acceso a otros usuarios. Estas cuentas proporcionarán seguridad para tu Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nAmbas cuentas deben crearse con cifrado **ed25519**. Debido a esto, debe crear una cuenta utilizando la interfaz de usuario de Polkadot-JS y seleccionar el cifrado requerido. \\n\\nEsta función está desactivada de forma predeterminada en la interfaz de usuario de Polkadot-JS. Para habilitarla, ve a `Settings` -> `General` -> `account options` y selecciona `Allow local in-browser account storage` en el menú desplegable `creación de cuentas en el navegador`.\\n\\n</robo-wiki-note>\\n\\n## Crear cuentas de propietario y controlador\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Ve a la [aplicación de Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) en el Portal de Polkadot / Substrate. **Verifica la esquina superior izquierda para asegurarte de que estás conectado a Robonomics Parachain.**\\n\\n2. Ve a `Accounts` -> `Accounts` y presiona el botón `Add account`. Verás un menú emergente con la semilla de la cuenta. Tiene dos formas: *Mnemonic* (legible por humanos) y *Raw* (una secuencia de dígitos y letras). \\n\\n3. Abre `Advanced creation options`, cambia el tipo de criptografía para crear la cuenta a `Edwards - ed25519` y presiona `Next`.\\n\\n\\n4. Guarda de forma segura la frase de recuperación de la semilla mnemotécnica y presiona `Next`.\\n\\n5. En el siguiente menú, debes establecer el nombre de la cuenta y la contraseña. Dale el nombre `sub_owner` por conveniencia. Presiona `Next`.\\n\\n6. En la última ventana, haz clic en `Save` para finalizar la creación de la cuenta. También generará archivos JSON de respaldo que debes guardar de forma segura. Más adelante podrás usar este archivo para recuperar tu cuenta si recuerdas la contraseña.\\n\\n7. Repite estos pasos para una cuenta con el nombre `sub_controller`.\\n\\n\\n## Agregar cuentas a Polkadot.js\\n\\nPara mayor comodidad, debes usar la [extensión de Polkadot.js](https://polkadot.js.org/extension/) y agregar estas cuentas recién creadas a ella. Para una cuenta ed25519, solo puedes hacerlo con un archivo JSON de respaldo. Puedes usar los archivos guardados cuando creaste las cuentas.\\n\\nPuedes obtener estos archivos nuevamente creando un archivo de respaldo de la cuenta. Haz clic en los tres puntos de tu cuenta, elige `Create a backup file for this account` e ingresa tu contraseña.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Abre la extensión y haz clic en el botón `+` en la esquina superior derecha, luego elige `Restore account from backup JSON file`.\\n\\n2. En la ventana abierta, carga el archivo JSON, ingresa la contraseña y presiona `Restore`.\\n\\n3. Asegúrate de que la red de Robonomics esté seleccionada para las cuentas en la extensión de Polkadot.js. En el Portal de Polkadot / Substrate, ve a `Setting` -> `Metadata`  y haz clic en el botón `Update metadata`.\\n\\n4. Confirma la actualización de metadatos en el cuadro emergente. Ahora la extensión mostrará la etiqueta de la red para la cual se utiliza la dirección.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Activar suscripción de Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nPara este paso, debes tener una cantidad suficiente de tokens XRT (mínimo 2-3 XRT) en tu cuenta `sub_owner`.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Ve a la dapp de Robonomics a la [página de suscripción](https://dapp.robonomics.network/#/subscription) y presiona conectar cuenta en la barra lateral derecha.\\n\\n2. En el menú emergente siguiente, conecta la extensión Polkadot.js. Verás tu dirección de cuenta con saldo.\\n\\n3. Antes de comprar, verifica que hayas elegido la cuenta `sub_owner`. Presiona el icono de perfil de la dirección, deberías ver la cuenta `sub_owner` en el campo  `Check owner account`.\\n\\n4. Finalmente, presiona el botón `SUBMIT` e ingresa la contraseña de tu cuenta. Después espera hasta que se complete el proceso de activación. Verás el estado de tu suscripción después de un tiempo.\\n\\n\\n## Agregar cuentas a la suscripción\\n\\nAhora necesita agregar una cuenta `sub_controller` a la **lista de acceso**.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Abre la extensión y haz clic en el icono junto al nombre de la cuenta. Se copiará la dirección de la cuenta.\\n\\n\\n2. Pega esta dirección en el campo `Robonomics parachain address` en la parte **Gestionar acceso**. Dale un nombre y presiona el botón `+`. \\n\\n3. Repite los pasos 1 y 2 para la cuenta `sub_owner`.\\n\\n4. Presiona `Save`. Ingresa la contraseña de tu `sub_owner` en la ventana emergente y espera hasta que se complete el proceso de activación.\\n\"}},{\"node\":{\"id\":\"e69897b63c88716cc1f89316571058f2\",\"title\":\"Obtener Telemetría del Hogar Inteligente\",\"path\":\"/docs/es/smart-home-telemetry/\",\"content\":\"\\n**En este artículo, utilizarás el servicio Robonomics, que consulta la telemetría de los dispositivos del hogar inteligente.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Ve a la aplicación y elige el servicio [Telemetría del Hogar Inteligente](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. En el campo del controlador, ingresa la dirección `SUB_CONTROLLER`. Inserta la frase de seguridad para encriptar los datos.\\n\\n3. En el bloque `Get telemetry`, elige una marca de tiempo de la lista desplegable y presiona el botón `DOWNLOAD TELEMETRY`.\\n\\n4. La descarga de la telemetría puede llevar algún tiempo. Después de finalizar, verás la información de tus dispositivos y sensores.\\n\\n\\n<!---\\n## Lanzamiento devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Lanzamiento\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"60873bccb7a70398aacee5b3ef752969\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/es/sls-gateway/\",\"content\":\"\\n**En este artículo configurarás Robonomics SLS Gateway. Instalarás el software necesario para la puerta de enlace, lo configurarás y lo conectarás a Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nPrimero debes instalar el firmware del microcontrolador de la puerta de enlace. Prepara la puerta de enlace configurando los interruptores `1` y `3` en la parte inferior de SLS Gateway en `ON`, los demás deben estar en `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nConecta la puerta de enlace a tu Raspberry Pi a través del puerto USB tipo C en la puerta de enlace.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nClona el repositorio con el firmware en tu Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nVe a `robonomics-hass-utils/esp_firmware/linux`. Para flashear la puerta de enlace SLS, debes ejecutar los scripts `Clear` y `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Solución de problemas\\n\\nSi tienes problemas al actualizar el firmware de la puerta de enlace, debes seguir estos pasos adicionales:\\n\\n1. Asegúrate de tener instalado el módulo pySerial:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Otorga derechos de acceso al puerto USB a tu usuario y reinicia la computadora:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. En algunos casos, es necesario cambiar la configuración de ancho de banda en el script para actualizar el firmware. Abre el script `Flash_16mb.sh` con el editor `nano` y cambia el parámetro de velocidad de transmisión (`baud`) de `921600` a un valor más bajo (por ejemplo, `115200`).\\n\\n## Configuración\\n\\n1. Desconecta la puerta de enlace SLS de la computadora. Configura los interruptores en la parte posterior de la puerta de enlace en la posición correcta. Los interruptores `5` (RX Zigbee a ESP) y `6` (TX Zigbee a ESP) deben estar en la posición `ON`, los demás deben estar en `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Conecta el cable de alimentación tipo C. La luz indicadora en el centro debe ponerse verde.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. En el primer inicio, la puerta de enlace comenzará a compartir Wi-Fi con el SSID `zgw****`. Conéctate a esta red. Ten en cuenta que la señal puede ser bastante débil, por lo que es mejor mantener la puerta de enlace SLS más cerca de tu computadora. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Si la conexión es exitosa, se abrirá la interfaz web (o puedes encontrarla en la dirección 192.168.1.1). \\n\\n5. Verás la página `Wi-Fi Settings`. Selecciona tu Wi-Fi e ingresa la contraseña. Presiona el botón `Apply`. La puerta de enlace se reiniciará y se conectará a tu red Wi-Fi. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Encuentra la IP local de la puerta de enlace SLS para acceder a la interfaz web. Puedes usar la aplicación móvil [Fing](https://www.fing.com/products) o la herramienta de línea de comandos [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) para encontrarla. El nombre de la puerta de enlace debe verse así: `zgw****`. Abre la interfaz web de la puerta de enlace pegando la IP de la puerta de enlace en un navegador.\\n\\n7. Ve a `Setting` -> `Hardware` y asegúrate de que la configuración se vea como en la imagen. Corrige la configuración si es necesario y haz clic en el botón `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nLa tabla con los valores requeridos:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Luego reinicia la puerta de enlace. Elige `Actions` -> `Reboot system` en la esquina superior derecha.\\n\\n9. Asegúrate de que la puerta de enlace funcione correctamente en la ventana de información de Zigbee. El estado del dispositivo (`DeviceState`) debe ser `OK`.\\n\\n10. Configura la adición automática de dispositivos a Home Assistant. Ve a `Zigbee` -> `Config` y elige `Home Assistant MQTT Discovery` y `Clear States`. Guarda los cambios y **reinicia** la puerta de enlace SLS.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSi ya tienes una puerta de enlace SLS activa en tu hogar y ahora estás configurando otra, entrarán en conflicto entre sí. Para resolver este problema, debes cambiar el canal en el nuevo dispositivo. Para hacer esto, ve a `Zigbee` -> `Config` y cambia el canal a otro (por ejemplo, canal 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Emparejamiento de SLS con MQTT\\n\\nDespués de configurar la puerta de enlace SLS, debes conectarla a Home Assistant. Abre la interfaz web de la puerta de enlace SLS y ve a `Settings/Link` -> `MQTT Setup`:\\n\\n\\nAgrega la dirección de tu broker (dirección de la Raspberry Pi con Home Assistant en la red local, puedes encontrarla con la aplicación móvil [Fing](https://www.fing.com/products) o la herramienta de línea de comandos [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), el puerto (por defecto es `1883`), tu nombre de usuario y contraseña del broker (que creaste anteriormente) y el nombre del tema (puedes elegir cualquier nombre). Además, la dirección IP de la Raspberry Pi debe ser estática. Haz clic en `Enable` y `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nGuarda los cambios. Ahora los dispositivos se mostrarán automáticamente en Home Assistant.\\n\\n## Conectar Dispositivos\\n\\nConecta tus dispositivos yendo a `Zigbee` -> `Join`. Pon tus sensores en modo de emparejamiento, la forma más común de cambiar un dispositivo al modo de conexión es mantener presionado su botón de encendido o encender/apagarlos 5 veces. Presiona el botón `Enable Join`  para comenzar a buscar dispositivos Zigbee. Verás sensores activos.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nAhora puedes ir a la sección [**Suscripción IoT**](/docs/sub-activate) y comenzar a activar la suscripción de Robonomics.\\n\"}},{\"node\":{\"id\":\"2f527bf6f63710bf42f2e5bcf4cda5de\",\"title\":\"Red de Sensores Descentralizados\",\"path\":\"/docs/es/sensors-network-introduction/\",\"content\":\"\\nLos artículos sobre la Red de Sensores Descentralizados se transfirieron a Robonomics Academy: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"0dccc7288404a262bcaa2a12889e9c49\",\"title\":\"Conecta de forma segura la inteligencia artificial en la nube con el suelo de fábrica\",\"path\":\"/docs/es/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nLas tecnologías de Robonomics ya pueden resolver los desafíos a los que se enfrenta la Industria 4.0 y ya se aplican en escenarios del mundo real en el entorno industrial.\\n\\nUn gran número de empresas de inteligencia artificial están desarrollando soluciones para optimizar los procesos en el suelo de fábrica, permitiendo a las plantas producir más con menos coste. Sin embargo, la mayoría de las plantas dudan en conectar su infraestructura directamente a la nube, ya que esto resulta en posibles riesgos de ciberseguridad, que podrían llevar a pérdidas millonarias e incluso a la pérdida de vidas humanas.\\n\\n[MerkleBot](https://merklebot.com) ha utilizado [Robonomics Network](https://robonomics.network) para desarrollar una solución para clientes industriales que les permite conectar su fábrica a la inteligencia artificial basada en la nube de forma segura.\\n\\nEste artículo se escribe a raíz de un experimento que realizamos con [Veracity Protocol](https://www.veracityprotocol.org/) que utiliza algoritmos para crear una protección no invasiva de cualquier objeto físico basada en las fotografías de un dispositivo móvil.\\n\\nEste caso de uso muestra el proceso de escaneo de las piezas industriales utilizando un brazo robótico.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Proceso paso a paso\\n\\n### DApp como interfaz de usuario\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp actúa como una interfaz de usuario para el operador. Se utiliza para solicitar el lanzamiento del robot para recopilar las fotografías y su objetivo es permitir una comunicación segura entre el entorno de la fábrica y la inteligencia artificial basada en la nube.\\n\\n### Lanzamiento del robot\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nEl operador lanza el escaneo robótico firmando la transacción en la DApp. Este paso garantiza que el proceso en el suelo de fábrica solo pueda comenzar en función de la transacción en la cadena de bloques pública.\\n\\nEl robot recibe un comando de la cadena de bloques a través de la Red Robonomics y comienza el escaneo. Las tecnologías de la Red Robonomics nos permiten cerrar la brecha entre el objetivo empresarial y la operación robótica.\\n\\n### Recopilación de datos y envío a la inteligencia artificial basada en la nube\\n\\nEn la DApp, el operador ve la confirmación y el robot comienza a escanear los objetos colocados en la mesa, como en este caso de uso, o directamente en la línea de fábrica si es necesario.\\n\\n<!-- ![](../images/Veracity_Protocol_Lanzamiento.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nCuando el robot recopila los datos, los almacena localmente y los pone a disposición de la inteligencia artificial basada en la nube a través del protocolo IPFS. Al encriptar los datos y organizar el intercambio de datos a través de una transacción en la cadena de bloques, podemos autorizar el acceso a la inteligencia artificial basada en la nube asegurándonos de que los datos permanezcan seguros y en su lugar.\\n\\nEl mecanismo de seguridad incorporado en Robonomics basado en la seguridad compartida de las cadenas de bloques públicas permite obtener el nivel de seguridad que resulta prohibitivamente caro para la mayoría de las fábricas organizar por sí mismas.\\n\\n### Creación de pasaporte digital\\n\\nCuando la inteligencia artificial basada en la nube analiza los datos, el archivo de registro y las recomendaciones se registran automáticamente como un [Pasaporte Digital](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/). Cada operación y escaneo se pueden rastrear ya que el registro de la cadena de bloques tiene el hash de todos estos archivos a través del protocolo IPFS.\\n\\n## Comentarios sobre el caso de uso\\n\\nEn este caso de uso, se utilizó el brazo industrial Universal Robot UR3. Pero gracias al soporte de Robonomics para ROS, se pueden utilizar y conectar de forma segura la mayoría de los principales manipuladores industriales, incluidos KUKA, Fanuc y Yaskawa.\\n\\nSi estás interesado en obtener más información sobre la implementación e integración de instrumentos de inteligencia artificial basados en la nube de forma segura, por favor [contáctanos](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"f25eea666571bb5cbaffdc5c2dc9cf99\",\"title\":\"Cómo agregar el sensor SDS011 a Home Assistant\",\"path\":\"/docs/es/sds-sensor-hass/\",\"content\":\"\\nEste artículo explica cómo conectar el sensor de calidad del aire SDS con el firmware [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) y [Robonomics](https://github.com/airalab/sensors-software) a Home Assistant.\\n\\n## Instalación \\nHay dos opciones de instalación disponibles:\\n\\n### Opción 1: HACS\\n\\nLa forma más fácil de agregar un sensor local de Luftdaten es a través de HACS. [Aquí](https://hacs.xyz/docs/setup/download/) puedes encontrar una breve explicación sobre cómo configurar HACS.\\n\\nUna vez instalado HACS, ve a HACS -> Integraciones y busca la integración `Local Luftdaten Sensor`. Haz clic en el botón de descarga y reinicia Home Assistant una vez que se haya descargado la integración.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Option 2: Manual Instalación\\n\\nBajo el usuario homeassistant, clona el repositorio del proyecto:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nSi ya tienes integraciones personalizadas, copia `custom_components/local_luftdaten/` en tu directorio `custom_components`, por ejemplo:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nSi no tienes integraciones personalizadas, copia todo el directorio `custom_components` en el directorio de configuración de Home Assistant, por ejemplo:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Configuración\\n\\nCrea una nueva entrada de sensor en tu `configuration.yaml` y ajusta el nombre del host o la dirección IP. Para encontrar la dirección IP local de tu sensor, puedes usar la aplicación móvil [Fing](https://www.fing.com/products) o la herramienta de línea de comandos [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). El nombre puede ser cualquier cosa.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> Puedes encontrar una lista de todos los sensores compatibles en el [repositorio](https://github.com/lichtteil/local_luftdaten).\\n\\nReinicia Home Assistant.\\nDespués de eso, puedes agregar el sensor a tu panel de control. El nombre de la entidad será el nombre que agregaste en `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"092a841dfdf77a6ecf53778bd251c5aa\",\"title\":\"Cómo conectar el sensor SDS011\",\"path\":\"/docs/es/sds-sensor-connect/\",\"content\":\"\\n** Aquí hay una guía paso a paso sobre cómo conectar su sensor a la Red de Sensores Robonomics. Nuestros sensores utilizan el firmware de Robonomics, que es una versión mejorada del firmware de sensor.community. Incluye sensores adicionales y tiene un mecanismo de envío de datos modificado. **\\n\\n1. Conecte el sensor al enchufe para alimentarlo.\\n2. La placa creará una red Wi-Fi llamada `RobonomicsSensor-xxxxxxxxx`. Conéctese a ella desde su teléfono o computadora: verá la ventana de autorización (si no, abra el navegador e vaya a `192.168.4.1`).\\n3. Seleccione su red Wi-Fi de la lista (o escríbala usted mismo si no está en la lista) y complete el campo de contraseña.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nEl sensor sólo se puede conectar a una red Wi-Fi de 2,4 GHz.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Escriba las coordenadas del lugar donde se instalará el sensor. Puede obtenerlas de cualquier mapa o obtenerlas de la dirección utilizando [este enlace.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nLas coordenadas del sensor se mostrarán en un mapa de acceso público. Si no desea mostrar su información privada, escriba cerca, pero no coordenadas exactas.\\n</robo-wiki-note> \\n5. Haga clic en `Save configuration and restart`. La placa se reiniciará y se conectará a la red Wi-Fi especificada.\\n6. Abra [el mapa de sensores de Robonomics](https://sensors.robonomics.network/#/) y encuentre el lugar donde instaló el sensor. En un par de minutos podrá ver su sensor con datos en el mapa.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"534230a310f96f75684c8396bdb1dcd3\",\"title\":\"Cómo ejecutar un nodo de desarrollo de Robonomics\",\"path\":\"/docs/es/run-dev-node/\",\"content\":\"\\n**Para probar tus aplicaciones en Robonomics, es posible que desees ejecutarlo en modo de desarrollo. Este artículo muestra paso a paso\\ninstrucciones sobre cómo obtener tu propia instancia de prueba local de Robonomics.**\\n\\n\\n## Obtener el archivo binario del nodo\\n\\n1. Primero, necesitas un archivo binario, descarga el archivo comprimido desde la última [versión](https://github.com/airalab/robonomics/releases).\\n\\n2. Navega hasta la carpeta del archivo comprimido, descomprímelo y cambia los permisos:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Ejecutar\\n\\nEjecuta el nodo con:\\n\\n```bash\\n./robonomics --dev\\n```\\nVerás la siguiente salida:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Si deseas eliminar los bloques existentes, puedes hacerlo eliminando RocksDB en `/tmp/substrate******/chains/dev/db/full`.\\n  Reemplaza `******` con el identificador correspondiente que se muestra en los registros al iniciar.\\n\\n  Si deseas iniciar el nodo desde cero cada vez, utiliza la opción `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Conectar\\n\\nAhora puedes conectarte a tu nodo local a través del [Portal Polkadot](https://polkadot.js.org/apps/#/explorer).\\n\\nCambia la red a `Local Node` en la esquina superior izquierda y presiona `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\n¡Bienvenido a la instancia local de Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"b26cab98c1cfe4b36a6cee70725365a1\",\"title\":\"Resumen de Robonomics Smart Home\",\"path\":\"/docs/es/robonomics-smart-home-overview/\",\"content\":\"\\n## IoT seguro con Blockchain \\n\\nPara tu hogar inteligente, el mercado moderno de IoT ofrece una amplia gama de soluciones. Pero generalmente estás atado a proveedores de nube centralizados o costosos gateways propietarios. Como resultado, como usuario siempre dependes del proveedor de hardware e infraestructura para ejecutar tu sistema inteligente. Al mismo tiempo, tu hogar inteligente no puede ser verdaderamente inteligente sin estadísticas y análisis en la nube.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Vemos dos problemas principales con los hogares inteligentes actuales:**\\n\\n1. No tienes control sobre qué datos compartes con el proveedor o terceros.\\n2. Tu hogar inteligente es vulnerable a los cierres de servidores de nube centralizados. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nPara resolver ambos problemas, te sugerimos probar Robonomics, nuestra nube descentralizada **segura**, **sin servidor** y **futurista**.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Pasos para una nube sin corporaciones\\n\\nAquí tienes algunos pasos sencillos para crear un hogar inteligente asequible utilizando Home Assistant como aplicación de comunicación de dispositivos y Robonomics como una plataforma de nube descentralizada sin corporaciones. Robonomics aprovecha tecnologías modernas y seguras de Web3, asegurando una mayor seguridad durante todo el proceso..\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Comienza aquí tu hogar inteligente\\n\\nHemos preparado guías detalladas sobre cómo configurar un hogar inteligente en Robonomics. Los pasos pueden variar según tu situación específica: si ya tienes un Home Assistant operativo con dispositivos emparejados, o si estás comenzando desde cero para establecer tu hogar inteligente.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/es/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/es/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"b85c2d4925f11a642d73fca400f1493d\",\"title\":\"Servicio de Video Robonomics\",\"path\":\"/docs/es/robonomics-video/\",\"content\":\"\\nEste artículo muestra cómo agregar una cámara IP a Home Assistant y enviar videos al Servicio Web Robonomics.\\n\\nPara conectar una cámara a Home Assistant, necesitas conocer su dirección IP y crear una cuenta de cámara local para conectarte al flujo RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nDado que esto se hace de manera diferente para cada cámara, este proceso no se considera en este artículo.\\n</robo-wiki-note>\\n\\nRequisitos:\\n- Cámara IP\\n- Cuenta de cámara local configurada\\n- Dirección IP de la cámara\\n- Home Assistant configurado\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nEste artículo asume que tienes una cámara IP general sin opciones de RTZ (rotar, inclinar, hacer zoom). \\nSi tienes una cámara RTZ, consulta el artículo \\\"Cámara RTZ\\\" (/docs/ptz-camera). Y luego regresa al segundo paso aquí.\\n\\n</robo-wiki-note>\\n\\n## Conectar la cámara\\n\\nPrimero, necesita encontrar la URL de la transmisión RTSP de la cámara.\\nPara hacerlo, intenta ingresar la siguiente consulta en Internet: \\\"<NOMBRE_DE_LA_CÁMARA> flujo RTSP\\\".\\nLa URL del flujo debe comenzar con `rtsp://<DIRECCIÓN_IP>...`. \\n\\nEste artículo utiliza una cámara \\\"Tapo\\\" y la ruta del flujo es `rtsp://<DIRECCIÓN_IP>/stream1`.\\n\\nAbre Home Assistant y ve a \\\"Settings\\\"-> \\\"Devices & Services\\\". Presiona el botón \\\"ADD INTEGRATION\\\" y\\ncomienza a escribir \\\"Generic Camera\\\". Elígelo.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nEn la ventana de configuración proporciona la siguiente información:\\n- Stream Source URL - La URL del flujo RTSP de la cámara\\n- Username - escribe el nombre de usuario de tu cuenta de cámara local\\n- Password - escribe una contraseña para tu cuenta de cámara local\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nDesplázate hacia abajo en la configuración y presiona el botón \\\"Submit\\\".\\n\\nEn la ventana de vista previa, activa la casilla \\\"This image looks good.\\\" y presiona el botón \\\"Submit\\\". Luego - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Agregar al tablero\\n\\nAdemás, puedes agregar el flujo a tu tablero. Para hacer esto, ve al tablero y crea una nueva tarjeta \\n\\\"Picture Glance\\\". Pasos adicionales:\\n- ingresa el \\\"Títle\\\" que desees\\n- borra los datos de \\\"Image path\\\"\\n- selecciona la cámara en \\\"Camera Entity\\\"\\n- en la \\\"Camera View\\\", selecciona \\\"en vivo\\\" para que haya menos retraso\\n\\nY guárdalo.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Verificar la carpeta de medios\\n\\nBefore being sent to the Robonomics Video Service, the video must be saved in a folder, and Home Assistant must have access to this folder. \\nLa opción más fácil en este caso es usar un paquete de medios, en el cual Home Assistant almacena todos los medios.\\n\\n- Si usas HAOS o una imagen preinstalada, tu Home Assistant **ya tiene una carpeta de medios**.\\n- Si usas Home Assistant Core, debes ir a la carpeta `.homeassistant` y crear la carpeta `media` en ella.\\n- Si usas Home Assistant Docker, agrega la línea ` -v /RUTA_A_TU_MEDIA:/media \\\\` al comando Docker.\\n\\nPara verificar que todo se configuró correctamente, ve a la pestaña “Media” -> “local media” en tu Home Assistant. \\nDeberías ver una carpeta vacía (sin errores):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Llamada de servicio\\n\\nPara enviar un video a Robonomics, debes llamar a un servicio dedicado en Home Assistant. \\nEn este artículo se hace manualmente, pero puedes crear una automatización para ello.\\n\\nPara hacer esto, ve a \\\"Developer tools\\\" -> \\\"Services\\\" y busca \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nEn \\\"Targets\\\" elige la entidad de tu cámara.\\nEn \\\"Path to save the recording\\\" debes proporcionar una ruta absoluta a la carpeta,\\ndonde Home Assistant puede guardar el video:\\n- Para imagen preinstalada - `/home/homeassistant/.homeassistant/media`;\\n- Para HA OS o Home Assistant Docker- `/media`;\\n- Para Home Assistant Core - Ruta a la carpeta de medios creada anteriormente.\\n\\nAdemás, puedes elegir la Duración de la grabación. \\n\\nCompleta los datos y llama al servicio con el botón \\\"CALL SERVICE\\\".\\n\\n## DAPP\\n\\nPara ver el video resultante, ve a [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nPega la dirección de cuenta de tu controlador y haz clic en el botón de abajo. Espera el proceso de \\\"Search for Twins\\\". \\nComo resultado, obtendrás un CID de IPFS con todos los videos grabados.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nA continuación, selecciona la cuenta del controlador (u otra) de la lista desplegable y firma un mensaje para autorizar en\\nla puerta de enlace Web3 IPFS para descargar todos los videos. Como resultado, obtendrás todos los videos grabados por tu hogar inteligente.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nDado que todos los videos en la carpeta están encriptados con la clave del controlador, debes insertarla para descifrar los videos.\\nDespués de eso, se activa el botón de reproducción de video. Haz clic en él para descargar el video.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"a8dc5a4baecb2ac1567ced959bbd0feb\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/es/robonomics-prometheus-grafana/\",\"content\":\"\\n**La siguiente instrucción es proporcionada por [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**El artículo original se encuentra [aquí](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Introducción\\nPara monitorear y mantener mejor el/los nodo(s) de Robonomics, es bueno configurar un monitoreo basado en Prometheus Server y Grafana. Este documento mostrará cómo configurar cada uno de ellos para monitorear completamente su nodo.\\n\\n##  Prerrequisitos\\n* [Configuración del servidor con Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Collator de parachain de Robonomics instalado](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Asegúrese de que robonomics.service esté funcionando en su máquina y que el puerto 9615 sea accesible \\n\\n## Paso 1: Crear usuarios de servicio\\n\\nPor razones de seguridad, comenzaremos creando dos nuevas cuentas de usuario, prometheus y node_exporter. Cree estos dos usuarios y use las opciones _--no-create-home_ y _--shell /bin/false_ para que estos usuarios no puedan iniciar sesión en el servidor.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nAntes de descargar los binarios de Prometheus, cree los directorios necesarios para almacenar los archivos y datos de Prometheus. Siguiendo las convenciones estándar de Linux, crearemos un directorio en _/etc_ para los archivos de configuración de Prometheus y un directorio en _/var/lib_ para sus datos.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nAhora, establezca la propiedad del usuario y del grupo en los nuevos directorios para el usuario prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Paso 2: Descargar Prometheus\\n\\nPrimero, descargue y descomprima la versión estable actual de Prometheus en su directorio de inicio. Puede encontrar los últimos binarios en la [página de descarga de Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nAhora, descomprima el archivo descargado.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nEsto creará un directorio llamado prometheus-2.21.0.linux-amd64 que contiene dos archivos binarios (prometheus y promtool), los directorios _consoles_ y _console_libraries_ que contienen los archivos de la interfaz web, una licencia, un aviso y varios archivos de ejemplo.\\n\\nCopie los dos binarios al directorio _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nEstablezca la propiedad del usuario y del grupo en los binarios para el usuario prometheus creado en el Paso 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nCopie los directorios consoles y _console_libraries_ a _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nEstablezca la propiedad del usuario y del grupo en los directorios para el usuario prometheus. Usar la bandera -R asegurará que la propiedad se establezca también en los archivos dentro del directorio.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nAhora que Prometheus está instalado, crearemos su configuración y archivos de servicio en preparación para su primera ejecución.\\n\\n## Paso 3: Configurar Prometheus\\n\\nEn el directorio _/etc/prometheus_, use nano o su editor de texto favorito para crear un archivo de configuración llamado _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nEn la configuración global, defina el intervalo predeterminado para recopilar métricas. Tenga en cuenta que Prometheus aplicará esta configuración a cada exportador a menos que la configuración propia del exportador anule las globales.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nEste valor de scrape_interval le indica a Prometheus que recopile métricas de sus exportadores cada 15 segundos, lo cual es suficiente para la mayoría de los exportadores.\\nAhora, agregue Prometheus mismo a la lista de exportadores para recopilar con la siguiente directiva scrape_configs:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus utiliza el _job_name_ para etiquetar los exportadores en consultas y gráficos, así que asegúrese de elegir algo descriptivo aquí.\\n\\nY, como Prometheus exporta datos importantes sobre sí mismo que puede utilizar para monitorear el rendimiento y depurar, hemos anulado la directiva global scrape_interval de 15 segundos a 5 segundos para actualizaciones más frecuentes.\\n\\nPor último, Prometheus utiliza las directivas _static_configs_ y _targets_ para determinar dónde se ejecutan los exportadores. Dado que este exportador en particular se ejecuta en el mismo servidor que Prometheus mismo, podemos usar localhost en lugar de una dirección IP junto con el puerto predeterminado, 9090.\\n\\nSu archivo de configuración debería verse así ahora:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nGuarde el archivo y salga de su editor de texto.\\n\\nAhora, establezca la propiedad del usuario y del grupo en el archivo de configuración para el usuario prometheus creado en el Paso 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nCon la configuración completa, estamos listos para probar Prometheus ejecutándolo por primera vez.\\n\\n## Paso 4: Ejecutar Prometheus\\n\\nInicie Prometheus como usuario _prometheus_, proporcionando la ruta tanto al archivo de configuración como al directorio de datos.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nLa salida contiene información sobre el progreso de carga de Prometheus, el archivo de configuración y los servicios relacionados. También confirma que Prometheus está escuchando en el puerto _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nSi recibes un mensaje de error, verifica que hayas utilizado la sintaxis YAML en tu archivo de configuración y luego sigue las instrucciones en pantalla para resolver el problema.\\n\\nAhora, detén Prometheus presionando _CTRL+C_, y luego abre un nuevo archivo de servicio _systemd_.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nEl archivo de servicio le indica a _systemd_ que ejecute Prometheus como usuario prometheus, con el archivo de configuración ubicado en el directorio _/etc/prometheus/prometheus.yml_ y que almacene sus datos en el directorio _/var/lib/prometheus_. Copia el siguiente contenido en el archivo:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nFinalmente, guarda el archivo y cierra tu editor de texto. Para usar el servicio recién creado, recarga systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nAhora puedes iniciar Prometheus usando el siguiente comando:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nPara asegurarte de que Prometheus esté en funcionamiento, verifica el estado del servicio.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nLa salida te muestra el estado de Prometheus, el identificador del proceso principal (PID), el uso de memoria y más.\\n\\nSi el estado del servicio no está activo, sigue las instrucciones en pantalla y vuelve a seguir los pasos anteriores para resolver el problema antes de continuar con el tutorial.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nCuando estés listo para continuar, presiona _Q_ para salir del comando de estado. Por último, habilita el servicio para que se inicie en el arranque.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nAhora que Prometheus está en funcionamiento, podemos instalar un exportador adicional para generar métricas sobre los recursos de nuestro servidor.\\n\\n## Paso 5 — Descargar Node Exporter\\n\\nPara ampliar Prometheus más allá de las métricas solo sobre sí mismo, instalaremos un exportador adicional llamado Node Exporter. Node Exporter proporciona información detallada sobre el sistema, incluido el uso de CPU, disco y memoria. Descarga la versión estable actual de Node Exporter en tu directorio de inicio. Puedes encontrar los últimos binarios en [la página de descarga de Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nAhora, descomprima el archivo descargado.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nEsto creará un directorio llamado _node_exporter-1.0.1.linux-amd64_ que contiene un archivo binario llamado _node_exporter_, una licencia y un aviso.\\n\\nCopia el binario al directorio _/usr/local/bin_ y establece la propiedad de usuario y grupo en el usuario node_exporter que creaste en el Paso 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nAhora que has instalado Node Exporter, probémoslo ejecutándolo antes de crear un archivo de servicio para que se inicie en el arranque.\\n\\n## Paso 6 — Ejecutar Node Exporter\\n\\nLos pasos para ejecutar Node Exporter son similares a los de ejecutar Prometheus en sí. Comienza creando el archivo de servicio Systemd para Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nCopia el siguiente contenido en el archivo de servicio:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nGuarda el archivo y cierra tu editor de texto. Por último, recarga systemd para usar el servicio recién creado.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nAhora puedes ejecutar Node Exporter usando el siguiente comando:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nVerificar that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nAl igual que antes, esta salida te muestra el estado de Node Exporter, el identificador del proceso principal (PID), el uso de memoria y más. Si el estado del servicio no está activo, sigue los mensajes en pantalla y vuelve a seguir los pasos anteriores para resolver el problema antes de continuar.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nPor último, habilita Node Exporter para que se inicie en el arranque.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nCon Node Exporter completamente configurado y funcionando como se esperaba, le diremos a Prometheus que comience a recopilar las nuevas métricas.\\n\\n## Paso 7 — Configurar Prometheus para recopilar Node Exporter\\n\\nDado que Prometheus solo recopila exportadores que están definidos en la sección scrape_configs de su archivo de configuración, deberemos agregar una entrada para Node Exporter, al igual que hicimos para Prometheus en sí. Abre el archivo de configuración.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nAl final del bloque scrape_configs, agrega una nueva entrada llamada node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nDado que este exportador también se está ejecutando en el mismo servidor que Prometheus en sí, podemos usar localhost en lugar de una dirección IP nuevamente junto con el puerto predeterminado de Node Exporter, 9100. Tu archivo de configuración completo debería verse así:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nGuarda el archivo y cierra tu editor de texto cuando estés listo para continuar. Por último, reinicia Prometheus para que los cambios surtan efecto.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nUna vez más, verifica que todo esté funcionando correctamente con el comando de estado.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nSi el estado del servicio no está activo, sigue las instrucciones en pantalla y vuelve a seguir tus pasos anteriores antes de continuar.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nAhora tenemos Prometheus y Node Exporter instalados, configurados y en funcionamiento.\\n\\n## Paso 8 - Agregar Robonomic build en node_exporter\\n\\nDespués de instalar correctamente Prometheus y node_exporter, tendremos que usar el exportador de Prometheus integrado en cada proyecto de sustrato. Para lograr esto, debemos agregar una entrada adicional a _/etc/prometheus/prometheus.yml_. \\nAbre el archivo de configuración.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nAl final del bloque scrape_configs, agrega una nueva entrada llamada robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nGuarde el archivo y salga de su editor de texto. Su archivo de configuración completo debería verse así:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nFinalmente, reinicie Prometheus para que los cambios surtan efecto.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nUna vez más, verifica que todo esté funcionando correctamente con el comando de estado.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nAhora tenemos _Prometheus_, _Node Exporter_ y _Robonomic Exporter_ instalados, configurados y en funcionamiento. Ahora pasemos a Grafana.\\n\\n## Paso 9 - Configuración de Grafana\\n\\nEl último paso es conectar Prometheus como una Fuente de Datos en Grafana. Para este tutorial, utilizaremos una instancia gratuita de Grafana basada en la nube que permite tener hasta 5 paneles de control, así como un panel de control dedicado de [Robonomics](https://grafana.com/grafana/dashboards/13015). Simplemente vaya a [grafana.com](https://grafana.com/), cree una cuenta nueva e inicie sesión en su instancia de Grafana recién creada.\\n\\nAl principio, debemos agregar a Grafana una nueva _**Fuente de Datos**_, que en nuestro caso será el servidor Prometheus.\\nVaya a Fuente de Datos:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nLuego haga clic en **_Agregar fuente de datos_**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext seleccione _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nEn la nueva pantalla, ingrese la **_dirección IP de su servidor Prometheus con el puerto 9090_**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nDespués de eso, haga clic en _**Guardar y probar**_ si ha seguido todos los pasos, debería aparecer en verde y listo para importar el panel de control. En el sitio principal, haga clic en **+** y luego en **Importar**, como se muestra en la imagen a continuación:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nLuego debería ver la página de importación:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nEn la _URL o ID del panel de control de Grafana.com_, escriba _**13015**_ (ya que este es el ID del panel de control de Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nDespués de cargar el panel de control externo, verá esta pantalla:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nEl último paso es elegir la **_Fuente de Datos_** previamente creada y hacer clic en _**Importar**_\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\n¡ESO ES TODO! En este punto, debería ver el panel de control importado. \\n\\n\\n## Referencias\\n\\n* [Cómo instalar Prometheus en Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Crear un panel de control de monitoreo con Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Soporte de Grafana para Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Monitoreo de métricas de host de Linux con el exportador de nodos](https://prometheus.io/docs/guides/node-exporter/)\\n* [Consultar Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Visualizar métricas de nodos](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Exportador de Prometheus para Substrate](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Métricas de nodos de Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [Panel de control del Exportador de Nodos para Prometheus](https://grafana.com/grafana/dashboards/11074)\\n* [Métricas de ROBONOMICS (XRT) de Grafana](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"82d93a7a823902a5696393b055803174\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/es/robonomics-opengov/\",\"content\":\"\\n## Introducción\\n\\nRobonomics ha cambiado el modelo de gobernanza de la parachain al sofisticado mecanismo OpenGov de Polkadot que permite que la cadena evolucione con el tiempo, bajo la voluntad final de los titulares de tokens.\\nLa transición de Robonomics a OpenGov garantiza que el DAO de los titulares de tokens, que controla la mayoría de las participaciones, siempre pueda dirigir la dirección de la parachain de Robonomics, promoviendo cualquier cambio en la red que consideren adecuado.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov solo se aplica a la Parachain de Robonomics, que es una cadena basada en Substrate conectada a la Kusama Relay Chain. OpenGov no se aplica a la implementación de Robonomics Ethereum, ya que la mainnet de Ethereum actualmente no admite sistemas de gobernanza sofisticados como OpenGov.\\n</robo-wiki-note>\\n\\nOpenGov cambia la forma en que se llevan a cabo las operaciones y la toma de decisiones diarias en la parachain. Proporciona una mayor claridad sobre el alcance de los referendos y tiene el potencial de aumentar drásticamente la capacidad de decisión en la parachain.\\n\\nOpenGov ha estado activo en la Kusama Relay Chain durante algunos meses en el momento de escribir esto, y ha demostrado que aumenta drásticamente el número de decisiones (referendos individuales y discretos) que el DAO de los titulares de tokens puede proponer, votar y, a través de la votación, controlar en última instancia la dirección del protocolo.\\n\\n**El siguiente contenido contenido en esta sección de la wiki explicará los principios fundamentales de OpenGov en la parachain de Robonomics y tiene como objetivo ayudarlo a comprender mejor los conceptos detrás de OpenGov.**\\n\\n*Es importante tener en cuenta que la gobernanza es un mecanismo en constante evolución en el protocolo, especialmente en las etapas iniciales de implementación.*\\n\\nPara aquellos interesados ​​únicamente en los parámetros de seguimiento de Robonomics OpenGov, consulte [aquí](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## Acerca de los referendos\\n\\nLos referendos son esquemas de votación simples, inclusivos y basados ​​en participaciones. Cada referendo tiene una propuesta específica asociada que toma la forma de una llamada de función privilegiada en el tiempo de ejecución de las cadenas. Esto también puede incluir la llamada más poderosa `set_code`, que tiene la capacidad de cambiar todo el código del tiempo de ejecución de las cadenas; esto es exclusivo de las cadenas basadas en Substrate y elimina el requisito de una \\\"bifurcación dura\\\" de la cadena al actualizar la lógica empresarial de las cadenas ( tiempo de ejecución).\\n\\nLos referendos son eventos discretos que tienen un período de votación fijo (más sobre los diferentes períodos durante el ciclo de vida de un referendo más adelante). Los titulares individuales de tokens pueden votar de tres formas en los referendos: AYE (acuerdo/sí), NAY (desacuerdo/no) o ABSTENERSE de votar por completo.\\n\\nTodos los referendos tienen un retraso de promulgación asociado. Este es el período entre el final del referendo y, suponiendo que el referendo haya sido aprobado, la promulgación de los cambios en la red. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Existe un Período de Promulgación **Mínimo** específicamente establecido para cada tipo diferente de Origen, pero el originador de un referendo en particular puede establecer que las tareas específicas de ese referendo se ejecuten en muchos bloques en el futuro\\n\\n</robo-wiki-note>\\n\\nLos referendos se consideran \\\"baked\\\" si están cerrados y los votos se cuentan. Suponiendo que el referendo haya sido aprobado, se programará su promulgación (en el programador de las cadenas). Los referendos se consideran \\\"unbaked\\\" si el resultado está pendiente, como si el referendo aún se estuviera votando actualmente.\\n\\nCon la adición de OpenGov, cualquier persona puede iniciar un referendo en cualquier momento y puede hacerlo tantas veces como desee. OpenGov elimina la limitación de que solo se pueda procesar 1 referendo a la vez (tenga en cuenta que, en Gov v1, solo se puede votar en 1 referendo a la vez. La única excepción es un referendo de emergencia adicional por parte del Comité Técnico acelerado que también puede ser votado simultáneamente por la comunidad).\\n\\nOpenGov introduce varias características / conceptos nuevos conocidos como Orígenes y Tracks, y estos se introducen para ayudar en el flujo y procesamiento de referendos en el protocolo.\\n\\nCada Origen está asociado con una sola clase de referendo, y cada clase está asociada con un track. El track describe el ciclo de vida del referendo y es específico para ese Origen particular desde el cual se origina el referendo. Tener tracks con sus propios parámetros específicos permite que la red modifique dinámicamente el ciclo de vida de los referendos según su nivel de privilegio (puede pensar en el nivel de privilegio como el poder de un referendo / qué tipos de cambios puede realizar en el protocolo).\\n\\n*Piense en los Orígenes como el poder asociado con un referendo y piense en los Tracks como los parámetros de votación asociados con un referendo, como la duración de sus períodos y los criterios de aprobación y apoyo.*\\n\\nPor ejemplo, una actualización de tiempo de ejecución no tiene las mismas implicaciones para el protocolo que una pequeña propina del tesoro, por lo que se necesitan orígenes diferentes en los que se predeterminarán diferentes participaciones, aprobaciones, depósitos y períodos de promulgación (Tracks) en la paleta de las cadenas.\\n\\n## Proponiendo un Referéndum y Ciclo de Vida del Referéndum \\n\\n### Período de Preparación\\n\\nEn OpenGov, cuando se crea inicialmente un referéndum, puede ser votado inmediatamente por la comunidad de poseedores de tokens. Sin embargo, no está inmediatamente en un estado en el que pueda finalizar, o de otra manera tener sus votos contados, ser aprobado y promulgado sumariamente. En cambio, los referendos deben cumplir una serie de criterios antes de ser trasladados al Período de Decisión. Hasta que los referendos entren en el Período de Decisión, permanecerán sin decidir, y eventualmente expirarán después del período de ciclo de vida general especificado en la pista individual.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nLos criterios para que un referéndum entre en el Período de Decisión son los siguientes:\\n1. Un Período de Preparación que establece la cantidad de tiempo que debe transcurrir antes de que pueda comenzar el Período de Decisión. Este Período de Preparación ayuda a mitigar la posibilidad de \\\"ataques de decisión\\\" en los que un atacante que controla una cantidad sustancial de poder de voto podría intentar utilizar su gran participación para que un referéndum sea aprobado inmediatamente después de proponerlo, evitando así la posibilidad de que los demás miembros del DAO de poseedores de tokens tengan tiempo suficiente para considerar el referéndum y participar en la votación. Por eso, las Orígenes con niveles de privilegio más altos tienen Períodos de Preparación significativamente más largos.\\n\\n2. Debe haber espacio para la decisión. Cada pista tiene sus propios límites para la cantidad de referendos que se pueden decidir simultáneamente (max_deciding). Las pistas que tienen niveles de privilegio más altos tendrán límites más bajos. Por ejemplo, el origen de nivel Raíz tendrá una cantidad significativamente menor de referendos que se pueden decidir simultáneamente en comparación con los orígenes de nivel de privilegio más bajo, como el origen de Small Tipper.\\n\\n3. Se debe presentar el Depósito de Decisión. La creación inicial de un referéndum es bastante económica, y el valor del Depósito de Presentación (reservado cuando se crea inicialmente el referéndum) es bastante bajo, y está compuesto principalmente por el valor que cuesta el almacenamiento en cadena asociado con el referéndum. Los Depósitos de Decisión son significativamente más altos, lo cual es necesario para combatir el spam, y juegan en el juego económico que OpenGov trae, que veremos más adelante.\\n\\nUna vez que se hayan cumplido estos tres criterios anteriores, el referéndum pasará al Período de Decisión. Los votos sobre el referéndum luego se contarán para el resultado.\\n\\n### Período de Decisión\\n\\n*Para una demostración rápida en video del Período de Decisión, vea [este video](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nUna vez que un referéndum haya cumplido todos los criterios detallados en la sección anterior, entrará en el Período de Decisión.\\n\\nEl Período de Decisión gira en torno a dos conceptos principales, que son los criterios de Aprobación y Soporte. \\n\\nLa Aprobación se define como la proporción del peso del voto de aprobación (AYEs vs NAYs) en comparación con el peso total del voto (todos los votos AYE y NAY combinados). La convicción de cada voto cuenta para el peso total de los votos AYE/NAY (más sobre la votación por convicción / bloqueo voluntario en una sección posterior).\\n\\nEl Soporte es el número total de votos (tokens) que han participado en el referéndum (y no se ajusta por convicción) en comparación con el total de votos posibles que se pueden realizar en el sistema (piense en esto como la emisión total de XRT en la parachain - notablemente, el suministro circulante total de XRT no es el factor principal aquí, debido al hecho de que una parte de ese número existe en Ethereum como tokens ERC-20).\\n\\n**Los votos que están en la dirección de ABSTENCIÓN NO contribuyen a los criterios de Aprobación, pero se incluyen / cuentan hacia los criterios de Soporte**\\n\\nUn referéndum debe cumplir los criterios de Soporte y Aprobación durante el Período de Decisión para avanzar al Período de Confirmación.\\n\\nPara obtener detalles de los criterios de Soporte y Aprobación individuales para cada pista, consulte esta [hoja de cálculo](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Período de Confirmación\\n\\nCada pista tiene su propia duración específica para su Período de Confirmación. Las pistas que tienen niveles de privilegio más altos (como Root) tienen Períodos de Confirmación significativamente más largos que aquellos con niveles de privilegio más bajos (como Small Tipper).\\n\\nLos referendos deben seguir cumpliendo los criterios de Aprobación y Soporte durante toda la duración del Período de Confirmación, de lo contrario volverán al Período de Decisión (nota: el Período de Decisión no se pausa durante el Período de Confirmación, por lo que es completamente posible que un Período de Decisión expire durante el Período de Confirmación, lo que significa que si un referéndum es expulsado del Período de Confirmación debido a que ya no cumple los criterios de Aprobación y Soporte, entonces se considerará como un referéndum fallido y no promulgado).\\n\\n**Es posible ajustar los criterios de aprobación y soporte para pistas individuales a través de un referéndum con privilegios de Root Origin.**\\n\\nLos orígenes con niveles de privilegios más bajos tienen criterios de aprobación y soporte significativamente más fáciles de cumplir (establecidos por la pista) que aquellos con niveles de privilegios más altos. De manera similar, los orígenes con niveles de privilegios más altos tienen curvas menos pronunciadas que aquellos con menos privilegios (como se define en la pista), para garantizar que el poseedor del token DAO realmente apruebe el referéndum y evitar ataques de referéndum por referendos de origen con altos privilegios.\\n\\nEn OpenGov, los referendos que no se aprueban después de que expire el Período de Decisión se consideran rechazados por defecto, y tanto los depósitos de presentación como de decisión se reembolsan a sus originadores (nota: el depósito de decisión puede ser publicado por alguien que no sea el originador del referéndum) .\\n\\nSi un referéndum logra cumplir continuamente con los criterios de Aprobación y Respaldo durante todo el Período de Confirmación, entonces se considera aprobado y se programará su ejecución desde el origen propuesto, pero el referéndum solo se ejecutará después de que haya transcurrido el período mínimo de promulgación.\\n\\n### Período de promulgación\\n\\nEl período de promulgación lo especifica quien lo origina cuando se propone el referéndum, pero está sujeto al período mínimo de promulgación que se especifica en cada vía. Los Orígenes más poderosos tienen un período mínimo de promulgación mucho más alto que aquellos con menos privilegios. Esto asegura que la red tenga tiempo suficiente para prepararse para cualquier cambio que un poderoso referéndum pueda imponer.\\n\\n## Bloqueo voluntario / Condena\\n\\nRobonomics utiliza un concepto conocido como bloqueo voluntario o votación por convicción. Esto permite a los poseedores de tokens aumentar su poder de voto al decidir durante cuánto tiempo están dispuestos a guardar sus tokens para un referéndum en particular. Este mecanismo sólo afecta los criterios de Aprobación de cada referéndum, y la votación de convicción no afecta los criterios de Apoyo.\\n\\nLa votación por condena se puede calcular utilizando esta fórmula:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nEsta tabla muestra cómo cada nivel creciente de período de bloqueo multiplica su voto para los criterios de aprobación:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nLa cantidad máxima de convicción que puede utilizar un poseedor de tokens es 6 veces la convicción. Solo puede establecer la convicción según la tabla anterior y no puede, por ejemplo, utilizar una convicción de 5,5x.\\n\\nSi bien un token está bloqueado debido a la votación, aún se puede usar para votar en otros referendos; sin embargo, no formará parte de su saldo transferible (no puede enviarlo a otra cuenta) y el saldo solo volverá a ser transferible una vez. todo el período de bloqueo ha expirado.\\n\\n## Delegación de Voto\\n\\nEn OpenGov, se agregó un mecanismo para permitir que los poseedores de tokens que no necesariamente tienen tiempo suficiente para revisar cada referéndum puedan seguir usando sus tokens como parte del sistema de gobernanza, esto se conoce como delegación de voto.\\n\\nLos poseedores de tokens pueden optar por delegar su poder de voto a otro votante en el sistema (otra cuenta). Los votantes pueden especificar delegar su poder de voto de forma ágil, lo que les permite asignar su poder de voto a una cuenta diferente para cada Origen individual. Los votantes también pueden configurar la asignación de una cantidad diferente de poder de voto para cada Origen (número de tokens y nivel de convicción).\\n\\nEsta función de delegación tiene un objetivo: aumentar la participación de votantes y ayudar a garantizar que se cumplan los criterios de aprobación y apoyo necesarios.\\n\\nPara delegar su poder de voto, puede utilizar la función \\\"Delegar\\\" que puede encontrar en la sección Gobernanza -> Referéndum del [Portal de Robonomics](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). Alternativamente, los usuarios pueden enviar el extrínseco de votación de convicción (delegado) usando la sección Desarrollador -> Extrínsecos del Portal Robonomics; sin embargo, usar la función \\\"Delegar\\\" de la sección de referéndum del portal es mucho más fácil.\\n\\n## Cancelar/matar el referéndum y el juego económico de la gobernanza\\n\\nEn OpenGov, hay Origins que se dedican a rechazar referendos en curso, independientemente de su estado. Estos se conocen como las pistas Governance Canceller y Governance Killer.\\n\\nEstos Orígenes intervienen en un referéndum que ya ha sido votado. Estos Orígenes, si se aprueba el referéndum que se origina en ellos, rechazarán inmediatamente un referéndum en curso independientemente de su estado. \\n\\nLa cancelación en sí es un tipo de referéndum que los poseedores del token deben votar para poder ejecutarse. La cancelación viene con su propio origen y seguimiento, que tienen un tiempo de entrega más bajo (período de decisión, etc.) y tienen curvas de aprobación y soporte con una curva más pronunciada (lo que significa que sus criterios son mucho más fáciles de cumplir con el tiempo) que otros orígenes. Esto se debe al hecho de que la cancelación de un referéndum suele venir acompañada de un sentido de urgencia.\\n\\nGovernance Canceller tiene como objetivo rechazar instantáneamente un referéndum que ya está en curso. Cuando un referéndum es cancelado por este origen, tanto la Presentación como el Depósito de Decisión son reembolsados a sus originadores. Un ejemplo de cuándo se podría considerar cancelado un referéndum es si el autor ha cometido algún error humano en el contenido del referéndum y no necesariamente ha intentado hacer nada malicioso.\\n\\nGovernance Killer tiene como objetivo rechazar instantáneamente un referéndum que ya está en curso. Aquí es donde entra en juego el juego de la gobernanza económica. Los orígenes con altos niveles de privilegio, como Root, tienen un depósito de decisión que requiere la publicación de una gran cantidad de capital (tokens XRT) para que el referéndum entre en el período de decisión.\\n\\nSi un actor malintencionado presenta un referéndum, como un referéndum con orígenes de raíz que tiene como objetivo \\\"establecer código\\\" del tiempo de ejecución de las cadenas en algo que detendrá la producción de bloques de la cadena, entonces el poseedor del token DAO puede plantear un referéndum contrario a Governance Killer para castigar. esta acción. Si el referéndum malicioso es rechazado a través del origen Governance Killer, entonces tanto los depósitos de Presentación como de Decisión se reducen drásticamente, lo que significa que el originador (las cuentas que registraron estos depósitos) perderá esos fondos.\\n\\nEsto significa que existe una consecuencia económica grave para que actores malintencionados intenten convocar un referéndum, lo que tendría graves impactos negativos para la cadena, lo que en teoría impedirá que cualquier actor malintencionado intente hacerlo.\\n\\nEl depósito de decisión para la pista Governance Killer en sí es bastante alto, esto es para evitar que actores igualmente maliciosos intenten recortar los depósitos de referéndum que de otro modo sería bueno. **Un referendo existente sobre Governance Killer puede ser anulado por un referéndum posterior sobre Governance Killer.**\\n\\n## Comité técnico de Robonomics y origen incluido en la lista blanca\\n\\nEste grupo es un organismo de expertos autónomo que tiene el objetivo principal de representar a los humanos que encarnan y poseen el conocimiento técnico del protocolo de red Robonomics.\\n\\nEste grupo (y sólo este grupo) puede generar referendos desde la paleta de la Lista blanca. Esta paleta hace una cosa: permite que un Origen escale el nivel de privilegio de otro Origen para una determinada operación. \\n\\nEste grupo puede autorizar referéndum desde un origen conocido como Whitelisted-Root, y estos referéndums se pueden ejecutar con privilegios de nivel raíz, pero estos referéndums solo funcionarán exitosamente con ciertos comandos específicos que hayan sido autorizados por el grupo. La paleta Whitelist verifica dos cosas:\\n1. El Origen realmente es la Raíz de la Lista Blanca (es decir, ese referéndum pasó por la pista de este Origen).\\n2. De hecho, la propuesta ha sido incluida en la lista blanca del grupo.\\n\\nSi ambas condiciones son verdaderas, la operación se ejecutará con privilegios de nivel raíz.\\n\\nEste sistema permite tener una nueva vía paralela (origen raíz en lista blanca), cuyos parámetros permiten un plazo de votación más corto (los criterios de aprobación y soporte son un poco más fáciles de cumplir que los de raíz). Este proceso abierto y transparente permite a este cuerpo de expertos del Protocolo de Red Robonomics proponer referendos que han determinado que son seguros y urgentes.\\n\\nCabe señalar que los criterios de apoyo para el referéndum iniciado con el origen de raíz en la lista blanca no tienden a 0 como muchos otros orígenes/pistas. Esto garantiza que este grupo no tenga control de facto sobre todo el protocolo de red Robonomics y requiere un nivel mínimo de apoyo (participación de votantes) por parte del titular general del token DAO.\\n\\n\\n## Duraciones del referéndum\\n\\nEs importante entender que la duración de cada referéndum individual no es algo concreto, no está escrita en piedra. Sin embargo, algunos períodos dentro del ciclo de vida del referéndum, como el período mínimo de promulgación, sí tienen una duración concreta; otros, incluido el período de decisión, no la tienen. Por ejemplo, no es exacto sumar las duraciones máximas de Preparación, Decisión, Confirmación y Min. Períodos de promulgación y afirman que \\\"cada referéndum tomará X días\\\", es mucho más fluido que eso.\\n\\nMiremos esto a través del lente de algunos referendos separados, todos los cuales se originan en el mismo Origen, en este caso, el Origen Raíz.\\n\\nEl Origen Raíz tiene su propio track, donde se fijan las duraciones de cada periodo, así como las curvas de Aprobación y Soporte.\\n\\nEs importante recordar que los referendos sólo pasarán a la siguiente etapa de su ciclo de vida si se cumplen ciertas condiciones.\\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nDebe asumir en las siguientes imágenes que, para que un referéndum pase a la siguiente etapa de su ciclo de vida, se tendrían que haber cumplido las condiciones descritas en la imagen de arriba (a menos que se indique lo contrario).\\n\\n\\n### Máxima duración posible con muy poca participación electoral\\n\\nLa siguiente imagen es una representación del cronograma máximo posible para un referéndum. Piense en esto como un referéndum que:\\n1. Ha publicado su Depósito de Decisión y, por lo tanto, ha entrado en el Período de Decisión.\\n2. Tiene un solo voto, por ejemplo, 1 XRT, en la dirección AYE; esto significará que solo cumplirá con el apoyo requerido (participación de votantes) al final del período de decisión (ya que el apoyo general es extremadamente bajo). , pero tiene un 100% de Aprobación, por lo que eventualmente cumplirá con los requisitos para ingresar al Período de Confirmación.\\n3. Continúe cumpliendo con los criterios antes mencionados durante el Período de Confirmación.\\n4. La propuesta planteada por el referéndum se promulgará exactamente en el mismo bloque cuando finalice el Período Mínimo de Promulgación; técnicamente, el iniciador del referéndum puede establecer los cambios en la red como se detalla en el referéndum para promulgar muchos bloques en el futuro, por lo que, de manera realista, la propuesta real El ciclo de vida de un referéndum individual podría abarcar muchos días, semanas, meses o años.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nPodemos ver que en este ejemplo, el ciclo de vida del referéndum sería (aproximadamente) 17 días.\\n\\n\\n### Duración con mucha participación electoral (con una gran cantidad de votos AYE)\\n\\nAhora echemos un vistazo a un referéndum en el que el poseedor del token XRT, DAO, ha expresado mucho interés. En este ejemplo, asumiremos que se han producido ~248,771 XRT en la participación electoral general, y que todos los votantes están votando en la dirección AYE (nota: técnicamente en esta etapa de un referéndum raíz, según el track, solo el 60% de los votos debe estar en la dirección AYE para que un referéndum cumpla con los criterios de aprobación).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Consulte siempre la información de pista más actualizada para obtener información precisa con respecto a cada pista; puede encontrar más información en esta [hoja de cálculo](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nEn este ejemplo:\\n1. El Depósito de Decisión se publicó durante el Período de Preparación y, por lo tanto, pudo pasar al Período de Decisión al final del Período de Preparación.\\n2. Muchos votantes votaron en este referéndum, obteniendo una participación electoral de ~248,771 XRT en un período de tiempo relativamente corto.\\n3. Los votos fueron mayoritarios en la dirección AYE (cualquier valor superior al 60% AYE).\\n4. El referéndum cumple continuamente con los criterios del Período de Confirmación durante todo su Período de Confirmación (Nota: si un referéndum deja de cumplir con los criterios del Período de Confirmación, entonces regresa a su Período de Decisión).\\n5. La propuesta planteada por el referéndum se promulgará exactamente en el mismo bloque en que finalice el Plazo Mínimo de Sanción.\\n\\nDebido al hecho de que hubo una participación de ~248,771 XRT, el referéndum cumplirá con los criterios para ingresar a su Período de Confirmación después de ~168 horas (7 días).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nPodemos ver que en este segundo ejemplo, debido al hecho de que hubo una buena cantidad de participación electoral, el Período de Decisión en realidad terminó a la mitad de su tiempo máximo asignado. Resultando en un referéndum que puede promulgarse en ~10 días.\\n\\n\\n### Duración en la que el depósito de decisión nunca se publica\\n\\nAhora, echemos un vistazo a un referéndum que se originó, pero nunca se publicó su depósito de decisión. Dichos referendos se encuentran en una especie de estado de \\\"limbo\\\", donde su Período de Preparación ha finalizado, pero como el Depósito de Decisión no fue publicado, el referéndum permanece en el \\\"Estado de Preparación\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nPodemos ver que en este tercer ejemplo, debido al hecho de que el Depósito de Decisión nunca se publicó, el referéndum en realidad nunca entrará en el Período de Decisión, sino que permanecerá en el \\\"Estado de Preparación\\\". Esto significa que eventualmente, si nunca se publica un Depósito de Decisión, el referéndum expirará después de que haya transcurrido la duración especificada en la constante timeOut de la paleta.\\n\\nEsto sucedió anteriormente en Kusama, donde se publicó un referéndum con orígenes de Root, pero debido a los altos requisitos de capital para publicar el Depósito de Decisión, el referéndum nunca entró en las últimas etapas de su ciclo de vida. Dicho referéndum concluye con la bandera de \\\"tiempo agotado\\\".\\n\\n\\n### Duración cuando el depósito de decisión se publica tarde\\n\\nFinalmente, echemos un vistazo a un ejemplo en el que el depósito de decisión no se publicó durante bastante tiempo después de que se originó el referéndum. Esto sucedió anteriormente en Kusama, donde se publicó un referéndum con el origen Root, pero el creador tuvo que dedicar tiempo a encontrar a alguien con una gran cantidad de capital para publicar el Depósito de Decisión en su nombre.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nEn este último ejemplo, debido al hecho de que el Depósito de Decisión se publicó después de que finalizó el Período de Preparación, pero antes de que expirara el tiempo del referéndum, el ciclo de vida del referéndum es en realidad mucho más largo de lo normal, ya que entra en el Período de Decisión después una cantidad de tiempo más larga.\\n\\nEs importante tener en cuenta que el poseedor del token DAO puede votar SÍ/NO en referendos que se encuentran en el Período de Preparación o estancados en el \\\"Estado de Preparación\\\".\\n\"}},{\"node\":{\"id\":\"31fad1aef6ff858366cf129d47bdabfc\",\"title\":\"Configuración de integración de Robonomics\",\"path\":\"/docs/es/robonomics-hass-integration/\",\"content\":\"\\n**En este artículo, agregarás Robonomics a Home Assistant. Esto permite que Home Assistant registre registros de datos con datos cifrados en Robonomics Parachain y escuche comandos de lanzamiento desde el parachain para controlar dispositivos inteligentes. La integración utiliza IPFS para almacenar datos y enviar hashes de IPFS a funciones de registro de datos o lanzamiento.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. En la interfaz web de Home Assistant, ve a `Settings` -> `Device & Services` y presiona `ADD INTEGRATION`. Busca `Robonomics`.\\n\\n2. Haz clic en Robonomics y completa la configuración: \\n\\n- Agrega la semilla de la cuenta `SUB_CONTROLLER` a la semilla de la cuenta del controlador.\\n- Agrega la dirección pública de la cuenta `SUB_OWNER` a la dirección del propietario de la suscripción.\\n- Establece el intervalo de envío de datos (por defecto es de 10 minutos).\\n- (Opcional) Puedes agregar credenciales para el servicio de anclaje Pinata u otro gateway personalizado para difundir tus datos de manera más amplia en la red IPFS.\\n\\n3. Presiona `SUBMIT` después de terminar la configuración. Si completaste todo correctamente, verás la ventana de éxito.\\n\\n¡Eso es todo! Has configurado completamente la integración de Robonomics en Home Assistant. Ahora puedes usar todos los \\nServicios web de Robonomics. Para obtener más información sobre ellos, ve a la sección [\\\"Uso\\\"](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"ba422b67bf555bce485e41080bac20fa\",\"title\":\"Robonomics en Ethereum\",\"path\":\"/docs/es/robonomics-ethereum/\",\"content\":\"\\nToda la información sobre Robonomics en Ethereum se trasladó al repositorio de GitHub. Toda la información necesaria se puede encontrar [aquí.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"9ce33ff3f26ce642787fecec3d1e6c25\",\"title\":\"Interfaz de Python y Robonomics IO\",\"path\":\"/docs/es/rinterface/\",\"content\":\"\\n**Algunas extrínsecas implementadas en los palets de Robonomics son difíciles de enviar desde la aplicación Polkadot. Además de eso, hay \\nuna necesidad de interactuar con esta funcionalidad utilizando lenguajes de programación. Con este propósito se desarrolló una herramienta simple de Python\\nllamado [interfaz-robonomics](https://github.com/Multi-Agent-io/robonomics-interface). Es una envoltura sobre mantenida por polkascan.\\n[interfaz-substrato-py](https://github.com/polkascan/py-substrate-interface).A continuación se muestra una breve descripción de este paquete\\ny algunos enlaces y ejemplos útiles. También se discuten las herramientas de línea de comandos.\\n\\n## robonomics-interface\\n\\nDisponible en [PyPi](https://pypi.org/project/robonomics-interface/) el paquete está listo para descargar e instalar.\\nTambién hay disponible una [documentación](https://multi-agent-io.github.io/robonomics-interface/) detallada generada por docstring.\\n\\nEn resumen, esta es una herramienta para desarrolladores que desean interactuar con la cadena de bloques de Robonomics a través de herramientas de programación. Casi \\ntodos los proyectos de Python del equipo de Robonomics que interactúan con la parachain utilizan esta interfaz.\\n\\n### Instalación\\n\\nEl proceso de instalación requiere que el usuario tenga al menos Python 3.8 instalado. Ni `x86`, ni `arm7`, ni `arm8`\\narquitecturas requieren un proceso de compilación. Todas las ruedas son construidas y publicadas por los mantenedores de las dependencias.\\n\\n`pip` se utiliza como herramienta de instalación:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Uso de ejemplo\\n\\nLa idea principal es crear una instancia de `Account` y luego usarla para crear instancias dedicadas a los palets.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  También es posible utilizar puntos finales personalizados (por ejemplo, un nodo local para pruebas):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nTambién es posible enviar extrínsecas:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Como se ha dicho, hay más ejemplos disponibles en la página de [documentación](https://multi-agent-io.github.io/robonomics-interface/).\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` también contiene herramientas de línea de comandos de Python `click` para usar con fines de prototipado y pruebas rápidas. Se instala\\ncon el paquete y está disponible en la Terminal:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nPuedes intentar usarlo con un nodo local. Se adopta la filosofía de canalización.\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"8418d270c41161bcdfe8a77ed20a76ac\",\"title\":\"Control de cámara PTZ en Home Assistant\",\"path\":\"/docs/es/ptz-camera/\",\"content\":\"\\nEste artículo cubre un proceso de configuración de una cámara PTZ en Home Assistant. \\nSe utilizará el protocolo ONVIF. Esto requiere una cuenta de cámara local.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nEl proceso de configuración de la cuenta de cámara local no se cubre en este artículo.\\n</robo-wiki-note>\\n\\nRequisitos:\\n- Cámara PTZ\\n- Cuenta de cámara local\\n- Dirección IP de la cámara\\n- Home Assistant configurado\\n\\n## Integración ONVIF\\n\\nComencemos con la instalación de la integración de **ONVIF**. \\n\\nVe a \\\"Devices & Services\\\" en \\\"Settings\\\" y presiona el botón \\\"ADD INTEGRATION\\\".\\nEscribe \\\"ONVIF\\\" y elige la integración. Verás la siguiente ventana.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nPresiona el botón \\\"Submit\\\". Intentará buscar automáticamente tu cámara. Si tiene éxito, \\nelige tu cámara de la lista y completa los campos vacíos. \\nDe lo contrario, tendrás que completar todos los campos manualmente. Verás la siguiente ventana.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nCompleta los espacios en blanco:\\n- Name - asigna un nombre a tu cámara\\n- Host - proporciona la dirección IP de tu cámara\\n- Port - generalmente es común que sea 2020, pero tu proveedor de cámaras puede cambiarlo\\n- Username - escribe el nombre de usuario de tu cuenta local de la cámara\\n  - Password - escribe una contraseña para tu cuenta local de la cámara\\n\\ny presiona \\\"Submit\\\". Elige un área para tu cámara y haz clic en \\\"Finish\\\".\\n\\n## Agrega el control de la cámara al panel de control\\n\\nAhora que has configurado completamente la cámara, puedes agregar su transmisión y botones de control al panel de control.\\n\\nVe al panel de control y comienza creando una nueva tarjeta. Elige la opción \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nCompleta los datos:\\n- Title - elige el título de la imagen de la cámara\\n- Camera Entity - elige una entidad de cámara de la lista desplegable\\n- Camera View - elige \\\"live\\\" para obtener menos retraso\\n\\nA continuación, cambia al modo \\\"Code Editor\\\" presionando el botón en la parte inferior izquierda. Verás el siguiente código:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nReemplaza el contenido de `entities: []` según el ejemplo a continuación (`<TU_ENTIDAD_DE_CÁMARA>` es lo mismo que el parámetro `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nEso es todo. Ahora deberías ver la tarjeta de la cámara PTZ en el panel de control junto con los botones de control..\\n\\n## Solución de problemas\\nSi estás utilizando Home Assistant Core y no ves una transmisión de la cámara, debes instalar las integraciones \\\"stream\\\" y \\\"FFMPEG\\\". \\nPara hacer esto, debes agregar las cadenas `stream: ` y `ffmpeg: ` al final de configuration.yaml.\"}},{\"node\":{\"id\":\"c2c8d15f0eef8718b93e7e06e589d116\",\"title\":\"Responsabilidad\",\"path\":\"/docs/es/liability/\",\"content\":\"\\n**Para convertir a los robots en agentes económicos se necesita una herramienta de contrato para esto. ¡Conozca Responsabilidad - Robonomics pallet que implementa contratos entre cuentas de parachain!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Por favor, preste atención a que este tutorial se muestra en una instancia local de Robonomics Node. Configure la suya con [estas instrucciones](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Resumen de la teoría\\n\\nEn Ethereum había una estructura bastante complicada de interacción de responsabilidad. Puede familiarizarse con ella [aquí](/docs/robonomics-how-it-works). ¡Hoy en día las cosas son un poco más fáciles con Kusama!\\n\\n### Negociaciones\\n\\nPara firmar un contrato, las dos partes primero deben negociar. Esto se puede hacer de varias maneras, incluido [IPFS PubSub](https://blog.ipfs.tech/25-pubsub/) o Robonomics PubSub. Un ejemplo de código Python usando Robonomics PubSub es presentado [aquí](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub).\\n\\nOferta y demanda son mensajes que contienen dos características principales de un contrato: **descripción del trabajo** y **precio**. El formato del mensaje debe ser diseñado por el usuario para cada aplicación específica. No es tan importante en el proceso de negociación seguir una regla de formato estricta. El flujo posible se presenta en la imagen a continuación.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Tenga en cuenta que PubSub es un protocolo abierto, por lo que no se deben transferir datos sensibles. Para esto, debe utilizar otros protocolos.\\n\\n</robo-wiki-note>\\n\\n\\n### Firmas\\n\\nCuando las negociaciones finalizan con éxito, cada parte debe firmar el llamado acuerdo denominado firma. Este es un mensaje que contiene la descripción del trabajo y el precio **en un formato específico** firmado con una clave privada de la cuenta.\\nTambién existe una [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability) para eso.\\n - La descripción del trabajo se llama **técnicas**. Es una cadena de 32 bytes de longitud similar a un lanzamiento que puede ser un CID de IPFS codificado.\\n - El precio se llama **economía**. Es un decimal XRT - Weiner. 1 Weiner = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Se puede obtener un CID de [IPFS](https://ipfs.tech/) formateado de manera adecuada con la [biblioteca de Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  Cuando se utiliza la función `sign_liability`, no es necesario transformar el hash, se hará automáticamente.\\n\\n</robo-wiki-note>\\n\\nSiguiendo el ejemplo del café:\\n\\n1. La tarea es un JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Su CID de IPFS es `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Por lo tanto, las **técnicas** (CID transformado) son `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **Economía** es `1.5 XRT`.\\n\\nCuando esté firmado, ¡es hora de crear una responsabilidad! Esto puede ser hecho por una de las partes (ya sea el prometido o el promisor) o por una cuenta de terceros de un proveedor llamado.\\n\\n## Crear responsabilidad\\n\\n### Preparativos\\n\\nComo se mencionó anteriormente, al menos dos partes están involucradas en el proceso. Para este ejemplo, usemos tres y hagamos un proveedor separado para esto. Supongamos que las negociaciones ya tuvieron lugar de alguna manera.\\n\\n### 1. Cree tres cuentas y añada fondos a ellas\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nAquí hemos suministrado al proveedor con 100 XRT para firmar extrínsecos de responsabilidad, al prometido se le dieron 2 XRT para pagar por el trabajo.\\nAl promisor no se le concedieron fondos (excepto por un depósito existencial de al menos 1 mXRT).\\n\\n### 1. Navega a Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Elija liability -> create en la lista desplegable de extrínsecos posibles\\n\\nTambién elija una cuenta con la que desee enviar el extrínseco. Rellene todos los parámetros.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Firmas\\\">\\n\\n  Dado que aquí se utiliza un proveedor, no es necesario conocer las semillas de los participantes. Solo se necesitan sus firmas.\\n\\n</robo-wiki-note>\\n\\n### 3. Envía la transacción\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Revise su responsabilidad en los eventos\\n\\nPara esto, vaya a `Network -> Explorer` y encuentre una lista de eventos a la derecha. Haga clic en un icono de triángulo para expandir.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  El hash se puede transformar en un CID IPFS con la misma [herramienta Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Exploración de almacenamiento\\n\\nTambién puede explorar algunas características de las responsabilidades en el módulo de almacenamiento `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  La función de almacenamiento `Next Index` muestra el último índice de responsabilidad +1, por lo que aunque sea `1`, se explora la responsabilidad `0`.\\n\\n</robo-wiki-note>\\n\\n## Informes\\n\\nImagínese que se ha hecho un café y ahora la máquina de café necesita informarlo de alguna manera. Ahí es donde entran en escena los informes de responsabilidad. Como prueba de trabajo, la cuenta agrega otro CID de IPFS como contenido del informe al finalizar la responsabilidad existente. Esto nuevamente requiere una firma del promisor.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  El mensaje firmado contiene el índice de responsabilidad existente y el CID IPFS del informe codificado en una representación de 32 bytes. Una vez más, la [herramienta de Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) puede ayudar a firmar el informe.\\n\\n</robo-wiki-note>\\n\\nSiguiendo con el ejemplo de la máquina de café:\\n\\n1. El informe es un JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Su CID IPFS es `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. Entonces la **carga útil** (CID transformado) es `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2`\\n4. **Índice** es `0`, es el índice de responsabilidad existente.\\n\\n### 1. Navega a extrinsics, liability -> finalize(report)\\n\\nComplete los parámetros y envíe extrínseco. Nuevamente, esto se puede hacer mediante una cuenta de terceros. \\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Presta atención a que la cuenta del promisor no debe estar \\\"muerta\\\" - debe tener el depósito existencial de al menos 1 mXRT.\\n\\n</robo-wiki-note>\\n\\nFirma y envía el informe. Cuando hayas terminado, puedes explorarlo en los eventos.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Explora los informes\\n\\nTambién puedes observar el informe en el almacenamiento. Ve a `Developer -> Storage` y elige `liability` de la lista desplegable.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Verifica los saldos\\n\\nEn la imagen se muestra que ahora el promisor ha recibido el \\\"salario\\\". ¡La relación económica ha ocurrido!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  Por ahora no hay forma de verificar que el trabajo esté hecho, así que tan pronto como el promisor informe, los tokens se transfieren a su cuenta. \\n  La función de verificación se agregará en el futuro.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"7f0a4e45d1be83b16f9e92a94fa1edf8\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/es/notifications/\",\"content\":\"\\nPuedes recibir notificaciones en tu smartphone con [notify](https://notify.events/). Primero regístrate allí y en el `Control Panel` crea un nuevo canal:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nAgrega un título y presiona `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nLuego presiona `Add Source` y elige `Home Assistant` en la pestaña `IoT y Smart Home`:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nEscribe un título y presiona `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nAllí verás el token que necesitas agregar a tu archivo de configuración para Home Assistant. Guárdalo en algún lugar y presiona `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nluego presiona `Subscribe` para agregar suscriptores:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nElige el suscriptor que desees y sigue las instrucciones.\\n\\nAhora necesitas editar la configuración en tu computadora con Home Assistant. Bajo el usuario `homeassistant`, abre el archivo `configuration.yaml`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nY agrega estas líneas:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nTambién agrega una nueva automatización después de la línea `automation:`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nEsta automatización enviará el mensaje `Door was changed to on/off` después de que el sensor con ID de entidad `binary_sensor.contact_sensor_contact` cambie de estado de `apagado` a `encendido`.\\n\\nY reinicia Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"af58e043a18ba399c88af35062b5636f\",\"title\":\"Lanzamiento\",\"path\":\"/docs/es/launch/\",\"content\":\"\\n**Otra característica básica de la parachain de Robonomics es el palet de Lanzamiento. Te permite enviar comandos a las cuentas/cualquier entidad detrás de ellas. Estos comandos incluyen parámetros para especificar la tarea a ejecutar.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Por favor, presta atención a que estos tutoriales se demuestran en una instancia local de Robonomics Node. Configura la tuya con [estas instrucciones](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navegue hasta Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Elige launch -> launch de la lista desplegable de posibles extrínsecos\\n\\nTambién elige una cuenta con la que quieras enviar el extrínseco. Rellena el campo de dirección objetivo y el campo de parámetros.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Launch admite cadenas de 32 bytes de largo como comandos ([fuente](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)),\\n  así que aquí hay espacio para improvisar:\\n  - Para comandos básicos como alternar, puede usar \\\"0x000000000000000000000000000000000000000000000000000000000000001\\\" o\\n  \\\"0x00000000000000000000000000000000000000000000000000000000000000000\\\".\\n  - Para comandos avanzados, incluidos los de tipo json, puede utilizar [IPFS](https://ipfs.tech/) CID formateado en un\\n  [forma correcta](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Enviar transacción\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Revisa tu lanzamiento en los eventos\\n\\nPara esto, navega a *Network -> Explorer* y encuentra una lista de eventos a la derecha. Haz clic en un icono de triángulo para expandirlo.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"53af2021a80af17e9eceaf234cd60623\",\"title\":\"Cómo actualizar la versión del nodo Robonomics Collator\",\"path\":\"/docs/es/how-to-update-collator-node-version/\",\"content\":\"\\nSe recomienda haber leído los siguientes artículos antes de leer esta publicación: [\\\"Cómo construir un nodo Collator\\\"](/docs/how-to-build-collator-node) y [\\\"Cómo lanzar el Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nEste artículo contiene los comandos necesarios para actualizar un nodo Collator de Robonomics (ejecutándose en Ubuntu), y también proporciona un ejemplo posteriormente.\\n\\n## **Comandos necesarios**\\n\\n0. Antes de comenzar, se recomienda que haya iniciado sesión como `root`, si no es así, entonces recomendaría que utilice:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Detenga el servicio de Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Elimine la versión anterior de Robonomics (asegúrese de estar en el directorio correcto):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Obtenga la [última versión](https://github.com/airalab/robonomics/releases) de Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Extraiga el archivo:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Mueva el archivo:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nDebe mover este archivo al directorio correcto donde instaló el nodo Robonomics)\\n\\n</robo-wiki-note>\\n\\n6. Inicie Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nEjemplo para actualizar el nodo Collator a Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Cambiar la base de datos de la cadena de relevo Kusama sin establecer una ruta base**\\n\\nHay momentos en los que ciertos snapshots de la cadena de relevo Kusama causan errores en su nodo. Esto a menudo hace que su nodo deje de funcionar. Ejemplo de error causado por una base de datos corrupta de la cadena de relevo:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nPara solucionar este error, debe eliminar su base de datos existente de la cadena de relevo Kusama (probablemente RocksDb) y reemplazarla por otra base de datos como ParityDb. Ejecute los siguientes comandos:\\n\\n1. Encuentre el directorio del nodo Robonomics y verifique los archivos:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Confirme que ve el directorio polkadot y luego navegue hasta el directorio chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Elimine el directorio `ksmcc3`:\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Cree un nuevo directorio `ksmcc3`.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Ahora debe descargar un nuevo snapshot. Este ejemplo utiliza un snapshot de la cadena de relevo altamente podado, pero puede cambiarlo por cualquier snapshot que prefiera.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Mientras se descarga el snapshot, abra una nueva sesión y edite su archivo de servicio:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nModifique las líneas dentro del archivo de servicio que se refieren a la base de datos y la poda:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nUse `Ctrl + S` y luego `Ctrl + X` para guardar y salir del archivo de servicio.\\n\\n7. Ahora debe recargar su daemon.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. Para este momento, en su otra sesión, esperemos que se haya descargado la nueva base de datos, así que extraiga el archivo:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. Después de que se complete el desempaquetado, ejecute lo siguiente:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Ahora puede iniciar el servicio, monitorearlo en busca de errores y verificar que esté emparejado tanto en la cadena de relevo como en la parachain:\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"df82612684f2641c2f206a4dbfd2c5e7\",\"title\":\"Cómo lanzar el colador Robonomics\",\"path\":\"/docs/es/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  En el screencast y las capturas de pantalla de este artículo, utilizamos la versión 1.4.0 de Robonomics. Debes usar los mismos comandos, pero reemplazar la versión de Robonomics por la actual.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nActualmente, la red Robonomics es mantenida principalmente por los desarrolladores iniciales, pero cualquier persona puede apoyar el proyecto. Cada nodo completo adicional de la cadena de bloques ayuda a que sea más sostenible y tolerante a fallos. Los binarios del nodo Robonomics están disponibles en [release](https://github.com/airalab/robonomics/releases) o se pueden [compilar desde el código fuente](/docs/how-to-build-collator-node/).\\n\\n## ¿Qué es un collator?\\n\\nUn colador es parte de la paracadena Robonomics. Este tipo de nodo crea nuevos bloques para la cadena Robonomics.\\n\\n>Los collators mantienen las parachains recopilando transacciones de los usuarios y produciendo pruebas de transición de estado para los validadores de la Relay Chain. En otras palabras, los collators mantienen las parachains agregando transacciones de parachain en candidatos de bloques de parachain y produciendo pruebas de transición de estado para los validadores basadas en esos bloques.\\n\\nPuedes obtener más información sobre los coladores en la página wiki relacionada de [Polkadot](https://wiki.polkadot.network/docs/learn-collator).\\n\\nEn la parachain de Robonomics, cada clasificador obtiene recompensas de (**0.001598184 XRT**) por cada bloque que construye (las recompensas se producen cuando los bloques se sellan a la cadena).\\nAdemás, el colador que construye el bloque recibe **el 50% de las tarifas de transacción** contenidas en el bloque que crean.\\n\\n## Requisitos\\n\\nSe recomienda lanzar un colador utilizando los **requisitos de hardware estándar** para [validadores de Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ Compatible con x86-64.\\n+ Intel Ice Lake, o más nuevo (Xeon o serie Core); AMD Zen3, o más nuevo (EPYC o Ryzen).\\n+ 4 núcleos físicos a 3.4GHz.\\n+ Multihilo simultáneo desactivado (Hyper-Threading en Intel, SMT en AMD).\\n+ Almacenamiento: Un SSD NVMe de 1 TB (debe tener un tamaño razonable para manejar el crecimiento de la cadena de bloques).\\n+ Memoria: 32 GB DDR4 ECC.\\n\\n\\nEn este artículo utilizamos las siguientes especificaciones:\\n+ 4 vCPU\\n+ 700 GB de espacio NVMe para las bases de datos del colador. Se requiere la capacidad de ampliar este espacio en disco.\\n+ 8GB de RAM.\\n\\n\\n## Información importante\\n1. Utilizamos algunas variables en estas instrucciones y deberás reemplazar los valores por los tuyos en todos los comandos:\\n    + **%NODE_NAME%** es el nombre del nodo. Ejemplo: *mi-robonomics-kusama-collator*.\\n    + **%BASE_PATH%** es la ruta al volumen montado. Ejemplo: */mnt/HC_Volume_16056435/*.\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** es la dirección de la cuenta en el ecosistema de Polkadot en formato SS58. Ejemplo: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*.\\n\\n2. Ten en cuenta que debes incluir *--state-cache-size=0* en el lanzamiento del servicio del colador. Este parámetro es importante para la estabilidad del colador.\\nPuedes ver más información en el [issue](https://github.com/airalab/robonomics/issues/234) relacionado en GitHub.\\n\\n## Lanzar fácilmente un colador Robonomics por primera vez\\n\\nPuedes lanzar fácilmente un colador directamente desde la línea de comandos para verificar errores.\\nDespués de hacer esto, se recomienda encarecidamente lanzar el colador Robonomics como un servicio (siguiente paso).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Lanzar el colador Robonomics como un servicio\\n\\n1. Crea el usuario para el servicio con directorio de inicio.\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Descarga, extrae y mueve el binario de Robonomics al directorio */usr/local/bin/*. Debes reemplazar *$ROBONOMICS_VERSION* con la versión actual de Robonomics en los comandos de esta sección. Puedes encontrar la versión actual en la [página de lanzamientos del repositorio de Robonomics en GitHub](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Crea el archivo de servicio systemd llamado *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    Y agrega las siguientes líneas en el archivo de servicio:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Guarda este archivo, luego habilita y inicia el servicio:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nURL de telemetría: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nLos registros de los clasificadores se pueden monitorear con: `journalctl -u robonomics.service -f` \\n\\nUna vez que se inicia el clasificador Robonomics, comenzará a sincronizarse con Kusama Relay Chain, esto puede llevar una cantidad de tiempo considerable, dependiendo de la velocidad de su red y las especificaciones del sistema, por lo que recomendamos descargar una instantánea de Kusama.\\n\\n\\n## Acelerar el proceso de sincronización utilizando una instantánea de Kusama\\n\\nRecomendamos hacer esto inmediatamente después de haber creado e iniciado el servicio de Robonomics. Puedes encontrar más información sobre instantáneas e instrucciones de uso en la siguiente página: https://ksm-rocksdb.polkashots.io/\\n\\nInstrucciones:\\n\\n1. Detén el servicio de Robonomics y elimina el directorio actual de la base de datos de Kusama:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Descarga la instantánea actual y extráela:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    Puede eliminar el archivo descargado después de descomprimirlo correctamente:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Establece la propiedad correcta para la carpeta de la base de datos:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Inicia nuevamente el servicio de Robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Verifica los registros del servicio:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Solución de problemas\\n### Error: \\\"State Database error: Too many sibling blocks inserted\\\"\\nPara corregir este error, simplemente puede iniciar su clasificador en modo archivo:\\n\\n1) Primero, debes detener el servicio de Robonomics. \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Luego agregue el parámetro `--state-pruning=archive` a la parte de la parachain del archivo de servicio. Ejemplo del archivo de servicio editado:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Recargue la configuración del administrador de systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Elimine la base de datos existente de la parachain:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Inicie el servicio de robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    Después de eso, es necesario esperar la sincronización de la base de datos de la parachain.\\n\\n### Error: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nEste error está relacionado con los parámetros de virtualización. Es necesario utilizar el tipo \\\"host-model\\\" del procesador emulado. Puede configurarlo en el host de virtualización.\\n\\nPero, si encuentra este error en cualquier alojamiento, es necesario consultar al soporte técnico solo sobre este problema.\\n\"}},{\"node\":{\"id\":\"0d2d79e9cd354e38242b80de0e339be0\",\"title\":\"Cómo construir un nodo de collator desde el código fuente\",\"path\":\"/docs/es/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  En el screencast y las capturas de pantalla de este artículo, utilizamos la versión 1.4.0 de Robonomics. Debes usar los mismos comandos, pero reemplazar la versión de Robonomics por la actual.\\n</robo-wiki-note>\\n\\n## ¿Qué es un collator?\\n\\nCollator es parte de la parachain de Robonomics. Este tipo de nodo crea nuevos bloques para la cadena..\\n\\n>Los collators mantienen las parachains recopilando transacciones de los usuarios y produciendo pruebas de transición de estado para los validadores de la Relay Chain. En otras palabras, los collators mantienen las parachains agregando transacciones de parachain en candidatos de bloques de parachain y produciendo pruebas de transición de estado para los validadores basadas en esos bloques.\\n\\nPuedes obtener más información sobre collator en la página wiki relacionada de [Polkadot](https://wiki.polkadot.network/docs/learn-collator).\\n\\nEn Robonomics parachain, cada clasificador obtiene recompensas (**0.000380520 XRT**) por cada bloque que construye, si este bloque estaba sellado a la cadena.\\nAdemás, el clasificador obtiene **tarifas de transacción del 50 %** de este bloque.\\n\\n## Proceso de construcción\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nAsegúrate de tener Rust y el software de soporte instalados. El instalador de Rust te preguntará sobre las opciones de instalación actuales, debes elegir la opción `1) Continuar con la instalación (predeterminado)`.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Instalar Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nInstala la cadena de herramientas nocturna requerida y el objetivo wasm.\\nLos siguientes comandos son válidos para Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nTambién necesitarás instalar los siguientes paquetes:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nAhora puedes instalar el nodo de Robonomics desde la fuente de git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nDespués de este comando, el binario compilado de Robonomics estará en el directorio `~/.cargo/bin`.\\n\\nEl siguiente paso es cómo lanzar el nodo de collator. Puedes leer sobre ello en el artículo [\\\"Cómo lanzar el collator de Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"219f8a66cf04a51961acc28687065f5b\",\"title\":\"Actualiza tu Home Assistant OS\",\"path\":\"/docs/es/hass-os-upgrade/\",\"content\":\"\\n**Este artículo contiene instrucciones para actualizar tu Home Assistant OS existente con la integración de Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Instalar IPFS Add-on\\n\\n\\nLa integración de Robonomics almacena los datos utilizando un demonio IPFS local, por lo que primero debes instalarlo. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. Existe un [complemento IPFS para Home Assistant](https://github.com/airalab/ipfs-addon). Para instalarlo, ve a `Settings` -> `Add-ons` y presiona el botón `ADD-ON STORE` en la esquina inferior derecha.\\n\\n2. Presiona en los tres puntos de la esquina superior derecha y elige `Repositories`. Agrega allí el siguiente enlace:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Presiona el botón `ADD`.\\n\\n4. Cierra el administrador de repositorios y actualiza la página. Ahora al final de la página puedes ver el complemento IPFS Daemon.\\n\\n5. Abre el complemento y presiona ``INSTALL`. Después de la instalación, presiona `START`.\\n\\n## Instala HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) te permite instalar integraciones personalizadas.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Antes de comenzar, necesitas instalar un complemento para conectarte al dispositivo de Home Assistant con SSH. En la Tienda de Complementos busca `ssh`. Recomendamos instalar el complemento `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Si no encuentras el complemento SSH, intenta habilitar el Modo Avanzado en la configuración de tu perfil de usuario. Para hacer esto, haz clic en el icono de perfil en la esquina inferior izquierda y encuentra la opción de Modo Avanzado.\\n\\n</robo-wiki-note>\\n\\n2. Elige el complemento y presiona `INSTALL`. Después de que la instalación haya finalizado, ve a la pestaña `Configuración` y agrega una `password` o `authorized_keys`. No olvides guardar esta parte de la configuración.\\n\\n3. En la pestaña `Info`, presiona `START`. Si deseas ver el complemento en la barra lateral, no olvides habilitar `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Abre el complemento SSH y ejecuta el siguiente comando:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Reinicie Home Assistant (puede hacerlo en `Settings`->`System`). \\n\\n6. Ahora la Integración HACS estará disponible para agregar en el menú `Integrations`. Ve a Settings`->`Devices & Services`, presiona `Add Integration` y busca HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Para usar HACS necesitas una cuenta de Github.\\n\\n</robo-wiki-note>\\n\\n7. Haz clic en él y sigue las instrucciones de instalación. \\n\\n## Instala la Integración de Robonomics\\n\\nAhora puedes instalar la Integración de Robonomics usando HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nAbre HACS desde el menú de la barra lateral y navega hasta `Integrations`. Haz clic en `Explore & Download Repositories`, luego busca `Robonomics` y haz clic en el botón `Download` ubicado en la esquina inferior derecha. Una vez que la descarga esté completa, reinicia Home Assistant.\"}},{\"node\":{\"id\":\"87f694358f53083c339a9e219ca57cb5\",\"title\":\"Inicialización de Home Assistant\",\"path\":\"/docs/es/hass-init/\",\"content\":\"\\n**Después de instalar Home Assistant, es necesario inicializarlo.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nEstás comenzando con la creación de la cuenta de propietario de Home Assistant. Esta cuenta es un administrador y puede realizar cualquier cambio. Abre un navegador web y ve a `http://%RASPBERRY_IP_ADDRESS%:8123`. Puedes encontrar la dirección IP de Raspberry Pi usando la [aplicación móvil Fing](https://www.fing.com/products) o la [herramienta de línea de comandos nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">La dirección de Raspberry Pi puede cambiar con el tiempo debido a la configuración del enrutador.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. En la primera página, ingresa un nombre, nombre de usuario, contraseña y haz clic en el botón `CREATE ACCOUNT`.\\n\\n2. En la siguiente pantalla, ingresa un nombre para tu hogar y configura tu ubicación y sistema de unidades. Haz clic en `DETECT` para encontrar tu ubicación y configurar tu zona horaria y sistema de unidades en función de esa ubicación. Si no deseas enviar tu ubicación, puedes configurar estos valores manualmente.\\n\\n3. Después de eso, Home Assistant mostrará todos los dispositivos que ha descubierto en tu red. No te preocupes si ves menos elementos de los que se muestran a continuación; siempre puedes agregar dispositivos manualmente más tarde. Por ahora, simplemente haz clic en `FINISH` y estarás en la pantalla principal de Home Assistant.\\n\\n4. Por último, verás la interfaz web de Home Assistant, que mostrará todos tus dispositivos. \\n\\n\\n## Solución de problemas\\n\\n1. Si olvidas tu inicio de sesión o contraseña para el usuario local, [consulta este artículo](https://www.home-assistant.io/docs/locked_out/) para restaurar tus credenciales.\\n\"}},{\"node\":{\"id\":\"cfadf8a989d43849a851534dd7ae4329\",\"title\":\"Imagen preinstalada para Raspberry Pi\",\"path\":\"/docs/es/hass-image-install/\",\"content\":\"\\n**Bienvenido a la guía de instalación de Home Assistant con integración de Robonomics en una Raspberry Pi. Home Assistant es un sistema de automatización del hogar de código abierto que proporciona un centro centralizado para controlar dispositivos inteligentes en su red doméstica. Al integrarse con Robonomics, un servicio en la nube descentralizado, puede mejorar la funcionalidad y seguridad de su hogar inteligente. En este artículo, proporcionaremos instrucciones paso a paso sobre cómo instalar Home Assistant con Robonomics en una Raspberry Pi, lo que le permitirá automatizar y controlar varios aspectos de su hogar utilizando una solución segura y descentralizada. ¡Comencemos!**\\n\\n## Hardware que necesitas para la instalación\\n\\nSi aún no has incorporado Home Assistant en tu configuración de hogar inteligente, es importante que conozcas el equipo que necesitarás para establecer un sistema completo de hogar inteligente desde cero.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Descarga la imagen preinstalada de Robonomics\\n\\nLa imagen preinstalada de Robonomics contiene:\\n- Home Assistant Core\\n- IPFS\\n- Broker y Integración MQTT\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nPuedes verificar el código fuente y descargar la última versión de la imagen en [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Configura la imagen\\n\\nInstala [Raspberry Pi Imager](https://www.raspberrypi.com/software/) en tu computadora. Luego, inserta la tarjeta SD.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nEjecute el programa Raspberry Pi Imager. Elija la imagen requerida como sistema operativo y asegúrese de seleccionar su tarjeta SD en el menú desplegable de almacenamiento.\\nEn la configuración:\\n- Establece un nombre de usuario y contraseña (guarda el nombre de usuario predeterminado \\\"pi\\\" para que sea fácil de recordar),  \\n- proporciona el nombre y la contraseña de tu Wi-Fi, \\n- elige tu país de la lista desplegable\\ny luego `Escribe` la imagen. \\n                   \\n<robo-wiki-note type=\\\"note\\\">Guarda el nombre de usuario y la contraseña cuidadosamente, ya que se necesitarán en caso de problemas.</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nPuedes encontrar códigos de país [aquí](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. Primer arranque\\n\\n**Expulsa de forma segura la tarjeta SD**, insértala en la Raspberry Pi. Luego **inserta el adaptador Zigbee** en la Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">¡Es importante insertar el adaptador Zigbee antes del primer inicio de la Raspberry Pi! \\nEs necesario para la autoconfiguración de la red Zigbee.</robo-wiki-note>\\n\\n**Si tienes el [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (que tiene todo el firmware necesario), simplemente puedes seguir estas instrucciones. Sin embargo, si tienes otro adaptador, lo primero que debes hacer es flashearlo con el software Zigbee2MQTT. Puedes encontrar instrucciones para tu dispositivo [aquí](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nA continuación, conecta el cable de alimentación a tu dispositivo. Debería conectarse a tu red Wi-Fi. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nUna vez que tu Raspberry Pi esté conectada, el LED rojo se encenderá y el LED verde parpadeará durante un tiempo. Espere hasta 5 minutos para que Raspberry Pi se inicie y se registre en la red.\\n\\nAhora encuentra la dirección IP de la Raspberry Pi. Puedes usar la aplicación móvil [Fing](https://www.fing.com/products) o \\nla herramienta de línea de comandos [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Encuentra el nombre `robots-home` (el nombre opcional podría ser `Home(homeassistant)`) \\nde la máquina host en la lista de direcciones IP. \\n\\nEn este ejemplo, la dirección es `192.168.43.56`. \\n\\nPara verificar que todo funciona, abre un navegador web e ingresa a la página web `http://%RASPBERRY_IP_ADDRESS%:8123`. En este ejemplo, será `192.168.43.56:8123`.\\nSi todo está bien, verás la interfaz web de Home Assistant. Si la página web no se abre, espera hasta 5 minutos para que la Raspberry Pi se inicie y vuelve a intentarlo. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Solución de problemas\\n\\n1. Para cambiar la configuración de Wi-Fi más tarde, debes iniciar sesión en tu Raspberry Pi a través del comando `ssh`. Para ello, abre la terminal en tu computadora\\ny escribe el comando `ssh` con tu nombre de usuario, que creaste en el paso \\\"Configuración de la imagen\\\" (el predeterminado es \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\ny luego usa el comando `sudo raspi-config`. Encuentra más información sobre este comando en [el sitio oficial.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"56ffd66909a229f35390d25b8bec2ad9\",\"title\":\"Actualiza tu Home Assistant Docker para sistemas operativos similares a Unix\",\"path\":\"/docs/es/hass-docker-upgrade/\",\"content\":\"\\n**Este artículo contiene instrucciones para actualizar tu Home Assistant Docker existente (en un sistema operativo similar a Unix) con la integración de Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Se asume que se utilizan las imágenes y el contenedor predeterminados de Docker de Home Assistant llamados <u>homeassistant</u>.\\n  2. IPFS se instalará y se ejecutará como un servicio <u>systemd</u> en la máquina host.\\n  3. Se asume que tienes instalado [Python3.9](https://www.python.org/downloads/) o una versión superior.\\n\\n</robo-wiki-note>\\n\\n## Instalar\\n\\nDescarga el script de instalación y ejecútalo en la terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nVerás la siguiente salida:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Es posible que veas un error como `mkdir: can't create directory 'custom_components': File exists`. Esto significa que ya tienes esta carpeta con algunos componentes personalizados instalados. Simplemente ignora este mensaje.\\n\\n</robo-wiki-note>\\n\\nReinicia el contenedor:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Verificar\\n\\nVerifica que el servicio de IPFS esté en funcionamiento:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVerás la siguiente salida:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"22fd6cd484f85005b29ca7cfb2b0055c\",\"title\":\"Actualiza tu Home Assistant Core\",\"path\":\"/docs/es/hass-core-upgrade/\",\"content\":\"\\n**Este artículo contiene instrucciones para actualizar tu Home Assistant Core existente con la integración de Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Se asume que la instalación de tu Home Assistant Core se completó de acuerdo con las [instrucciones oficiales](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) y que hay un usuario <u>homeassistant</u> y el entorno `venv`. Si no es el caso, sigue las instrucciones a continuación, **pero edita el script en consecuencia**.\\n  2. IPFS se instalará y se ejecutará como un servicio <u>systemd</u> en la máquina host.\\n  3. Se supone que tiene instalado [Python3.9](https://www.python.org/downloads/) o superior.\\n\\n</robo-wiki-note>\\n\\n## Instalar\\n\\nDescarga el script de instalación y ejecútalo en la terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nVerás la siguiente salida:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nDurante el proceso, se te pedirá que confirmes el reinicio de varios servicios. Navega con `tab` y selecciona la opción `yes`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Es posible que veas un error como `mkdir: can't create directory 'custom_components': File exists`. Esto significa que ya tienes esta carpeta con algunos componentes personalizados instalados. Simplemente ignora este mensaje.\\n\\n</robo-wiki-note>\\n  \\nDespués de terminar, reinicia tu Home Assistant.\\n\\n## Verificar\\n\\nVerifica que el servicio de IPFS esté en funcionamiento:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nVerás la siguiente salida:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"e390cc4cb37a25af354af247113244df\",\"title\":\"Glossary\",\"path\":\"/docs/es/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\nuna conjunción de un par de claves público-privadas, la parte pública de las cuales es la dirección pública del usuario, y la parte privada es la clave secreta para acceder al control de esta dirección.\\n\\n\\n### Auction (of Parachains)\\nmecanismo de arrendamiento de espacios para parachains en los ecosistemas de Polkadot y Kusama; un parachain debe ganar una subasta de velas para obtener un espacio.\\n\\n### Autonomous Agent\\nun sistema computacional que recibe datos sensoriales de su entorno y decide cómo responder a estímulos externos para lograr sus objetivos.\\n\\n### AIRA\\no Agente Robot Autónomo Inteligente — un software, desarrollado por el equipo de Robonomics en 2015, que implementa el estándar de interacción económica humano-máquina y máquina-máquina a través de un contrato de responsabilidad intelectual.\\n\\n\\n## B\\n\\n### Blockchain\\nen un sentido amplio, una red distribuida que utiliza criptografía para permitir que un grupo de participantes llegue a un consenso de confianza sobre el estado cambiante de un sistema.\\n\\n### Blockchain Explorarr\\nuna aplicación que permite explorar los diferentes bloques, transacciones y direcciones en una cadena de bloques (por ejemplo, Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\nuna lógica de automatización predefinida que se puede agregar fácilmente a una instancia de Home Assistant.\\n\\n### Bridge\\nuna tecnología y métodos mediante los cuales dos cadenas económicamente soberanas y tecnológicamente diversas pueden comunicarse entre sí. \\n\\n\\n## C\\n\\n### Coase (XRT)\\no Cs: una millonésima parte de un token XRT, 1 XRT = 1.000.000 Cs; lleva el nombre de Ronald Coase, un economista británico, uno de los fundadores de la economía institucional, ganador del Premio Nobel de Ciencias Económicas.\\n\\n### Collator\\nun nodo que mantiene un parachain recopilando transacciones de parachain y produciendo pruebas de transición de estado para los validadores.\\n\\n### Consensus\\nun proceso en el que los nodos de una red blockchain llegan a un acuerdo sobre el estado actual de los datos en la red (por ejemplo, prueba de trabajo, prueba de participación).\\n\\n### Crowdloan\\nuna campaña de financiamiento colectivo para recolectar tokens y hacer una oferta en la subasta de espacios en el ecosistema de Polkadot / Kusama.\\n\\n### Cybernetics\\nel estudio del control y la comunicación en el animal y la máquina, según la definición de N. Wiener.\\n\\n### Cyber-Physical System\\no CPS — una fuerte unificación e integración mutua de múltiples procesos computacionales, de redes y físicos.\\n\\n\\n## D\\n\\n### DAO\\nuna organización de propiedad colectiva y gobernada por una cadena de bloques, en la cual la gestión de recursos se lleva a cabo de acuerdo con un conjunto de reglas preacordadas y formalizadas, cuya aplicación se realiza automáticamente.\\n\\n### Datalog (Function)\\nuna función de parachain de Robonomics, que almacena datos de dispositivos en la cadena de bloques.\\n\\n### Dapp\\no aplicación descentralizada — una aplicación que se ejecuta como parte de una red distribuida y proporciona acceso a sus funciones de manera fácil de usar.\\n\\n### Decentralized Cloud\\nun servicio de computación en la nube basado en una red descentralizada de pares a pares a la que los usuarios pueden unirse para utilizar servicios o proporcionar sus recursos, como computación, redes, almacenamiento, etc.\\n\\n### Digital Twin\\nuna versión digital de un equipo real que copia sus características técnicas y datos históricos.\\n\\n\\n## E\\n\\n### Edge-system\\nun dispositivo de IoT que actúa como un enlace entre sistemas integrados accesibles localmente y la red global, generalmente compatible con protocolos de comunicación y transmisión de telemetría y señales de control.\\n\\n### Embedded System\\nun dispositivo de IoT con recursos limitados de computación y comunicación que proporciona funciones básicas (sensores, actuadores, botones) en el nivel más bajo, generalmente sin interfaces de usuario.\\n\\n### Ethereum\\nun sistema de cadena de bloques descentralizado y de código abierto que funciona como plataforma para numerosas otras criptomonedas, así como para la ejecución de contratos inteligentes descentralizados.\\n\\n### Ethereum Upgrade\\nanteriormente conocido como Ethereum 2.0 o Eth2 — una actualización del protocolo Ethereum que debería hacer que la red sea más escalable, segura y sostenible; para estos fines, se propone cambiar el consenso a Prueba de Participación y agregar un mecanismo de fragmentación para aumentar la capacidad de la red.\\n\\n### Exodus\\nproceso de transferencia de tokens XRT de la red Ethereum a la parachain de Robonomics.\\n\\n### Extrinsic\\nuna función en la red de Polkadot y Kusama, que puede desencadenar transiciones de estado de la red desde fuera del estado.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\no Gk — una milésima parte de un token XRT, 1 XRT = 1 000 Gk; nombrado en honor a Víctor Glushkov, un matemático soviético, uno de los fundadores de la tecnología de la información y la cibernética en la Unión Soviética.\\n\\n\\n## H\\n\\n### Home Assistant\\no Hass, un software de sistema de control de código abierto, diseñado para ser un centro central para dispositivos inteligentes.\\n\\n### HRMP\\no Paso de mensajes enrutados por retransmisión horizontal: un mensaje seguro que pasa entre paracaídas, que almacena todos los mensajes en el almacenamiento de la cadena de retransmisión antes de enviarlos a paracaídas.\\n\\n### HMI\\no Interfaz Humano-Máquina — una interfaz de usuario o panel de control que conecta al usuario con una máquina, sistema o dispositivo.\\n\\n\\n## I\\n\\n### Industry 4.0\\no la Cuarta Revolución Industrial — la automatización continua de las prácticas tradicionales de fabricación e industriales, utilizando tecnología inteligente moderna.\\n\\n### IPFS\\no Sistema de Archivos Interplanetario — un software peer-to-peer para almacenar y compartir datos en un sistema de archivos distribuido.\\n\\n### IoT\\no Internet de las Cosas — una conexión a una red global de miles de millones de dispositivos, capaces de recopilar datos e integrados en el entorno.\\n\\n### IoT Gateway\\nun sistema periférico que recopila y transmite datos de dispositivos de IoT a la red y viceversa; a menudo, estos dispositivos son una versión más compleja del enrutador WiFi.\\n\\n### IoT Provider\\nun servicio externo que proporciona a los usuarios de IoT acceso remoto a datos y análisis, así como control de dispositivos inteligentes a través de Internet.\\n\\n### IoT Subscription\\nuna función de la parachain de Robonomics que permite utilizar todas las funciones de la parachain durante un cierto período sin cargo.\\n\\n\\n## K\\n\\n### KSM\\nun token nativo para la red de Kusama.\\n\\n### Kusama\\nla \\\"red canaria\\\" para Polkadot que consiste en una versión de lanzamiento temprano y no auditada del software de Polkadot.\\n\\n\\n## L\\n\\n### Lanzamiento (Function)\\nuna función de la parachain de Robonomics que inicia o detiene un dispositivo enviando un comando a través de la cadena de bloques.\\n\\n### Lease Period\\nuna cantidad de tiempo durante la cual una parachain puede conectarse a la Relay Chain.\\n\\n### Libp2p\\nuna biblioteca de código abierto para crear redes peer-to-peer encriptadas.\\n\\n### Lights-out Factory\\no Smart Factory - una fábrica completamente automatizada que no requiere presencia humana en el lugar.\\n\\n### Lighthouse\\nun contrato inteligente, en el concepto de economía de robots, que realiza una transacción cuando el Proveedor establece una coincidencia de mercado entre el Promisor y el Promisee.\\n\\n### Responsabilidad\\nun contrato inteligente, realizado por sistemas ciberfísicos entre sí o con humanos, para ejecutar una tarea a cambio de pago.\\n\\n### Responsabilidad Market\\nuna plataforma, en el concepto de economía de robots, encargada de emparejar ofertas y demandas entre los nodos del sistema.\\n\\n\\n## M\\n\\n### MQTT\\no Message Queuing Telemetry Transport - un protocolo de publicación-suscripción diseñado para redes de baja capacidad de ancho de banda, alta latencia e inestables para operar volúmenes altos de mensajes de dispositivos IoT.\\n\\n### MQTT Broker\\nun servicio que recibe todos los mensajes de los clientes MQTT y luego enruta los mensajes a los clientes suscritos correspondientes.\\n\\n\\n## N\\n\\n### NFT\\no Token no fungible - un token que no puede ser intercambiado e indistinguible de otros tokens que permiten la tokenización de elementos únicos y proporcionan propiedad exclusiva para esos tokens.\\n\\n### Node (of Robonomics)\\nun módulo de blockchain basado en Substrate o Ethereum con extensiones de Robonomics para conectarse a la Red de Robonomics.\\n\\n\\n## O\\n\\n### On-chain Governance\\nun proceso para determinar qué cambios en la red son permitidos, como modificaciones al código o movimiento de fondos, que existen en la propia red y pueden cambiarla directamente.\\n\\n\\n## P\\n\\n### Pallet\\nun módulo de Substrate escrito en Rust que incluye lógica o algoritmo específico para el tiempo de ejecución de la cadena de bloques basada en Substrate.\\n\\n### Parachain\\nuna estructura de datos personalizada y específica de la aplicación (generalmente, una blockchain) que está integrada en la Relay Chain y puede ser validada por los validadores.\\n\\n### Parathread\\nuna parachain sin una ranura que puede participar temporalmente (en una base de bloque por bloque con una tarifa) en la seguridad de la Relay Chain.\\n\\n### Polkadot\\nuna red heterogénea y multi-chain que permite la comunicación arbitraria entre blockchains de diferentes características bajo una seguridad compartida.\\n\\n### Polkadot/Substrate Portal\\nuna interfaz de usuario básica de Substrate para interactuar con una red de Polkadot, Kusama y otras redes de Substrate.\\n\\n### Proposal (on Polkadot / Kusama)\\nuna posible convocatoria de función que se votará en un referéndum de Polkadot, Kusama o parachains.\\n\\n### Proof-of-Work\\nun mecanismo de consenso en el cual, para llegar a un acuerdo, los participantes de la red deben realizar trabajo computacional.\\n\\n### Proof-of-Stake\\nun mecanismo de consenso en el cual, para llegar a un acuerdo, los participantes de la red deben apostar capital de la criptomoneda asociada que actúa como garantía.\\n\\n### Promisee\\nun nodo que realiza un pedido para la ejecución de una tarea en el concepto de economía de robots.\\n\\n### Promisor\\nun nodo que acepta ejecutar una tarea a cambio de un pago en el concepto de economía de robots.\\n\\n### Provider (Robonomics)\\nun nodo, en el concepto de economía robótica, que monitorea los mensajes del Mercado de Pasivo y casa una oferta y una demanda por una pequeña tarifa.\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\nComo parte de la gobernanza en cadena, votar si los usuarios de la red deben aceptar o no una propuesta. \\n\\n### Relay Chain\\nla cadena principal que coordina el consenso de Polkadot / Kusama y la comunicación entre parachains.\\n\\n### Robofirm\\nuna organización en la cual todo el ciclo de proceso de negocios está completamente automatizado y no requiere participación humana.\\n\\n### Rococo\\nla red de prueba para probar parachains en Kusama.\\n\\n### robonomics-interface\\nuna biblioteca de Python especializada en la interfaz con Robonomics para una programación conveniente.\\n\\n### Robonomics en Ethereum\\nuna versión de Robonomics Network que se ejecuta sobre Ethereum, lanzada en 2018.\\n\\n### Robot Economy\\nun sistema económico en el cual los dispositivos actúan como agentes independientes capaces de realizar actividades económicas clave anteriormente únicas para los humanos.\\n\\n### Robot-as-a-Service\\no RaaS - un modelo de negocio en el cual las empresas alquilan su equipo de robótica a clientes y usuarios para uso a corto o largo plazo.\\n\\n### ROS\\no Robot Operating System - un marco para el desarrollo de software de robots, que proporciona servicios diseñados para un clúster de computadoras heterogéneo como abstracción de hardware, control de dispositivos de bajo nivel, implementación de funcionalidad comúnmente utilizada, paso de mensajes entre procesos y gestión de paquetes.\\n\\n### ROS 2\\nuna versión actualizada y reconstruida de Robot Operating System con nuevas características, como soporte para sistemas multi-robot y sistemas integrados pequeños, e integración con tiempo real.\\n\\n### ROS 2 Middleware\\no RMW - un protocolo que proporciona características estándar de ROS 2 como descubrimiento, serialización y transporte; ROS 2 admite múltiples implementaciones de middleware que se pueden elegir según los requisitos del proyecto.\\n\\n### RWS\\no Robonomics Web Services - servicios de infraestructura descentralizados para robótica e IoT que permiten conectar dispositivos fácilmente e interactuar de forma segura con aplicaciones de usuario, servicios en la nube y otros dispositivos; también tiene su propio token llamado RWS, que proporciona una suscripción IoT de por vida en la parachain de Robonomics.\\n\\n### Ejecutartime\\nuna función de transición de estado de una blockchain que define un algoritmo válido para determinar el estado del siguiente bloque dado el estado anterior.\\n\\n\\n## S\\n\\n### Seed Phrase\\nuna clave privada legible por humanos creada como una secuencia de palabras aleatorias y necesaria para acceder a la dirección de la blockchain y sus tokens.\\n\\n### Shared Security\\nel modelo de seguridad de Polkadot / Kusama mediante el cual todas las cadenas están igualmente protegidas al colocar pruebas de la validez de los bloques de parachain en la Relay Chain de manera que un posible atacante tendría que atacar todo el sistema.\\n\\n### SLS Gateway\\nuna pasarela de IoT de código abierto para dispositivos Zigbee basada en el microcontrolador ESP32 desarrollado por Smart Logic System.\\n\\n### Slot (of Parachain)\\nun recurso escaso en el ecosistema de Polkadot / Kusama que permite que una parachain se conecte a la Relay Chain sin una tarifa por cada bloque.\\n\\n### Smart Leasing\\nuna variante del modelo de Robot-as-a-Service, en la cual se paga un alquiler no por tiempo, sino por operaciones específicas y su número.\\n\\n### Smart Contract\\nun programa o algoritmo almacenado en una blockchain que se ejecuta automáticamente cuando se cumplen condiciones predeterminadas.\\n\\n### SSH\\nor Secure Shell — a network protocol for operating network services securely over an unsecured network, that uses public-key cryptography to authenticate the remote computer. \\n\\n### Staking\\nparte del consenso de Prueba de Participación, un acto de vincular tokens al depositarlos como garantía para tener la oportunidad de producir un bloque válido y obtener una recompensa.\\n\\n### Substrate\\nun marco modular para construir blockchains como Polkadot y Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nun fondo de fondos recolectados a través de una parte de las recompensas de producción de bloques, tarifas de transacción, participación, etc., que se pueden gastar mediante una propuesta de gasto; si el Tesoro termina un período de gasto sin gastar todos sus fondos, sufre una quema de un porcentaje de los fondos.\\n\\n### Transaction Costs\\nel costo de recopilar y procesar información debido a la racionalidad limitada de los agentes económicos y la complejidad de los procesos.\\n\\n\\n## V\\n\\n### Validator\\nun nodo que asegura la Relay Chain mediante el apoyo de sus tokens, validando pruebas de los colaboradores en las parachains y votando en el consenso junto con otros validadores.\\n\\n\\n## W\\n\\n### Web3\\nuna idea para una nueva iteración de la Web que incorpora conceptos como la descentralización, tecnologías blockchain y economía basada en tokens.\\n\\n### Wiener (XRT)\\no Wn - una billonésima parte de un token XRT, 1 XRT = 1 000 000 000 Wn; nombrado en honor a Norbert Wiener, un matemático estadounidense, uno de los fundadores de la cibernética y la teoría de la inteligencia artificial.\\n\\n\\n## X\\n\\n### XCM\\no Cross-Consensus Message Format - un formato de mensajería entre diferentes sistemas blockchain en Polkadot / Kusama.\\n\\n\\n### XRT\\nun token nativo para la Red Robonomics, que existe de forma independiente en las redes Ethereum y Kusama.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nuna implementación de red superpuesta de un esquema de enrutamiento completamente cifrado de extremo a extremo para redes de malla.\\n\\n\\n## Z\\n\\n### Zigbee\\nun protocolo de comunicación inalámbrica, muy utilizado para conectar dispositivos inteligentes debido a su bajo consumo de energía, facilidad de uso y flexibilidad de configuración, y soporte de topología de red autoorganizada y autorrecuperable.\\n\\n### Zigbee Adapter\\nun dispositivo que transfiere datos entre la red Zigbee y otra red (por ejemplo, Wi-Fi) para controlar dispositivos Zigbee.\\n\\n### Zigbee2MQTT\\nun software que permite conectar Zigbee a redes MQTT traduciendo mensajes de una red a otra.\"}},{\"node\":{\"id\":\"45c592eaab45cdb592f9b7e8e3add9c8\",\"title\":\"Empezando\",\"path\":\"/docs/es/getting-started/\",\"content\":\"\\n## ¿Qué es Robonomics?\\n\\nLa plataforma Robonomics proporciona herramientas para trabajar con la red de economía de robots. Robonomics permite a los diseñadores de ciudades inteligentes y zonas de industria 4.0 construir confianza entre los servicios de robots autónomos, proporcionar acceso directo a los usuarios a través de dapp para ordenar productos de fábricas autónomas y servicios de redes de sensores urbanos. Esto, a su vez, nos permitirá implementar un sistema descentralizado que monitoree globalmente las actividades de los sistemas ciberfísicos.\\n\\nEl siguiente gráfico describe el lugar que ocupa Robonomics en el escenario:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nEncuentra más en [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Inicio rápido de la red Robonomics\\n**Para mayor comodidad de los recién llegados, los desarrolladores principales de Robonomics han creado una [curva de aprendizaje de 6 lecciones](/docs/wschool2021-intro/)!**\\n\\n¡Explorarás la arquitectura de IoT sin servidor! Robonomics Web Services (RWS) es el servicio infraestructural básico para Robótica e IoT sobre Polkadot && IPFS.\\n\\nLos graduados del curso pueden lanzar una cadena de relé local y controlar un dispositivo compatible con ROS a través de transacciones entre cadenas.\\n\\n**[Únete a Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) para conectarte con la comunidad y obtener soporte técnico.**\\n\\n### Beneficios para los graduados de Robonomics Academy\\n- Prácticas para los mejores estudiantes   Conviértete en miembro del equipo de Robonomics y contribuye al desarrollo del producto elegido.\\n- Comunidad activa y eventos regulares   Forma parte de la comunidad de estudiantes, discute tus casos de uso con expertos de la industria. ¡Únete y participa en hackathons!\\n- Certificado de finalización   Agrega un certificado por completar el curso de construcción de DAPPs para IoT a tu portafolio.\\n- Asistencia en la admisión a la Universidad ITMO. Ya seas licenciado o máster, recibirás asistencia en tu admisión a la universidad.\\n- Oportunidades de financiamiento y aceleración: 1)Solicita una subvención de apoyo Academia de hasta $50.000; 2)Participa en el programa de aceleración de constructores de Robonomics apoyado por Web3 Foundation; 3)Implementa tu DAPP independiente sobre Robonomics; 4)Monetízalo y recibe apoyo de marketing del equipo de Robonomics.\\n\\n\\n## Qué contiene la documentación\\n\\n### Soy un desarrollador de Dapp\\n\\n- [Robonomics-js en GitHub](https://github.com/airalab/robonomics-js) - SDK simple de Javascript para desarrolladores de dApp de la red Robonomics.\\n- [Plantilla de dApp](https://github.com/airalab/vue-dapp-robonomics-template) - utiliza Vue.js\\n- [Documentación Wiki](/docs/robonomics-js/)\\n\\n### Soy un ingeniero en robótica\\n\\nConsulta la sección de [casos](/docs/iot-sensors-connectivity/) y comienza a desarrollar con [ejemplos](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"12ea0a1c744be00937ea245737189a20\",\"title\":\"Administración Global\",\"path\":\"/docs/es/global-administration/\",\"content\":\"\\n**Este artículo te mostrará cómo configurar un nuevo usuario en tu Home Assistant.**\\n\\n## Añadir usuarios a la suscripción\\n\\nNo puedes utilizar cuentas creadas anteriormente porque `SUB_OWNER` y `SUB_CONTROLLER` proporcionan seguridad, y el primer usuario que creaste cuando iniciaste por primera vez Home Assistant no tiene una cuenta de Robonomics Parachain.\\n\\n1. Crea una cuenta en Robonomics parachain, como lo hiciste en el [artículo anterior](/docs/sub-activate/).\\n\\n2. Utilizando la cuenta `SUB_OWNER`, añade una nueva cuenta de usuario a la suscripción en la [dapp](https://dapp.robonomics.network/#/subscription/devices). Ahora debería haber tres direcciones en la lista de acceso: `SUB_OWNER`, `SUB_CONTROLLER` y `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Conceder acceso al usuario\\n\\n1. Ve al servicio de dapp llamado [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Elige la cuenta que acabas de crear en la barra lateral derecha (verifica que has elegido la cuenta deseada presionando el ícono de perfil).\\n\\n2. Ingresa la semilla `USER` en el campo requerido. Añade las direcciones `SUB_OWNER` y `SUB_CONTROLLER` en los campos de créditos de administrador. Si todo es correcto, verás el estado de verificación `VERIFIED`.\\n\\n3. Crea una contraseña para el nuevo usuario que acabas de registrar y luego confirma la transacción, que ahora no tendrá tarifa debido a la suscripción. Más tarde podrás restaurar la contraseña en la pestaña de Restaurar.\\n\\n4. Después del proceso de registro, inicia sesión en Home Assistant con la dirección de tu usuario como inicio de sesión y la contraseña recién creada.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nAhora puedes utilizar la dapp para controlar tu hogar a través de Robonomics, consulta el artículo [**\\\"Obtener Telemetría del Hogar Inteligente\\\"**](/docs/smart-home-telemetry/).\\n\\n## Solución de problemas\\n\\n1. Si olvida una contraseña para Home Assistant desde su cuenta de Robonomics, [consulte la Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nVe a la parte \\\"Your Home Assistant password\\\" y elige la pestaña \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"2e9901ec276b7c0607c24d7e58b6479a\",\"title\":\"Cómo comprar una suscripción\",\"path\":\"/docs/es/get-subscription/\",\"content\":\"\\n**Pagar comisiones por transacciones en blockchain es molesto. Imagina un dispositivo IoT que envía telemetría cada 5-10 minutos. Esto te hará pagar bastante durante el mes. Una de las características clave de Robonomics Network es RWS - Suscripción al Servicio Web de Robonomics. ¡Paga mensualmente y olvídate del costo de las transacciones! Para obtener información teórica, consulta [este](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) artículo.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Presta atención a que este tutorial demuestra cómo comprar una suscripción en la parachain de Robonomics Kusama. También puedes realizar todos los mismos pasos en tu [nodo local](/docs/run-dev-node).\\n\\n  Una cosa más antes de comenzar. Esta es una forma \\\"difícil\\\" de comprar una suscripción. Existe una forma convencional de hacerlo a través de [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Pujar en una subasta\\n\\nLas suscripciones en Robonomics se venden con un modelo de subasta. Para obtener una, debes pujar en una subasta y ganarla (no te preocupes, es rápido).\\n\\nEn `Developer/Chain state` puedes ver las subastas disponibles. \\nElige `rws` y `auctionQueue` y presiona el botón `+`, verás los IDs de las subastas disponibles:\\n\\n![queue](../images/rws/queue.png)\\n\\nPuedes ver información sobre cualquier suscripción con `rws` `auction` e ID de la subasta (el ID de la subasta en la imagen es 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nEn la información sobre la subasta puedes ver el campo `winner`, en este momento es `null`, lo que significa que nadie tiene esta suscripción y tú puedes obtenerla. Para eso, ve a `Developer/Extrinsic`, elige tu cuenta y `rws -> bid`. También establece el ID de la subasta (79) y la cantidad de unidades a pujar (más de 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nEnvía la transacción y verifica la información sobre la subasta con ID 79 (en `Chain state` elige `rws -> auction` e ID 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nAhora en el campo `winner` verás la dirección de tu cuenta, lo que significa que esta cuenta tiene la suscripción 79. Una subasta comienza con la primera puja y dura unos pocos bloques, por lo que si alguien puja más tokens que tú en los siguientes bloques, esa persona será la ganadora y se llevará la suscripción.\\n\\nAhora puedes agregar dispositivos. Los dispositivos son cuentas que pueden usar esta suscripción y enviar extrinsics sin cargo.\\nTo test it create a new account with no tokens and add it to devices. \\n\\nPara agregar dispositivos, elige `rws -> setDevices` en `Developer/Extrinsic`. Luego presiona el botón `Add Item` y elige la cuenta recién creada sin tokens:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nEnvía la transacción. Ahora puedes verificar la lista de dispositivos en `Chain state` con `rws -> devices`. Allí verás la dirección de tu cuenta sin tokens. Elige la cuenta que ha comprado la suscripción y presiona `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nAhora puedes intentar [enviar un lanzamiento](/docs/subscription-launch) extrinsic usando la suscripción.\"}},{\"node\":{\"id\":\"660ecba2847e6181e891dfd115884f16\",\"title\":\"Cómo editar Wiki\",\"path\":\"/docs/es/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki es de código abierto. Se aceptan correcciones: corregir errores, errores tipográficos, información confusa o desactualizada, traducción a cualquier idioma. Necesitarás una [GitHub](https://github.com/) cuenta.**\\n\\n\\n## Cómo editar\\n\\nSi necesitas editar los documentos de Robonomics Wiki, por favor, sigue estos pasos\\n\\nMake sure, you have [Node.js](https://nodejs.org/en/download/package-manager/) y [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) instalado.\\n\\n### 1. Clonar repositorio\\n\\nPrimero, necesitas clonar el repositorio de la wiki:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nVe al directorio del repositorio y ejecuta los siguientes comandos:\\n\\n`usando npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`usando yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Servir localmente (desarrollo, desarrollo-m1)\\n\\nLuego despliega el proyecto localmente: \\n\\n```\\ngridsome develop\\n```\\n\\n> Si tienes el error `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`, ejecuta el siguiente comando:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Hacer PR\\n\\n[Hacer pull request](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) a [repositorio de la wiki](https://github.com/airalab/robonomics-wiki)\\n\\n## Componentes\\n\\n### Asciinema\\nRobonomics Wiki tiene soporte para Asciinema. Para insertar Asciinema, por favor, sigue estas instrucciones:\\n* Importa el componente después del bloque frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* Inserta como párrafo separado `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, donde vid es el ID del asciicast específico\\n\\n> Puedes obtener el script del widget para un asciicast específico haciendo clic en el enlace “Embed” en la página del asciicast.\\n> Se verá así:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Documentación de Asciinema](https://asciinema.org/docs/embedding)\\n\\nEn el ejemplo anterior, vid es 14.\\n\\n### Código\\n\\nPuede agregar extras útiles a su código:\\n\\n`código con botón de copia`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\no `código con línea adicional`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Propiedades para code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nLos documentos en Robonomics Wiki contienen un bloque frontmatter. Debe estar en la parte superior del archivo Markdown y debe tener la forma de un YAML válido entre líneas de guiones triples. Entre las líneas de guiones triples, puedes establecer o editar las siguientes opciones:\\n\\n```YAML\\n---\\ntitle: How to contribute # Título de la página, no es necesario duplicarlo en el texto\\ncontributors: [positivecrash] # Principales colaboradores (quienes curan activamente esta página). Se requiere el nombre de usuario de GitHub, sin ningún símbolo adicional\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Instalaration\\n    # Herramientas que se utilizaron para probar la tecnología\\n---\\n```\\n\\n### Grid \\nAyuda a agregar un diseño de cuadrícula a los elementos:\\n\\n- Usa primero el componente de envoltura de cuadrícula: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- Y luego usa tantos componentes de elementos de cuadrícula como desees dentro del envoltorio:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Propiedades para robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Imágenes\\n\\n#### Cómo subir \\nSube la imagen en la carpeta `/docs/images/url-de-tu-doc`\\n* Si la imagen necesita ser localizada, insértalas todas en una carpeta\\n* Usa un apéndice de localización en el nombre de las imágenes si está localizado, por ejemplo, `image_en.jpg`\\n* Asegúrate de que tu imagen esté optimizada para la web y al mismo tiempo se vea bien\\n\\n#### Cómo insertar \\n\\nHay dos formas de insertar imágenes en tus documentos:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSe recomienda insertar imágenes con la etiqueta incorporada `<robo-wiki-picture>`, sin embargo, también puedes usar la forma estándar para archivos Markdown.\\n\\n</robo-wiki-note>\\n\\n`con subtítulo`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`o sin subtítulo` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`o imagen simple` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`o imagen simple con subtítulo`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`imagen con texto alternativo`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Propiedades para robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Notas y advertencias\\nPuedes agregar notas y darles tipos específicos:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`nota con título`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`nota con contenido`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`nota con título y contenido`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Propiedades para robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nPuedes agregar pestañas al documento:\\n\\n- Usa el componente de envoltura de pestañas: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- Y luego usa tantos componentes de elementos de pestañas como desees dentro del envoltorio:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`pestañas horizontales`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`pestañas verticales`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`elemento de pestaña con borde`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Propiedades para robo-wiki-tabs (envoltorio)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Propiedades para robo-wiki-tab (elemento)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Título con anclas\\nPuedes crear títulos personalizados con anclas y darles un valor específico\\n\\n`título con ancla`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\no\\n\\n`título sin ancla`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Propiedades para robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Videos\\n\\nHay dos formas de insertar videos en tus documentos:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nSe recomienda insertar videos con la etiqueta incorporada `<robo-wiki-video>`, sin embargo, también puedes usar la forma estándar para archivos Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nDebes especificar el formato del video\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Propiedades\\n\\n- Si agregas un archivo con un tamaño mayor a <span style=\\\"color:#af1c1c\\\">10MB</span>, please, upload it on server, not in repo.\\n\\n- Puedes usar cualquier propiedad para [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Formatos aceptables: mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nPuedes incrustar cualquier video de YouTube en el documento insertando el enlace de compartir como párrafo separado sin comillas ni etiquetas adicionales, por ejemplo: `https://youtu.be/kQaSwNYHJQ8`\\n\\nSin embargo, si necesitas una reproducción automática, debes usar un componente especial:\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Propiedades para robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Cómo editar la navegación de la barra lateral\\n\\nSi necesitas editar la navegación de la barra lateral de Robonomics Wiki, por favor, sigue estos pasos:\\n\\n* Editar archivo `/data/sidebar_docs.yaml`.\\n\\n* Decidir dónde colocar tu documento\\n\\n* Utilizar YAML válido para `/data/sidebar_docs.yaml` y confiar en la estructura de archivos existente\\n\\n* **NOTA IMPORTANTE:** si estás utilizando el mismo documento en diferentes secciones/subsecciones, por ejemplo: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Imagen preinstalada para Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nASEGÚRATE DE AGREGAR EL PARÁMETRO `topic` DE ESTA MANERA: \\n\\n(para que la navegación funcione correctamente)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## Cómo agregar navegación personalizada para documentos\\n\\n* Edite el archivo `/data/sidebar_docs.yaml`.\\n\\n* Busque el documento correcto y agregue los parámetros `prev` y `next` como este:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Si deseas eliminar completamente la navegación, agrega el parámetro `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Si deseas eliminar solo la navegación de `página anterior` o `página siguiente`, agrega el parámetro `withoutPrev` o `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\no\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"be4c0d5977a0e3ed65555c7edea3087c\",\"title\":\"Configuración e instalación de software de Gaka-Chu\",\"path\":\"/docs/es/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**En este artículo repasaremos algunos pasos de instalación y lanzamiento para configurar un robot pintor. Requisitos:**\\n- KUKA KR6 R900 sixx con KRC4 y un SmartPad;\\n- Intel NUC con [ROS melodic](http://wiki.ros.org/melodic/Instalaration/Ubuntu) instalado;\\n- Mesa, pintura, pincel, agua.\\n\\n## Instalación de software en KRC4\\nSe requiere la interfaz EKI tanto en KRC4 como en NUC. Se presenta información detallada sobre cómo configurarlo en KRC4 [aquí](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Lanzarlo en el controlador del robot.\\n\\n## Instalación de software en NUC\\nCrear un espacio de trabajo de catkin:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nDescargar paquetes de ROS. Todos los scripts se almacenan [aquí](https://github.com/airalab/robot_painter/tree/test_branch). Clonar el repositorio:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nEs posible que necesite algunos archivos de encabezado y bibliotecas para que todo funcione correctamente. Descárguelos:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nAgregar el comando de origen al archivo `.bashrc`:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nHasta ahora, debería poder lanzar los scripts. Si algo sale mal, intente algunas [soluciones](https://github.com/airalab/robot_painter/issues)\\n\\n## Rellenando constantes\\nEn primer lugar, el robot necesita conocer la ubicación y orientación del lienzo, así como la posición del bote de pintura. Todo esto se especifica en `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Echemos un vistazo.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nEstas son las constantes de la ecuación del plano que especifican la posición del lienzo en el espacio tridimensional. Se deben obtener durante un proceso de calibración que se describe a continuación. A continuación, viene la pintura.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nEstas son las coordenadas del bote de pintura. También se pueden especificar durante la calibración. El tamaño del lienzo se especifica en\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nVarias constantes importantes más se almacenan en `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nSus nombres lo dicen todo, así que complételos según la situación.\\n\\n## Calibrando Gaka-Chu\\nEl proceso de calibración en sí es bastante simple.\\n\\n1) Inicie la interfaz EKI en el KRC4:\\n\\nInicie sesión en el modo 'AUT', encienda los controladores y ejecute el script `eki_hw_interface`\\n\\n2) Inicie la interfaz EKI en el NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nDebería mostrar registros infinitos.\\n\\n3) Inicie RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nDebería ver lo siguiente:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nIntente mover el efector final y hacer clic en 'Planificar y ejecutar'. El robot debería moverse. En SmartPad, vaya a **Mostrar -> Posición actual** y observe las coordenadas del efector final. Coloque un lienzo horizontalmente en la base del robot. Conecte un pincel al soporte del pincel y muévalo cuidadosamente hasta que apenas toque el lienzo. En esta posición, guarde las coordenadas del efector final. Repita 12-15 veces. Además, guarde las coordenadas del centro del lienzo y del bote de pintura.\\nCuando tenga un conjunto de coordenadas, use [estos](https://github.com/nakata5321/Matlab_scripts_gaka-chu) scripts de Matlab para resolver las constantes y cuaternión faltantes. Péguelos. Reconstruya su espacio de trabajo con\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Probando la calibración de Gaka-Chu\\nUna vez calibrado, Gaka-Chu debe ser probado dibujando los bordes del lienzo. Para hacerlo, ejecute cada uno en una nueva terminal:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nDespués de esto, debería ver un contorno del lienzo en RViz:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nEn la terminal, presione \\\"S\\\" para realizar la prueba. El efector final del robot debería moverse justo encima de los bordes del lienzo y el pincel debería tocar suavemente el lienzo durante todo el movimiento. Si no es así, intente recalibrar. Si el modelo del lienzo está girado incorrectamente, puede girarlo cambiando el cuaternión en Matlab.\\n\\n## Haciendo arte\\nNecesitas 6 módulos básicos para que todo funcione:\\n- Interfaz EKI;\\n- MOVEit + RViz;\\n- Transmisión de marcos de entorno;\\n- Servicio de conversión de imágenes;\\n- Módulo de dibujo de trayectorias;\\n- Disparador de inicio.\\n\\nVamos a lanzarlos uno por uno.\\n\\n### Interfaz Eki\\nEn KRC4, inicie `eki_hw_interface`, en NUC en una nueva terminal haga:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz y MOVEit\\nNecesitas un planificador y una simulación. Lánzalos con\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Entorno\\nIndique al robot dónde se encuentra el bote de pintura y el lienzo. Tenga en cuenta que no es necesario lanzar el nodo `draw workspace`, el `tf_broadcaster` comparte el tamaño del lienzo. Simplemente no lo muestra en RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Procesador de imágenes\\nTodas las imágenes entrantes deben ser procesadas. Lanza el servicio.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nCuando recibe la llamada, procesa una imagen con un filtro HP y crea un archivo rosbag con trayectorias.\\n\\n### Dibujante de trayectorias\\nEl script principal aquí es el propio dibujante de trayectorias. Espera la imagen, llama al servicio TextConverter y dibuja la pintura.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Envía al robot una imagen para dibujar\\nEl robot escucha un tópico específico de ROS donde debes pasar la ruta a una imagen deseada. La imagen debe ser cuadrada (ancho igual a alto) y estar compuesta por líneas. Envía la ruta:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nDespués de eso, aparecen dos ventanas mostrando los contornos y las pistas. Ciérralas y observa a Gaka-Chu dibujando. Ten cuidado con la seguridad y siempre esté listo para presionar el botón de parada de emergencia.\\nCuando Gaka-Chu termina su arte, puedes enviar otra ruta de imagen y el pintor repite todo el proceso.\\n\"}},{\"node\":{\"id\":\"c53a8b64e574b08e488e9fcc668609b7\",\"title\":\"Conecta un dispositivo Amazon FreeRTOS a Robonomics mediante MQTT\",\"path\":\"/docs/es/freertos-mqtt/\",\"content\":\"\\nAquí está la demostración de cómo un microcontrolador que ejecuta [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) puede conectarse a la red Robonomics a través de MQTT. Por favor, consulta [este repositorio](http://github.com/khssnv/freertos_mqtt_robonomics_example) para obtener el código fuente del proyecto.\\n\\nUtilizamos [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) con la distribución FreeRTOS y la implementación MQTT proporcionada por [Espressif IoT Development Framework](https://github.com/espressif/esp-idf), mientras que Espressif es un proveedor del microcontrolador utilizado.\\n\\nTambién hay un sensor [PMS-3003](http://www.plantower.com/en/content/?107.html) con fines de demostración. El sensor mide la presencia de partículas en el aire y se puede utilizar para estimar la calidad del aire.\\n\\nLa calidad del aire no es el tema del artículo, puedes encontrar más información al respecto en el sitio web de la OMS: [Contaminación del aire ambiente (exterior)](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). El objetivo del sistema es publicar las mediciones del sensor en la red Robonomics de Airalab.\\n\\n## Configuración de hardware\\n\\nConectamos el PIN5 de TXD de PMS3003 a IO17 de ESP32 DevKitC para transferir las mediciones mediante UART.\\nAmbos dispositivos también requieren alimentación y tierra común.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Flujo de datos\\n\\nPara enviar las mediciones del sensor a la red Robonomics, nuestro objetivo a nivel de firmware es obtener los datos de un sensor mediante el protocolo de comunicación integrado que admite (UART en nuestro caso) y enviarlo a una instancia de AIRA mediante MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nEn nuestro ejemplo, utilizamos la implementación en la nube de AIRA disponible mediante una dirección IP pública y un nombre de dominio asignado.\\nEn la instancia de AIRA, configuramos el broker MQTT `mosquitto` y nos suscribimos al tema `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` para recibir mensajes de MQTT.\\n\\nLuego, pasamos los mensajes al escritor `robonomics io` mediante una tubería.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nAhora los datos están disponibles en la red Robonomics y podemos leerlos nuevamente con `robonomics io`.\\n\\n## Firmware\\n\\nUtilizamos la aplicación de ejemplo [ESP-MQTT con transporte TCP](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) como base.\\n\\nSolo modificamos `main/app_main.c` para la conexión UART al sensor, la sincronización horaria SNTP y la rutina periódica de publicación MQTT.\\n\\nSi estás intentando repetir el proyecto y es tu primer proyecto basado en ESP IDF, por favor, sigue primero la guía de programación de ESP-IDF de [Espressif](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) para familiarizarte con las operaciones del firmware, como la configuración, compilación y carga con la herramienta `idf.py`.\\n\\n### Configuración de Wi-Fi\\n\\nPara comunicarse con la instancia de AIRA implementada en la nube, nuestro microcontrolador requiere una conexión a Internet.\\nUtilizamos el Wi-Fi del ESP32 para ello.\\nEspressif proporciona utilidades para configurar el Wi-Fi incorporado.\\nEn nuestro ejemplo, utilizamos un entorno de desarrollo con Ubuntu 20.04 GNU/Linux.\\nPara configurar el Wi-Fi, vamos a la carpeta del proyecto y ejecutamos la herramienta de configuración del SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nLuego configuramos el SSID y la contraseña del punto de acceso Wi-Fi en la sección `Example Conectarion Configuración`.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### Configuración del punto final MQTT\\n\\nHay dos cosas que configurar para MQTT.\\nLa primera es la dirección del broker MQTT.\\nSe puede configurar con la herramienta de configuración del SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nEstablece la `URL del broker` en la sección `Example Configuración`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nLa segunda cosa es el tema MQTT.\\nLo configuramos en el firmware con el prefijo del nombre del proyecto seguido de la dirección MAC de nuestro ESP32.\\nEsto nos da `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` para nuestro microchip en particular.\\n\\n## De MQTT a Robonomics\\n\\nPrimero, comprobemos si recibimos datos por MQTT.\\nPodemos suscribirnos al tema del broker MQTT de Mosquitto al que el dispositivo publica.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nAquí traemos el paquete `mosquitto` a nuestro entorno para usar la utilidad `mosquitto_sub`.\\nLuego nos suscribimos al tema establecido en el firmware.\\nObtuvimos nuestras mediciones, lo que significa que AIRA recibe datos correctamente a través de MQTT.\\nAhora vamos a enviar estos mensajes a la Red Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nAquí usamos la utilidad `robonomics` para publicar mensajes en el canal pubsub `/freertos_mqtt_robonomics_example`.\\nEspecificamos `bootnodes` para asegurar al menos una conexión establecida.\\n\\nAhora estamos leyendo estos mensajes desde el mismo canal pubsub.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Recursos originales utilizados\\n\\n* Esquema de pines ESP32 DevKitC de GoJimmy's blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* Estructura de datos y decodificador PSM3003 de OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**¡Gracias a todos!**\\n\"}},{\"node\":{\"id\":\"a0e46dd12ee805aa20311a91c9813245\",\"title\":\"Recibir una notificación cuando se abre la puerta\",\"path\":\"/docs/es/door-notification/\",\"content\":\"\\nEn este artículo instalarás la integración del bot de Telegram y configurarás una automatización que enviará una notificación a tu cuenta de Telegram cuando se abra una puerta.\\n\\n## Notificaciones del bot de Telegram\\n\\nPrimero, necesitas crear un bot personal de Telegram. Para ello, ve a [el bot de Telegram especial @BotFather](https://t.me/botfather) y sigue las instrucciones. \\nGuarda tu token para acceder a la API de HTTP.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nMantén tu token **seguro** y guárdalo **de forma segura**, cualquiera puede usarlo para controlar tu bot. \\n\\n</robo-wiki-note>\\n\\nEl siguiente paso es encontrar tu ***User Chat ID***. Para ello, utiliza el siguiente [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nAhora vamos a instalar la integración de \\\"Telegram broadcast\\\". Esta integración enviará mensajes a tu Telegram.\\n\\nPara la imagen preinstalada de Robonomics, Docker de Home Assistant o Home Assistant Core, debes editar `configuration.yaml`. Conéctate a tu Raspberry Pi a través de `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nPega las siguientes líneas al final del archivo. Inserta tu **bot API key** y **your User Chat ID**. También crea un nombre para tu servicio de notificación:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Guarda la configuración y reinicia Home Assistant.**\\n\\n\\nComo resultado, se creará un servicio en tu Home Assistant que enviará cualquier mensaje al chat de Telegram contigo. \\nPuedes comprobarlo en el menú Herramientas para desarrolladores en la interfaz web de Home Assistant. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Notificación de puerta abierta\\n\\nAhora es el momento de crear una automatización. Primero, importa el modelo a tu Home Assistant desde este enlace:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nY crea la automatización:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nAhora recibirás un mensaje del bot de Telegram cada vez que se abra la puerta.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nPuedes utilizar esta automatización con cualquier puerta/ventana de tu hogar.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"eb55457b8956323549602c26f137e545\",\"title\":\"Gemelos digitales\",\"path\":\"/docs/es/digital-twins/\",\"content\":\"  \\n**Imagina tener un dispositivo o sistema complicado que tiene varios módulos para mantener y requiere algunas cuentas para usar. Para mantenerlos todos en un solo lugar o codificar alguna funcionalidad con cuentas separadas o, por ejemplo, establecer diferentes fuentes de registro de datos para diferentes flujos de información, se debe utilizar el módulo de Gemelo Digital.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Por favor, preste atención de que estos tutoriales se demuestran en una instancia local de Robonomics Node. Configure la suya con [estas instrucciones](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Resumen de la teoría\\nCualquier cuenta puede crear y gestionar un Gemelo Digital. El Gemelo se puede imaginar como una especie de tabla con el siguiente contenido:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nDonde:\\n* **DT id** es un índice de Gemelo Digital único sin firmar.\\n* **Topic name** es un dato hex `H256` o ASCII de longitud de 32 bytes, igual que [`Lanzamiento`](/docs/launch) parámetro extrínseco. \\nPor ejemplo: `0x1234....FF` o `hello.parachain.robonomics.world`.\\n* **Source** - es alguna dirección de cuenta.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Como se ha discutido anteriormente en la descripción general del extrínseco de lanzamiento, el `H256` se puede representar como un CID de IPFS codificado (ver\\n  [herramienta de Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) para eso).\\n  Por lo tanto, los temas también se pueden utilizar como almacenamiento de datos, por ejemplo, una descripción del módulo de un Gemelo.\\n\\n</robo-wiki-note>\\n\\n\\n## Crear Gemelo Digital\\n\\n### 1. Ir a Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Elegir digitalTwin -> create en la lista desplegable de posibles extrínsecos\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nEnviar la transacción. Aquí no se necesitan parámetros para crear un Gemelo. Se le otorgará un índice y solo el propietario del Gemelo Digital podrá agregar/modificar temas del Gemelo a partir de ahora.\\n\\nEl ID del Gemelo se puede encontrar en la página de descripción general del Explorador.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Agregar Tema\\n\\n### Elegir digitalTwin -> setSource en la lista desplegable de posibles extrínsecos\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID, que se ha obtenido en la página de Esplorar.\\n* `topic` - nombre del tema `H256` discutido anteriormente. En esta imagen es una cadena de 32 símbolos.\\n* `source` - dirección de cuenta para asociar con el tema.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Presta atención a que el tema se puede sobrescribir con otra dirección de origen si es necesario.\\n\\n</robo-wiki-note>\\n\\nFirmar y enviar el extrínseco.\\n\\n## Explore\\n\\nPuedes encontrar toda la información sobre los Gemelos Digitales existentes en el módulo de almacenamiento `digitalTwin` del estado de la cadena en `Developer -> Chain state`.\\n\\n- Número total de Gemelos - `total()`;\\n- Propietario del Gemelo Digital - `owner(u32)`;\\n- Información sobre los temas de un Gemelo Digital - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"68052158122b3bff285add0075b5ada4\",\"title\":\"Datalog\",\"path\":\"/docs/es/datalog/\",\"content\":\"\\n**Ahora que tienes algunos fondos en tu cuenta, puedes enviar extrinsics. El primero en probar es un Datalog. Te permite almacenar datos de forma persistente en la cadena de bloques. ¡Imagina un almacenamiento distribuido y protegido criptográficamente para tus datos y esto es todo!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nPor favor, preste atención de que estos tutoriales se demuestran en una instancia local de Robonomics Node. Configure la suya con [estas instrucciones](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navegue hasta  Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Elija datalog -> record desde la lista desplegable de posibles extrínsecos\\n\\nTambién elija una cuenta con la que desee enviar el extrínseco. Rellene el campo de registro.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog admite una cadena con un máximo de 512 bytes. Para almacenar una gran cantidad de datos, se puede utilizar [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Enviar transacción\\n\\nFirme y envíe la transacción con una cuenta creada previamente utilizando la extensión o la DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  También puede borrar **TODOS** sus registros con *datalog -> erase* llamada.\\n\\n</robo-wiki-note>\\n\\n## 4. Revise su datalog en el almacenamiento\\n\\nPara ello, navegue hasta *Developer -> Chain state*, seleccione *datalog -> datalogIndex*, especifique su cuenta y presione el \\n\\\"+\\\" botón para obtener los índices de los registros de su cuenta y luego explore el que necesite con *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Explorarr\\\">\\n\\n  Todos los eventos, incluido el registro de datalog, se pueden ver en el flujo de eventos en el *Explorador*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"e1b763c02a7968fa73fa077bbacdacc8\",\"title\":\"Crear identidad digital gestionada por Ethereum\",\"path\":\"/docs/es/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nUno de los servicios de Robonomics es [Registro de pasaporte digital](https://dapp.robonomics.network/#/passport/) para datos arbitrarios. El servicio te permite crear una identidad digital guardando los hashes de los datos en la cadena de bloques pública y asignando una dirección única.\\n\\nPuedes encontrar el servicio de \\\"Registro de pasaporte digital\\\" en [Robonomics DApp](https://dapp.robonomics.network/) en la sección de \\\"Servicios\\\" o simplemente sigue este [enlace directo](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Recorrido en video\\n\\nEl siguiente video muestra el progreso del registro del Libro Blanco de Robonomics:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Paso a paso en imágenes\\n\\n### 1. Abre el servicio\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Agrega la información y los archivos necesarios\\n\\nTen en cuenta que es posible agregar varias imágenes.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Firma la solicitud\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Aprueba los tokens\\n\\nEl servicio cobra una pequeña tarifa. Pero primero debes aprobar la cantidad requerida de tokens que se gastarán de tu cuenta.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Acepta la oferta y firma el mensaje nuevamente\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Echa un vistazo al pasaporte creado\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nEl proceso de registro lleva algún tiempo. Al final, verás un enlace a la identidad creada.\\n\"}},{\"node\":{\"id\":\"b03e427fc99f8ace4b50713de815d64b\",\"title\":\"Crear cuenta para Robonomics Parachain\",\"path\":\"/docs/es/create-account-in-dapp/\",\"content\":\"\\n**Para interactuar y operar con Robonomics Parachain, los desarrolladores y usuarios deben crear una cuenta en el Portal Polkadot/Substrate. La cuenta realiza funciones básicas para la red: su dirección de red pública (la clave pública), el control de acceso a la dirección y a los fondos (la clave privada), enviar transacciones a la red, mostrar sus tokens y su monto, etc. A continuación se detallan Hay dos formas principales de crear una cuenta para Robonomics Parachain.**\\n\\n## 1. Usando la Extensión del Navegador Polkadot{.js}\\n\\nLa Extensión de Polkadot proporciona un mecanismo para generar la cuenta e interactuar con todos los proyectos de Polkadot / Kusama, incluido Robonomics Parachain. Esta no es la forma más segura de administrar su cuenta, pero es la más conveniente en términos de seguridad / usabilidad.\\n\\n## 1.1. Instalar la Extensión del Navegador\\n\\nLa extensión del navegador está disponible para [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) and [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (además de los navegadores basados en Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Abrir la Aplicación Robonomics Parachain\\n\\nVe a [Aplicación Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) en el Portal Polkadot / Substrate. Si es la primera vez que ingresa al portal, solicitará acceso a la extensión del navegador, así que permita el acceso. \\n\\nUna vez que hayas abierto la aplicación, mira la esquina superior izquierda. Allí se muestran el nombre de la red, su icono y el número del último bloque. Al hacer clic en esta área se abrirá una lista de todas las redes de Polkadot/Kusama, incluidas las redes de prueba y los nodos locales. Puede cambiar entre redes seleccionando la requerida y presionando el botón `Switch`. **Asegúrese de estar conectado a Robonomics Parachain ahora**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Actualizar los Metadatos de la Extensión\\n\\nEs muy probable que la aplicación le solicite actualizar los metadatos de la extensión para mostrar la información correcta sobre la cadena a la que está conectado. Vaya a **Settings -> Metadata**, presione el botón `Update metadata` y luego, en la ventana emergente, permita que la extensión lo haga. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Crear Cuenta en la Extensión\\n\\nAbra la extensión del navegador Polkadot{.js}. Haga clic en el botón grande de suma o seleccione `Create new account` desde el pequeño icono de suma en la esquina superior derecha. Debería ver el siguiente menú, con una semilla mnemotécnica generada en forma de doce palabras y la dirección. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nLa semilla es su clave para la cuenta. Conocer la semilla le permite a usted (o a cualquier otra persona que conozca la semilla) tomar el control de esta cuenta e incluso volver a crearla si olvida la contraseña. **Es muy importante almacenarla de manera segura**, preferiblemente en papel u otro dispositivo no digital, no en almacenamiento digital o en una computadora. \\n\\nGuardar la semilla y presionar `Next step`. Deberías ver el siguiente menú.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* te permite elegir en qué redes se utilizará exclusivamente esta cuenta. Puedes usar la misma dirección en múltiples redes, sin embargo, por razones de privacidad, se recomienda crear una nueva dirección para cada red que uses. \\nSelecciona la red de Robonomics de la lista desplegable. Si no puedes encontrar la red de Robonomics, es probable que no hayas actualizado los metadatos, vuelve atrás y hazlo.\\n\\n    - Notarás que el formato de la dirección y el ícono de la cuenta cambiarán, esto es normal. Los diferentes formatos de red son simplemente otras representaciones de la misma clave pública. \\n\\n- *Name* es solo el nombre de la cuenta para tu uso exclusivo. No se almacena en la cadena de bloques y no será visible para otros usuarios. \\n\\n- *Password* se utiliza para cifrar la información de tu cuenta. Deberás volver a ingresarla al firmar transacciones en el portal. Crea una y recuérdala.\\n\\nComo resultado, después de crear una cuenta, la verás en la lista de cuentas en la extensión Polkadot{.js}. Al hacer clic en los tres puntos, puedes cambiar el nombre de la cuenta, exportarla, eliminarla de la extensión y cambiar la red utilizada para la cuenta. \\n\\nAdemás, la cuenta aparecerá en el menú **Accounts -> Accounts** del portal, donde se anotará que fue inyectada usando la extensión.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Directamente en la aplicación Robonomics Parachain\\n\\nPuedes utilizar la interfaz de usuario en el Portal Polkadot / Substrate para crear una cuenta. Puede ser utilizada para desarrollo y pruebas. \\n\\n## 2.1. Abrir la aplicación Robonomics Parachain\\n\\nVe a [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) en el Portal Polkadot / Substrate. **Verifica en la esquina superior izquierda que estás conectado a Robonomics Parachain**.  \\n\\nVe a **Accounts -> Accounts** y presione el botón `Add account`.\\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Crear cuenta\\n\\nDeberías ver el siguiente menú emergente con la semilla de la cuenta. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nTiene dos formas: *Mnemonic* (legible por humanos) y *Raw* (una secuencia de dígitos y letras). Guarde la frase de recuperación de forma segura y presione `Next`.\\n\\n> También puede cambiar el tipo de criptomoneda para crear una cuenta, para ello abra `Advanced creation options` y elija el tipo (`ed25519` en la imagen).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nEn el siguiente menú, debe establecer el nombre de la cuenta y la contraseña, similar a las instrucciones de la extensión descritas anteriormente.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nHaciendo clic en el botón `Next` lo llevará a la última ventana. Haga clic en `Save` para finalizar la creación de la cuenta. También generará archivos JSON de respaldo que debe guardar de forma segura. Más tarde puede usar este archivo para recuperar su cuenta si recuerda la contraseña.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Agregar cuenta ed25519 a la extensión de Polkadot\\n\\nEs posible que necesite agregar la cuenta creada a la extensión de Polkadot.js (para la cuenta ed25519 solo puede hacerlo con el archivo JSON de respaldo). Para ello, necesita crear un archivo de respaldo de la cuenta. Presione en los tres puntos de su cuenta y elija `Create a backup file for this account` y escriba su contraseña.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nLuego abra una extensión y presione el botón `+` en la parte superior derecha, luego elija `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nEn la ventana abierta, suelte el archivo guardado, ingrese la contraseña y presione `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Cuenta creada exitosamente \\n\\nAhora puede operar completamente con su cuenta recién creada. Envíe y reciba tokens, mensajes, escriba datalog y más. Siéntase libre de explorar todas las funciones de la aplicación. Para copiar la dirección de su cuenta, simplemente haga clic en su icono, la dirección se copiará al portapapeles. \\n\\nSi desea obtener más información sobre las cuentas de Polkadot / Kusama y formas adicionales de crearlas, puede encontrar más información [aquí](https://wiki.polkadot.network/docs/learn-accounts) e [aquí](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"df2b7e4e70929da97a4d369a0995ca25\",\"title\":\"Cómo contribuir a los recursos de Robonomics\",\"path\":\"/docs/es/contributing/\",\"content\":\"\\nRobonomics Network es un proyecto de código abierto y queremos que cualquiera pueda contribuir fácilmente. Puede crear artículos, sugerir cambios, mejorar la documentación o ejecutar pruebas. Si desea contribuir, abra una nueva edición o cree una solicitud de extracción en el mismo repositorio.\\n\\n## Principales repositorios de Robonomics \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Proyecto principal de la wiki\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Sitio web oficial principal de Robonomics Network\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Inicio de los servicios web de Robonomics\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Dapp oficial\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Sitio web oficial de Robonomics Academy\\n\\n### Reglas para informar\\n\\nAl abrir un nuevo problema, no olvides algunas reglas básicas para informar:\\n\\n1. Elige el repositorio exacto al que deseas enviar un problema.\\n\\n2. Si estás informando un error, asegúrate de que el error no haya sido informado anteriormente.\\n\\n3. Asegúrate de incluir un título y una descripción clara, así como toda la información relevante posible.\\n\\n4. Por favor, agrega un prefijo a tu problema con uno de los siguientes: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Solicitudes de extracción\\n\\nCualquier repositorio de Robonomics puede estar sujeto a solicitudes de extracción o cambios por parte de los contribuyentes, cuando usted crea que tiene algo valioso que agregar o cambiar. Por favor, no te olvides de las reglas básicas para los contribuyentes.\\n\\n### Reglas para contribuir\\n\\n1. Se prefieren las solicitudes de extracción a los problemas, si tienes algunas correcciones, especialmente para cambios pequeños como errores tipográficos.\\n\\n2. Asegúrate de que la descripción de la solicitud de extracción describa claramente el problema y la solución. Incluye el número de problema relevante si corresponde.\\n\\n3. Por favor, no corrijas espacios en blanco, formatees el código o hagas un parche puramente estético.\\n\\n4. Por favor, intenta adherirte al estilo, lenguaje y diseño predominantes de Markdown.\\n\\n\\n\"}},{\"node\":{\"id\":\"9eef64a22ab900c4a81a753c0db2945b\",\"title\":\"Servicios de respaldo\",\"path\":\"/docs/es/backup-services/\",\"content\":\"\\n**En este artículo, aprenderás cómo generar respaldos de la configuración de tu Home Assistant y restaurarla cuyo sea necesario. Para crear respaldos, se llama a un servicio que genera un archivo seguro con los archivos de configuración. Además, el servicio agrega la configuración de Mosquitto brocker y Zigbee2MQTT al respaldo si existen. Luego, este servicio agrega el archivo a IPFS y almacena el CID resultante en Robonomics Digital Twin.**\\n## Creación de respaldo de la configuración de Home Assistant\\n\\nCrear un respaldo te permite restaurar fácilmente la configuración de tu Home Assistant en caso de una falla.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ADVERTENCIA\\\">\\n\\nPara respaldar y restaurar tu configuración, es necesario utilizar una **puerta de enlace IPFS personalizada** como Pinata. Sin ella, tu respaldo se almacenará únicamente en tu nodo IPFS local, lo que puede impedirte restaurar la configuración de tu Home Assistant en caso de una falla del nodo local.\\n\\n</robo-wiki-note>\\n\\n1. En la interfaz web de Home Assistant, ve a `Developer Tools` -> `Services`. Buscar `Robonomics: Save Backup to Robonomics` y presiona `CALL SERVICE`.\\n\\n2. Espera hasta que veas la notificación `Backup was updated in Robonomics` aparecer en `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ADVERTENCIA\\\">\\n\\nNo intentes crear un respaldo o restaurar la configuración inmediatamente después de cargar Home Assistant y Robonomics Integration. Por favor, **espera aproximadamente 5 minutos** para permitir que la configuración inicial se complete.\\n\\n</robo-wiki-note>\\n\\nArgumentos del servicio:\\n- **Respaldo completo**  (default: False) - agrega la base de datos al respaldo, por lo que también se almacenará el historial de estados de las entidades.\\n- **Ruta al archivo de contraseña de mosquitto** (default: `/etc/mosquitto`) - Si utilizaste los métodos de instalación de Home Assistant Core o Docker y no tienes la ruta predeterminada al Mosquitto brocker, debes cambiar este parámetro. *No es necesario para Home Assistant OS o Superviser*.\\n\\n## Restauración de la configuración de Home Assistant desde un respaldo\\n\\nPara restaurar tu configuración, necesitarás tener instalado Home Assistant y Robonomics Integration. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ADVERTENCIA\\\">\\n\\nPara asegurar una restauración exitosa de tu configuración en Home Assistant Core y los métodos de instalación de Docker, debes realizar pasos de configuración adicionales como se describe al final de la página.\\n\\n</robo-wiki-note>\\n\\n1. Instala Home Assisntant con Robonomics Integration (si aún no está instalado), siguiendo los pasos del artículo para el [método de instalación deseado](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2. [Configuración de integración de Robonomics](https://wiki.robonomics.network/docs/robonomics-hass-integration) usando **las mismas semillas** que utilizaste en la configuración anterior de Robonomics. Si tu suscripción ha finalizado, [reactívala](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. En la interfaz web de Home Assistant ve a `Developer Tools` -> `Services`. Search for `Robonomics: Restore from the Backup in Robonomics` and presione el botón `CALL SERVICE`. Navega hasta la `Overview` page, to check the status of your backup, .\\n\\n4. Después de restaurar, Home Assistant se reiniciará automáticamente. Si por alguna razón Home Assistant no se reinicia, puedes verificar el estado de restauración monitoreando el estado de la `robonomics.backup` entidad. Si el estado es `restored` necesitarás reiniciar manualmente Home Assistant navegando a `Settings` > `System` y haciendo clic en el `RESTART` botón ubicado en la esquina superior derecha.\\n\\n5. Si tu respaldo incluye la configuración de Zigbee2MQTT o Mosquitto, necesitarás reiniciar estos servicios para habilitar la nueva configuración. Puedes hacer esto manualmente reiniciando los servicios individualmente, o simplemente reiniciando la computadora de Home Assistant para asegurarte de que todos los servicios se reinicien.\\n\\nArgumentos del servicio:\\n- **Ruta al archivo de contraseña de Mosquito** (default: `/etc/mosquitto`) - Si utilizaste los métodos de instalación de Home Assistant Core o Docker y no tienes la ruta predeterminada al broker de Mosquitto, debes cambiar este parámetro. *Not needed for Home Assistant OS or Superviser*.\\n- **Ruta de configuración de Zigbee2MQTT**  (default: `/opt/zigbee2mqtt`) - Si utilizaste los métodos de instalación de Home Assistant Core o Docker y no tienes la ruta predeterminada a Zigbee2MQTT, debes cambiar este parámetro. *Not needed for Home Assistant OS or Superviser*.\\n\\n## Restaurar la configuración de Mosquitto y Zigbee2MQTT para el método de instalación de Home Assistant Core\\n\\nSi el respaldo incluye la configuración de Mosquitto o Zigbee2MQTT, durante el proceso de restauración, se colocarán en la ruta predeterminada o en la ruta especificada en los argumentos. Sin embargo, si instalaste la integración de Robonomics en un Home Assistant Core existente *(no desde la imagen preinstalada de Robonomics)*, `homeassistant` el usuario puede no tener acceso a esta ruta.\\n\\nPor lo tanto, para restaurar la configuración de Mosquitto y Zigbee2MQTT, necesitas otorgar los permisos de lectura necesarios al usuario `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Respaldo de la configuración de Mosquitto y Zigbee2MQTT para el método de instalación de Home Assistant Docker\\n\\nPara respaldar las configuraciones de Mosquitto y Zigbee2MQTT desde un contenedor Docker, necesitas crear volúmenes para sus respectivas configuraciones. Esto se puede lograr ejecutando tu contenedor de Home Assistant con argumentos adicionales:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\no hacer cambios en tu `compose.yaml` archivo:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nTen en cuenta que las rutas predeterminadas para las configuraciones de Mosquitto y Zigbee2MQTT son `/etc/mosquitto` and `/opt/zigbee2mqtt`, respectivamente. Sin embargo, estas rutas pueden variar dependiendo de tu configuración específica.\\n\\n</robo-wiki-note>\\n\\n## Botones de respaldo\\n\\nAdemás de utilizar servicios para trabajar con respaldos, puedes simplificar el proceso utilizando los `button.create_backup` and `button.restore_from_backup` botones de la integración de Robonomics. Estos botones invocan los servicios respectivos con parámetros predeterminados (el botón de respaldo crea un respaldo sin historial).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nPara agregar botones a tu panel de control, sigue estos pasos:\\n\\n1. Haz clic en los tres puntos en la esquina superior derecha del panel de control.\\n2. Selecciona `Edit Dashboard`.\\n3. Haz clic en el `Add Card` botón en la esquina inferior derecha.\\n4. Choose the `Entities` tarjeta.\\n5. En el campo `Entities` busca las entidades button.create_backup y button.restore_from_backup.\\n6. Presiona `Save` para agregar las entidades a la tarjeta.\\n7. Finaliza la edición haciendo clic en el `Done` botón en la esquina superior derecha.\"}},{\"node\":{\"id\":\"3fb9dae9aafbead5734aa732608060aa\",\"title\":\"Servicio de compensación\",\"path\":\"/docs/es/carbon-footprint-service/\",\"content\":\"\\nEjemplo de trabajo está en el video:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nServicio para compensar la huella de carbono CO2 quemando tokens en la red de Statemine. \\nEl CO2 producido se calcula de la siguiente manera: los datos del dispositivo en Wh se multiplican por coeficientes que dependen de la región. 1 tonelada de CO2 se cubre con el consumo de 1 token. [Aquí](/docs/carbon-footprint-sensor) están las instrucciones para conectar el dispositivo.\\n\\n## Escenario\\n\\n1. Register a new deivce in Digital Twin in Robonomics network \\n2. Once in an interval getting last data from all device y multiply by the coefficient depending on the region\\n3. Sumar los datos y convertirlos a toneladas de CO2.\\n4. Restar el número total de tokens quemados de los datos actuales. \\n5. Quemar un número entero de tokens en la red de Statemine. \\n6. Guardar el número total de tokens quemados en la base de datos local y en Datalog. \\n\\n\\n## Instalación\\n\\nClonar el repositorio y editar el archivo de configuración.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Configuración description\\n\\nNo editar `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network waquí Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nLos coeficientes para la energía no renovable se han tomado de [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) y se almacenan en `utils/coefficients.py`. \\n\\n## Lanzamiento\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"6e0a0277cddc1dff798e2aac8071a2ef\",\"title\":\"Conectar sensor\",\"path\":\"/docs/es/carbon-footprint-sensor/\",\"content\":\"\\nEjemplo de trabajo está en el video:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Requisitos\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (o uno de [soportado](https://www.zigbee2mqtt.io/enformation/supported_adapters.html))\\n\\nService is running on Raspberry Pi y contact the smart plug via zigbee protocol.\\n\\n## Zigbee stick\\n\\nSi tienes el JetHome USB JetStick Z2, ya tiene el firmware necesario, por lo que no necesitas flashearlo. Pero si tienes otro adaptador, primero debes flashearlo con el software zigbee2MQTT. Puedes encontrar instrucciones para tu dispositivo [aquí](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nConecta el adaptador y verifica la dirección del adaptador (también puede ser `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nEs posible que primero necesites acceder al puerto USB. Añade tu usuario a `dialout` grupo (funciona para ubuntu, pero el nombre del grupo puede ser diferente en otros sistemas operativos).\\n\\nPara ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nPara arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nLuego cierra sesión e inicia sesión nuevamente o reinicia la computadora.\\n\\n## Instalación\\n\\nClona el repositorio:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Configuración\\n\\nVe a `data/configuration.yaml` y configura `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nTambién es posible que desees completar los campos `server` and `port` con la información correspondiente. En el campo `server` utiliza la IP del `docker0` puente para establecer la conexión: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nAquí tu dirección es `172.17.0.1`.\\n\\nLuego crea el archivo config/config.yaml con la siguiente información y configura tu ubicación (puedes consultar https://countrycode.org/ para el código ISO de 3 letras):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Conectar enchufe\\n\\nPrimer inicio:\\n\\n```\\ndocker-compose up     \\n```\\n\\nPara cambiar al modo de emparejamiento en el enchufe, mantenga presionado el botón de encendido durante unos segundos hasta que la luz comience a parpadear en azul rápidamente.\\n\\nEn los registros debería ver ahora que su complemento comenzó a publicarse en mqtt.\\n\\n\\n## Después de emparejar\\n\\nSi no quieres permitir que otros dispositivos se emparejen con tu adaptador, ahora debes ir a `data/configuration.yaml` y establecer `permit_join: false`. Restart service (use 'Ctrl+C' y\\n\\n```bash\\ndocker-compose up     \\n```\\nuna vez más para enviar los cambios).\\n\\n## Ejecución\\nEn el primer inicio se creará una cuenta para el enchufe. \\n> Si ya tiene una cuenta, debe agregar su semilla al archivo `config.config.yaml` en la sección `device_seed`:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nDespués de crear la cuenta, verás la dirección en los registros (la semilla se agregará a `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nNecesitas transferir algunos tokens a esta cuenta para las tarifas de transacción, puedes hacerlo en [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nEl servicio verá que tienes suficientes tokens, en los registros verás:\\n```\\nplug               | Balance is OK\\n```\\nEl servicio verá los mensajes mqtt del enchufe y garantizará un uso seguro de la energía. Cada hora (puedes cambiar el tiempo de espera en `config/config.yaml` in `sending_timeout` sección, el tiempo de espera está en segundos) creará un registro de datos con la siguiente información:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"ed2655f96cd070d4ba5d0d6f136a1823\",\"title\":\"Ajouter des fonds à votre compte sur le portail Robonomics\",\"path\":\"/docs/es/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Después de crear exitosamente sus cuentas en el portal de Robonomics, es hora de agregar fondos a ellas para que pueda eniciar transacciones.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nPor favor, preste atención a que estos tutoriales se demuestran en una instancia local de Robonomics Node. Configure la suya con [estas instrucciones](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navegue a la sección de Cuentas en el portal de Robonomics \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Elija la cuenta desde la cual desea transferir fondos\\n\\nEn el modo de desarrollo, existen varias cuentas, con un valor de 10000 Unidades de fondos cada una, que se pueden utilizar para transferir fondos a otras cuentas creadas en la red de desarrollo. Estas cuentas están indicadas por signos de llave inglesa <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> junto a ellas.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Haga clic en el botón \\\"enviar\\\" de la cuenta desde la cual desea transferir fondos, por ejemplo BOB\\n\\n## 3. Elija la cuenta a la cual desea transferir fondos\\nDespués de hacer clic en el botón \\\"enviar\\\", se le pedirá en la \\\"ventana de envío de fondos\\\". En la ventana solicitada:\\n\\n- De la lista de cuentas disponibles, elija la cuenta a la cual desea enviar fondos.\\n- Ingrese la cantidad de Unidades que desea enviar.\\n- Presione \\\"realizar transferencia\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Autorice la transacción\\n\\nDespués de presionar \\\"realizar transferencia\\\" en la etapa anterior, se le pedirá en la \\\"ventana de autorización de transacción\\\".<br/>\\nRevise los detalles de la transacción y finalmente haga clic en el botón \\\"firmar y enviar\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nEn este ejemplo, transferimos 500 unidades de fondos de \\\"BOB\\\" a \\\"EMPLEADOR\\\". Puede ver que la cuenta de EMPLEADOR, que inicialmente no tenía fondos, ahora tiene 500 Unidades de fondos.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Asegúrese de tener suficientes fondos en las cuentas que desea utilizar en el playground.**\"}},{\"node\":{\"id\":\"61bc5bd69bf2b7accede8cf6099f1b87\",\"title\":\"Προσαρμογέας Zigbee με Zigbee2MQTT για προεγκατεστημένη εικόνα\",\"path\":\"/docs/el/zigbee-to-mqtt-image/\",\"content\":\"\\n**Σε αυτό το άρθρο θα συνδέσετε έξυπνες συσκευές.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nΑνοίξτε έναν περιηγητή ιστού και μεταβείτε στη διεύθυνση `http://%RASPBERRY_IP_ADDRESS%:8099`. Μπορείτε να βρείτε τη διεύθυνση IP του Raspberry Pi χρησιμοποιώντας την εφαρμογή [Fing mobile app](https://www.fing.com/products) ή το εργαλείο γραμμής εντολών [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nΘα δείτε τη διεπαφή χρήστη του Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nΉρθε η ώρα να συνδέσετε την έξυπνη συσκευή σας. \\nΠατήστε πρώτα το κουμπί `Permit join (All)` στην κορυφή της διεπαφής χρήστη του Zigbee2MQTT. \\n\\nΣτη συνέχεια, ξεκινήστε τη σύζευξη των συσκευών. Ο πιο συνηθισμένος τρόπος να μεταβείτε μια συσκευή σε λειτουργία σύνδεσης είναι να κρατήσετε πατημένο το κουμπί λειτουργίας ή να τις ενεργοποιήσετε/απενεργοποιήσετε 5 φορές. Βεβαιωθείτε ότι το Zigbee2MQTT εκτελείται.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nΌταν η συσκευή συνδεθεί, θα τις δείτε στη διεπαφή χρήστη:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nΤώρα θα πρέπει να δείτε αυτόν τον αισθητήρα στο Home Assistant WebUI σας. Μεταείτε στις `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nΑφού προσθέσετε όλους τους αισθητήρες, μπορείτε να κλείσετε τη διεπαφή χρήστη του Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"f8d44aa7f17cf48b5b6c5f63e18be170\",\"title\":\"Πώς να χρησιμοποιήσετε τα σχέδια\",\"path\":\"/docs/el/use-blueprints/\",\"content\":\"\\nΣε αυτό το άρθρο θα μάθετε πώς να προσθέσετε αυτοματισμούς σχεδίων στο Home Assistant σας και να το διαμορφώσετε.\\n\\n## Αυτοματισμοί Σχεδίων\\n\\nΟρισμένα σχέδια έχουν ήδη εγκατασταθεί. Οι αυτοματισμοί που βασίζονται σε τέτοια σχέδια χρειάζεται μόνο να διαμορφωθούν. Στη διεπαφή ιστού μπορείτε να βρείτε προεγκατεστημένα σχέδια στις `Settings/Automations & Scenes`. Ανοίξτε τα `Blueprints` και βρείτε το σχέδιο που θέλετε να χρησιμοποιήσετε. Σε αυτό το παράδειγμα θα χρησιμοποιηθεί το `Motion-activated Light`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nΚάντε κλικ στο `Create Automation` για να ανοίξετε τον επεξεργαστή αυτοματισμού. Δώστε ένα όνομα, επιλέξτε ένα σχέδιο που θέλετε να χρησιμοποιήσετε (`Motion-activated Light` στην περίπτωσή μας). Έπειτα πρέπει να επιλέξετε αισθητήρα κίνησης και λάμπα. Όταν ολοκληρωθεί η διαμόρφωση, κάντε κλικ στο `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Διαμόρφωση\\\" />\\n\\nΑν θέλετε να κάνετε αλλαγές, μπορείτε να το βρείτε πηγαίνοντας στις `Settings/Automations & Scenes` και στη συνέχεια στους `Automations`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Εισαγωγή Σχεδίων\\n\\nΤο Home Assistant μπορεί να εισάγει σχέδια από τα φόρουμ του Home Assistant, το GitHub και τα GitHub gists. Η λίστα όλων των Σχεδίων βρίσκεται στο [Ανταλλαγή Σχεδίων](https://community.home-assistant.io/c/blueprints-exchange/53). Αφού επιλέξετε, πηγαίνετε στις `Settings/Automations & Scenes`  και ανοίξτε τα `Blueprints`. Κάντε κλικ στο `Import Blueprint` και εισαγάγετε το URL του επιλεγμένου σχεδίου. Στη συνέχεια κάντε κλικ στο `PREVIEW BLUEPRINT`. Σε αυτήν την περίπτωση θα χρησιμοποιήσουμε το [Ανίχνευση χαμηλού επιπέδου μπαταρίας και ειδοποίηση για όλους τους αισθητήρες μπαταρίας](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nΑυτό θα φορτώσει το σχέδιο και θα εμφανσει μια προεπισκόπηση στο παράθυρο εισαγωγής. Μπορείτε να αλλάξετε το όνομα και να ολοκληρώσετε την εισαγωγή. Κάντε κλικ στο `Create Automation` για να ανοίξετε τον επεξεργαστή αυτοματισμού. Εδώ μπορείτε να διαμορφώσετε τις παραμέτρους του αυτοματισμού και να προσθέσετε ενέργειες για να λάβετε ειδοποιήσεις.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"f27ff4c4d1a989dd776506da14e6ed29\",\"title\":\"Δοκιμαστική σουίτα Substrate Cumulus Parachain για ανταλλαγή μηνυμάτων μεταξύ αλυσίδων\",\"path\":\"/docs/el/xcm-robobank/\",\"content\":\"\\n\\nΟ κύριος στόχος αυτού του έργου είναι η απλοποίηση της ανάπτυξης του runtime των parachain, όταν χρησιμοποιούντι μηνύματα μεταξύ αλυσίδων. \\nΕπιτρέπει την ανάπτυξη κώδικα runtime με ενσωματωμένες δοκιμές με υψηλό βαθμό επαναληψιμότητας και απλή χρήση.\\nΑυτοματοποιεί την κατασκευή, την κατασκευή προκαθορισμένης διαμόρφωσης δικτύου (δηλαδή 1 αλυσίδα ρελέ + 2 parachains), τη δημιουργία καναλιών μεταξύ των parachains και την εκτέλεση δοκιμών μηνυμάτων, αποστολή μηνυμάτων, χρήση κλήσης στο runtime, όλα κατασκευασμένα και συνταγμένα σε Python.\\n\\nΤο XCM Testsuite χρησιμοποιείται για τη δοκιμή του κύκλου παραγωγής της Robobank - του συνόλου των Substrate pallets, που επιτρέπουν σε ρομπότ να εγγραφούν σε εξωτερικά parachains, να λαμβάνουν προπληρωμένες παραγγελίες, να τις εκτελούν και να λαμβάνουν πληρωμές χρησιμοποιώντας εξωτερικά tokens. Αυτό επιτρέπει στα ρομπότ να λειτουργούν εντός του δικτύου Robonomics με όλη την απαιτούμενη υποδομή, αλλά ταυτόχρονα να προσφέρουν τις υπηρεσίες τους σε οποιοδήποτε άλλο parachain.\\n\\nΈνα παράδειγμα βίντεο είναι διαθέσιμο στο [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nΟι κύρια βήματα στο σενάριο επίδειξης είναι:\\n- εκκίνηση αλυσίδας ρελέ και δύο parachains σε ένα πακέτο 6 διεργασιών\\n- δημιουργία καναλιών μηνυμάτων XCM μεταξύ των parachains\\n- εγγραφή ενός ρομπότ σε και τα δύο parachains\\n- δημιουργία μιας παραγγελίας για αυτό το ρομπότ στο client parachain (κράτηση πληρωμής για την ολοκλήρωση της παραγγελίας)\\n- αποστολή μηνύματος XCM στο Robonomics parachain\\n- δημιουργία της καταγραφής της παραγγελίας \\\"καθρέφτη\\\" στο Robonomics parachain\\n- το ρομπότ αποδέχεται την παραγγελία στο Robonomics parachain\\n- αποστολή μηνύματος XCM για την αποδοχή της παραγγελίας πίσω στο client parachain\\n- αποδοχή της παραγγελίας στο client parachain (κράτηση ποινής για έλλειψη ολοκλήρωσης της παραγγελίας μέχρι την προθεσμία της παραγγελίας)\\n- το ρομπότ ολοκληρώνει την παραγγελία στο Robonomics parachain\\n- αποστολή μηνύματος XCM για την ολοκλήρωση της παραγγελίας στο client parachain\\n- εξόφληση όλων των πληρωμών (η πληρωμή του πελάτη μεταφέρεται στο ρομπότ, καθώς και η μη αξιοποίητη ποινή)\\n- κλείσιμο της παραγγελίας1\\n\\n\\n## Προς τα πάνω\\nΑυτό το έργο είναι ένα fork του\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nΠεριέχει κώδικα των runtime pallets που δοκιμάζονται.\\nΌπως και στον αρχικό κώδικα των κόμβων, ο κώδικας των parachains βρίσκεται στους καταλόγους \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nΔιαφορές με το αρχικό \\\"substrate-node-template\\\":\\n- αυτός ο collator runtime έχει τον HRMP handler module και μπορεί να χειριστεί μηνύματα από αδελφούς parachains\\n- έτοιμος δοκιμαστικός runtime για εσωτερικές δοκιμές XCM\\n\\n## Κατασκευή & Εκτέλεση\\nΣυνιστάται (ιδιαίτερα) η εγκατάσταση: \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[ΣΗΜΕΙΩΣΗ] Η πρώτη δημιουργία μπορεί να πάρει πολύ χρόνο, έως και αρκετές ώρες σε μη βέλτιστες μηχανές.\\n\\n[ΣΗΜΕΙΩΣΗ] Το σενάριο λειτουργεί με τις ΣΤΑΘΕΡΕΣ εκδόσεις (commit hashes) του Polkadot(Rococo) στην αλυσίδα αναμετάδοσης και των παρααλυσίδων.\\n\\n[ΣΗΜΕΙΩΣΗ] Από προεπιλογή, το σενάριο δημιουργεί ξανά το ίδιο περιβάλλον κάθε φορά που ξεκινάει, αφαιρώντας όλες τις προηγούμενες καταστάσεις. Αυτή η συμπεριφορά μπορεί να αλλάξει στο \\\"config.sh\\\" χρησιμοποιώντας την παράμετρο \\\"PERSISTENT\\\".\\n\\n\\nΕκτέλεση δημιουργίας και εγκατάστασης σεναρίου.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nΒασικές ενέργειες του σεναρίου \\\"init.sh\\\":\\n - ανάγνωση ρυθμίσεων (αρχείο \\\"config.sh\\\" με αριθμό αναθεώρησης, αρχικά κλειδιά κόμβου και αναγνωριστικά, παράμετρος διατήρησης chaindata κ.λπ.)\\n - εγκατάσταση πακέτων λειτουργικού συστήματος, Rust και Python\\n - δημιουργία ξεχωριστών δυαδικών αρχείων για την αλυσίδα αναμετάδοσης και για τις δύο παρααλυσίδες\\n    - τα δυαδικά αρχεία θα δημιουργηθούν στον υποφάκελο ./bin. \\n - (προαιρετικό) αφαίρεση όλων των προηγούμενων δεδομένων αλυσίδας για όλες τις αλυσίδες\\n    - απενεργοποιείται αν η \\\"PERSISTENT=1\\\" έχει οριστεί στο \\\"config.sh\\\"\\n - εκτέλεση ως ξεχωριστές διεργασίες (με ξεχωριστά PIDs και I/O pipes):\\n    - επαληθευτές της αλυσίδας αναμετάδοσης (δηλαδή 4 επαληθευτές που εκτελούν μια σταθερή αναθεώρηση Rococo)\\n    - συλλέκτες για την παρααλυσίδα-100 (δηλαδή ένας μόνο συλλέκτης για την πρώτη παρααλυσίδα που αναπτύσσετε)\\n    - συλλέκτες για την παρααλυσίδα-200 (δηλαδή ένας μόνο συλλέκτης για την δεύτερη παρααλυσίδα που αναπτύσσετε)\\n - εκτύπωση όλων των σημείων έναρξης, θυρών στην κονσόλα, επιτρέποντάς σας να μελετήσετε οποιαδήποτε αλυσίδα χρησιμοποιώντας εφαρμογές προσκομιστή (explorer, DApp)\\n - συνεχής εκτύπωση όλων των δεδομένων εξόδου όλων των αλυσίδων στην κονσόλα\\n\\n[ΠΡΟΕΙΔΟΠΟΙΗΣΗ] Μετά την εκκίνηση, περιμένετε μέχρι η δίκτυο να είναι ενεργό, βεβαιωθείτε ότι η ολοκλήρωση των μπλοκ έχει ξεκινήσει και ότι οι παρααλυσίδες έχουν καταχωρηθεί. Αυτές οι διαδικασίες θα πρέπει να απαιτούν περίπου 5 λεπτά (50 μπλοκ x 6 δευτερόλεπτα).\\n\\n## Έλεγχος ότι η αρχική ρύθμιση λειτουργεί \\n\\nΧρησιμοποιήστε το πρότυπο προσκομιστή Polkdot και τα δημιουργημένα σημεία έναρξης \\\"--ws-port\\\" για να συνδεθείτε με κάθε κόμβο.\\nΑνοίξτε την [εφαρμογή Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) για να παρακολουθήσετε τις αλυσίδες. \\n\\n### Παράδειγμα:\\nΤοπικός υπολογιστής, 4 επαληθευτές αλυσίδας αναμετάδοσης, ένας συλλέκτης παρααλυσίδας-100, ένας συλλέκτης παρααλυσίδας-200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nΑν όλα λειτουργούν και η συναίνεση ξεκίνησε, μπορούμε να προχωρήσουμε στην εκτέλεση των δοκιμαστικών μας περιπτώσεων (σε ένα νέο τερματικό).\\n\\n### Δοκιμή μετάδοσης μηνυμάτων UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nΔημιουργεί ένα μήνυμα `Balance.transfer` στην `παρααλυσίδα-100` και το περνά στην αλυσίδα αναμετάδοσης.\\nΌταν η αλυσίδα αναμετάδοσης λάβει το μήνυμα, θα μεταφέρει 15 νομίσματα από τον λογαριασμό `para 100` στον λογαριασμό Charlie.\\n\\n\\n### Δοκιμή πέρασματος μηνυμάτων HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nΔημιουργεί ένα μήνυμα `Balance.transfer` στο `parachain-100` και το περνάει στο `sibling 200`.\\nΠριν από αυτό, εφοδιάζει τον λογαριασμό `subl 100` με 1000 νομίσματα και δημιουρεί ένα κανάλι επικοινωνίας μεταξύ των parachains.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nΤα επόμενα μηνύματα μπορούν να σταλούν εκτελώντας την υποεντολή `hrmpm`. Δεν δημιουργεί ένα κανάλι και γι' αυτό τρέχει πιο γρήγορα.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Περισσότερες επιλογές\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Τοπικό Testnet\\n\\n### Δημιουργία προσαρμοσμένου chain spec\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nΕπεξεργασία του rococo_local.json, αντικατάσταση των παραμέτρων ισορροπιών και αρχών με τις δικές σας.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nΔιεύθυνση Polkadot για το //Alice//stash (κρυπτογραφία sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nΚλειδί συνεδρίας Polkadot grandpa για το //Alice (κρυπτογραφία ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nΔιεύθυνση Polkadot για το //Alice (κρυπτογραφία sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nΜετατροπή του rococo_local.json σε μορφή raw.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nΓια να χρησιμοποιήσετε το νέο chain spec αντικαταστήστε το αρχείο rococo.json στον φάκελο ./config/ με αυτό το νέο και εκτελέστε ξανά την αλυσίδα.\\n```bash\\n./scripts/init.sh run\\n```\\nΜπορείτε να επεξεργαστείτε ελεύθερα τον κώδικα. Η παραπάνω εντολή θα ξαναχτίσει το έργο και θα ενημερώσει τον κόμβο συλλέκτη πριν ξεκινήσει.\\nΤο Cumulus είναι λογισμικό προεκδόσεων που εξακολουθεί να βρίσκεται υπό έντονη ανάπτυξη.\\nΧρησιμοποιούμε ένα συγκεκριμένο commit του polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nΜπορείτε να χρησιμοποιήσετε πιο πρόσφατες εκδόσεις του λογισμικού. Για να το κάνετε αυτό, αλλάξτε το POLKADOT_COMMIT στο αρχείο ./scipt/config.sh\\nστο πιο πρόσφατο commit του κλάδου `rococo-v1`, διαγράψτε το ./bin/polkadot και εκτελέστε \\n```bash\\n./scripts/init.sh run\\n```\\n\\nΕνημέρωση των εξαρτήσεων του έργου συλλέκτη \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nΟρισμένες εξαρτήσεις πιθανόν να απαιτούν νέα χαρακτηριστικά του εργαλείου rust. Αυτό το έργο βασίζεται στο rust `nightly-2021-01-26`\\nΕνημέρωση της έκδοσης του εργαλείου rust στο αρχείο ./scripts/config.sh πριν την κατασκευή.\\n\\n## Χάκεψε το parachain\\n[Προσθήκη εξωτερικής παλέτας](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - πρέπει να είναι πιθανόν στο \\\"μάθετε περισσότερα\\\";\\n## Learn More\\n\\nΑνατρέξτε στο ανώτερο [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template) για να μάθετε περισσότερα για τη δομή αυτού του έργου, τις δυνατότητες που ενσωματώνει και τον τρόπο με τον οποίο υλοποιούνται αυτές οι δυνατότητες. Μπορείτε να μάθετε περισσότερα για [Το Μονοπάτι του Μπλοκ Parachain](https://polkadot.network/the-path-of-a-parachain-block/) στο επίσημο ιστολόγιο του Polkadot. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"3be8f62c8f2415499c7e7e7006b96689\",\"title\":\"Πώς να στείλετε εκτέλεση με συνδρομή\",\"path\":\"/docs/el/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Προσέξτε ότι αυτός ο οδηγός δείχνει πώς να χρησιμοποιήσετε μια συνδρομή στο Robonomics Kusama parachain. Μπορείτε επίσης να εκτελέσετε όλα τα ίδια βήματα στον [τοπικό κόμβο](/docs/run-dev-node) σας.\\n\\n</robo-wiki-note>\\n\\nΕάν η διεύθυνσή σας έχει μια ενεργή συνδρομή, τότε οποιεσδήποτε συσκευές που έχουν ρυθμιστεί με το μυστικό αυτού του λογαριασμού μπορούν να στείλουν extrinsics χωρίς χρέωση. \\nΑς δοκιμάσουμε να στείλουμε την εντολή `launch`.\\n\\nΠηγαίνετε στη σελίδα `Developer/Extrinsics`, στη συνέχεια επιλέξτε τον λογαριασμό σας (από τη λίστα συσκευών) και επιλέξτε `rws -> call(subscriptionId, call)`. \\nΣτο πεδίο `subscriptionId` επικολλήστε τη διεύθυνση του ιδιοκτήτη της συνδρομής (αυτός που προσέφερε στη δημοπρασία) και στο επόμενο πεδίο επιλέξτε `launch -> launch(robot, param)`. Στο πεδίο `robot` πληκτρολογήστε τη διεύθυνση στην οποία θέλετε να στείλετε τη συναλλαγή `launch` και εισαγάγετε την εντολή (για περιγραφή της εντολής launch ανατρέξτε [εδώ](/docs/launch)). Στη συνέχεια υποβάλετε τη σναλλαγή:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\nΤώρα πηγαίνετε στη σελίδα `Network/Explorer` και στην περιοχή `Recent Events` θα δείτε δύο γεγονότα που δημιουργήσατε· `rws.NewCall` και `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"c64b03489a77761dd5784b9fc8cc8ac8\",\"title\":\"Ενεργοποίηση συνδρομής\",\"path\":\"/docs/el/sub-activate/\",\"content\":\"\\nΣε αυτό το άρθρο θα δημιουργήσετε λογαριασμούς Robonomics parachain και θα αγοράσετε συνδρομή IoT. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nΓια να ελέγξετε το Home Assistant με το Robonomics, χρειάζεστε 2 λογαριασμού στο Robonomics parachain. Για έναν από τους λογαριασμούς (`sub_owner`), θα αγοράσετε μια συνδρομή Robonomics. Ο δεύτερος λογαριασμός (`sub_controller`) θα ελέγχει όλες τις διεργασίες του Home Assistant (όπως η τηλεμετρία) και θα παρέχει πρόσβαση σε άλλους χρήστες. Αυτοί οι λογαριασμοί θα παρέχουν ασφάλεια για το Home Assistant σας. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nΚαι οι δύο λογαριασμοί πρέπει να δημιουργηθούν με κρυπτογράφηση **ed25519**. Εξαιτίας αυτού, πρέπει να δημιουργήσετε έναν λογαριασμό χρησιμοποιώντας τη διεπαφή χρήστη Polkadot-JS και να επιλέξετε την απαιτούμενη κρυπτογράφηση.\\n\\nΑυτή η λειτουργία είναι απενεργοποιημένη από προεπιλογή στο Polkadot-JS UI. Για να την ενεργοποιήσετε, μεταβείτε στις `Settings` -> `General` -> `account options` και επιλέξτε `Allow local in-browser account storage` από το αναπτυσσόμενο μενού `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Δημιουργήστε λογαριασμούς κατόχου και ελεγκτή\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Μεταβείτε στην εφαρμογή [Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) στο Polkadot / Substrate Portal. **Ελέγξτε την πάνω αριστερή γωνία για να βεβαωθείτε ότι είστε συνδεδεμένοι με το Robonomics Parachain.**\\n\\n2. Μεταβείτε σε `Accounts` -> `Accounts` και πατήστε το κουμπί `Add account`. Θα δείτε το αναδυόμενο μενού με τον κωδικό σπόρου του λογαριασμού. Έχει δύο μορφές: *Μνημονικό* (αναγνώσιμο από ανθρώπους) και *Ακατέργαστο* (μια ακολουθία αριθμών και γραμμάτων). \\n\\n3. Ανοίξτε τις `Advanced creation options`, αλλάξτε τον τύπο κρυπτογράφησης της δημιουργίας λογαριασμού σε `Edwards - ed25519` και πατήστε `Next`.\\n\\n\\n4. Αποθηκεύστε το μνημονικό φράσης σπόρου με ασφάλεια και πατήστε `Next`.\\n\\n5. Στο επόμενο μενού, πρέπει να ορίσετε το όνομα και τον κωδικό πρόσβασης του λογαριασμού. Δώστε του το όνομα `sub_owner` για την ευκολία. Πατήστε `Next`.\\n\\n6. Στο τελευταίο παράθυρο κάντε κλικ στο `Save` για να ολοκληρώσετε τη δημιουργία του λογαριασμού. Θα δημιουργηθούν επίσης αρχεία εφεδρικής αντιγραφής JSON που πρέπει να αποθηκεύσετε με ασφάλεια. Αργότερα μπορείτε να χρησιμοποιήσετε αυτό το αρχείο για να ανακτήσετε τον λογαριασμό σας αν θυμάστε τον κωδικό πρόσβασης.\\n\\n7. Επαναλάβετε αυτά τα βήματα για έναν λογαριασμό με το όνομα `sub_controller`.\\n\\n\\n## Προσθέστε λογαριασμούς στο Polkadot.js\\n\\nΓια την ευκολία σας, θα πρέπει να χρησιμοποιήσετε την [επέκταση Polkadot.js](https://polkadot.js.org/extension/) και να προσθέσετε αυτούς τους νεοδημιουργημένους λογαριασμούς σε αυτήν. Για έναν λογαριασμό ed25519 μπορείτε να το κάνετε μόνο με ένα αρχείο JSON αντιγράφου ασφαλείας. Μπορείτε να χρησιμοποιήσετε τα αρχεία που αποθηκεύτηκαν όταν δημιουργήσατε τους λογαριασμούς.\\n\\nΜπορείτε να πάρετε αυτά τα αρχεία ξανά δημιουργώντας ένα αρχείο αντιγράφου ασφαλείας του λογαριασμού. Πατήστε στις τρεις τελείες στον λογαριασμό σας, επιλέξτε `Create a backup file for this account` και πληκτρολογήστε τον κωδικό πρόσβασής σας.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Ανοίξτε μια επέκταση και πατήστε το κουμπί `+` στην πάνω δεξιά γωνία, στη συνέχεια επιλέξτε `Restore account from backup JSON file`.\\n\\n2. Σε ένα ανοιχτό παράθυρο ανεβάστε το αρχείο JSON, εισαγάγετε τον κωδικό πρόσβασης και πατήστε `Restore`.\\n\\n3. Βεβαιωθείτε ότι ο δικτυακός τόπος Robonomics είναι επιλεγμένος για τους λογαριασμούς στην επέκταση Polkadot.js. Στον δικτυακό τόπο Polkadot / Substrate Portal πηγαίνετε στις `Setting` -> `Metadata` και κάντε κλικ στο κουμπί `Update metadata`.\\n\\n4. Επιβεβαιώστε την ενημέρωση των μεταδεδομένων στο αναδυόμενο παράθυρο. Τώρα η επέκταση θα εμφανίζει την ετικέτα του δικτύου για το οποίο χρησιμοποιείται η διεύθυνση.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Ενεργοποίηση Συνδρομής Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nΓια αυτό το βήμα, πρέπει να έχετε επαρκή ποσότητα κερμάτων XRT (ελάχιστα 2-3 XRTs) στον λογαριασμό `sub_owner` σας.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Πηγαίνετε στην εφαρμογή Robonomics στη [σελίδα συνδρομής](https://dapp.robonomics.network/#/subscription) και πατήστε σύνδεση λογαριασμού στη δεξιά πλευρά.\\n\\n2. Στο αναδυόμενο μενού συνδέστε την επέκταση Polkadot.js. Θα δείτε τη διεύθυνση ου λογαριασμού σας με το υπόλοιπο.\\n\\n3. Πριν αγοράσετε, ελέγξτε ότι επιλέξατε τον λογαριασμό `sub_owner`. Πατήστε το εικονίδιο προφίλ της διεύθυνσης, θα πρέπει να δείτε τον λογαριασμό `sub_owner` κάτω από το πεδίο `Check owner account`.\\n\\n4. Τέλος, πατήστε το κουμπί `SUBMIT` και εισαγάγετε τον κωδικό πρόσβασης για τον λογαριασμό σας. Μετά από αυτό περιμένετε μέχρι να ολοκληρωθεί η διαδικασία ενεργοποίησης. Θα δείτε την κατάσταση της συνδρομής σας μετά από λίγο.\\n\\n\\n## Προσθήκη Λογαριασμών στη Συνδρομή\\n\\nΤώρα πρέπει να προσθέσετε έναν λογαριασμό «sub_controller» στη **λίστα πρόσβασης**. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Ανοίξτε την επέκταση και κάντε κλικ στο εικονίδιο κοντά στο όνομα του λογαριασμού. Αυτό θα αντιγράψει τη διεύθυνση του λογαριασμού.\\n\\n\\n2. Επικολλήστε αυτήν τη διεύθυνση στο πεδίο `Robonomics parachain address` στο τμήμα **Διαχείριση πρόσβασης**. Δώστε του ένα όνομα και πατήστε το κουμπί `+`. \\n\\n3. Επαναλάβετε τα βήματα 1 και 2 για τον λογαριασμό `sub_owner`.\\n\\n4. Πατήστε `Save`. Εισαγάγετε τον κωδικό πρόσβασης του `sub_owner` σας στο αναδυόμενο παράθυρο και περιμένετε μέχρι να ολοκληρωθεί η διαδικασία ενεργοποίησης.\\n\"}},{\"node\":{\"id\":\"10af15b764d890db1d9d69ad15198dc3\",\"title\":\"Λήψη Τηλεμετρίας Έξυπνου Σπιτιού\",\"path\":\"/docs/el/smart-home-telemetry/\",\"content\":\"\\n**Σε αυτό το άρθρο, θα χρησιμοποιήσετε την υπηρεσία Robonomics, η οποία επερωτά την τηλεμετρία των συσκευών έξυπνου σπιτιού.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Πηγαίνετε στο dapp και επλέξτε την υπηρεσία [Τηλεμετρία Έξυπνου Σπιτιού](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. Στο πεδίο ελέγχου εισαγάγετε τη διεύθυνση `SUB_CONTROLLER`. Εισαγάγετε τη φράση σπόρου για την κρυπτογράφηση των δεδομένων.\\n\\n3. Στο μπλοκ `Get telemetry` επιλέξτε ένα χρονικό σημείο από την αναπτυσσόμενη λίστα και πατήστε το κουμπί `DOWNLOAD TELEMETRY`.\\n\\n4. Η λήψη της τηλεμετρίας μπορεί να διαρκέσει κάποιο χρόνο. Αφού ολοκληρωθεί, θα δείτε τις πληροφορίες από τις συσκευές και τους αισθητήρες σας.\\n\\n\\n<!---\\n## Εκκίνηση devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Εκκίνηση\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nΕκκίνηση command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"a635589d8a28d210cec9931b3a30696b\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/el/sls-gateway/\",\"content\":\"\\n**Σε αυτό το άρθρο θα ρυθμίσετε το Robonomics SLS Gateway. Θα εγκαταστήσετε το απαιτούμενο λογισμικό για την πύλη, θα το διαμορφώσετε και θα το συνδέσετε με το Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nΠρώτα πρέπει να εγκαταστήσετε το λογισμικό του μικροελεγκτή της πύλης. Προετοιμάστε την πύλη ρυθμίζοντας τις διακόπτες `1` και `3` στο κάτω μέρος του SLS Gateway σε `ON`, οι υπόλοιποι πρέπει να είναι `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nΣυνδέστε την πύλη στο Raspberry Pi σας μέσω της θύρας USB τύπου C στην πύλη.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nΚλωνοποιήστε το αποθετήριο με το λογισμικό στο Raspberry Pi σας:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nΜεταβείτε στο `robonomics-hass-utils/esp_firmware/linux`. Για να αναβαθμίσετε την πύλη SLS, πρέπει να εκτελέσετε τα σενάρια `Clear` και `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Επίλυση Προβλημάτων\\n\\nΕάν αντιμετωπίζετε προβλήματα κατά την ενημέρωση του λογισμικού της πύλης, πρέπει να ακολουθήσετε επιπλέον βήματα:\\n\\n1. Βεβαιωθείτε ότι έχετε εγκαταστήσει το πρόσθετο pySerial:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Δώστε στον χρήστη σας δικαιώματα πρόσβασης στη θύρα USB και επανεκκινήστε τον υπολογιστή:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. Σε ορισμένες περιπτώσεις, είναι απαραίτητο να αλλάξετε τη ρύθμιση της εύρους ζώνης στο σενάριο για την ενημέρωση του λογισμικού. Ανοίξτε το σενάριο `Flash_16mb.sh` με τον επεξεργαστή κειμένου `nano` και αλλάξτε την παράμετρο baud από `921600` σε μικρότερη τιμή (για παράδειγμα, `115200`).\\n\\n## Διαμόρφωση\\n\\n1. Αποσυνδέστε το SLS Gateway από τον υπολογιστή. Ρυθμίστε τους διακόπτες στο πίσω μέρος της πύλης στη σωστή θέση. Οι διακόπτες `5` (RX Zigbee προς ESP) και `6` (TX Zigbee προς ESP) πρέπει να είναι στη θέση `ON`, οι υπόλοιποι πρέπει να είναι `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Συνδέστε το καλώδιο τροφοδοσίας τύπου C. Το φωτεινό ένδειγμα στο κέντρο πρέπει να γίνει πράσινο.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. Κατά την πρώτη εκκίνηση, η πύλη θα αρχίσει να μοιράζεται Wi-Fi με το SSID `zgw****`. Συνδεθείτε σε αυτό το δίκτυο. Να έχετε υπόψη ότι το σήμα μπορεί να είναι αρκετά αδύναμο, επομένως είναι καλτερο να κρατήσετε την πύλη SLS κοντά στον υπολογιστή σας. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Εάν η σύνδεση είναι επιτυχής, η διεπαφή ιστού θα ανοίξει (ή μπορείτε να τη βρείτε στη διεύθυνση 192.168.1.1). \\n\\n5. Θα δείτε τη σελίδα `Wi-Fi Settings`. Επιλέξτε το Wi-Fi σας και εισαγάγετε τον κωδικό πρόσβασης. Πατήστε το κουμπί `Apply`. Η πύλη θα επανεκκινήσει και θα συνδεθεί στο δίκτυο Wi-Fi σας. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Βρείτε την τοπική IP της πύλης SLS για να αποκτήσετε πρόσβαση στη διεπαφή ιστού. Για να το βρείτε, μπορείτε να χρησιμοποιήσετε την εφαρμογή κινητού [Fing](https://www.fing.com/products) ή το εργαλείο γραμμής εντολών [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Το όνομα της πύλης πρέπει να φαίνεται όπως αυτό: `zgw****`. Ανοίξτε τη διεπαφή ιστού της πύλης επικολλώντας την IP της πύλης στον περιηγητή.\\n\\n7. Πηγαίνετε στο `Setting` -> `Hardware` και βεβαιωθείτε ότι οι ρυθμίσεις φαίνονται όπως στην εικόνα. Διορθώστε τις ρυθμίσεις αν είναι απαραίτητο και κάντε κλικ στο κουμπί `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nΟ πίνακας με τις απαιτούμενες τιμές:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Στη συνέχεια επανεκκινήστε την πύλη. Επιλέξτε  `Actions` -> `Reboot system` στην πάνω δεξιά γωνία.\\n\\n9. Βεβαιωθείτε ότι η πύλη λειτουργεί σωστά στο παράθυρο πληροφοριών Zigbee. Η κατάσταση της συσκευής πρέπει να είναι `OK`.\\n\\n10. Διαμορφώστε την αυτόματη προσθήκη συσκευών στο Home Assistant. Πηγαίνετε στο  `Zigbee` -> `Config` και επιλέξτε `Home Assistant MQTT Discovery` και `Clear States`. Αποθηκεύστε τις αλλαγές και ξανα**επανεκκινήστε** την πύλη SLS.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nΕάν ήδη έχετε μια ενεργή πύλη SLS στο σπίτι σας και τώρα διαμορφώνετε μια άλλη, τότε θα συγκρουστούν εταξύ τους. Για να λύσετε αυτό το πρόβλημα, πρέπει να αλλάξετε το κανάλι στη νέα συσκευή. Για να το κάνετε αυτό, πηγαίνετε στο `Zigbee` -> `Config`  και αλλάξτε το κανάλι σε ένα άλλο (π.χ. κανάλι 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Σύζευξη SLS με MQTT\\n\\nΜετά τη διαμόρφωση της πύλης SLS, πρέπει να συνδέσετε την πύλη SLS με το Home Assistant. Ανοίξτε τη διεπαφή ιστού της πύλης SLS και πηγαίνετε στο `Settings/Link` -> `MQTT Setup`:\\n\\n\\nΠροσθέστε τη διεύθυνση του μεσολαβητή (διεύθυνση του Raspberry Pi με το Home Assistant στο τοπικό δίκτυο, μπορείτε να το βρείτε με την εφαρμογή κινητού [Fing](https://www.fing.com/products) ή το εργαλείο γραμμής εντολών [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), τη θύρα (η προεπιλεγμένη είναι `1883`), το όνομα χρήστη και ο κωδικός πρόσβασης του μεσολαβητή (το οποίο έχετε δημιουργήσει προηγουμένως) και το όνομα του θέματος (μπορείτε να επιλέξετε οποιοδήποτε). Επίσης, η IP διεύθυνση του Raspberry Pi πρέπει να είναι στατική. Κάντε κλικ στο  `Enable` και `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nΑποθηκεύστε τις αλλαγές. Τώρα οι συσκευές θα εμφανίζονται αυτόματα στο Home Assistant.\\n\\n## Σύνδεση Συσκευών\\n\\nΣυνδέστε τις συσκευές σας πηγαίνοντας στο `Zigbee` -> `Join`. Βάλτε τους αισθητήρες σας σε λειτουργία σύζευξης, ο πιο κοινός τρόπος να μεταβείτε μια συσκευή σε λειτουργία σύνδεσης είναι να κρατήσετε πατημένο το κουμπί λειτουργίας ή να τα ενεργοποιήσετε/απενεργοποιήσετε 5 φορές. Πατήστε το κουμπί `Enable Join` για να ξεκινήσει η αναζήτηση συσκευών Zigbee. Θα δείτε ενεργοποιημένους αισθητήρες.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nΤώρα μπορείτε να μεταβείτε στην ενότητα [**Συνδρομή IoT**](/docs/sub-activate) και να ξεκινήσετε την ενεργοποίηση της συνδρομής Robonomics.\\n\"}},{\"node\":{\"id\":\"dedc679c2c8ca6b66049388d95fc51bb\",\"title\":\"Αποκεντρωμένο Δίκτυο Αισθητήρων\",\"path\":\"/docs/el/sensors-network-introduction/\",\"content\":\"\\nΤα άρθρα σχετικά με το Αποκεντρωμένο Δίκτυο Αισθητήρων μεταφέρθηκαν στην Ακαδημία Robonomics: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"05c734186d4dc299d068d280c57945bf\",\"title\":\"Ασφαλής σύνδεση της τεχνητής νοημοσύνης στον νέφος με το εργοστάσιο\",\"path\":\"/docs/el/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nΟι τεχνολογίες της ρομπονομίας μπορούν ήδη να λύσουν τις προκλήσεις που αντιμετωπίζει η Βιομηχανία 4.0 και έχουν ήδη εφαρμοστεί σε πραγματικά περιβάλλοντα σε βιομηχανικό περιβάλλον.\\n\\nΈνας μεγάλος αριθμός εταιρειών τεχνητής νοημοσύνης δημιουργούν λύσεις για τη βελτιστοποίηση των διεργασιών στο εργοστάσιο, επιτρέποντας στα εργοστάσια να παράγουν περισσότερα με λιγότερο κόστος. Ωστόσο, τα περισσότερα εργοστάσια είναι διστακτικά να συνδέσουν την υποδομή τους με το νέφος απευθείας, καθώς αυτό οδηγεί σε δυνητικούς κυβερνοασφαλειακούς κινδύνους, οι οποίοι μπορεί να οδηγήσουν σε απώλειες εκατομμυρίων δολαρίων και ακόμα και στην απώλεια ανθρώπινων ζωών.\\n\\n[MerkleBot](https://merklebot.com) χρησιμοποίησε το [Robonomics Network](https://robonomics.network) για να δημιουργήσει μια λύση για βιομηχανικούς πελάτες για να συνδέσουν το εργοστάσιό τους με την τεχνητή νοημοσύνη που βασίζεται το νέφος με ασφάλεια.\\n\\nΑυτό το άρθρο γράφτηκε μετά από ένα πείραμα που διεξήγαγε το [Veracity Protocol](https://www.veracityprotocol.org/) που χρησιμοποιεί αλγόριθμους για να δημιουργήσει μη επεμβατική προστασία οποιουδήποτε φυσικού αντικειμένου με βάση τις φωτογραφίες από ένα κινητό τηλέφωνο.\\n\\nΑυτή η περίπτωση χρήσης δείχνει τη διαδικασία σάρωσης των βιομηχανικών εξαρτημάτων χρησιμοποιώντας ένα ρομποτικό χέρι.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Διαδικασία βήμα προς βήμα\\n\\n### Η DApp λειτουργεί ως διεπαφή χρήστη\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nΗ DApp λειτουργεί ως διεπαφή χρήστη για τον χειριστή. Χρησιμοποιείται για να ζητήσει την εκκίνηση του ρομπότ για τη συλλογή των φωτογραφιών και ο σκοπός της είναι να επιτρέψει την ασφαλή επικοινωνία μεταξύ του εργοστασιακού περιβάλλοντος και της τεχνητής νοημοσύνης που βασίζεται στο νέφος.\\n\\n### Εκκίνηση του ρομπότ\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nΟ χειριστής εκκινεί τη ρομποτική σάρωση υπογράφοντας τη συναλλαγή στη DApp. Αυτό το βήμα εγγυάται ότι η διαδικασία στο εργοστάσιο μπορεί να ξεκινήσει μόνο βάσει της συναλλαγής στη δημόσια αλυσίδα.\\n\\nΤο ρομπότ λαμβάνει μια εντολή από την αλυσίδα μπλοκ μέσω του Robonomics Network και ξεκινά τη σάρωση. Οι τεχνολογίες του Robonomics Network μας επιτρέπουν να κλείσουμε το χάσμα μεταξύ του επιχειρηματικού στόχου και της λειτουργίας της ρομποτικής.\\n\\n### Συλλογή δεδομένων και αποστολή στην τεχνητή νοημοσύνη που βασίζεται στο νέφος\\n\\nΣτη DApp ο χειριστής βλέπει την επιβεβαίωση και το ρομπότ αρχίζει να σαρώνει τα αντικείμενα που τοποθετούνται στο τραπέζι, όπως σε αυτήν την περίπτωση, ή απευθείας στη γραμμή παραγωγής του εργοστασίου αν υπάρξει ανάγκη.\\n\\n<!-- ![](../images/Veracity_Protocol_Εκκίνηση.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Εκκίνηση.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nΌταν ο ρομπότ συλλέγει τα δεδομένα, τα αποθηκεύει τοπικά και τα καθιστά διαθέσιμα στην AI βασισμένη στο cloud μέσω του πρωτοκόλλου IPFS. Με την κρυπτογράφηση των δεδομένων και την οργάνωσ της ανταλλαγής δεδομένων μέσω μιας συναλλαγής blockchain, μπορούμε να εξουσιοδοτήσουμε την πρόσβαση στην AI βασισμένη στο cloud ενώ εξασφαλίζουμε ότι τα δεδομένα παραμένουν ασφαλή και στη θέση τους.\\n\\nΟ μηχανισμός ασφαλείας που ενσωματώνεται στο Robonomics βασίζεται στην κοινή ασφάλεια των δημόσιων blockchain και επιτρέπει την επίτευξη ενός επιπέδου ασφάλειας που είναι απαγορευτικά ακριβό για τις περισσότερες εργοστασιακές μονάδες να οργανώσουν μόνες τους.\\n\\n### Δημιουργία ψηφιακού διαβατηρίου\\n\\nΌταν η AI βασισμένη στο cloud αναλύει τα δεδομένα, το αρχείο καταγραφής και οι συστάσεις καταγράφονται αυτόματα ως [Ψηφιακό Διαβατήριο](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/). Κάθε λειτουργία και σάρωση μπορεί να ανιχνευθεί από την αρχή, καθώς η εγγραφή blockchain έει το hash για όλα αυτά τα αρχεία μέσω του πρωτοκόλλου IPFS.\\n\\n## Σχόλια για τη χρήση\\n\\nΣε αυτήν την περίπτωση χρησιμοποιήθηκε το βιομηχανικό χέρι Universal Robot UR3. Ωστόσο, χάρη στην υποστήριξη του Robonomics για το ROS, μπορούν να χρησιμοποιηθούν και να συνδεθούν με ασφάλεια οι περισσότεροι μεγάλοι βιομηχανικοί μανιπουλατόρ, συμπεριλαμβανομένων των KUKA, Fanuc και Yaskawa.\\n\\nΕάν ενδιαφέρεστε να μάθετε περισσότερα για την ανάπτυξη και την ολοκλήρωση ασφαλών μέσων AI βασισμένων στο cloud, παρακαλούμε [επικοινωνήστε](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"182c0dc795ba2da86d442d2ddf943878\",\"title\":\"Πώς να προσθέσετε τον αισθητήρα SDS011 στο Home Assistant\",\"path\":\"/docs/el/sds-sensor-hass/\",\"content\":\"\\nΑυτό το άρθρο εξηγεί πώς να συνδέσετε τον αισθητήρα ποιότητας αέρα SDS με το [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) & [Robonomics](https://github.com/airalab/sensors-software) Λογισμκό ενσωματωμένου στο Home Assistant.\\n\\n## Εγκατάσταση \\nΥπάρχουν δύο επιλογές εγκατάστασης διαθέσιμες:\\n\\n### Επιλογή 1: HACS\\n\\nΟ ευκολότερος τρόπος για να προσθέσετε έναν τοπικό αισθητήρα Luftdaten είναι μέσω του HACS. [Εδώ](https://hacs.xyz/docs/setup/download/) μπορείτε να βρείτε μια σύντομη εξήγηση για το πώς να εγκαταστήσετε το HACS.\\n\\nΑφού εγκατασταθεί το HACS, μεταβείτε στο HACS -> Ενσωματώσεις και αναζητήστε την ενσωμάτωση `Local Luftdaten Sensor`. Κάντε κλικ στο κουμπί λήψης και επανεκκινήστε το Home Assistant μόλις ολοκληρωθεί η λήψη της ενσωμάτωσης.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Επιλογή 2: Χειροκίνητη εγκατάσταση\\n\\nΥπό τον χρήστη homeassistant, κλωνοποιήστε το αποθετήριο του έργου:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nΕάν ήδη έχετε οποιεσδήποτε προσαρμοσμένες ενσωματώσεις, αντιγράψτε τον φάκελο `custom_components/local_luftdaten/` στον φάκελο `custom_components` σας, για παράδειγμα:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nΕάν δεν έχετε αμία προσαρμοσμένη ενσωμάτωση, αντιγράψτε ολόκληρο τον φάκελο `custom_components` στον κατάλογο διαμόρφωσης του Home Assistant σας. Για παράδειγμα:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Διαμόρφωση\\n\\nΔημιουργήστε μια νέα καταχώριση αισθητήρα στο `configuration.yaml` σας και προσαρμόστε το όνομα του υπολογιστή ή τη διεύθυνση IP. Για να βρείτε την τοπική διεύθυνση IP του αισθητήρα σας, μπορείτε να χρησιμοποιήσετε την εφαρμογή κινητού [Fing](https://www.fing.com/products) ή το εργαλείο γραμμής εντολών [nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Το όνομα μπορεί να είναι οποιοδήποτε.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> Μπορείτε να βρείτε τη λίστα όλων των υποστηριζόμενων αισθητήρων στο [αποθετήριο](https://github.com/lichtteil/local_luftdaten).\\n\\nΕπανεκκινήστε το Home Assistant σας.\\nΜετά από αυτό, μπορείτε να προσθέσετε τον αισθητήρα στον πίνακα ελέγχου σας. Το όνομα του στοιχείου θα είναι το όνομα που προσθέσατε στο `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"03f28621a3d474042567c6b997e85ae6\",\"title\":\"Πώς να συνδέσετε τον αισθητήρα SDS011\",\"path\":\"/docs/el/sds-sensor-connect/\",\"content\":\"\\n** Εδώ υπάρχει ένας οδηγός βήμα προς βήμα για το πώς να συνδέσετε τον αισθητήρα σας στο Δίκτυο Αισθητήρων Robonomics. Οι αισθητήρες μας χρησιμοποιούν το firmware του Robonomics, το οποίο είναι μια βελτιωμένη έκδοση του firmware του sensor.community. Περιλαμβάνει επιπλέον αισθητήρες και έχει έναν τροποποιημένο μηχανισμό αποστολής δεδομένων. **\\n\\n1. Συνδέστε τον αισθητήρα στην πρίζα για να τον τροφοδοτήσετε.\\n2. Το πίνακας θα δημιουργήσει ένα δίκτυο Wi-Fi με το όνομα `RobonomicsSensor-xxxxxxxxx`. Συνδεθείτε σε αυτό από το τηλέφωνο ή τον υπολογιστή σας: θα δείτε το παράθυρο εξουσιοδότησης (αν δεν το δείτε, ανοίξτε τον περιηγητή και μεταβείτε στη διεύθυνση `192.168.4.1`).\\n3. Επιλέξτε το δίκτυο Wi-Fi σας από τη λίστα (ή γράψτε το μόνοι σας αν δεν είναι στη λίστα) και συμπληρώστε το πεδίο κωδικού πρόσβασης.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nΟ αισθητήρας μπορεί να συνδεθεί μόνο σε δίκτυο Wi-Fi 2,4 GHz.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Γράψτε τις συντεταγμένες του μέρους όπου θα εγκατασταθεί ο αισθητήρας. Μπορείτε να τις αποκτήσετε από οποιοδήποτε χάρτη ή να τις αποκτήσετε από τη διεύθυνση χρησιμοποιώντας [αυτόν το σύνδεσμο.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nΟι συντεταγμένες του αισθητήρα θα εμφανιστούν σε έναν δημόσια διαθέσιμο χάρτη. Αν δεν θέλετε να εμφανίζονται οι προσωπικές σας πληροφορίες, γράψτε κοντά, αλλά όχι ακριβείς συντεταγμένες.\\n</robo-wiki-note> \\n5. Κάντε κλικ στο `Save configuration and restart`. Ο πίνακας θα επανεκκινήσει και θα συνδεθεί στο καθορισμένο δίκτυο Wi-Fi.\\n6. Ανοίξτε το [χάρτη αισθητήρων Robonomics](https://sensors.robonomics.network/#/) και βρείτε τον τόπο όπου εγκαταστήσατε τον αισθητήρα. Σε λίγα λεπτά θα μπορείτε να δείτε τον αισθητήρα σας με δεδομένα στο χάρτη.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"101b0155759687f78ca345b9e7480969\",\"title\":\"Πώς να εκτελέσετε τον κόμβο ανάπτυξης του Robonomics\",\"path\":\"/docs/el/run-dev-node/\",\"content\":\"\\n** Για να δοκιμάσετε τις εφαρμογές σας στο Robonomics μπορεί να θέλετε να το εκτελέσετε σε λειτουργία ανάπτυξης. Αυτό το άρθρο δείχνει βήμα προς βήμα \\nοδηγίες για το πώς να αποκτήσετε τη δική σας τοπική δοκιμαστική περίπτωση του Robonomics. **\\n\\n\\n## Λήψη δυαδικού κόμβου\\n\\n1. Πρώτα, χρειάζεστε ένα δυαδικό αρχείο, κατεβάστε το αρχείο απόσυμπιέστε το αρχείο από την τελευταία [έκδοση](https://github.com/airalab/robonomics/releases).\\n\\n2. Πλοηγηθείτε στον φάκελο του αρχείου, αποσυμπιέστε το δυαδικό και αλλάξτε τα δικαιώματα:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Εκτέλεση\\n\\nΕκτελέστε τον κόμβο με:\\n\\n```bash\\n./robonomics --dev\\n```\\nΘα δείτε την παρακάτω έξοδο:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Εάν θέλετε να απαλείψετε υπάρχουσες μπλοκ, μπορείτε να το κάνετε αυτό αφαιρώντας το RocksDB από `/tmp/substrate******/chains/dev/db/full`.\\n  Αντικαταστήστε το `******` με τον αντίστοιχο αναγνωριστικό που εμφανίζεται στα αρχεία καταγραφής κατά την εκκίνηση.\\n\\n  Εάν θέλετε να ξεκινήσετε τον κόμβο από την αρχή κάθε φορά, χρησιμοποιήστε τη σημαία `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Σύνδεση\\n\\nΤώρα μπορείτε να συνδεθείτε στον τοπικό σας κόμβο μέσω του [Polkadot Portal](https://polkadot.js.org/apps/#/explorer).\\n\\nΑλλάξτε το δίκτυο σε `Local Node` στην πάνω αριστερή γωνία και πατήστε `Swtitch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nΚαλώς ήλθατε στην τοπική περίπτωση του Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"e2cf3d5aefab18bdb66dee9205227fc3\",\"title\":\"Υπηρεσία Βίντεο Robonomics\",\"path\":\"/docs/el/robonomics-video/\",\"content\":\"\\nΑυτό το άρθρο δείχνει πώς να προσθέσετε μια κάμερα IP στο Home Assistant και να στέλνετε βίντεο στην Υπηρεσία Ιστού Robonomics.\\n\\nΓια να συνδέσετε μια κάμερα στο Home Assistant, ρέπει να γνωρίζετε τη διεύθυνση IP της και να δημιουργήσετε ένα τοπικό λογαριασμό κάμερας για να συνδεθείτε στη ροή RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nΔεδομένου ότι αυτό γίνεται διαφορετικά για κάθε κάμερα, αυτή η διαδικασία δεν λαμβάνεται υπόψη σε αυτό το άρθρο.\\n</robo-wiki-note>\\n\\nΑπαιτήσεις:\\n- Κάμερα IP\\n- Διαμορφωμένος τοπικός λογαριασμός κάμερας\\n- Διεύθυνση IP της κάμερας\\n- Ρυθμισμένο Home Assistant\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nΑυτό το άρθρο υποθέτει ότι έχετε μια γενική κάμερα IP χωρίς επιλογές RTZ (περιστροφή, κλίση, ζουμ). \\nΑν έχετε μια κάμερα RTZ, ελέγξτε το άρθρο \\\"Κάμερα RTZ\\\" (/docs/ptz-camera). Και στη συνέχεια επιστρέψτε στο δεύτερο βήμα εδώ.\\n\\n</robo-wiki-note>\\n\\n## Συνδέστε την Κάμερα\\n\\nΠρώτα, πρέπει να μάθετε τη διεύθυνση URL για τη ροή RTSP της κάμερας. \\nΓια να το κάνετε αυτό, δοκιμάστε να εισάγετε τον παρακάτω ερώτημα στο Διαδίκτυο: \\\"<ΟΝΟΜΑ_ΚΑΜΕΡΑΣ> ροή RTSP\\\".\\nΗ διεύθυνση URL της ροής πρέπει να ξεκινά με `rtsp://<Διεύθυνση_IP>...`. \\n\\nΑυτό το άρθρο χρησιμοποιεί μια κάμερα \\\"Tapo\\\" και η διαδρομή της ροής είναι `rtsp://<Διεύθυνση_IP>/stream1`.\\n\\nΑνοίξτε το Home Assistant και πηγαίνετε στις \\\"Settings\\\"-> \\\"Devices & Services\\\". Πατήστε το κουμπί \\\"ADD INTEGRATION\\\"  και\\nαρχίστε να πληκτρολογείτε την ενσωμάτωση \\\"Generic Camera\\\". Επιλέξτε την.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nΣτο παράθυρο διαμόρφωσης παρέχετε τις ακόλουθες πληροφορίες:\\n- Stream Source URL - Η διεύθυνση URL της ροής RTSP της κάμερας\\n- Username - γράψτε ένα όνομα χρήστη για τον τοπικό λογαριασμό της κάμερας σας\\n- Password - γράψτε έναν κωδικό πρόσβασης για τον τοπικό λογαριασμό της κάμερας σας\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nΚάντε κύλιση προς τα κάτω στις ρυθμίσεις και πατήστε το κουμπί Submit\\\".\\n\\nΣτο παράθυρο προεπισκόπησης ενεργοποιήστε το πλαίσιο ελέγχου \\\"This image looks good.\\\" και πατήστε το κουμπί \\\"Submit\\\". Στη συνέχεια - \\\"Finish\\\".\\n\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Προσθέστε στον πίνακα ελέγχου\\n\\nΕπιπλέον, μπορείτε να προσθέσετε τη ροή στον πίνακα ελέγχου σας. Για να το κάνετε αυτό, πλοηγηθείτε στον πίνακα ελέγχου και δημιουργήστε ένα νέο καρτέλα \\n\\\"Picture Glance\\\". Επιπλέον βήματα:\\n- εισαγάγετε το \\\"Τίτλο\\\" που θέλετε\\n- διαγράψτε τα δεδομένα από το \\\"Image Path\\\"\\n- επιλέξτε την κάμερα στο \\\"Camera Entity\\\"\\n- στην \\\"Camera View\\\", επιλέξτε \\\"live\\\" ώστε να υπάρχει λιγότερη καθυστέρηση\\n\\nΚαι αποθηκεύστε το.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Ελέγξτε τον φάκελο πολυμέσων\\n\\nΠριν αποσταλεί στην υπηρεσία βίντεο Robonomics, το βίντεο πρέπει να αποθηκευτεί σε έναν φάκελο και ο Βοηθός Οικίας πρέπει να έχει πρόσβαση σε αυτόν τον φάκελο. \\nΗ πιο εύκολη επιλογή σε αυτήν την περίπτωση είναι να χρησιμοποιήσετε ένα πακέτο πολυμέσων, στον οποίο το Home Assistant αποθηκεύει όλα τα πολυμέσα.\\n\\n- Εάν χρησιμοποιείτε HAOS ή προεγκατεστημένη εικόνα, το Home Assistant **έχει ήδη φάκελο πολυμέσων**.\\n- Εάν χρησιμοποιείτε το Home Assistant Core, πρέπει να μεταβείτε στον φάκελο `.homeassistant` και να δημιουργήσετε έναν φάκελο `media` μέσα σε αυτόν.\\n- Εάν χρησιμοποιείτε το Home Assistant Docker, προσθέστε τη γραμμή ` -v /PATH_TO_YOUR_MEDIA:/media \\\\` στην εντολή Docker.\\n\\nΓια να ελέγξετε ότι όλα έχουν ρυθμιστεί σωστά, μεταβείτε στην καρτέλα “Media” -> “local media” στο Home Assistant σας. \\nΘα πρέπει να δείτε έναν κενό φάκελο (χωρίς σφάλματα):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Κλήση Υπηρεσίας\\n\\nΓια να στείλετε ένα βίντεο στο Robonomics, πρέπει να καλέσετε μια αφιερωμένη υπηρεσία στο Home Assistant. \\nΣε αυτό το άρθρο γίνεται αυτό με το χέρι, αλλά μπορείτε να δημιουργήσετε μια αυτοματισμό για αυτό.\\n\\nΓια να το κάνετε αυτό, πηγαίνετε στο \\\"Developer tools\\\" -> \\\"Services\\\" και βρείτε \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nΣτους \\\"Targets\\\" επιλέξτε την οντότητα της κάμερας σας.\\nΣτο \\\"Path to save the recording\\\" πρέπει να παρέχετε μια απόλυτη διαδρομή προς τον φάκελο,\\nόπου το Home Assistant μπορεί να αποθηκεύσει το βίντεο:\\n- Για προεγκατεστημένη εικόνα - `/home/homeassistant/.homeassistant/media`;\\n- Για HA OS ή Home Assistant Docker- `/media`;\\n- Για Home Assistant Core - Διαδρομή προς τον προηγουμένως δημιουργημένο φάκελο πολυμέσων.\\n\\nΕπιπλέον, μπορείτε να επιλέξετε τη Διάρκεια εγγραφής. \\n\\nΣυμπληρώστε τα δεδομένα και καλέστε την υπηρεσία με το κουμπί  \\\"CALL SERVICE\\\".\\n\\n## DAPP\\n\\nΓια να δείτε το αποτέλεσμα του βίντεο, μεταβείτε στο [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nΕπικολλήστε τη διεύθυνση λογαριασμού του ελεγκτή σας και κάντε κλικ στο κουμπί παρακάτω. Περιμένετε για τη διαδικασία \\\"Search for Twins\\\".\\nΩς αποτέλεσμα, θα λάβετε ένα IPFS CID με όλα τα καταγεγραμμένα βίντεο.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nΣτη συνέχεια, επιλέξτε τον λογαριασμό του ελεγκτή (ή οποιονδήποτε άλλο) από τη λίστα αναπτυσσόμενου μενού και υπογράψτε ένα μήνυμα για εξουσοδότηση στην\\nπύλη Web3 IPFS για να κατεβάσετε όλα τα βίντεο. Ως αποτέλεσμα, θα λάβετε όλα τα βίντεο που έχουν καταγραφεί από το έξυπνο σπίτι σας.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nΕφόσον όλα τα βίντεο στον φάκελο είναι κρυπτογραφημένα με το κλειδί του ελεγκτή, πρέπει να το εισαγάγετε για να αποκρυπτογραφήσετε τα βίντεο.\\nΜετά από αυτό, το κουμπί αναπαραγωγής βίντεο ενεργοποιείται. Κάντε κλικ για να κατεβάσετε το βίντεο.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"36b427cee4bd2cd61d82410497386393\",\"title\":\"Επισκόπηση του Έξυπνου Σπιτιού Robonomics\",\"path\":\"/docs/el/robonomics-smart-home-overview/\",\"content\":\"\\n## Ασφαλής IoT με τη Χρήση Αλυσίδας Μπλοκ \\n\\nΓια το έξυπνο σπίτι σας, ο σύγχρονος αγορά IoT παρέχει μια μεγάλη ποικιλία λύσεων. Ωστόσο, συνήθως είστε δεμένοι με κεντρικούς παρόχους νέφους ή ακριβές ιδιόκτητες πύλες. Ως αποτέλεσμα, εσείς ως χρήστης εξαρτάστε πάντα από τον προμηθευτή υλικού και υποδομής για να λειτουργήσει το έξυπνο σας σύστημα. Ταυτόχρονα, το έξυπνο σπίτι σας δεν μπορεί να είναι πραγματικά έξυπνο χωρίς στατιστικά στοιχεία και αναλύσεις νέφους.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Βλέπουμε δύο κύρια προβλήματα με τα τρέχοντα έξυπνα σπίτια:**\\n\\n1. Δεν έχετε έλεγχο επί των δεδομένων που μοιράζεστε με τον προμηθευτή ή τρίτους.\\n2. Το έξυπνο σπίτι σας είναι ευάλωτο σε απενεργοποιήσεις κεντρικών διακομιστών νέφους. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nΓια να λύσετε και τα δύο προβλήματα, σας προτείνουμε να δοκιμάσετε το Robonomics, το **ασφαλές**, **ανεξάρτητο από διακομιστές** και **μελλοντικό** αποκεντρωμένο νέφος μας.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Βήματα για ένα ανεξάρτητο από εταιρείες νέφος\\n\\nΕδώ υπάρχουν μερικά απλά βήματα για να δημιουργήσετε ένα οικονομικό έξυπνο σπίτι χρησιμοποιώντας το Home Assistant ως εφαρμογή επικοινωνίας με τις συσκευές και το Robonomics ως ανεξάρτητο από εταιρείες, αποκεντρωμένο νέφος. Το Robonomics εκμεταλλεύεται σύγχρονες και ασφαλείς τεχνολογίες Web3, εξασφαλίζοντας βελτιωμένη ασφάλεια καθ' όλη τη διαδικασία.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Ξεκινήστε εδώ το έξυπνο σπίτι σας\\n\\nΈχουμε ετοιμάσει λεπτομερείς οδηγούς για την εγκατάσταση ενός έξυπνου σπιτιού στο Robonomics. Τα βήματα μπορεί να διαφέρουν ανάλογα με την συγκεκριμένη κατάστασή σας: εάν ήδη έχετε λειτουργικό Home Assistant με συζευγμένες συσκευές ή αν ξεκινάτε από την αρχή για να δημιουργήσετε το έξυπνο σας σπίτι.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/el/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/el/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"ef8660fdef9eb55441b68273529c2880\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/el/robonomics-prometheus-grafana/\",\"content\":\"\\n**Οι παρακάτω οδηγίες παρέχονται από τον [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**Το αρχικό άρθρο βρίσκεται [εδώ](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Εισαγωγή\\nΓια να παρακολουθείτε και να διατηρείτε καλύτερα τον κόμβο(ους) του Robonomics, είναι καλό να ρυθμίσετε ένα σύστημα παρακολούθησης βασισμένο στον Prometheus Server και το Grafana. Αυτό το έγγραφο θα δείξει πώς να ρυθμίσετε κάθε ένα από αυτά για να παρακολουθείτε πλήρως τον κόμβο σας.\\n\\n##  Προαπαιτήσεις\\n* [Ρύθμιση διακομιστή με Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Εγκατεστημένος collator του Robonomics parachain](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Βεβαιωθείτε ότι έχετε το robonomics.service να λειτουργεί στη μηχανή σας και η θύρα 9615 είναι προσβάσιμη \\n\\n## Βήμα 1 — Δημιουργία Χρηστών Υπηρεσίας\\n\\nΓια λόγους ασφαλείας, θα ξεκινήσουμε δημιουργώντας δύο νέους λογαριασμούς χρηστών, τον prometheus και τον node_exporter. Δημιουργήστε αυτούς τους δύο χρήστες και χρησιμποιήστε τις επιλογές _--no-create-home_ και _--shell /bin/false_ ώστε αυτοί οι χρήστες να μην μπορούν να συνδεθούν στον διακομιστή.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nΠριν κατεβάσουμε τα δυαδικά αρχεία του Prometheus, δημιουργήστε τους απαραίτητους φακέλους για την αποθήκευση των αρχείων και των δεδομένων του Prometheus. Ακολουθώντας τις τυπικές συμβάσεις του Linux, θα δημιουργήσουμε έναν φάκελο στο _/etc_ για τα αρχεία ρύθμισης του Prometheus και έναν φάκελο στο _/var/lib_ για τα δεδομένα του.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nΤώρα, ορίστε τον χρήστη και την ομάδα για τους νέους φακέλους στον χρήστη prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Βήμα 2 — Λήψη του Prometheus\\n\\nΠρώτα, κατεβάστε και αποσυμπιέστε την τρέχουσα σταθερή έκδοση του Prometheus στον προσωπικό σας φάκελο. Μπορείτε να βρείτε τα πιο πρόσφατα δυαδικά αρχεία στη [σελίδα λήψης του Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nΤώρα, αποσυμπιέστε το κατεβασμένο αρχείο.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nΑυτό θα δημιουργήσει έναν φάκελο με το όνομα prometheus-2.21.0.linux-amd64 που περιέχει δύο δυαδικά αρχεία (prometheus και promtool), τους φακέλους _consoles_ και _console_libraries_ που περιέχουν τα αρχεία της διεπαφής ιστού, μια άδεια χρήσης, μια ειδοποίηση και αρκετά παραδείγματα αρχείων.\\n\\nΑντιγράψτε τα δύο δυαδικά αρχεία στον φάκελο _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nΟρίστε τον χρήστη και την ομάδα για τα δυαδικά αρχεία στον χρήστη prometheus που δημιουργήθηκε στο Βήμα 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nΑντιγράψτε τους φακέλους consoles και _console_libraries_ στον φάκελο _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nΟρίστε τον χρήστη και την ομάδα για τους φακέλους στον χρήστη prometheus. Χρησιμοποιώντας τη σημαία -R θα διασφαλίσει ότι η ιδιοκτησία θα οριστεί και στα αρχεία μέσα στον φάκελο.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nΤώρα που έχει εγκατασταθεί ο Prometheus, θα δημιουργήσουμε τα αρχεία ρύθμισης και υπηρεσίας του για την προετοιμασία της πρώτης του εκτέλεσης.\\n\\n## Βήμα 3 — Ρύθμιση του Prometheus\\n\\nΣτον φάκελο _/etc/prometheus_, χρησιμοποιήστε το nano ή τον αγαπημένο σας επεξεργαστή κειμένου για να δημιουργήσετε ένα αρχείο ρύθμισης με το όνομα _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nΣτις γενικές ρυθμίσεις, ορίστε το προεπιλεγμένο διάστημα για τη συλλογή μετρήσεων. Σημειώστε ότι ο Prometheus θα εφαρμόσει αυτές τις ρυθμίσεις σε κάθε εξαγωγέα εκτός αν οι δικές του ρυθμίσεις αντικαταστήσουν τις γενικές.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nΑυτή η τιμή scrape_interval λέει στον Prometheus να συλλέγει μετρήσεις από τους εξαγωγείς του κάθε 15 δευτερόλεπτα, που είναι αρκετά για τους περισσότερους εξαγωγείς.\\nΤώρα, προσθέστε τον ίδιο τον Prometheus στη λίστα των εξαγωγέων για συλλογή με την ακόλουθη οδηγία scrape_configs:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nΟ Prometheus χρησιμοποιεί το _job_name_ για να επισημάνει τους εξαγωγείς σε ερωτήματα και γραφήματα, οπότε βεβαιωθείτε ότι επιλέγετε κάτι περιγραφικό εδώ.\\n\\nΕπιπλέον, καθώς ο Prometheus εξάγει σημαντικά δεδομένα για τον εαυτό του που μπορείτε να χρησιμοποιήσετε για την παρακολούθηση της απόδοσης και την εντοπισμό σφαλμάτων, έχουμε αντικαταστήσει την οδηγία scrape_interval από 15 δευτερόλεπτα σε 5 δευτερόλεπτα για πιο συχνές ενημερώσεις.\\n\\nΤέλος, ο Prometheus χρησιμοποιεί τις οδηγίες _static_configs_ και _targets_ για να προσδιορίσει πού εκτελούνται οι εξαγωγείς. Εφόσον αυτός ο συγκεκριμένος εξαγωγέας εκτελείται στον ίδιο διακομιστή με τον Prometheus ίδιο, μπορούμε να χρησιμοποιήσουμε το localhost αντί για μια διεύθυνση IP μαζί με την προεπιλεγμένη θύρα, 9090.\\n\\nΤο αρχείο διαμόρφωσής σας πρέπει να φαίνεται πλέον όπως αυτό:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nΑποθηκεύστε το αρχείο και κλείστε τον επεξεργαστή κειμένου σας.\\n\\nΤώρα, ορίστε την ιδιοκτησία χρήστη και ομάδας στο αρχείο διαμόρφωσης στον χρήστη prometheus που δημιουργήθηκε στο Βήμα 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nΜε την ολοκλήρωση της διαμόρφωσης, είμαστε έτοιμοι να δοκιμάσουμε τον Prometheus εκτελώντας τον για πρώτη φορά.\\n\\n## Βήμα 4 — Εκτέλεση του Prometheus\\n\\nΞεκινήστε τον Prometheus ως χρήστης _prometheus_, παρέχοντας τη διαδρομή τόσο για το αρχείο διαμόρφωσης όσο και για τον κατάλογο δεδομένων.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nΗ έξοδος περιέχει πληροφορίες σχετικά με την πρόοδο φόρτωσης του Prometheus, το αρχείο διαμόρφωσης και τις σχετικές υπηρεσίες. Επιβεβαιώνει επίσης ότι ο Prometheus ακούει στη θύρα _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nΕάν λάβετε ένα μήνυμα σφάλματος, ελέγξτε διπλά ότι χρησιμοποιήσατε σύνταξη YAML στο αρχείο διαμόρφωσής σας και στη συνέχεια ακολουθήστε τις οδηγίες που εμφανίζονται στην οθόνη για να επιλύσετε το πρόβλημα.\\n\\nΤώρα, διακόψτε τον Prometheus πατώντας _CTRL+C_, και στη συνέχεια ανοίξτε ένα νέο αρχείο υπηρεσίας _systemd_.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nΤο αρχείο υπηρεσίας λέει στο _systemd_ να εκτελέσει τον Prometheus ως χρήστη prometheus, με το αρχείο διαμόρφωσης που βρίσκεται στον κατάλογο _/etc/prometheus/prometheus.yml_ και να αποθηκεύει τα δεδομένα του στον κατάλογο _/var/lib/prometheus_. Αντιγράψτε το παρακάτω περιεχόμενο στο αρχείο:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nΤέλος, αποθηκεύστε το αρχείο και κλείστε τον επεξεργαστή κειμένου σας. Για να χρησιμοποιήσετε τη νεοδημιουργηθείσα υπηρεσία, επαναφορτώστε το systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nΤώρα μπορείτε να ξεκινήσετε τον Prometheus χρησιμοποιώντας την παρακάτω εντολή:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nΓια να βεβαιωθείτε ότι ο Prometheus εκτελείται, ελέγξτε την κατάσταση της υπηρεσίας.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nΗ έξοδος σας λέει την κατάσταση του Prometheus, τον αναγνωριστικό της κύριας διεργασίας (PID), τη χρήση μνήμης και άλλα.\\n\\nΕάν η κατάσταση της υπηρεσίας δεν είναι ενεργή, ακολουθήστε τις οδηίες στην οθόνη και επαναλάβετε τα προηγούμενα βήματα για να επιλύσετε το πρόβλημα πριν συνεχίσετε τον οδηγό.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nΌταν είστε έτοιμοι να προχωρήσετε, πατήστε _Q_ για να τερματίσετε την εντολή κατάστασης. Τέλος, ενεργοποιήστε την υπηρεσία για να ξεκινήσει κατά την εκκίνηση.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nΤώρα που ο Prometheus είναι ενεργός και λειτουργεί, μπορούμε να εγκαταστήσουμε έναν επιπλέον εξαγωγέα για να δημιουργήσουμε μετρήσεις σχετικά με τους πόρους του διακομιστή μας.\\n\\n## Βήμα 5 — Λήψη του Node Exporter\\n\\nΓια να επεκτείνουμε το Prometheus πέρα ​​από τις μετρήσεις μόνο για τον εαυτό του, θα εγκαταστήσουμε έναν επιπλέον εξαγωγέα που ονομάζεται Node Exporter. Ο Node Exporter παρέχει λεπτομερείς πληροφορίες σχετικά με το σύστημα, συμπεριλαμβανομένης της χρήσης CPU, δίσκου και μνήμης. Λάβετε την τρέχουσα σταθερή έκδοση του Node Exporter στον κατάλογο του αρχικού σας φακέλου. Μπορείτε να βρείτε τις τελευταίες δυαδικές εκδόσεις στη [σελίδα λήψης του Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nΤώρα, αποσυσκευάστε το ληφθέν αρχείο.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nΑυτό θα δημιουργήσει έναν κατάλογο με το όνομα _node_exporter-1.0.1.linux-amd64_ που περιέχει ένα δυαδικό αρχείο με το όνομα _node_exporter_, μια άδεια χρήσης και μια ειδοποίηση.\\n\\nΑντιγράψτε το δυαδικό αρχείο στον κατάλογο _/usr/local/bin_ και ορίστε τον χρήστη και την ομάδα ιδιοκτησίας στον χρήστη node_exporter που δημιουργήσατε στο Βήμα 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nΤώρα που έχετε εγκαταστήσει το Node Exporter, ας το δοκιμάσουμε εκτελώντας το πριν δημιουργήσουμε ένα αρχείο υπηρεσίας για να ξεκινά κατά την εκκίνηση.\\n\\n## Βήμα 6 — Εκτέλεση του Node Exporter\\n\\nΤα βήματα για την εκτέλεση του Node Exporter είναι παρόμοια με αυτά για την εκτέλεση του ίδιου του Prometheus. Ξεκινήστε δημιουργώντας το αρχείο υπηρεσίας Systemd για το Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nΑντιγράψτε το παρακάτω περιεχόμενο στο αρχείο υπηρεσίας:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Εγκατάσταση]\\nWantedBy=multi-user.target\\n```\\n\\nΑποθηκεύστε το αρχείο και κλείστε τον επεξεργαστή κειμένου. Τέλος, επαναφορτώστε το systemd για να χρησιμοποιήσετε τη νεοδημιουργημένη υπηρεσία.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nΤώρα μπορείτε να εκτελέσετε το Node Exporter χρησιμοποιώντας την παρακάτω εντολή:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nΕπαλήθευση that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nΌπως και πριν, αυτή η έξοδος σας δείχνει την κατάσταση του Node Exporter, τον αναγνωριστικό κύριας διεργασίας (PID), τη χρήση μνήμης και άλλα. Εάν η κατάσταση της υπηρεσίας δεν είναι ενεργή, ακολουθήστε τις οδηγίες στην οθόνη και επαναλάβετε τα προηγούμενα βήματα για να επιλύσετε το πρόβλημα πριν συνεχίσετε.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nΤέλος, ενεργοποιήστε το Node Exporter για να ξεκινά αυτόματα κατά την εκκίνηση.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nΜε το Node Exporter πλήρως διαμορφωμένο και λειτουργούντα όπως αναμένεται, θα πούμε στο Prometheus να ξεκινήσει τη συλλογή των νέων μετρήσεων.\\n\\n## Βήμα 7 - Διαμόρφωση του Prometheus για την Συλλογή του Node Exporter\\n\\nΕπειδή το Prometheus συλλέγει μόνο εξαγωγείς που έχουν καθοριστεί στ τμήμα scrape_configs του αρχείου διαμόρφωσής του, θα πρέπει να προσθέσουμε μια καταχώριση για το Node Exporter, όπως κάναμε και για τον ίδιο τον Prometheus. Ανοίξτε το αρχείο διαμόρφωσης.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nΣτο τέλος του τμήματος scrape_configs, προσθέστε μια νέα καταχώριση με το όνομα node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nΕπειδή αυτός ο εξαγωγέας τρέχει επίσης στον ίδιο διακομιστή με τον ίδιο τον Prometheus, μπορούμε να χρησιμοποιήσουμε το localhost αντί για μια διεύθυνση IP, μαζί με την προεπιλεγμένη θύρα του Node Exporter, 9100. Το σύνολο του αρχείου διαμόρφωσής σας θα πρέπει να φαίνεται όπως ακολούθως:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nΑποθηκεύστε το αρχείο και κλείστε τον επεξεργαστή κειμένου όταν είστε έτοιμοι να συνεχίσετε. Τέλος, επανεκκινήστε το Prometheus για να τεθούν σε ισχύ οι αλλαγές.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nΓια μια ακόμα φορά, επαληθεύστε ότι όλα λειτουργούν σωστά με την εντολή κατάστασης.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nΕάν η κατάσταση της υπηρεσίας δεν είναι ενεργή, ακολουθήστε τις οδηγίες στην οθόνη και επαναλάβετε τα προηγούμενα βήματα πριν προχωρήσετε.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nΤώρα έχουμε εγκατεστημένο, διαμορφωμένο και λειτουργικό το Prometheus και το Node Exporter.\\n\\n## Βήμα 8 - Προσθήκη ενσωματωμένου node_exporter στο Robonomic\\n\\nΑφού εγκαταστήσουμε με επιτυχία το Prometheus και το node_exporter, θα πρέπει να χρησιμοποιήσουμε τον ενσωματωμένο εξαγωγέα prometheus σε κάθε έργο υποστρώματος. Για να το επιτύχουμε αυτό, πρέπει να προσθέσουμε μια επιπλέον καταχώριση στο _/etc/prometheus/prometheus.yml_. \\nΑνοίξτε το αρχείο διαμόρφωσης.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nΣτο τέλος του τμήματος scrape_configs, προσθέστε μια νέα καταχώριση με το όνομα robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nΑποθηκεύστε το αρχείο και βγείτε από τον επεξεργαστή κειμένου. Το συνολικό αρχείο διαμόρφωσής σας θα πρέπει να φαίνεται όπως παρακάτω:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nΤέλος, επανεκκινήστε το Prometheus για να εφαρμοστούν οι αλλαγές.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nΓια άλλη μια φορά, βεβαιωθείτε ότι όλα εκτελούνται σωστά με την εντολή status.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nΤώρα έχουμε εγκατεστημένο, διαμορφωμένο και λειτουργικό το _Prometheus_, το _Node Exporter_ καθώς και το _Robonomic Exporter_. Προχωρήστε τώρα στο Grafana\\n\\n## Βήμα 9 - Ρύθμιση του Grafana\\n\\nΤο τελευταίο βήμα είναι να συνδέσετε το Prometheus ως πηγή δεδομένων στο Grafana. Για τον σκοπό αυτού του εγχειριδίου, θα χρησιμοποιήσουμε το δωρεάν cloud-based grafana που επιτρέπει έως 5 πίνακες ελέγχου καθώς και τον αφιερωμένο [πίνακα ελέγχου Robonomics](https://grafana.com/grafana/dashboards/13015). Απλά μεταβείτε στο [grafana.com](https://grafana.com/), δημιουργήστε έναν νέο λογαριασμό και συνδεθείτε στη νεοδημιουργημένη παρουσία grafana σας.\\n\\nΣτην αρχή πρέπει να προσθέσουμε στο Grafana μια νέα _**Πηγή Δεδομένων**_ που στην περίπτωσή μας θα είναι ο διακομιστής Prometheus.\\nΜεταβείτε στην Πηγή Δεδομένων:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nΚάντε κλικ στο **_Προσθήκη πηγής δεδομένων_**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext επιλέξτε _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nΣτη νέα οθόνη, εισαγάγετε τη **_διεύθυνση IP του διακομιστή Prometheus με τη θύρα 9090_**\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nΈπειτα, πατήστε _**Αποθήκευση & Δοκιμή**_ αν ακολουθήσατε όλα τα βήματα και πρέπει να είστε πράσινοι και έτοιμοι να προχωρήσετε στην εισαγωγή του πίνακα ελέγχου. Στην κύρια σελίδα, κάντε κλικ στο **+** και στη συνέχεια στην **Εισαγωγή**, όπως φαίνεται στην παρακάτω εικόνα:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nΣτη συνέχεια, θα πρέπει να δείτε τη σελίδα Εισαγωγής:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nΣτο πεδίο _Διεύθυνση URL ή αναγνωριστικό πίνακα ελέγχου του Grafana.com_ γράψτε _**13015**_ (καθώς αυτό είναι το αναγνωριστικό του πίνακα ελέγχου Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nΜετά τη φόρτωση του εξωτερικού πίνακα ελέγχου, θα δείτε αυτήν την οθόνη:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nΤο τελευταίο βήμα είναι να επιλέξετε την προηγουμένως δημιουργημένη **_Πηγή Δεδομένων_** και να κάνετε κλικ στο _**Εισαγωγή**_\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nΑΥΤΟ ΕΙΝΑΙ! Σε αυτό το σημείο θα πρέπει να δείτε τον εισαγόμενο πίνακα ελέγχου. \\n\\n\\n## Αναφορές\\n\\n* [Πώς να εγκαταστήσετε το Prometheus στο Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Δημιουργία ενός πίνακα ελέγχου παρακολούθησης από το Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Υποστήριξη του Grafana για το Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Παρακολούθηση μετρήσεων του Linux με τον node exporter](https://prometheus.io/docs/guides/node-exporter/)\\n* [Ερωτήματα στο Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Οπτικοποίηση μετρήσεων του κόμβου](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Εξαγωγέας Prometheus για το Substrate](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Μετρικές κόμβου Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [Πίνακας ελέγχου Node Exporter για το Prometheus](https://grafana.com/grafana/dashboards/11074)\\n* [Μετρικές ROBONOMICS (XRT) του Grafana](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"99d87b0300a84edcb414f442dc440f83\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/el/robonomics-opengov/\",\"content\":\"\\n## Εισαγωγή\\n\\nΗ Robonomics έχει μεταβεί στο μηχανισμό διακυβέρνησης OpenGov του Polkadot που επιτρέπει στην αλυσίδα να εξελίσσεται με τον χρόνο, κατά την απόλυτη επιθυμία των κατόχων των τοκενών.\\nΗ μετάβαση της Robonomics στο OpenGov εξασφαλίζει ότι η DAO των κατόχων των τοκενών, η οποία ελέγχει την πλειοψηφία του μεριδίου, μπορεί πάντα να διατάξει την κατεύθυνση της αλυσίδας της Robonomics, επιβάλλοντας οποιαδήποτε αλλαγή στο δίκτυο που θεωρεί κατάλληλη.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  Το OpenGov εφαρμόζεται μόνο στην Robonomics Parachain, η οποία είναι μια αλυσίδα βασισμένη στο Substrate που συνδέεται με την Kusama Relay Chain. Το OpenGov δεν εφαρμόζεται για την υλοποίηση της Robonomics Ethereum, καθώς το Ethereum mainnet δεν υποστηρίζει αυτήν τη στιγμή προηγμένα συστήματα διακυβέρνησης όπως το OpenGov.\\n</robo-wiki-note>\\n\\nΤο OpenGov αλλάζει τον τρόπο με τον οποίο πραγματοποιούνται οι καθημερινές λειτουργίες και οι αποφάσεις στην parachain. Παρέχει μεγαλύτερη σαφήνεια όσον αφορά το πεδίο των δημοψηφισμάτων και έχει τη δυνατότητα να αυξήσει δραματικά την απόδοση των αποφάσεων που λαμβάνονται στην parachain.\\n\\nΤο OpenGov είναι ήδη ενεργό στην Kusama relay chain εδώ και μερικούς μήνες και έχει αποδείξει ότι αυξάνει δραματικά τον αριθμό των αποφάσεων (ατομικών και διακριτών δημοψηφισμάτων) που μπορεί να προτείνει, να ψηφίσει και να ελέγξει την κατεύθυνση του πρωτοκόλλου η DAO των κατόχων των τοκενών.\\n\\n**Το παρακάτω περιεχόμενο που περιέχεται σε αυτήν την ενότητα του wiki θα εξετάσει τις βασικές αρχές του OpenGov στην parachain της Robonomics και θα σας βοηθήσει να κατανοήσετε καλύτερα τις έννοιες πίσω από το OpenGov.**\\n\\n*Σημειώνεται ότι η διακυβέρνηση είναι ένας συνεχώς εξελισσόμενος μηχανισμός στο πρωτόκολλο, ειδικά στα αρχικά στάδια εφαρμογής.*\\n\\nΓια όσους ενδιαφέρονται αποκλειστικά για τις παραμέτρους του Robonomics OpenGov Track, δείτε [εδώ](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## Σχετικά με τα Δημοψηφίσματα\\n\\nΤα δημοψηφίσματα είναι απλά, συμπερασματικά και βασισμένα στο μερίδιο συμμετοχής στο stake. Κάθε δημοψήφισμα έχει συγκεκριμένη πρόταση που συνδέεται με μια προνομιούχα κλήση συνάρτησης στην εκτέλεση των αλυσίδων. Αυτό μπορεί να περιλαμβάνει και την ισχυρότερη κλήση `set_code`, το οποίο έχει τη δυνατότητα να απενεργοποιεί ολόκληρο τον κώδικα του χρόνου εκτέλεσης των αλυσίδων – αυτό είναι μοναδικό για τις αλυσίδες που βασίζονται στο υπόστρωμα και καταργεί την απαίτηση για \\\"σκληρό πιρούνι\\\" της αλυσίδας κατά την ενημέρωση της επιχειρηματικής λογικής των αλυσίδων ( χρόνος εκτέλεσης).\\n\\nΤα δημοψηφίσματα είναι διακριτά γεγονότα που έχουν μια σταθερή περίοδο ψηφοφορίας (περισσότερα για τις διάφορες περιόδους κατά τη διάρκεια του κύκλου ζωής ενός δημοψηφίσματος αργότερα). Οι ατομικοί κάτοχοι των τοκενών μπορούν να ψηφίσουν με τρεις τρόπους σε ένα δημοψήφισμα - ΝΑΙ (συμφωνώ/ναι), ΟΧΙ (διαφωνώ/όχι) ή ΑΠΟΧΗΣΗ από την ψήφο.\\n\\nΌλα τα δημοψηφίσματα έχουν μια καθυστέρηση εκτέλεσης που συνδέεται με αυτά. Αυτή είναι η περίοδος μεταξύ της λήξης του δημοψηφίσματος και, υποθέτοντας ότι το δημοψήφισμα εγκρίθηκε, η εφαρμογή των αλλαγών στο δίκτυο. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Υπάρχει ένας **Ελάχιστος** Χρόνος Εφαρμογής που έχει οριστεί ειδικά για κάθε διαφορετικό τύπο Προέλευσης, αλλά ο δημιουργός ενός συγκεκριμένου δημοψηφίσματος μπορεί να ορίσει τις εργασίες αυτού του συγκεκριμένου δημοψηφίσματος για εκτέλεση πολλών μπλοκ στο μέλλον\\n\\n</robo-wiki-note>\\n\\nΤα δημοψηφίσματα θεωρούνται \\\"ψημένα\\\" αν έχουν κλείσει και έχουν καταμετρηθεί οι ψήφοι. Υποθέτοντας ότι το δημοψήφισμα εγκρίθηκε, θα προγραμματιστεί για εφαρμογή (στον προγραμματιστή των αλυσίδων). Τα δημοψηφίσματα θεωρούνται \\\"ανψημένα\\\" αν η έκβαση είναι εκκρεμής - όπως αν το δημοψήφισμα εξακολουθεί να ψηφίζεται.\\n\\nΜε την προσθήκη του OpenGov, οποιοσδήποτε μπορεί να ξεκινήσει ένα δημοψήφισμα οποιαδήποτε στιγμή και μπορεί να το κάνει όσες φορές επιθυμεί. Το OpenGov καταργεί τον περιορισμό του μόνο 1 δημοψηφίσματος που μπορεί να επεξεργαστεί ταυτόχρονα (σημειώστε ότι, στο Gov v1, μόνο 1 δημοψήφισμα μπορεί να ψηφιστεί ταυτόχρονα. Μόνη εξαίρεση είναι ένα επιπλέον έκτακτο δημοψήφισμα από την επιταχυνόμενη Τεχνική Επιτροπή που μπορεί επίσης να ψηφιστεί ταυτόχρονα από την κοινότητα).\\n\\nΗ OpenGov παρουσιάζει αρκετά νέα χαρακτηριστικά / έννοιες που ονομάζονται Προέλευση και Κομμάτια, και αυτά εισάγονται για να βοηθήσουν στη ροή και επεξεργασία των δημοψηφισμάτων στο πρτόκολλο.\\n\\nΚάθε Προέλευση συνδέεται με μια μόνο κλάση δημοψηφίσματος, και κάθε κλάση συνδέεται με ένα κομμάτι. Το κομμάτι περιγράφει τον κύκλο ζωής του δημοψηφίσματος και είναι συγκεκριμένο για αυτήν τη συγκεκριμένη Προέλευση από την οποία προέρχεται το δημοψήφισμα. Έχοντας κομμάτια με τις δικές τους συγκεκριμένες παραμέτρους επιτρέπει στο δίκτυο να τροποποιεί δυναμικά τον κύκλο ζωής των δημοψηφισμάτων με βάση το επίπεδο προνομίου τους (μπορείτε να σκεφτείτε το επίπεδο προνομίου ως το πόσο ισχυρό μπορεί να είναι ένα δημοψήφισμα / ποιες τύπου αλλαγές μπορεί να κάνει στο πρωτόκολλο).\\n\\n*Σκεφτείτε τις Προελεύσεις ως τη δύναμη που συνδέεται με ένα δημοψήφισμα και σκεφτείτε τα Κομμάτια ως τις παραμέτρους ψηφοφορίας που συνδέονται με ένα δμοψήφισμα, όπως οι διάρκειες των περιόδων του και οι κριτήρια Έγκρισης και Υποστήριξης.*\\n\\nΓια παράδειγμα, μια αναβάθμιση κατά τη διάρκεια εκτέλεσης δεν έχει τις ίδιες επιπτώσεις για το πρωτόκολλο με ένα μικρό κεφάλαιο ταμείου, και για τον λόγο αυτό χρειάζονται διαφορετικές προελεύσεις στις οποίες θα προκαθορίζονται διάφορες συμμετοχές, έγκρισεις, καταθέσεις και περίοδοι εκτέλεσης (Κομμάτια) στο πλέγμα.\\n\\n## Πρόταση δημοψηφίσματος και κύκλος ζωής δημοψηφίσματος \\n\\n### Περίοδος προετοιμασίας\\n\\nΣτο OpenGov, όταν δημιουργείται αρχικά ένα δημοψήφισμα, μπορεί να ψηφιστεί αμέσως από την κοινότητα ων κατόχων των δικαιωμάτων. Ωστόσο, δεν βρίσκεται αμέσως σε κατάσταση όπου μπορεί να τελειώσει ή να μετρηθούν οι ψήφοι του, να εγκριθεί και να εφαρμοστεί απότομα. Αντ' αυτού, τα δημοψηφίσματα πρέπει να πληρούν ορισμένα κριτήρια πριν μεταφερθούν στην περίοδο Απόφασης. Μέχρι να μπουν τα δημοψηφίσματα στην περίοδο Απόφασης, θα παραμείνουν αναποφασισμένα - και τελικά θα λήξουν μετά την συνολική περίοδο ζωής όπως ορίζεται στον ατομικό τροχό.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nΤα κριτήρια για την είσοδο ενός δημοψηφίσματος στην περίοδο Απόφασης είναι τα εξής:\\n1. Μια περίοδος προετοιμασίας που καθορίζει το χρονικό διάστημα που πρέπει να παρέλθει πριν αρχίσει η περίοδος Απόφασης. Αυτή η περίοδος προετοιμασίας βοηθά να αντιμετωπιστεί η πιθανότητα \\\"επίθεσης με απόφαση\\\" όπο ένας επιτιθέμενος που ελέγχει μεγάλο μέρος της ψηφοφορικής ισχύος μπορεί να επιδιώξει να περάσει ένα δημοψήφισμα αμέσως μετά την πρόταση, παρακάμπτοντας τη δυνατότητα για τα άλλα μέλη του DAO των κατόχων των δικαιωμάτων να έχουν επαρκή χρόνο για να εξετάσουν το δημοψήφισμα και να συμμετάσχουν στην ψηφοφορία. Γι' αυτό τα Origins με υψηλότερα επίπεδα προνομίου έχουν σημαντικά μεγαλύτερες περίοδους προετοιμασίας.\\n\\n2. Πρέπει να υπάρχει χώρος για την απόφαση. Κάθε κομμάτι έχει τα δικά του όρια για τον αριθμό των δημοψηφισμάτων που μπορούν να αποφασιστούν ταυτόχρονα (max_deciding). Τα κομμάτια που έχουν ιο ισχυρά επίπεδα προνομίων θα έχουν χαμηλότερα όρια. Για παράδειγμα, η προέλευση Root επιπέδου θα έχει ένα σημαντικά χαμηλότερο ποσό δημοψηφισμάτων που μπορούν να αποφασιστούν ταυτόχρονα σε σύγκριση με προελεύσεις χαμηλότερου επιπέδου προνομίων, όπως η προέλευση Small Tipper.\\n\\n3. Πρέπει να υποβληθεί η Κατάθεση Απόφασης. Αρχικά, η δημιουργία ενός δημοψηφίσματος είναι αρκετά φθηνή, και η αξία της Κατάθεσης Υποβολής (που κρατείται όταν δημιουργείται αρχικά το δημοψήφισμα) είναι αρκετά χαμηλή και αποτελείται κυρίως από την αξία που κοστίζει για την αποθήκευση στην αλυσίδα που συνδέεται με το δημοψήφισμα. Οι Καταθέσεις Απόφασης είναι αρκετά υψηλές, πράγμα που απαιτείται για να αντιμετωπιστεί το spam και παίζει ρόλο στο οικονομικό παιχνίδι που φέρνει το OpenGov, το οποίο θα αναλύσουμε αργότερα.\\n\\nΜόλις έχουν πληρούνται όλα τα παραπάνω τρία κριτήρια, το δημοψήφισμα θα μεταβεί στην Περίοδο Απόφασης. Οι ψήφοι για το δημοψήφισμα θα μετρηθούν για το αποτέλεσμα.\\n\\n### Περίοδος Απόφασης\\n\\n*Για μια γρήγορη επίδειξη βίντεο της Περιόδου Απόφασης, [δείτε αυτό το βίντεο](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nΜόλις ένα δημοψήφισμα πληροί όλα τα κριτήρια που αναφέρονται στην παραπάνω ενότητα, θα εισέλθει στην Περίοδο Απόφασης.\\n\\nΗ Περίοδος Απόφασης περιστρέφεται γύρω από δύο κύριες έννοιες, αυτές της Έγκρισης και της Υποστήριξης. \\n\\nΗ Έγκριση ορίζεται ως το ποσοστό του βάρους της ψήφου έγκρισης (AYEs έναντι NAYs) σε σύγκριση με το συνολικό βάρος της ψήφου (όλες οι AYE & NAY ψήφοι συνδυασμένες). Η πεποίθηση κάθε ψήφου συντελεί στο συνολικό βάρος των ψήφων AYE/NAY (περισσότερα για την ψηφοφορία πεποίθησης / εθελοντικό κλείδωμα σε μια αργότερη ενότητα).\\n\\nΗ Υποστήριξη είναι το συνολικό αριθμό ψήφων (κέρματα) που έχουν συμμετάσχει στο δημοψήφισμα (και δεν προσαρμόζεται για την πεποίθηση) σε σύγκριση με τον συνολικό δυνατό αριθμό ψήφων που μπορούν να γίνουν στο σύστημα (σκεφτείτε αυτό ως τη συνολική έκδοση του XRT στο parachain - ιδιαίτερα, ο συνολικός κυκλοφορούντας εφοδιασμός του XRT δεν είναι το κύριο στοιχείο εδώ, λόγω του γεγονότος ότι μια μερίδα αυτού του αριθμού υπάρχει στο Ethereum ως ERC-20 κέρματα).\\n\\n** Οι ψήφοι που είναι στην κατεύθυνση ΑΠΟΧΗΣΗΣ ΔΕΝ συνεισφέρουν στα κριτήρια Έγκρισης, αλλά συμπεριλαμβάνονται / μετρώνται για τα κριτήρια Υποστήριξης **\\n\\nΈνα δημοψήφισμα πρέπει να πληροί τα κριτήρια Υποστήριξης ΚΑΙ Έγκρισης κατά την Περίοδο Απόφασης για να προχωρήσει στην Περίοδο Επιβεβαίωσης.\\n\\nΓια λεπτομέρειες για τα ατομικά κριτήρια Υποστήριξης και Έγκρισης για κάθε κομμάτι, δείτε αυτό το [υπολογιστικό φύλλο](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Περίοδος Επιβεβαίωσης\\n\\nΚάθε κομμάτι έχει τη δική του συγκεκριμένη διάρκεια για την Περίοδο Επιβεβαίωσης. Τα κομμάτια που έχουν υψηλότερα επίπεδα προνομίων (όπως το Root) έχουν σημαντικά μεγαλύτερες Περίοδους Επιβεβαίωσης από αυτά με χαμηλότερα επίπεδα προνομίων (όπως το Small Tipper).\\n\\nΟι δημοψηφίσματα πρέπει να συνεχίσουν να πληρούν τα κριτήρια Έγκρισης και Υποστήριξης για ολόκληρη τη διάρκεια της Περιόδου Επιβεβαίωσης, διαφορετικά θα επιστραφούν και πάλι στην Περίοδο Απόφασης (σημείωση: η Περίοδος Απόφασης δεν διακόπτεται κατά τη διάρκεια της Περιόδου Επιβεβαίωσης, οπότε είναι εντελώς πιθανό μια Περίοδος Απόφασης να λήξει κατά τη διάρκεια της Περιόδου Επιβεβαίωσης, προκαλώντας έτσι την απόρριψη του δημοψηφίσματος και τη μη εφαρμογή του).\\n\\n**Είναι δυνατή η προσαρμογή των κριτηρίων Έγκρισης και Υποστήριξης για τα μεμονωμένα κομμάτια μέσω δημοψηφίσματος με προνόμια Root Origin.**\\n\\nΟι προέλευσες με χαμηλότερα επίπεδα πονομίων έχουν πολύ πιο εύκολα κριτήρια έγκρισης και υποστήριξης (ορίζονται από το κομμάτι) προς εκπλήρωση από αυτές με υψηλότερα επίπεδα προνομίων. Αντίστοιχα, οι προέλευσεις με υψηλότερα επίπεδα προνομίων έχουν λιγότερο απότομες καμπύλες από αυτές με λιγότερα προνόμια (όπως ορίζονται στο κομμάτι), προκειμένου να διασφαλιστεί ότι το DAO κάτοχος των καταλλήλων κριτηρίων έγκρισης του δημοψηφίσματος και να αποφευχθεί η επίθεση στα δημοψηφίσματα υψηλού προνομίου.\\n\\nΣτο OpenGov, τα δημοψηφίσματα που δεν εγκρίνονται μετά τη λήξη της Περιόδου Απόφασης θεωρούνται απόρριψη από προεπιλογή, και τόσο οι καταθέσεις υποβολής όσο και απόφασης επιστρέφονται στους αποστολείς τους (σημείωση: η κατάθεση απόφασης μπορεί να γίνει από κάποιον άλλον εκτός από τον αποστολέα του δημοψηφίσματος).\\n\\nΑν ένα δημοψήφισμα καταφέρει να πληροί συνεχώς τα κριτήρια Έγκρισης και Υποστήριξης για ολόκληρη την Περίοδο Επιβεβαίωσης, τότε θεωρείται εγκεκριμένο και θα προγραμματιστεί να εκτελεστεί από την προτεινόμενη προέλευση, αλλά το δημοψήφισμα θα εκτελεστεί μόνο μετά τη λήξη της ελάχιστης περιόδου εφαρμογής.\\n\\n### Περίοδος Εφαρμογής\\n\\nΗ Περίοδος Εφαρμογής καθορίζεται από τον αποστολέα κατά την πρόταση του δημοψηφίσματος, αλλά υπόκειται στην Ελάχιστη Περίοδο Εφαρμογής που καθορίζεται σε κάθε κομμάτι. Οι πιο ισχυρές Προελεύσεις έχουν πολύ μεγαλύτερη ελάχιστη περίοδο εφαρμογής από αυτές με λιγότερα προνόμια. Αυτό εξασφαλίζει ότι το δίκτυο έχει επαρκή χρόνο για να προετοιμαστεί για οποιεσδήποτε αλλαγές πορεί να επιβάλει ένα ισχυρό δημοψήφισμα.\\n\\n## Εθελοντικό Κλείδωμα / Πεποίθηση\\n\\nΤο Robonomics χρησιμοποιεί έναν έννοια γνωστή ως εθελοντικό κλείδωμα ή ψήφος πεποίθησης. Αυτό επιτρέπει στους κατόχους των κερμάτων να αυξήσουν την εξουσία ψήφου τους αποφασίζοντας για πόσο καιρό είναι πρόθυμοι να κλειδώσουν τα κέρματά τους για μια συγκεκριμένη δημοψήφιση. Αυτός ο μηχανισμός επηρεάζει μόνο τα κριτήρια έγκρισης για κάθε δημοψήφιση, και η ψήφος πεποίθησης δεν επηρεάζει τα κριτήρια υποστήριξης.\\n\\nΗ ψήφος πεποίθησης μπορεί να υπολογιστεί χρησιμοποιώντας τον παρακάτω τύπο:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nΑυτός ο πίνακας σας δείχνει πώς κάθε αυξανόμενο επίπεδο περιόδου κλειδώματος πολλαπλασιάζει την ψήφο σας για τα κριτήρια έγκρισης:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nΤο μέγιστο ποσό πεποίθησης που μπορεί να χρησιμοποιήσει ένας κάτοχος κερμάτων είναι 6 φορές η πεποίθηση. Μπορείτε να ορίσετε μόνο την πεποίθηση σύμφωνα με τον παραπάνω πίνακα και δεν μπορείτε, για παράδειγμα, να χρησιμοποιήσετε 5,5 φορές πεποίθηση.\\n\\nΕνώ ένα κέρμα είναι κλειδωμένο λόγω ψήφου, μπορεί ακόμα να χρησιμοποιηθεί για ψήφο σε άλλες δημοψηφίσεις, ωστόσο δεν θα αποτελεί μέρος του μεταφερόμενου υπολοίπου σας (δεν μπορείτε να το στείλετε σε άλλο λογαριασμό) - και το υπόλοιπο θα γίνει μεταφερόμενο ξανά μόνο όταν ολοκληρωθεί η περίοδος κλειδώματος.\\n\\n## Ανάθεση Ψήφου\\n\\nΣτο OpenGov, προστέθηκε ένας μηχανισμός για να επιτρέπει στους κατόχους κερμάτων που δεν έχουν αρκετό χρόνο για να εξετάσουν κάθε δημοψήφιση να χρησιμοποιούν τα κέρματά τους ως μέρος του συστήματος διακυβέρνησης, αυτό είναι γνωστό ως ανάθεση ψήφου.\\n\\nΟι κάτοχοι κερμάτων μπορούν να επιλέξουν να αναθέσουν την εξουσία ψήφου τους σε έναν άλλο ψηφοφόρο στο σύστημα (άλλο λογαριασμό). Οι ψηφοφόροι μπορούν να καθορίσουν την ανάθεση της εξουσίας ψήφυ τους με ευελιξία, επιτρέποντάς τους να αναθέσουν την εξουσία ψήφου τους σε διαφορετικό λογαριασμό για κάθε ξεχωριστή Προέλευση. Οι ψηφοφόροι μπορούν επίσης να ορίσουν διαφορετικό ποσό εξουσίας ψήφου για κάθε Προέλευση (αριθμός κερμάτων και επίπεδο πεποίθησης).\\n\\nΑυτή η δυνατότητα ανάθεσης έχει έναν στόχο, να αυξήσει την συμμετοχή των ψηφοφόρων και να βοηθήσει να διασφαλιστεί ότι οι απαιτούμενες συμμετοχές για την έγκριση και υποστήριξη των κριτηρίων πληρούνται.\\n\\nΓια να αναθέσετε την εξουσία ψήφου σας, μπορείτε να χρησιμοποιήσετε τη λειτουργία \\\"Ανάθεση\\\" που μπορείτε να βρείτε στην ενότητα Διακυβέρνηση -> Δημοψήφισμα του [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). Εναλλακτικά, οι χρήστες μπορούν να υποβάλουν το extrinsic convictionVoting(Delegate) χρησιμοποιώντας την ενότητα Προγραμματιστής -> Extrinsics του Robonomics Portal, ωστόσο η χρήση της λειτουργίας \\\"Ανάθεση\\\" της ενότητας δημοψηφίσματος του portal είναι πολύ πιο εύκολη.\\n\\n## Ακύρωση / Εξόντωση Δημοψηφίσματος και του Οικονομικού Παιχνιδιού Διακυβέρνησης\\n\\nΣτο OpenGov, υπάρχουν Προέλευση που απορρίπτουν τα διαρκή δημοψηφίσματα, ανεξάρτητα από την κατάστασ τους. Αυτά είναι γνωστά ως τα ίχνη του Διακυβερνητικού Ακυρωτή και του Διακυβερνητικού Εξοντωτή.\\n\\nΑυτές οι Προέλευση παρεμβαίνουν σε ένα δημοψήφισμα που έχει ήδη ψηφιστεί. Αυτές οι Προέλευση, εάν το δημοψήφισμα που προέρχεται από αυτές εγκριθεί, θα απορρίψουν αμέσως ένα διαρκές δημοψήφισμα, ανεξάρτητα από την κατάστασή του. \\n\\nΗ ακύρωση αυτή καθεαυτή είναι ένας τύπος δημοψηφίσματος που πρέπει να ψηφιστεί από τους κατόχους των διακριτικών σημάτων για να εκτελεστεί. Η ακύρωση έρχεται με τη δική της προέλευση και ίχνος που έχουν μικρότερο χρόνο οδήγησης (Περίοδος Απόφασης, κλπ.) και έχουν καμπύλες Έγκρισης και Υποστήριξης με πιο απότομη καμπύλη (που σημαίνει ότι τα κριτήριά τους είναι πολύ πιο εύκολο να πληρούνται με την πάροδο του χρόνου) από άλλες Προελεύσεις. Αυτό οφείλεται στο γεγονός ότι η ακύρωση ενός δημοψηφίσματος συνήθως συνοδεύεται από μια αίσθηση επείγοντος.\\n\\nΟ Διακυβερνητικός Ακυρωτής στοχεύει να απορρίψει αμέσως ένα ήδη διεξαγόμενο δημοψήφισμα. Όταν ένα δημοψήφισμα ακυρώνεται από αυτήν την προέλευση, τόσο η Κατάθεση Υποβολής όσο και η Κατάθεση Απόφασης επιστρέφονται στους προέλευσης τους. Ένα παράδειγμα όταν ένα δημοψήφισμα μπορεί να θεωρηθεί ότι ακυρώνεται είναι εάν ο προέλευσης έχει κάνει κάποιο ανθρώπινο λάθος στο περιεχόμενο του δημοψηφίσματος του και δεν έχει απαραιτήτως προσπαθήσει να κάνει κάτι κακό.\\n\\nΟ Διακυβερνητικός Εξοντωτής στοχεύει να απορρίψει αμέσως ένα ήδη διεξαγόμενο δημοψήφισμα. Εδώ έρχεται σε παιχνίδι το οικονομικό παιχνίδι της διακυβέρνησης. Οι Προέλευση με υψηλά επίπεδα προνομίου, όπως η Root, έχουν μια Κατάθεση Απόφασης που απαιτεί μεγάλο ποσό κεφαλαίου (XRT tokens) για να κατατεθεί προκειμένου το δημοψήφισμα να εισέλθει στην Περίοδο Απόφασης. \\n\\nΕάν ένας κακόβουλος δράστης υποβάλει ένα δημοψήφισμα, όπως ένα δημοψήφισμα με προέλευση Root που στοχεύει να `set_code` της χρονικής λειτουργίας της αλυσίδας σε κάτι που θα σταματήσει την παραγωγή μπλοκ της αλυσίδας, τότε η DAO των κατόχων διακριτικών σημάτων μπορεί να ανασηκώσει έναν αντί-δημοψήφισμα Διακυβερνητικού Εξοντωτή για να τιμωρήσει αυτήν την ενέργεια. Εάν το κακόβουλο δημοψήφισμα απορριφθεί μέσω της προέλευσης του Διακυβερνητικού Εξοντωτή, τότε και οι δύο καταθέσεις Υποβολής και Απόφασης κόβονται, πράγμα που σημαίνει τι ο προέλευσης (οι λογαριασμοί που κατέθεσαν αυτές τις καταθέσεις) θα χάσουν αυτά τα κεφάλαια. \\n\\nΑυτό σημαίνει ότι υπάρχει μια σοβαρή οικονομική συνέπεια για κακόβουλους δράστες που προσπαθούν να ανασηκώσουν δημοψήφισμα που θα είχε σοβαρές αρνητικές επιπτώσεις για την αλυσίδα, πράγμα που θεωρητικά θα σταματήσει οποιονδήποτε κακόβουλο δράστη να προσπαθήσει να το κάνει.\\n\\nΗ Κατάθεση Απόφασης για το ίχνος του Διακυβερνητικού Εξοντωτή είναι αρκετά υψηλή, αυτό γίνεται για να σταματήσει εξίσου κακόβουλους δράστες από το να κόψουν καταθέσεις κατά άλλα καλά δημοψηφίσματα. **Ένα υπάρχον δημοψήφισμα Διακυβερνητικού Εξοντωτή μπορεί να εξοντωθεί από ένα επόμενο δημοψήφισμα Διακυβερνητικού Εξοντωτή.**\\n\\n## Τεχνική Επιτροπή Robonomics & Λευκολίστα Προέλευση\\n\\nΑυτή η ομάδα είναι ένα αυτοδιοικούμενο επιτελείο εμπειρογνωμόνων που έχει ως κύριο στόχο να εκπροσωπεί ανθρώπους που ενσαρκώνουν κα διαθέτουν τεχνικές γνώσεις του πρωτοκόλλου δικτύου Robonomics. \\n\\nΑυτή η ομάδα (και μόνο αυτή η ομάδα) έχει τη δυνατότητα να προέρχεται από το Whitelist pallet. Αυτό το pallet κάνει μόνο μία πράξη, επιτρέπει σε μία Προέλευση να ανεβάσει το επίπεδο προνομίων μίας άλλης Προέλευσης για μία συγκεκριμένη λειτουργία. \\n\\nΑυτή η ομάδα μπορεί να εξουσιοδοτήσει δημοψήφισμα από μία προέλευση που είναι γνωστή ως Whitelisted-Root, και αυτά τα δημοψηφίσματα μπορούν να εκτελεστούν με προνόμια Root-level, αλλά αυτά τα δημοψηφίσματα θα λειτουργήσουν μόνο με συγκεκριμένες εντολές που έχουν εξουσιοδοτηθεί από την ομάδα. Το Whitelist pallet επαληθεύει δύο πράγματα:\\n1. Η Προέλευση είναι πραγματικά η Whitelisted-Root (δηλαδή το δημοψήφισμα πέρασε από την πορεία αυτής της Προέλευσης).\\n2. Η πρόταση έχει ράγματι εξουσιοδοτηθεί από την ομάδα.\\n\\nΕάν και οι δύο προϋποθέσεις είναι αληθείς, τότε η λειτουργία θα εκτελεστεί με προνόμια Root-level.\\n\\nΑυτό το σύστημα επιτρέπει τη δυνατότητα να υπάρχει ένα νέο παράλληλο Track (Whitelisted-Root Origin), των παραμέτρων του οποίου επιτρέπουν μια πιο σύντομη διαδικασία ψηφοφορίας (οι κριτήρια Έγκρισης και Υποστήριξης είναι ελαφρώς πιο εύκολα να εκπληρωθούν από το Root). Αυτή η ανοιχτή και διαφανής διαδικασία επιτρέπει σε αυτό το σώμα εμπειρογνωμόνων για το Πρωτόκολλο Δικτύου Robonomics να προτείνει δημοψηφίσματα που έχουν κρίνει ασφαλή και επείγοντα.\\n\\nΝα σημειωθεί ότι τα Κριτήρια Υποστήριξης για δημοψηφίσματα που ξεκινούν με την προέλευση Whitelisted-Root δεν τείνουν προς το 0 όπως πολλές άλλες προελεύσεις/πορείες. Αυτό εξασφαλίζει ότι αυτή η ομάδα δεν έχει απόλυτο έλεγχο στο σύνολο του Πρωτοκόλλου Δικτύου Robonomics, και απαιτεί ένα ελάχιστο επίπεδο Υποστήριξης (συμμετοχή ψηφοφόρων) από το συνολικό κατόχους των token.\\n\\n\\n## Διάρκειες Δημοψηφίσματος \\n\\nΕίναι σημαντικό να κατανοήσουμε ότι η διάρκεια κάθε μεμονωμένου δημοψηφίσματος δεν είναι κάτι συγκεκριμένο, δεν είναι απόλυτη. Ορισμένα διαστήματα εντς του κύκλου ζωής του δημοψηφίσματος, όπως το ελάχιστο διάστημα εφαρμογής, έχουν πράγματι συγκεκριμένη διάρκεια, όμως - άλλα, συμπεριλαμβανομένης της περιόδου απόφασης, δεν έχουν. Για παράδειγμα, δεν είναι ακριβές να προσθέσετε τις μέγιστες διάρκειες για τις περιόδους Προετοιμασίας, Απόφασης, Επιβεβαίωσης και Ελάχ. Περίοδος Εφαρμογής και να δηλώσετε ότι \\\"κάθε δημοψήφισμα θα πάρει X αριθμό ημερών\\\", είναι πολύ πιο ευέλικτο από αυτό.\\n\\nΑς δούμε αυτό μέσα από το πρίσμα μερικών ξεχωριστών δημοψηφισμάτων, όλα τα οποία προέρχονται από την ίδια Προέλευση, σε αυτήν την περίπτωση την Ρίζα προέλευση. \\n\\nΗ Ρίζα Προέλευση έχει το δικό της κομμάτι, όπου ορίζονται οι διάρκειες για κάθε περίοδο, καθώς και οι καμπύλες Έγκρισης και Υποστήριξης.\\n\\nΕίναι σημαντικό να θυμάστε ότι τα Δημοψηφίσματα θα προχωρήσουν μόνο στο επόμενο στάδιο του κύκλου ζωής τους εάν πληρούνται ορισμένες προϋποθέσεις. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nΘα πρέπει να υποθέσετε στις παρακάτω εικόνες ότι, προκειμένου ένα δημοψήφισμα να ανέβει στο επόμενο στάδιο του κύκλου ζωής του, θα πρέπει να έχουν πληρούνται οι προϋποθέσεις που περιγράφονται στην παραπάνω εικόνα (εκτός αν αναφέρεται διαφορετικά).\\n\\n\\n### Μέγιστη δυνατή διάρκεια με πολύ χαμηλή συμμετοχή των ψηφοφόρων\\n\\nΗ παρακάτω εικόνα αποτελεί μια αναπαράσταση του μέγιστου δυνατού χρονοδιαγράμματος για ένα δημοψήφισμα, σκεφτείτε αυτό ως ένα δημοψήφισμα που:\\n1. Έχει δημοσιευθεί η Κατάθεση Απόφασης και έχει εισέλθει στην Περίοδο Απόφασης.\\n2. Έχει μία μόνο ψήφο, για παράδειγμα, 1 XRT, προς την κατεύυνση ΝΑΙ - αυτό σημαίνει ότι θα πληροί την απαιτούμενη Υποστήριξη (συμμετοχή των ψηφοφόρων) μόνο στο πολύ τέλος της Περιόδου Απόφασης (αφού η συνολική Υποστήριξη είναι πολύ χαμηλή), αλλά έχει 100% Έγκριση, οπότε τελικά θα πληροί τις απαιτήσεις για να εισέλθει στην Περίοδο Επιβεβαίωσης.\\n3. Συνεχίζει να πληροί τα προαναφερθέντα κριτήρια κατά την Περίοδο Επιβεβαίωσης.\\n4. Η πρόταση που έχει ανακύψει από το δημοψήφισμα θα εφαρμοστεί ακριβώς στο ίδιο μπλοκ με το τέλος της Ελάχ. Περιόδου Εφαρμογής - τεχνικά, ο δημιουργός του δημοψηφίσματος μπορεί να ορίσει τις αλλαγές στο δίκτυο όπως περιγράφονται στο δημοψήφισμα για να εφαρμοστούν πολλά μπλοκ στο μέλλον, οπότε ρεαλιστικά ο πραγματικός κύκλος ζωής ενός μεμονωμένου δημοψηφίσματος μπορεί να διακέσει πολλές ημέρες, εβδομάδες, μήνες ή χρόνια.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nΒλέπουμε ότι σε αυτό το παράδειγμα, ο κύκλος ζωής του δημοψηφίσματος θα ήταν (περίπου) 17 ημέρες.\\n\\n\\n### Διάρκεια με πολύ υψηλή συμμετοχή ψηφοφόρων (με υψηλό αριθμό ψήφων ΥΠΕΡ)\\n\\nΑς ρίξουμε μια ματιά σε ένα δημοψήφισμα όπου ο DAO κάτοχος του τοκετού XRT έχει εκφράσει μεγάλο ενδιαφέρον. Σε αυτό το παράδειγμα, θα υποθέσουμε ότι έχει συμβεί συνολική συμμετοχή ψηφοφόρων περίπου 248.771 XRT και όλοι οι ψηφοφόροι ψηφίζουν υπέρ (σημείωση: τεχνικά, σε αυτό το στάδιο ενός δημοψηφίσματος Root, σύμφωνα με την πορεία, μόνο το 60% των ψήφων πρέπει να είναι υπέρ για να πληροί τα κριτήρια έγκρισης).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Πάντα συμβουλεύεστε τις πληροφορίες που αφορούν την πορεία για ακριβείς πληροφορίες για κάθε πορεία, περισσότερες πληροφορίες μπορούν να βρεθούν σε αυτό το [φύλλο εργασίας](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nΣε αυτό το παράδειγμα:\\n1. Το Κατάθεση Απόφασης αναρτήθηκε κατά τη διάρκεια της Περιόδου Προετοιμασίας και, ως εκ τούτου, μπόρεσε να μεταβεί στην Περίοδο Απόφασης στο τέλος της Περιόδου Προετοιμασίας.\\n2. Πολλοί ψηφοφόροι ψφισαν σε αυτό το δημοψήφισμα - επιτυγχάνοντας συμμετοχή ψηφοφόρων περίπου 248.771 XRT σε σχετικά σύντομο χρονικό διάστημα.\\n3. Οι ψήφοι ήταν πλειοψηφία υπέρ (πάνω από 60% υπέρ).\\n4. Το δημοψήφισμα πληροί συνεχώς τα κριτήρια της Περιόδου Επιβεβαίωσης για ολόκληρη την Περίοδο Επιβεβαίωσης (Σημείωση: Εάν ένα δημοψήφισμα σταματήσει να πληροί τα κριτήρια της Περιόδου Επιβεβαίωσης, τότε επιστρέφεται στην Περίοδο Απόφασης).\\n5. Η πρόταση που ανακοινώθηκε από το δημοψήφισμα θα εφαρμοστεί ακριβώς στο ίδιο μπλοκ που λήγει η Ελάχιστη Περίοδος Εφαρμογής.\\n\\nΛόγω του γεγονότος ότι υπήρξε συμμετοχή περίπου 248.771 XRT, το δημοψήφισμα θα πληροί τα κριτήρια για να εισέλθει στην Περίοδο Επιβεβαίωσης του μετά από περίπου 168 ώρες (7 ημέρες).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nΒλέπουμε ότι σε αυτό το δεύτερο παράδειγμα, λόγω του γεγονότος ότι υπήρξε μεγάλη συμμετοχή των ψηφοφόρων, η Περίοδος Απόφασης τελείωσε πριν το μισό από το μέγιστο επιτρεπόμενο χρόνο. Αποτέλεσμα αυτού είναι ένα δημοψήφισμα που μπορεί να εφαρμοστεί σε περίπου 10 ημέρες.\\n\\n\\n### Διάρκεια όταν η Κατάθεση Απόφασης δεν έχει ποτέ αναρτηθεί\\n\\nΑς ρίξουμε τώρα μια ματιά σε ένα δημοψήφισμα που προήλθε, αλλά ποτέ δεν έχει αναρτηθεί η Κατάθεση Απόφασης του. Τέτοια δημοψηφίσματα βρίσκονται σε μια είδους κατάσταση \\\"λιμβού\\\", όπου η Περίοδος Προετοιμασίας τους έχει λήξει, αλλά επειδή η Κατάθεση Απόφασης δεν έχει αναρτηθεί, το δημοψήφισμα παραμένει στην κατάσταση \\\"Προετοιμασίας\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nΒλέπουμε ότι σε αυτό το τρίτο παράδειγμα, λόγω του γεγονότος ότι η Κατάθεση Απόφασης δεν έχει ποτέ αναρτηθεί, το δημοψήφισμα πραγματικά δεν θα εισέλθει ποτέ στην Περίοδο Απόφασης, αντίθετα παραμένει στην κατάσταση \\\"Προετοιμασίας\\\". Αυτό σημαίνει ότι τελικά, αν δεν αναρτηθεί ποτέ η Κατάθεση Απόφασης, το δημοψήφισμα θα λήξει μετά τη διάρκεια που καθορίζεται στη σταθερά timeOut του παλέτου.\\n\\nΑυτό έχει συμβεί προηγουμένως στο Kusama, όπου ένα δημοψήφισμα αναρτήθηκε με ρίζες, αλλά λόγω των υψηλών απαιτήσεων κεφαλαίου για την ανάρτηση της Κατάθεσης Απόφασης, το δημοψήφισμα δεν εισήλθε ποτέ στα επόμενα στάδια του κύκλου ζωής του. Τέτοια δημοψηφίσματα ολοκληρώνονται με τη σημαία \\\"λήξης χρόνου\\\".\\n\\n\\n### Διάρκεια όταν η Κατάθεση Απόφασης αναρτήθηκε αργά\\n\\nΤέλος, ας ρίξουμε μια ματιά σε ένα παράδειγμα όπου η Κατάθεση Απόφασης αναρτήθηκε αρκετά αργά μετά την αρχική ανάρτηση του δημοψηφίσματος. Αυτό έχει συμβεί προηγουμένως στο Kusama, όπου ένα δημοψήφισμα αναρτήθηκε με τη ρίζα, αλλά ο αρχικός δημιουργός χρειάτηκε χρόνο για να βρει κάποιον με μεγάλο ποσό κεφαλαίου για να αναρτήσει την Κατάθεση Απόφασης εκ μέρους του.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nΣε αυτό το τελικό παράδειγμα, λόγω του γεγονότος ότι η Κατάθεση Απόφασης αναρτήθηκε μετά τη λήξη της Περιόδου Προετοιμασίας, αλλά πριν το δημοψήφισμα λήξει χρονικά – ο κύκλος ζωής του δημοψηφίσματος είναι πραγματικά πολύ μεγαλύτερος από τον κανονικό, καθώς εισέρχεται στην Περίοδο Απόφασης μετά από μεγαλύτερο χρονικό διάστημα.\\n\\nΕίναι σημαντικό να σημειωθεί ότι η DAO κατόχου των κερμάτων έχει τη δυνατότητα να ψηφίσει ΝΑΙ/ΟΧΙ σε δημοψηφίσματα που βρίσκονται στην Περίοδο Προετοιμασίας ή είναι ακόμα στην κατάσταση \\\"Προετοιμασίας\\\".\\n\"}},{\"node\":{\"id\":\"9e028dfe10c360d4ea04966da3c1c8d7\",\"title\":\"Robonomics στο Ethereum\",\"path\":\"/docs/el/robonomics-ethereum/\",\"content\":\"\\nΌλες οι πληροφορίες σχετικά με το Robonomics στο Ethereum μεταφέρθηκαν στο αποθετήριο GitHub. Όλες οι απαραίτητες πληροφορίες μπορούν να βρεθούν [εδώ.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"8aa6dc9adbe0a0dd600bb0ec3d9483b7\",\"title\":\"Ρύθμιση ενσωμάτωσης Robonomics\",\"path\":\"/docs/el/robonomics-hass-integration/\",\"content\":\"\\n**Σε αυτό το άρθρο, θα προσθέσετε το Robonomics στο Home Assistant. Αυτό επιτρέπει στο Home Assistant να καταγράφει δεδομένα με κρυπτογραφημένα δεδομένα στο Robonomics Parachain και α ακούει εντολές εκκίνησης από το parachain για τον έλεγχο έξυπνων συσκευών. Η ενσωμάτωση χρησιμοποιεί το IPFS για την αποθήκευση δεδομένων και την αποστολή των κατακερματισμένων IPFS στις λειτουργίες καταγραφής δεδομένων ή εκκίνησης.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Στην διεπαφή ιστού του Home Assistant πηγαίνετε σε `Settings` -> `Device & Services` και πατήστε `ADD INTEGRATION`. Αναζητήστε το `Robonomics`.\\n\\n2. Κάντε κλικ στο Robonomics και συμπληρώστε τη διαμόρφωση: \\n\\n- Προσθέστε το seed από τον λογαριασμό `SUB_CONTROLLER` στο seed του λογαριασμού ελεγκτή.\\n- Προσθέστε τη δημόσια διεύθυνση του λογαριασμού `SUB_OWNER` στη διεύθυνση του κατόχου συνδρομής.\\n- Ορίστε το διάστημα αποστολής δεδομένων (από προεπιλογή είναι 10 λεπτά).\\n- (Προαιρετικά) Μπορείτε να προσθέσετε διαπιστευτήρια για την υπηρεσία pinning Pinata ή άλλη προσαρμοσμένη πύλη για να διαδώσετε τα δεδομένα σας ευρύτερα στο δίκτυο IPFS.\\n\\n3. Πατήστε `SUBMIT` αφού ολοκληρώσετε τη διαμόρφωση. Αν συμπληρώσατε όλα σωστά, θα δείτε το παράθυρο επιτυχίας.\\n\\nΑυτό είναι όλο! Έχετε πλήρως εγκαταστήσει την Ενσωμάτωση Robonomics στο Home Assistant. Τώρα μπορείτε να χρησιμοποιήσετε όλες τις \\nΥπηρεσίες Ιστού Robonomics. Για να μάθετε περισσότερα για αυτές, πηγαίνετε στο [\\\"Χρήση\\\" τμήμα](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"4def3ae3ae26cb1f5461a982637e5cc9\",\"title\":\"Διεπαφή Python και Robonomics IO\",\"path\":\"/docs/el/rinterface/\",\"content\":\"\\n** Ορισμένες εξωτερικές λειτουργίες που υλοποιούνται στα παλέτα του Robonomics είναι δύσκολο να υποβληθούν από την εφαρμογή Polkadot. Περισσότερο από αυτό, υπάρχει \\nμια ανάγκη αλληλεπίδρασης με αυτή τη λειτουργία χρησιμοποιώντας γλώσσες προγραμματισμού. Για το σκοπό αυτό αναπτύχθηκε ένα απλό εργαλείο Python\\nονομάζεται [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface). Είναι ένα περιτύλιγμα πάνω από πουλικά συντηρημένο\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). Παρακάτω παρέχεται μια σύντομη περιγραφή αυτού του πακέτου\\nκαι μερικοί χρήσιμοι σύνδεσμοι και παραδείγματα. Επίσης, συζητείται το εργαλείο CLI. **\\n\\n## robonomics-interface\\n\\nΔιαθέσιμο στο [PyPi](https://pypi.org/project/robonomics-interface/) το πακέτο είναι έτοιμο για λήψη και εγκατάσταση.\\nΥπάρχει επίσης μια λεπτομερής τεκμηρίωση που δημιουργήθηκε από το docstring [τεκμηρίωση](https://multi-agent-io.github.io/robonomics-interface/) διαθέσιμη επίσης.\\n\\nΣυνολικά, αυτό είναι ένα εργαλείο για προγραμματιστές που επιθυμούν να αλληλεπιδράσουν με το blockchain του Robonomics μέσω εργαλείων προγραμματισμού. Σχεδόν \\nόλα τα έργα Python της ομάδας Robonomics που αλληλεπιδρούν με το parachain χρησιμοποιούν αυτήν τη διεπαφή.\\n\\n### Εγκατάσταση\\n\\nΗ διαδικασία εγκατάστασης απαιτεί τον χρήστη να έχει τουλάχιστον εγκατεστημένο το Python 3.8. Ούτε οι αρχιτεκτονικές `x86`, ούτε οι `arm7`, ούτε οι `arm8`\\nαπαιτούν διαδικασία συναρμολόγησης. Όλοι οι τροχοί κατασκευάζονται και δημοσιεύονται από τους διαχειριστές των εξαρτήσεων.\\n\\nΧρησιμοποιείται το `pip` ως εργαλείο εγκατάστασης:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Δείγμα χρήσης\\n\\nΗ κύρια ιδέα είναι να δημιουργήσετε μια περίπτωση `Account` και στη συνέχεια να τη χρησιμοποιήσετε για τη δημιουργία αφιερωμένων παλετών.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  Είναι επίσης δυνατή η χρήση προσαρμοσμένων σημείων πρόσβασης (π.χ. τοπικός κόμβος για δοκιμές):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nΕίναι επίσης δυνατή η υποβολή εξωτερικών λειτουργιών:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Όπως έχει αναφερθεί, περισσότερα παραδείγματα είναι διαθέσιμα στη [τεκμηρίωση](https://multi-agent-io.github.io/robonomics-interface/) σελίδα.\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\nΤο `robonomics-interface` περιλαμβάνει επίσης εργαλεία Python `click` CLI για χρήση σε σκοπούς πρωτοτυπίας και γρήγορων δοκιμών. Είναι εγκατεστημένο\\nμε το πακέτο και είναι διαθέσιμο στο Terminal:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nΜπορείτε να δοκιμάσετε να το χρησιμοποιήσετε με τον τοπικό κόμβο. Η φιλοσοφία του pipeline υιοθετείται:\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"fc258fd3b2b1260baf65bd75c887cb46\",\"title\":\"Έλεγχος κάμερας PTZ στο Home Assistant\",\"path\":\"/docs/el/ptz-camera/\",\"content\":\"\\nΑυτό το άρθρο καλύπτει τη διαδικασία εγκατάστασης μιας κάμερας PTZ στο Home Assistant. \\nΘα χρησιμοποιηθεί το πρωτόκολλο ONVIF. Αυτό απαιτεί ένα τοπικό λογαριασμό κάμερας.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nΗ διαδικασία ρύθμισης του τοπικού λογαριασμού κάμερας δεν καλύπτεται σε αυτό το άρθρο.\\n</robo-wiki-note>\\n\\nΑπαιτήσεις:\\n- Κάμερα PTZ\\n- Τοπικός λογαριασμός κάμερας\\n- Διεύθυνση IP κάμερας\\n- Ρυθμισμένο Home Assistant\\n\\n## Ενσωμάτωση ONVIF\\n\\nΑς ξεκινήσουμε με την εγκατάσταση της **ενσωμάτωσης ONVIF**. \\n\\nΠηγαίνετε στο \\\"Devices & Services\\\" στις \\\"Settings\\\" και πατήστε το κουμπί \\\"ADD INTEGRATION\\\".\\nΠληκτρολογήστε \\\"ONVIF\\\" και επιλέξτε την ενσωμάτωση. Θα δείτε το επόμενο παράθυρο.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nΠατήστε το κουμπί \\\"Submit\\\". Θα προσπαθήσει να αναζητήσει αυτόματα την κάμερά σας. Εάν επιτύχει, \\nεπιλέξτε την κάμερά σας από τη λίστα και συμπληρώστε τα κενά πεδία. \\nΔιαφορετικά, πρέπει να συμπληρώσετε όλα τα πεδία χειροκίνητα. Θα δείτε το παρακάτω παράθυρο.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nΣυμπληρώστε τα κενά:\\n- Name - δώστε ένα όνομα στην κάμερά σας\\n- Host - δώστε τη διεύθυνση IP της κάμεράς σας\\n- Port - συνήθως είναι 2020, αλλά ο πάροχος της κάμεράς σας μπρεί να το αλλάξει\\n- Username - γράψτε ένα όνομα χρήστη του τοπικού λογαριασμού της κάμεράς σας\\n  - Password - γράψτε έναν κωδικό πρόσβασης για τον τοπικό λογαριασμό της κάμεράς σας\\n\\nκαι πατήστε \\\"Submit\\\". Επιλέξτε μια περιοχή για την κάμερά σας και κάντε κλικ στο \\\"Finish\\\".\\n\\n## Προσθέστε έλεγχο κάμερας στον πίνακα ελέγχου\\n\\nΤώρα που έχετε ρυθμίσει πλήρως την κάμερα, μπορείτε να προσθέσετε τη ροή και τα κουμπιά ελέγχου στον πίνακα ελέγχου.\\n\\nΠηγαίνετε στον πίνακα ελέγχου και ξεκινήστε δημιουργώντας μια νέα κάρτα. Επιλέξτε την \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nΣυμπληρώστε τα δεδομένα:\\n- Title - επιλέξτε τον τίτλο της εικόνας της κάμερας\\n- Camera Entity - επιλέξτε μια οντότητα κάμερας από τη λίστα\\n- Camera View - επιλέξτε \\\"live\\\" για να έχετε λιγότερη καθυστέρηση\\n\\nΣτη συνέχεια, μεταβείτε στη λειτοργία \\\"Code Editor\\\" πατώντας το κουμπί στην κάτω αριστερή πλευρά. Θα δείτε τον παρακάτω κώδικα:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nΑντικαταστήστε το περιεχόμενο του `entities: []` σύμφωνα με το παράδειγμα παρακάτω (`<YOUR_CAMERA_ENTITY>` είναι το ίδιο με την παράμετρο `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nΑυτά είναι όλα. Τώρα θα πρέπει να δείτε την κάρτα της κάμερας PTZ στον πίνακα ελέγχου μαζί με τα κουμπιά ελέγχου.\\n\\n## Επίλυση Προβλημάτων\\nΕάν χρησιμοποιείτε το Home Assistant Core και δεν βλέπετε μια ροή από την κάμερα, θα πρέπει να εγκαταστήσετε τις ενσωματώσεις \\\"stream\\\" και \\\"FFMPEG\\\". \\nΓια να το κάνετε αυτό, πρέπει να προσθέσετε τις συμβολοσειρές `stream: ` και `ffmpeg: ` στο τέλος του configuration.yaml.\"}},{\"node\":{\"id\":\"452373b016c8f18277fed863413c77a1\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/el/notifications/\",\"content\":\"\\nΜπορείτε να λαμβάνετε ειδοποιήσεις στο smartphone σας με το [notify](https://notify.events/). Πρώτα εγγραφείτε εκεί και στο `Control Panel` δημιουργήστε νέο κανάλι:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nΠροσθέστε τίτλο και πατήστε `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nΣτη συνέχεια πατήστε `Add Source` και επιλέξτε `Home Assistant` στην καρτέλα `IoT και Smart Home`:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nΓράψτε τίτλο και πατήστε `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nΕκεί θα δείτε το τοκέν που χρειάζεστε για να προσθέσετε στο αρχείο διαμόρφωσης για το Home Assistant. Αποθηκεύστε το κάπου και πατήστε `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nστη συνέχεια πατήστε `Subscribe` για να προσθέσετε συνδρομητές:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nΕπιλέξτε τον επιθυμητό συνδρομητή και ακολουθήστε τις οδηγίες.\\n\\nΤώρα πρέπει να επεξεργαστείτε τη διαμόρφωση στον υπολογιστή σας με το Home Assistant. Υπό τον χρήστη `homeassistant` ανοίξτε το αρχείο `configuration.yaml`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nΚαι προσθέστε αυτές τις γραμμές:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nΠροσθέστε επίσης νέα αυτοματισμό μετά τη γραμμή `automation:`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nΑυτός ο αυτοματισμός θα στείλει το μήνυμα `Door was changed to on/off` μετά την αλλαγή της κατάστασης του αισθητήρα με αναγνωριστικό οντότητας `binary_sensor.contact_sensor_contact` από `off` σε `on`.\\n\\nΚαι επανεκκινήστε το Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"34ed49fca8ed77e574f8d936e7885b2c\",\"title\":\"Υποχρέωση\",\"path\":\"/docs/el/liability/\",\"content\":\"\\n**Για να μετατρέψετε τους ρομπότ σε οικονομικούς παράγοντες, χρειάζεστε ένα εργαλείο σύμβασης για αυτό. Γνωρίστε την Υποχρέωση - Ρομπονομική παλέτα που εφαρμόζει συμβάσεις μεταξύ λογαριασμών parachain!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Παρακαλούμε να προσέξετε ότι αυτός ο οδηγός παρουσιάζεται σε μια τοπική περίπτωση του Robonomics Node. Δημιουργήστε το δικό σας με [αυτές τις οδηγίες](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Επισκόπηση Θεωρίας\\n\\nΣτο Ethereum υπήρχε μια αρκετά περίπλοκη δομή αλληλεπίδρασης υποχρέωσης. Μπορείτε να το γνωρίσετε [εδώ](/docs/robonomics-how-it-works). Σήμερα τα πράγματα είναι λίγο πιο εύκολα με το Kusama!\\n\\n### Διαπραγματεύσεις\\n\\nTo sign a contract the two sides need to negotiate first. This may be done several ways, including [IPFS PubSub ](https://blog.ipfs.tech/25-pubsub/) or Robonomics PubSub. A sample of Python code using Robonomics PubSub is \\npresented [here](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub). \\n\\nΠροσφορά και ζήτηση είναι μηνύματα που περιέχουν δύο κύρια χαρακτηριστικά μιας σύμβασης: **περιγραφή εργασίας** και **τιμή**. Η μορφή του μηνύματος πρέπει να σχεδιαστεί από τον χρήστη για κάθε συγκεκριμένη εφαρμογή. Δεν είναι τόσο σημαντικό στη διαδικασία διαπραγμάτευσης να ακολουθείται μια αυστηρή κανόνα μορφής. Η πιθανή ροή παρουσιάζεται σην παρακάτω εικόνα.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Σημειώστε ότι το PubSub είναι ένα ανοιχτό πρωτόκολλο, οπότε δεν πρέπει να μεταφέρονται ευαίσθητα δεδομένα. Για αυτό πρέπει να χρησιμοποιήσετε άλλα πρωτόκολλα.\\n\\n</robo-wiki-note>\\n\\n\\n### Υπογραφές\\n\\nΌταν οι διαπραγματεύσεις τελειώσουν με επιτυχία, κάθε πλευρά πρέπει να υπογράψει τη λεγόμενη συμφωνία της που ονομάζεται υπογραφή. Αυτό είναι ένα μήνυμα που περιέχει περιγραφή εργασίας και τιμή **σε συγκεκριμένη μορφή** υπογεγραμμένο με ιδιωτικό κλειδί του Konto brauchen. Υπάρχει ένα [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Υποχρέωση.sign_liability) και για αυτό.\\n - Η περιγραφή της εργασίας ονομάζεται **τεχνική**. Αυτό είναι ένα συμβολοσειρά μήκους 32 bytes που μπορεί να είναι ένα κωδικοποιημένο IPFS CID.\\n - Η τιμή ονομάζεται **οικονομία**. Αυτό είναι ένα δεκαδικό XRT - Weiner. 1 Weiner = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Μπορείτε να λάβετε ένα [IPFS](https://ipfs.tech/) CID με τη σωστή μορφοποίηση με τη [βιβλιοθήκη Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  Όταν χρησιμοποιείτε τη λειτουργία `sign_liability`, δεν χρειάζεται να μετατρέψετε το hash, θα γίνει αυτόματα.\\n\\n</robo-wiki-note>\\n\\nΑκολουθώντας το παράδειγμα του καφέ:\\n\\n1. Η εργασία είναι ένα JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Το IPFS CID της είναι `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Έτσι η **τεχνική** (μετατραπέντα CID) είναι `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. Η **οικονομία** είναι `1.5 XRT`.\\n\\nΌταν υπογραφεί, είναι ώρα να δημιουργηθεί μια υποχρέωση! Αυτό μπορεί να γίνει από μία από τις πλευρές (είτε ο υπόσχομαι είτε ο υπόσχομαι) ή από έναν λογαριασμό τρίτου μέρους ενός ονομαζόμενου παρόχου.\\n\\n## Δημιουργία Υποχρέωσης\\n\\n### Προετοιμασίες\\n\\nΌπως αναφέρθηκε νωρίτερα, στη διαδικασία συμμετέχουν τουλάχιστον δύο πλευρές. Για αυτό το παράδειγμα, ας χρησιμοποιήσουμε τρεις και να δημιουργήσουμε έναν ξεχωριστό πάροχο για αυτό. Υποθέστε ότι οι διαπραγματεύσεις έλαβαν ήδη χώρα κάπως.\\n\\n### 1. Δημιουργήστε τρεις λογαριασμούς και προσθέστε κεφάλαια σε αυτούς\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nΕδώ έχουμε παρέχει στον πάροχο 100 XRT για να υπογράψει εξωτερικές υποχρεώσεις, ο υπόσχομαι έλαβε 2 XRT για να πληρώσει την εργασία.\\nΟ υπόσχομαι δεν έλαβε κανένα κεφάλαιο (εκτός από ένα επιταγματικό κατάθεση τουλάχιστον 1 mXRT).\\n\\n### 1. Πλοηγηθείτε στο Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Επιλέξτε liability -> create  από την αναπτυσσόμενη λίστα πιθανών εξωτερικών υποχρεώσεων\\n\\nΕπίσης, επιλέξτε έναν λογαριασμό με τον οποίο θέλετε να υποβάλετε ην εξωτερική υποχρέωση. Συμπληρώστε όλες τις παραμέτρους.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Υπογραφές\\\">\\n\\n  Εφόσον χρησιμοποιείται ο πάροχος εδώ, δεν χρειάζεται να γνωρίζετε τους κωδικούς σπόρων των συμμετεχόντων. Χρειάζονται μόνο οι υπογραφές τους.\\n\\n</robo-wiki-note>\\n\\n### 3. Υποβολή συναλλαγής\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Ελέγξτε την ευθύνη σας στα γεγονότα\\n\\nΓια αυτό, πλοηγηθείτε στο `Network -> Explorer` και βρείτε μια λίστα με τα γεγονότα στα δεξιά. Κάντε κλικ σε ένα εικονίδιο τριγώνου για να το ανοίξετε.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  Ο κατακερματισμός μπορεί να μετατραπεί σε ένα IPFS CID με το ίδιο [εργαλείο Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Εξερεύνηση αποθήκευσης\\n\\nΜπορείτε επίσης να εξερευνήσετε μερικά χαρακτηριστικά των υποχρεώσεων στο αποθηκευτικό μοντέλο `υποχρέωση`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  Η λειτουργία αποθήκευσης `Next Index` δείχνει τον τελευταίο δείκτη υποχρέωσης +1, οπότε αν και είναι `1`, η υποχρέωση `0` εξερευνάται.\\n\\n</robo-wiki-note>\\n\\n## Αναφορές\\n\\nΦανταστείτε ότι ένας καφές έχει φτιαχτεί και τώρα η μηχανή καφέ χρειάζεται να το αναφέρει κάπως. Εκεί εμφανίζονται οι αναφορές ευθύνης. Ως απόδειξη εργασίας, ο λογαριασμός προσθέτει έναν ακόμα IPFS CID ως περιεχόμενο αναφοράς κατά την ολοκλήρωση της υπάρχουσας υποχρέωσης. Αυτό απαιτεί ξανά μια υπογραφή του διαθέτη.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  Το υπογεγραμμένο μήνυμα περιέχει τον υπάρχοντα δείκτη υποχρέωσης και τον κωδικοποιημένο σε 32 bytes αναπαράσταση του IPFS CID της αναφορς. Και πάλι, το [εργαλείο Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Υποχρέωση.sign_report) μπορεί να βοηθήσει στην υπογραφή της αναφοράς.\\n\\n</robo-wiki-note>\\n\\nΣυνεχίζοντας με το παράδειγμα της μηχανής καφέ:\\n\\n1. Η αναφορά είναι ένα JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Το IPFS CID της είναι `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. Έτσι, το **ωφέλιμο φορτίο** (μετασχηματισμένο CID) είναι `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2`\\n4. **Δείκτης** είναι `0` είναι ο υπάρχων δείκτης υποχρέωσης.\\n\\n### 1. Πλοηγηθείτε στις extrinsics, liability -> finalize(report)\\n\\nΣυμπληρώστε τις παραμέτρους και υποβάλετε εξωγενείς. Και πάλι, αυτό μπορεί να γίνει από λογαριασμό τρίτου μέρους.\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Προσέξτε ότι ο λογαριασμός του διαθέτη δεν πρέπει να είναι \\\"νεκρός\\\" - πρέπει να έχει την υπαρξιακή κατάθεση τουλάχιστον 1 mXRT.\\n\\n</robo-wiki-note>\\n\\nΥπογράψτε και υποβάλετε την αναφορά. Όταν τελειώσετε, μπορείτε να την εξερευνήσετε στα γεγονότα.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Εξερεύνηση αναφορών\\n\\nΜπορείτε επίσης να παρατηρήσετε την αναφορά στην αποθήκευση. Πηγαίνετε στο `Developer -> Storage` και επιλέξτε `liability` από την αναπτυσσόμενη λίστα.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Ελέγξτε τις υπολογιστικές ισορροπίες\\n\\nΣτην εικόνα φαίνεται ότι τώρα ο διαθέτης έχει λάβει το \\\"μισθό\\\". Έχει συμβεί οικονομική σχέση!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  Μέχρι στιγμής δεν υπάρχει τρόπος να επαληθευτεί ότι η εργασία έχει γίνει, οπότε μόλις ο διαθέτης αναφέρει, τα κέρματα μεταφέρονται στον λογαριασμό του. \\n  Η δυνατότητα επαλήθευσης θα προστεθεί στο μέλλον.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"98a72b773fe641fa84c4afaa981d42cf\",\"title\":\"Πώς να ενημερώσετε την έκδοση του Robonomics Collator Node\",\"path\":\"/docs/el/how-to-update-collator-node-version/\",\"content\":\"\\nΣυνιστάται να έχετε διαβάσει τα παρακάτω άρθρα πριν από την ανάγνωση αυτής της ανάρτησης: [\\\"Πώς να κατασκευάσετε τον κόμβο Collator\\\"](/docs/how-to-build-collator-node) & [\\\"Πώς να ξεκινήσετε τον Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nΑυτό το άρθρο περιέχει τις εντολές που απαιτούνται για την ενημέρωση ενός κόμβου Robonomics collator (που εκτελείται σε Ubuntu) και δίνει επίσης ένα παράδειγμα αμέσως μετά.\\n\\n## **Απαιτούμενες Εντολές**\\n\\n0. Πριν ξεκινήσετε, συνιστάται να είστε συνδεδεμένοι ως `root`, αν όχι, τότε θα σας συνιστούσα να χρησιμοποιήσετε:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Διακόψτε την υπηρεσία Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Αφαιρέστε την προηγούμενη έκδοση του Robonomics (βεβαιωθείτε ότι βρίσκεστε στον σωστό κατάλογο):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Λάβετε την [τελευταία έκδοση](https://github.com/airalab/robonomics/releases) του Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Αποσυμπιέστε το αρχείο:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Μετακινήστε το αρχείο:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nΠρέπει να μετακινήσετε αυτό το αρχείο στον σωστό κατάλογο όπου εγκαταστήσατε τον κόμβο Robonomics)\\n\\n</robo-wiki-note>\\n\\n6. Ξεκινήστε το Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nΠαράδειγμα για αναβάθμιση του κόμβου collator σε Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Αλλαγή της Βάσης Δεδομένων της Αλυσίδας Ρελέ Kusama χωρίς Ορισμένη Βασική Διαδρομή**\\n\\nΥπάρχουν στιγμές όπου ορισμένα αποτυπώματα της Αλυσίδας Ρελέ Kusama προκαλούν σφάλματα στον κόμβο σας. Αυτό συνήθως οδηγεί στον τερματισμό του κόμβου σας. Παράδειγμα σφάλματος που προκαλείται από κατεστραμμένη βάση δεδομένων της Αλυσίδας Ρελέ:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nΓια να διορθώσετε αυτό το σφάλμα, πρέπει να αφαιρέσετε την υπάρχουσα βάση δεδομένων της Αλυσίδας Ρελέ Kusama (πιθανότατα RocksDb) και να την αντικαταστήσετε με μια άλλη Db, όπως το ParityDb. Εκτελέστε τις παρακάτω εντολές:\\n\\n1. Βρείτε τον κατάλογο του κόμβου Robonomics και ελέγξτε τα αρχεία:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Βεβαιωθείτε ότι βλέπετε τον κατάλογο polkadot και στη συνέχεια μεταβείτε στον κατάλογο chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Διαγράψτε τον κατάλογο `ksmcc3`:\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Δημιουργήστε ένα νέο κατάλογο `ksmcc3`.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Τώρα πρέπει να κατεβάσετε ένα νέο αποτύπωμα. Αυτό το παράδειγμα χρησιμοποιεί ένα αποτύπωμα της αλυσίδας ρελέ που έχει υποστεί έντονη περικοπή, αλλά μπορείτε να το αντικαταστήσετε με οποιοδήποτε αποτύπωμα προτιμάτε.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Ενώ το αποτύπωμα κατεβαίνει, ανοίξτε μια νέα συνεδρία και επεξεργαστείτε το αρχείο υπηρεσίας σας:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nΤροποποιήστε τις γραμμές μέσα στο αρχείο υπηρεσίας που σχετίζονται με τη βάση δεδομένων και την περικοπή:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nΧρησιμοποιήστε `Ctrl + S` και στη συνέχεια `Ctrl + X` για να αποθηκεύσετε και να βγείτε από το αρχείο υπηρεσίας.\\n\\n7. Τώρα πρέπει να επαναφορτώσετε το daemon σας.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. Μέχρι αυτή τη στιγμή, στην άλλη συνεδρία σας, ελπίζω ότι έχει κατεβάσει η νέα Db, οπότε αποσυμπιέστε το αρχείο:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. Αφού ολοκληρωθεί η αποσυμπίεση, εκτελέστε τα παρακάτω:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Τώρα μπορείτε να ξεκινήσετε την υπηρεσία, να την παρακολουθείτε για οποιαδήποτε σφάλματα και να ελέγξετε ότι συνδέεται τόσο με την αλυσίδα ρελέ όσο και με την παραλλαγή.\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"296d6cb22894d177b73ab21e0848177c\",\"title\":\"Εκκίνηση\",\"path\":\"/docs/el/launch/\",\"content\":\"\\n**Ένα άλλο βασικό χαρακτηριστικό του Robonomics parachain είναι η παλέτα Launch. Σας επιτρέπει να στέλνετε εντολές στους λογαριασμούς/οποιεσδήποτε οντότητες βρίσκονται πίσω από αυτές. Αυτές οι εντολές περιλαμβάνουν παράμετρο για τον καθορισμό της εργασίας που θα εκτελεστεί.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Παρακαλούμε να προσέξετε ότι αυτά και τα επόμενα εκπαιδευτικά προγράμματα παρουσιάζονται σε μια τοπική εκδοχή του Robonomics Node. Δημιουργήστε τη δική σας με [αυτές τις οδηγίες](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Πλοηγηθείτε στο Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Επιλέξτε launch -> launch από την αναπτυσσόμενη λίστα πιθανών extrinsics\\n\\nΕπίσης, επιλέξτε έναν λογαριασμό στον οποίο θέλετε να υποβάλετε το extrinsic. Συμπληρώστε τη διεύθυνση προορισμού και το πεδίο παραμέτρου.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  - Η εκκίνηση υποστηρίζει συμβολοσειρές μήκους 32 byte ως εντολές ([πηγή](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)),\\n  οπότε υπάρχει χώρος για αυτοσχεδιασμό εδώ:\\n  - Για βασικές εντολές όπως η εναλλαγή μπορείτε να χρησιμοποιήσετε \\\"0x000000000000000000000000000000000000000000000000000000000001\\\" ή\\n   \\\"0x0000000000000000000000000000000000000000000000000000000000000000000000000.\\n  - Για προχωρημένες εντολές, συμπεριλαμβανομένων json-like, μπορείτε να χρησιμοποιήσετε [IPFS](https://ipfs.tech/) CID μορφοποιημένο σε\\n  [σωστός τρόπος](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Υποβολή συναλλαγής\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Ελέγξτε την εκκίνησή σας στα events\\n\\nΓια αυτό, πλοηγηθείτε στο *Network -> Explorer* και βρείτε μια λίστα με events στα δεξιά. Κάντε κλικ σε ένα εικονίδιο τριγώνου για να το αναπτύξετε.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"4657da2bf151d849c033c577865d7116\",\"title\":\"Πώς να ξεκινήσετε τον συλλέκτη Robonomics\",\"path\":\"/docs/el/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  Στο συνεχόμενο βίντεο και στις στιγμιότυπες οθόνης αυτού του άρθρου, χρησιμοποιήσαμε την έκδοση 1.4.0 του Robonomics. Θα πρέπει να χρησιμοποιήσετε τις ίδιες εντολές, αλλά να αντικαταστήσετε την έκδοση του Robonomics με την τρέχουσα.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nΑυτήν τη στιγμή, το δίκτυο Robonomics διατηρείται κυρίως από τους αρχικούς προγραμματιστές, αλλά οποιοσδήποτε μπορεί να υποστηρίξει το έργο. Κάθε πιπλέον πλήρης κόμβος της αλυσίδας μπλοκ βοηθά να γίνει πιο βιώσιμο και ανθεκτικό σε σφάλματα. Οι δυαδικοί κόμβοι του Robonomics είναι διαθέσιμοι στο [release](https://github.com/airalab/robonomics/releases) assets ή μπορεί να δημιουργηθεί [από την πηγή](/docs/how-to-build-collator-node/).\\n\\n## Τι είναι ένας συλλέκτης\\n\\nΈνας Συλλέκτης είναι μέρος του Robonomics parachain. Αυτός ο τύπος κόμβου δημιουργεί νέα μπλοκ για την αλυσίδα Robonomics.\\n\\n>Οι συλλέκτες διατηρούν τα parachains συλλέγοντας συναλλαγές parachain από χρήστες και παράγοντας αποδείξεις μετάβασης κατάστασης για τους επικυρωτές της Relay Chain. Με άλλα λόγια, οι συλλέκτες διατηρούν τα parachains συγκεντρώνοντας συναλλαγές parachain σε υποψήφια μπλοκ parachain και παράγοντας αποδείξεις μετάβασης κατάστασης για τους επικυρωτές βάσει αυτών των μπλοκ.\\n\\nΜπορείτε να μάθετε περισσότερα για τους συλλέκτες στη σχετική [σελίδα του wiki του Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nΣτην parachain Robonomics, κάθε ταξινομητής λαμβάνει ανταμοιβές (**0,001598184 XRT**) για κάθε μπλοκ που δημιουργεί ο ταξινομητής (οι ανταμοιβές εμφανίζονται όταν τα μπλοκ σφραγίζονται στην αλυσίδα).\\nΕπίσης, ο συλλέκτης που δημιουργεί το μπλοκ λαμβάνει **50% των προμηθειών συναλλαγών** που περιέχονται στο μπλοκ που δημιουργούν.\\n\\n## Απαιτήσεις\\n\\nΣυνιστάται να ξεκινήσετε έναν συλλέκτη χρησιμοποιώντας τις **τυπικές απαιτήσεις υλικού** για τους [επικυρωτές του Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ Συμβατό με x86-64.\\n+ Intel Ice Lake, ή νεότερο (Xeon ή Core σειρά); AMD Zen3, ή νεότερο (EPYC ή Ryzen).\\n+ 4 φυσικοί πυρήνες @ 3.4GHz.\\n+ Απενεργοποιημένη ταυτόχρονη πολυνηματοποίηση (Hyper-Threading στην Intel, SMT στην AMD).\\n+ Αποθήκευση - Ένας NVMe SSD 1 TB (Καθώς πρέπει να έχει λογικό μέγεθος για να αντιμετωπίσει την ανάπτυξη της αλυσίδας μπλοκ).\\n+ Μνήμη - 32 GB DDR4 ECC\\n\\n\\nΣε αυτό το άρθρο χρησιμοποιούμε τις επόμενες προδιαγραφές:\\n+ 4 vCPU\\n+ 700 GB χώρου NVMe για τις βάσεις δεδομένων του συλλέκτη. Απαιτείται η δυνατότητα επέκτασης αυτού του χώρου δίσκου.\\n+ 8GB RAM\\n\\n\\n## Σημαντικές πληροφορίες\\n1. Χρησιμοποιούμε μερικές μεταβλητές σε αυτές τις οδηγίες και θα πρέπει να αντικαταστήσετε τις τιμές με τις δικές σας σε όλες τις εντολές:\\n    + **%NODE_NAME%** είναι το όνομα του κόμβου. Παράδειγμα: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** είναι η διαδρομή προς τοποθετημένο όγκο. Παράδειγμα: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** είναι η διεύθυνση λογαριασμού στο οικοσύστημα του Polkadot σε μορφή SS58. Παράδειγμα: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Σημειώστε ότι πρέπει να περιλαμβάνετε το *--state-cache-size=0* στην εκκίνηση της υπηρεσίας του συλλέκτη. Αυτή η παράμετρος είναι σημαντική για την σταθερότητα του συλλέκτη.\\nΜπορείτε να δείτε περισσότερες πληροφορίες στο σχετικό [θέμα](https://github.com/airalab/robonomics/issues/234) στο github.\\n\\n## Πρώτη φορά εύκολα ξεκινήστε έναν συλλέκτη Robonomics\\n\\nΜπορείτε εύκολα να ξεκινήσετε έναν συλλέκτη απευθείας από τη γραμμή εντολών για να ελέγξετε για σφάλματα.\\nΜετά από αυτό, συνιστάται ιδιαίτερα να ξεκινήσετε τον συλλέκτη Robonomics ως υπηρεσία (δείτε το επόμενο βήμα).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Ξεκινήστε τον συλλέκτη Robonomics ως υπηρεσία\\n\\n1. Δημιουργήστε τον χρήστη για την υπηρεσία με τον κατάλογο αρχικού καταλόγου\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Κατεβάστε, αποσυμπιέστε και μετακινήστε το δυαδικό του Robonomics στον κατάλογο */usr/local/bin/*. Θα πρέπει να αντικαταστήσετε το *$ROBONOMICS_VERSION* με την τρέχουσα έκδοση του Robonomics στις εντολές σε αυτήν την ενότητα. Μπορείτε να βρείτε την τρέχουσα έκδοση στη [σελίδα Κυκλοφορίας του αποθετηρίου Robonomics στο github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Δημιουργήστε το αρχείο υπηρεσίας systemd με το όνομα *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    Και προσθέστε τις παρακάτω γραμμές στο αρχείο υπηρεσίας:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Αποθηκεύστε αυτό το αρχείο, και στη συνέχεια ενεργοποιήστε και ξεκινήστε την υπηρεσία:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nΔιεύθυνση URL τηλεμετρίας: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nΤα αρχεία καταγραφής συλλαγτών μπορούν να παρακολουθούνται με: `journalctl -u robonomics.service -f`\\n\\nΜόλις εκκινηθεί ο συλλέκτης Robonomics, θα αρχίσει να συγχρονίζεται με την αλυσίδα αναμετάδοσης Kusama, αυτό μπορεί να διαρκέσει σημαντικό χρόνο, ανάλογα με την ταχύτητα του δικτύου σας και τις προδιαγραφές του συστήματός σας, γι' αυτό σας συνιστούμε να κάνετε λήψη ενός στιγμιότυπου Kusama.\\n\\n\\n## Επιτάχυνση της διαδικασίας συγχρονισμού χρησιμοποιώντας ένα στιγμιότυπο Kusama\\n\\nΣυνιστούμε να το κάνετε αμέσως μετά τη δημιουργία και την έναρξη της υπηρεσίας Robonomics. Μπορείτε να βρείτε περισσότερες πληροφορίες σχετικά με τα στιγμιότυπα και τις οδηγίες χρήσης στην ακόλουθη σελίδα: https://ksm-rocksdb.polkashots.io/\\n\\nΟδηγίες:\\n\\n1. Διακόψτε την υπηρεσία Robonomics και αφαιρέστε τον τρέχοντα κατάλογο βάσης δεδομένων Kusama:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Κατεβάστε το πραγματικό στιγμιότυπο και αποσυμπιέστε το:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    Μπορείτε να αφαιρέσετε το ληφθέν αρχείο μετά την επιτυχή αποσυσκευασία:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Ορίστε τη σωστή κυριότητα για τον φάκελο της βάσης δεδομένων:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Ξεκινήστε ξανά την υπηρεσία Robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Ελέγξτε τα αρχεία καταγραφής της υπηρεσίας:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Επίλυση Προβλημάτων\\n### Σφάλμα: \\\"State Database error: Too many sibling blocks inserted\\\"\\nΓια να διορθώσετε αυτό το σφάλμα, μπορείτε απλώς να εκκινήσετε τον ταξινομητή σας σε λειτουργία αρχειοθέτησης:\\n\\n1) Πρώτα, χρειάζεται να διακόψετε την υπηεσία Robonomics: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Στη συνέχεια, προσθέστε την παράμετρο `--state-pruning=archive` στο τμήμα parachain του αρχείου υπηρεσίας. Παράδειγμα του επεξεργασμένου αρχείου υπηρεσίας:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Επαναφορτώστε τη διαμόρφωση του διαχειριστή systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Αφαιρέστε την υπάρχουσα βάση δεδομένων parachain:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Ξεκινήστε την υπηρεσία robonomics:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    Μετά από αυτό, χρειάζεται να περιμένετε για τον συγχρονισμό της βάσης δεδομένων parahain.\\n\\n### Σφάλμα: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nΑυτό το σφάλμα σχετίζεται με τις παραμέτρους εικονικοποίησης. Χρειάζεται να χρησιμοποιήσετε τον τύπο \\\"host-model\\\" του εμούλαριστου επεξεργαστή. Μπορείτε να ρυθμίσετε αυτό στον κεντρικό υπολογιστή εικονικοποίησης.\\n\\nΩστόσο, αν αντιμετωπίσετε αυτό το σφάλμα σε οποιοδήποτε φιλοξενούμενο, χρειάζεται να ζητήσετε υποστήριξη από την τεχνική υποστήριξη για αυτό το πρόβλημα μόνο.\\n\"}},{\"node\":{\"id\":\"7bab4cd08e8d61ca47b56cd822672972\",\"title\":\"Πώς να κατασκευάσετε κόμβο συλλέκτη από την πηγή\",\"path\":\"/docs/el/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  Στο συνεχόμενο βίντεο και στις στιγμιότυπες οθόνης αυτού του άρθρου, χρησιμοποιήσαμε την έκδοση 1.4.0 του Robonomics. Θα πρέπει να χρησιμοποιήσετε τις ίδιες εντολές, αλλά να αντικαταστήσετε την έκδοση του Robonomics με την τρέχουσα.\\n</robo-wiki-note>\\n\\n## Τι είναι ένας συλλέκτης\\n\\nΟ συλλέκτης είναι μέρος του Robonomics parachain. Αυτός ο τύπος κόμβων δημιουργεί νέα μπλοκ για την αλυσίδα.\\n\\n>Οι συλλέκτες διατηρούν τα parachains συλλέγοντας συναλλαγές parachain από χρήστες και παράγοντας αποδείξεις μετάβασης κατάστασης για τους επικυρωτές της Relay Chain. Με άλλα λόγια, οι συλλέκτες διατηρούν τα parachains συγκεντρώνοντας συναλλαγές parachain σε υποψήφια μπλοκ parachain και παράγοντας αποδείξεις μετάβασης κατάστασης για τους επικυρωτές βάσει αυτών των μπλοκ.\\n\\nΜπορείτε να μάθετε περισσότερα για τον συλλέκτη στη σχετική [σελίδα του wiki του Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nΣτο Robonomics parachain, κάθε συλλέκτης λαμβάνει ανταμοιβές (**0.000380520 XRT**) για κάθε μπλοκ που κατασκεύασε, εάν αυτό το μπλοκ ήταν σφραγισμένο στην αλυσίδα.\\nΕπίσης, ο συλλέκτης λαμβάνει **50% χρεώσεις συναλλαγών** από αυτό το μπλοκ.\\n\\n## Διαδικασία κατασκευής\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nΒεβαιωθείτε ότι έχετε εγκαταστήσει το Rust και το λογισμικό υποστήριξης. Ο εγκαταστάτης του Rust θα σας ρωτήσει για τις τρέχουσες επιλογές εγκατάστασης, θα πρέπει να επιλέξετε την επιλογή `1) Συνέχεια με την εγκατάσταση (προεπιλογή)`.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Εγκατάσταση Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nΕγκατάσταση the required nightly toolchain and wasm target.\\nΟι επόμενες εντολές ισχύουν για το Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nΘα πρέπει επίσης να εγκαταστήσετε τα παρακάτω πακέτα:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nΤώρα μπορείτε να εγκαταστήσετε τον κόμβο robonomics από την πηγή git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nΜετά από αυτήν την εντολή, το μεταγλωττισμένο δυαδικό αρχείο robonomics θα βρίσκεται στον κατάλογο `~/.cargo/bin`.\\n\\nΤο επόμενο βήμα είναι πώς να ξεκινήσετε τον κόμβο συλλέκτη. Μπορείτε να διαβάσετε σχετικά στο [\\\"Πώς να ξεκινήσετε τον συλλέκτη Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator) άρθρο.\"}},{\"node\":{\"id\":\"7c00e3fb1c6c3d831a7e8204f1591fb8\",\"title\":\"Αναβαθμίστε το Home Assistant OS σας\",\"path\":\"/docs/el/hass-os-upgrade/\",\"content\":\"\\n**Αυτό το άρθρο περιέχει οδηγίες για την αναβάθμιση του υπάρχοντος Home Assistant OS σας με την ενσωμάτωση του Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Εγκατάσταση IPFS Add-on\\n\\n\\nΗ ενσωμάτωση Robonomics αποθηκεύει τα δεδομένα χρησιμοποιώντας το τοπικό IPFS daemon, οπότε πρέπει να το εγκαταστήσετε πρώτα. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. Υπάρχει ένα [IPFS Add-on για το Home Assistant](https://github.com/airalab/ipfs-addon). Για να το εγκαταστήσετε, πηγαίνετε στις `Settings` -> `Add-ons` και πατήστε το κουμπί `ADD-ON STORE` στην κάτω δεξιά γωνία.\\n\\n2. Πατήστε στις τρεις τελείες στην επάνω δεξιά γωνία και επιλέξτε `Repositories`. Προσθέστε εκεί τον παρακάτω σύνδεσμο:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Πατήστε το κουμπί `ADD`.\\n\\n4. λείστε τον διαχειριστή αποθετηρίων και ανανεώστε τη σελίδα. Τώρα στο τέλος της σελίδας μπορείτε να δείτε το IPFS Daemon Add-on.\\n\\n5. Ανοίξτε το πρόσθετο και πατήστε `INSTALL`. Μετά την εγκατάσταση, πατήστε `START`.\\n\\n## Εγκατάσταση HACS\\n\\nΤο [Home Assistant Community Store (HACS)](https://hacs.xyz/) σας επιτρέπει να εγκαταστήσετε προσαρμοσμένες ενσωματώσεις.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Πριν ξεκινήσετε, πρέπει να εγκαταστήσετε πρόσθετο για σύνδεση με τη συσκευή Home Assistant μέσω SSH. Στο Add-on Store αναζητήστε `ssh`. Συνιστούμε να εγκαταστήσετε το πρόσθετο `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Αν δεν βρεθεί το πρόσθετο SSH, δοκιμάστε να ενεργοποιήσετε την Προηγμένη Λειτουργία στις ρυθμίσεις του προφίλ χρήστη σας. Για να το κάνετε αυτό, κάντε κλικ στο εικονίδιο του προφίλ στην κάτω αριστερή γωνία και βρείτε την επιλογή Προηγμένη Λειτοργία.\\n\\n</robo-wiki-note>\\n\\n2. Επιλέξτε το πρόσθετο και πατήστε `INSTALL`. Αφού ολοκληρωθεί η εγκατάσταση, πηγαίνετε στην καρτέλα `Διαμόρφωση` και προσθέστε `password` ή `authorized_keys`. Μην ξεχάσετε να αποθηκεύσετε αυτό το μέρος της ρύθμισης.\\n\\n3. Στην καρτέλα `Info` πατήστε `START``. Αν θέλετε να δείτε το πρόσθετο στην πλαϊνή γραμμή, μην ξεχάσετε να ενεργοποιήσετε την επιλογή `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Ανοίξτε το SSH Add-on και εκτελέστε την παρακάτω εντολή:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Επανεκκινήστε το Home Assistant (μπορείτε να το κάνετε στις `Settings`->`System`). \\n\\n6. Τώρα η ενσωμάτωση HACS θα είναι διαθέσιμη για προσθήκη στο μενού `Integrations`. Πηγαίνετε στις `Settings`->`Devices & Services`, πατήστε `Add Integration` και βρείτε το HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Για να χρησιμοποιήσετε το HACS χρειάζεστε έναν λογαριασμό Github.\\n\\n</robo-wiki-note>\\n\\n7. Κάντε κλικ επάνω του και ακολουθήστε τις οδηγίες εγκατάστασης. \\n\\n## Εγκατάσταση Robonomics Integration\\n\\nΤώρα μπορείτε να εγκαταστήσετε την ενσωμάτωση Robonomics χρησιμοποιώντας το HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nΑνοίξτε το HACS από το μενού της πλαϊνής γραμμής και μεταβείτε στην επιλογή `Integrations`. Κάντε κλικ στο `Εxplore & Download Repositories`, μετά αναζητήστε `Robonomics` και κάντε κλικ στο κουμπί `Download` που βρίσκεται στην κάτω δεξιά γωνία. Μόλις ολοκληρωθεί η λήψη, επανεκκινήστε το Home Assistant.\"}},{\"node\":{\"id\":\"e56fc38a94eac3588713c1be9a3d8b08\",\"title\":\"Αρχικοποίηση του Home Assistant\",\"path\":\"/docs/el/hass-init/\",\"content\":\"\\n**Μετά την εγκατάσταση του Home Assistant, πρέπει να γίνει η αρχικοποίησή του.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nΞεκινάτε με τη δημιουργία του λογαριασμού ιδιοκτήτη του Home Assistant. Αυτός ο λογαριασμός είναι διαχειριστής και μπορεί να πραγματοποιήσει οποιεσδήποτε αλλαγές. Ανοίξτε έναν περιηγητή ιστού και μεταβείτε στη διεύθυνση `http://%RASPBERRY_IP_ADDRESS%:8123`. Μπορείτε να βρείτε τη διεύθυνση IP του Raspberry Pi χρησιμοποιώντας την εφαρμογή [Fing mobile app](https://www.fing.com/products) ή το εργαλείο γραμμής εντολών [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">Η διεύθυνση του Raspberry Pi μπορεί να αλλάξει με τον χρόνο, λόγω ρυθμίσεων δρομολογητή.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. Στην πρώτη σελίδα, εισαγάγετε ένα όνομα, όνομα χρήστη, κωδικό πρόσβασης και κάντε κλικ στο κουμπί `CREATE ACCOUNT`.\\n\\n2. Στην επόμενη οθόνη, εισαγάγετε ένα όνομα για το σπίτι σας και ορίστε την τοποθεσία και το σύστημα μονάδων σας. Κάντε κλικ στο `DETECT` για να βρείτε την τοποθεσία σας και να ορίσετε τη ζώνη ώρας κα το σύστημα μονάδων σας με βάση αυτήν την τοποθεσία. Αν δεν θέλετε να στείλετε την τοποθεσία σας, μπορείτε να ορίσετε αυτές τις τιμές χειροκίνητα.\\n\\n3. Στη συνέχεια, το Home Assistant θα εμφανίσει οποιεσδήποτε συσκευές έχει ανακαλύψει στο δίκτυό σας. Μην ανησυχείτε αν βλέπετε λιγότερα αντικείμενα από αυτά που φαίνονται παρακάτω· μπορείτε πάντα να προσθέσετε συσκευές χειροκίνητα αργότερα. Για τώρα, απλώς κάντε κλικ στο `FINISH` και θα βρεθείτε στην κύρια οθόνη του Home Assistant.\\n\\n4. Τέλος, θα δείτε τη διεπαφή ιστού του Home Assistant, η οποία θα εμφανίζει όλες τις συσκευές σας. \\n\\n\\n## Επίλυση Προβλημάτων\\n\\n1. Αν ξεχάσετε το όνομα χρήστη ή τον κωδικό πρόσβασης για τον τοπικό χρήστη, [ελέγξτε αυτό το άρθρο](https://www.home-assistant.io/docs/locked_out/) για να ανακτήσετε τα διαπιστευτήριά σας.\\n\"}},{\"node\":{\"id\":\"6489e81c0428fe5d57faf10dab3d7799\",\"title\":\"Προεγκατεστημένη εικόνα για το Raspberry Pi\",\"path\":\"/docs/el/hass-image-install/\",\"content\":\"\\n**Καλώς ήλθατε στον οδηγό εγκατάστασης του Home Assistant με ενσωμάτωση Robonomics σε ένα Raspberry Pi. Το Home Assistant είναι ένα σύστημα αυτοματισμού του σπιτιού ανοικτού κώδικα που παρέχει ένα κεντρικό κέντρο ελέγχου για τον έλεγχο έξυπνων συσκευών στο δίκτυο του σπιτιού σας. Με την ενσωμάτωση του Robonomics, ενός αποκεντρωμένου υπηρεσίας cloud, μπορείτε να ενισχύσετε τη λειτουργικότητα και την ασφάλεια του έξυπνου σπιτιού σας. Σε αυτό το άρθρο, θα παρέχουμε οδηγίες βήμα προς βήμα για την εγκατάσταση του Home Assistant με το Robonomics σε ένα Raspberry Pi, προσφέροντάς σας τη δυνατότητα αυτοματισμού και έλεγχου διάφορων πτυχών του σπιτιού σας χρησιμοποιώντας μια ασφαλή και αποκεντρωμένη λύση. Ας ξεκινήσουμε!**\\n\\n## Υλικό που χρειάζεστε για την εγκατάσταση\\n\\nΕάν δεν έχετε ήδη ενσωματώσει το Home Assistant στην έξυπνη κατοικία σας, είναι σημαντικό να γνωρίζετε τον εξοπλισμό που θα χρειαστείτε για να δημιουργήσετε ένα πλήρες σύστημα έξυπνου σπιτιού από το μηδέν.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Λήψη προεγκατεστημένης εικόνας Robonomics\\n\\nΗ προεγκατεστημένη εικόνα Robonomics περιλαμβάνει:\\n- Home Assistant Core\\n- IPFS\\n- Μεσίτη MQTT και Ενσωμάτωση\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nΜπορείτε να ελέγξετε τον πηγαίο κώδικα και να κατεβάσετε την τελευταία έκδοση της εικόνας στο [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Διαμόρφωση της εικόνας\\n\\nΕγκαταστήστε το [Raspberry Pi Imager](https://www.raspberrypi.com/software/) στον υπολογιστή σας. Στη συνέχεια, εισαγάγετε την κάρτα SD.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\nΕκτελέστε το πρόγραμμα Raspberry Pi Imager. Επιλέξτε την απαιτούμενη εικόνα ως λειτουργικό σύστημα και βεβαιωθείτε ότι έχετε επιλέξει την κάρτα SD από το αναπτυσσόμενο μενού αποθήκευσης.\\nΣτις ρυθμίσεις:\\n- Ορίστε όνομα χρήστη και κωδικό πρόσβασης (αποθηκεύστε το προεπιλεγμένο όνομα χρήστη \\\"pi\\\" για ευκολία στην ανάκληση),  \\n- παρέχετε το όνομα και τον κωδικό πρόσβασης του Wi-Fi σας, \\n- επιλέξτε τη χώρα σας από την αναπτυσσόμενη λίστα\\nκαι στη συνέχεια `Εγγραφή` της εικόνας. \\n                   \\n<robo-wiki-note type=\\\"note\\\">Φυλάξτε προσεκτικά το όνομα χρήτη και τον κωδικό πρόσβασης, καθώς αυτά τα διαπιστευτήρια θα χρειαστούν σε περίπτωση προβλημάτων.</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nΜπορείτε να βρείτε τους κωδικούς χώρας [εδώ](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. Πρώτη εκκίνηση\\n\\n**Αποσυνδέστε με ασφάλεια την κάρτα SD**, εισαγάγετέ την στο Raspberry Pi. Στη συνέχεια, **εισαγάγετε τον προσαρμογέα Zigbee** στο Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">Είναι σημαντικό να εισαγάγετε τον προσαρμογέα Zigbee πριν από την πρώτη εκκίνηση του Raspberry Pi! \\nΑυτό απαιτείται για την αυτόματη διαμόρφωση του δικτύου zigbee.</robo-wiki-note>\\n\\n**Εάν έχετε το [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (το οποίο διαθέτει όλο τον απαραίτητο firmware), μπορείτε απλά να συνεχίσετε με αυτές τις οδηγίες. Ωστόσο, εάν έχετε άλλο προσαρμογέα, το πρώτο πράγμα που πρέπει να κάνετε είναι να τον εγγράψετε με το λογισμικό Zigbee2MQTT. Μπορείτε να βρείτε οδηγίες για τη συσκευή σας [εδώ](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nΣτη συνέχεια, συνδέστε το καλώδιο τροφοδοσίας στη συσκευή σας. Θα πρέπει να συνδεθεί στο δίκτυο Wi-Fi σας. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nΜόλις συνδεθεί το Raspberry Pi, το κόκκινο LED θα ανάψει και το πράσινο LED θα αναβοσβήνει για κάποιο χρονικό διάστημα. Περιμένετε έως και 5 λεπτά για να εκκινήσει το Raspberry Pi και εγγραφείτε στο δίκτυο.\\n\\nΤώρα βρείτε τη διεύθυνση IP του Raspberry Pi. Για να το βρείτε, μπορείτε να χρησιμοποιήσετε την εφαρμογή κινητού [Fing](https://www.fing.com/products) ή \\nτο [εργαλείο γραμμής εντολών nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Βρείτε το `robots-home` (προαιρετικό όνομα μπορεί να είναι `Home(homeassistant)`) \\nόνομα της κεντρικής μηχανής στη λίστα IP. \\n\\nΣε αυτό το παράδειγμα η διεύθυνση είναι `192.168.43.56`. \\n\\nΓια να ελέγξετε ότι όλα λειτουργούν σωστά, ανοίξτε έναν web browser και μεταβείτε στην ιστοσελίδα `http://%RASPBERRY_IP_ADDRESS%:8123`. Σε αυτό το παράδειγμα, θα είναι `192.168.43.56:8123`.\\nΕάν όλα είναι εντάξει, θα δείτε τη διεπαφ χρήστη του Home Assistant. Εάν η ιστοσελίδα δεν ανοίγει, περιμένετε έως 5 λεπτά για να εκκινήσει το Raspberry Pi και δοκιμάστε ξανά. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Αντιμετώπιση προβλημάτων\\n\\n1. Για να αλλάξετε τις ρυθμίσεις Wi-Fi αργότερα, πρέπει να συνδεθείτε στο Raspberry Pi σας μέσω της εντολής `ssh`. Για να το κάνετε αυτό, ανοίξτε το τερματικό στον υπολογιστή σας\\nκαι πληκτρολογήστε την εντολή ssh με το όνομα χρήστη σας, που δημιουργήσατε στο βήμα \\\"Διαμόρφωση της εικόνας\\\" (το προεπιλεγμένο είναι \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\nκαι στη συνέχεια χρησιμοποιήστε την εντολή `sudo raspi-config`. Βρείτε περισσότερες πληροφορίες σχετικά με αυτήν την εντολή στο [επίσημο site.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"e716d821241e7058a7253a8c9008500a\",\"title\":\"Αναβαθμίστε το Home Assistant Docker σας για Unix-like λειτουργικό σύστημα\",\"path\":\"/docs/el/hass-docker-upgrade/\",\"content\":\"\\n**Αυτό το άρθρο περιέχει οδηγίες για την αναβάθμιση του υπάρχοντος Home Assistant Docker (σε Unix-like λειτουργικό σύστημα) με την ενσωμάτωση Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Υποθέτεται ότι χρησιμοποιούνται οι προεπιλεγμένες εικόνες και ο εμπορευματοκιβώτιο Docker του Home Assistant με το όνομα <u>homeassistant</u>.\\n  2. Το IPFS θα εγκατασταθεί και θα εκτελεστεί ως ένας <u>systemd</u> υπηρεσία στον κεντρικό υπολογιστή.\\n  3. Υποθέτεται ότι έχετε εγκατεστημένο το [Python3.9](https://www.python.org/downloads/) ή μεταγενέστερη έκδοση.\\n\\n</robo-wiki-note>\\n\\n## Εγκατάσταση\\n\\nΚατεβάστε το σενάριο εγκατάστασης και εκτελέστε το στο τερματικό:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nΘα δείτε την παρακάτω έξοδο:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Μπορεί να εμφανιστεί ένα σφάλμα όπως `mkdir: can't create directory 'custom_components': File exists`. Αυτό σημαίνει ότι έχετε ήδη αυτόν τον φάκελο με ορισμένα προσαρμοσμένα στοιχεία εγκατεστημένα. Απλά αγνοήστε αυτό το μήνυμα.\\n\\n</robo-wiki-note>\\n\\nΕπανεκκίνηση του εμπορευματοκιβωτίου:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Επαλήθευση\\n\\nΕλέγξτε ότι η υπηρεσία IPFS είναι ενεργή και λειτουργεί:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nΘα δείτε την παρακάτω έξοδο:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"c026a4afdf37a69d860fe770c7adf85c\",\"title\":\"Αναβαθμίστε τον πυρήνα του Home Assistant σας\",\"path\":\"/docs/el/hass-core-upgrade/\",\"content\":\"\\n**Αυτό το άρθρο περιέχει οδηγίες για την αναβάθμιση του υπάρχοντος πυρήνα του Home Assistant με την ενσωμάτωση του Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Υποθέτεται ότι η εγκατάσταση του πυρήνα του Home Assistant σας ολοκληρώθηκε σύμφωνα με τις [επίσημες οδηγίες](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) και υπάρχει ένας χρήστης <u>homeassistant</u> και το περιβάλλον `venv`. Αν δεν είναι αυτή η περίπτωση, ακολουθήστε τις οδηγίες παρακάτω, **αλλά επεξεργαστείτε το σενάριο αναλόγως**.\\n  2. Το IPFS θα εγκατασταθεί και θα εκτελεστεί ως ένας <u>systemd</u> υπηρεσία στον κεντρικό υπολογιστή.\\n  3. Υποτίθεται ότι έχετε εγκατεστημένο το [Python3.9](https://www.python.org/downloads/) ή νεότερη έκδοση.\\n\\n</robo-wiki-note>\\n\\n## Εγκατάσταση\\n\\nΚατεβάστε το σενάριο εγκατάστασης και εκτελέστε το στο τερματικό:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nΘα δείτε την παρακάτω έξοδο:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nΚατά τη διάρκεια της διαδικασίας, θα σας ζητηθεί να επιβεβαιώσετε την επανεκκίνηση αρκετών υπηρεσιών. Πλοηγηθείτε με το πλήκτρο `tab` και επιλέξτε την επιλογή `yes`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Μπορεί να εμφανιστεί ένα σφάλμα όπως `mkdir: can't create directory 'custom_components': File exists`. Αυτό σημαίνει ότι έχετε ήδη αυτόν τον φάκελο με ορισμένα προσαρμοσμένα στοιχεία εγκατεστημένα. Απλά αγνοήστε αυτό το μήνυμα.\\n\\n</robo-wiki-note>\\n  \\nΑφού τελειώσετε, επανεκκινήστε το Home Assistant σας.\\n\\n## Επαληθεύω\\n\\nΕλέγξτε ότι η υπηρεσία IPFS είναι ενεργή και λειτουργεί:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nΘα δείτε την ακόλουθη έξοδο:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"f91b1b02826feb26e541f67fa6f73fba\",\"title\":\"Glossary\",\"path\":\"/docs/el/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\nένας συνδυασμός ενός δημόσιου-ιδιωτικού ζεύγους κλειδιών, το δημόσιο μέρος του οποίου είναι η δημόσια διεύθυνση του χρήστη και το ιδιωτικό μέρος είναι το μυστικό κλειδί για την πρόβαση και έλεγχο αυτής της διεύθυνσης.\\n\\n\\n### Auction (of Parachains)\\nμηχανισμός ενοικίασης θέσεων για παρασυνδέσεις στα οικοσυστήματα Polkadot και Kusama. Μια παρασύνδεση πρέπει να κερδίσει μια δημοπρασία για να αποκτήσει μια θέση.\\n\\n### Autonomous Agent\\nένας υπολογιστικός σύστημα που λαμβάνει αισθητήρια δεδομένα από το περιβάλλον του και αποφασίζει πώς να ανταποκριθεί σε εξωτερικά ερεθίσματα για να επιτύχει τους στόχους του.\\n\\n### AIRA\\nή Αυτόνομος Έξυπνος Ρομποτικός Πράκτορας - ένα λογισμικό που αναπτύχθηκε από την ομάδα Robonomics το 2015, που υλοποιεί το πρότυπο οικονομικής αλληλεπίδρασης ανθρώπου-μηχανής και μηχανής-μηχανής μέσω ενός συμβολαίου οικονομικής ευθύνης.\\n\\n\\n## B\\n\\n### Blockchain\\nσε ευρύτερη έννοια, ένα κατανεμημένο δίκτυο που χρησιμοποιεί κρυπτογραφία για να επιτρέψει σε μια ομάδα συμμετεχόντων να καταλήξουν σε συναίνεση για την αλλαγή κατάστασης ενός συστήματος χωρίς αμοιβαία εμπιστοσύνη.\\n\\n### Blockchain Εξερευνήστεr\\nμια εφαρμογή που επιτρέπει να εξερευνήσετε τα διάφορα μπλοκ, συναλλαγές και διευθύνσεις σε ένα blockchain (π.χ. Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\nμια προκαθορισμένη λογική αυτοματισμού που μπορεί να προστεθεί εύκολα σε μια περίπτωση Home Assistant.\\n\\n### Bridge\\nμια τεχνολογία και μέθοδοι με τις οποίες δύο οικονομικά κυρίαρχες και τεχνολογικά ποικίλες αλυσίδες μπορούν να επικοινωνήσουν μεταξύ τους. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nή Cs — ένα εκατομμυριοστό μερίδιο ενός διακριτικού XRT, 1 XRT = 1 000 000 Cs. πήρε το όνομά του από τον Ronald Coase, Βρετανό οικονομολόγο, έναν από τους ιδρυτές των θεσμικών οικονομικών, βραβευμένο με το βραβείο Nobel Memorial στις Οικονομικές Επιστήμες.\\n\\n### Collator\\nένας κόμβος που διατηρεί μια παρασύνδεση συλλέγοντας συναλλαγές παρασύνδεσης και παράγοντας αποδείξεις μετάβασης κατάστασης για τους επαληθευτές.\\n\\n### Consensus\\nμια διαδικασία κατά την οποία οι κόμβοι ενός δικτύου blockchain καταλήγουν σε συμφωνία σχετικά με την παρούσα κατάσταση των δεδομένων στο δίκτυο (π.χ. Proof-of-Work, Proof-of-Stake).\\n\\n### Crowdloan\\nμια εκστρατεία χρηματοδότησης για τη συλλογή κερμάτων για να γίνει προσφορά στη δημοπρασία θέσεων στο οικοσύστημα Polkadot / Kusama.\\n\\n### Cybernetics\\nη μελέτη του ελέγχου και της επικοινωνίας στο ζώο και τη μηχανή, σύμφωνα με τον ορισμό του N. Wiener.\\n\\n### Cyber-Physical System\\nή CPS - μια ισχυρή ενοποίηση και αμοιβαία ολοκλήρωση πολλαπλών υπολογιστικών, δικτυακών και φυσικών διεργασιών.\\n\\n\\n## D\\n\\n### DAO\\nμια οργάνωση με κοινή κυριότητα και διακυβέρνηση με blockchain, όπου η διαχείριση πόρων πραγματοποιείται σύμφωνα με ένα προκαθορισμένο και φορμαλισμένο σύνολο κανόνων, η επιβολή των οποίων γίνεται αυτόματα.\\n\\n### Αρχείο καταγραφής δεδομένων (Function)\\nμια λειτουργία παρασύνδεσης Robonomics που αποθηκεύει δεδομένα συσκευής στο blockchain.\\n\\n### Dapp\\nή αποκεντρωμένη εφαρμογή - μια εφαρμογή που λειτουργεί ως μέρος ενός κατανεμημένου δικτύου και παρέχει πρόσβαση στις λειτουργίες της με φιλικό προς τον χρήστη τρόπο.\\n\\n### Decentralized Cloud\\nένας υπολογιστικός υπηρεσία βασισμένος σε ένα αποκεντρωμένο δίκτυο από ομότιμους χρήστες που μπορούν να συμμετέχουν είτε για να χρησιμοποιήσουν υπηρεσίες είτε για να παρέχουν τους πόρους τους, όπως για υπολογισμό, δικτύωση, αποθήκευση, κλπ.\\n\\n### Digital Twin\\nμια ψηφιακή έκδοση πραγματικού εξοπλισμού που αντιγράφει τα τεχνικά του χαρακτηριστικά και τα ιστορικά δεδομένα.\\n\\n\\n## E\\n\\n### Edge-system\\nένα IoT συσκευή που λειτουργεί ως σύνδεσμος μεταξύ τοπικά προσβάσιμων ενσωματωμένων συστημάτων και του παγκόσμιου δικτύου, συνήθως υποστηρίζοντας πρωτόκολλα επικοινωνίας και μεταίδοντας τηλεμετρία και σήματα ελέγχου.\\n\\n### Embedded System\\nμια IoT συσκευή με περιορισμένους υπολογιστικούς και επικοινωνιακούς πόρους που παρέχει βασικές λειτουργίες (αισθητήρες, ενεργοποιητές, κουμπιά) στο χαμηλότερο επίπεδο, συνήθως χωρίς διεπαφές χρήστη.\\n\\n### Ethereum\\nένα αποκεντρωμένο ανοικτού κώδικα σύστημα blockchain που λειτουργεί ως πλατφόρμα για πολλά άλλα κρυπτονομίσματα, καθώς και για την εκτέλεση αποκεντρωμένων έξυπνων συμβολαίων.\\n\\n### Ethereum Upgrade\\nπροηγουμένως γνωστό ως Ethereum 2.0 ή Eth2 - μια αναβάθμιση του πρωτοκόλλου Ethereum που θα πρέπει να καταστήσει το δίκτυο πιο κλιμακούμενο, ασφαλές και βιώσιμο. Για αυτούς τους σκοπούς, προτείνεται η αλλαγή της συναίνεσης σε Απόδειξη-της-Συμμετοχής και η προσθήκη μηχανισμού sharding για την αύξηση της χωρητικότητας του δικτύου.\\n\\n### Exodus\\nδιαδικασία μεταφοράς των κέρματων XRT από το δίκτυο Ethereum στο Robonomics parachain.\\n\\n### Extrinsic\\nμια λειτουργία στο δίκτυο Polkadot και Kusama, που μπορεί να ενεργοποιήσει μεταβάσεις κατάστασης του δικτύου από εκτός της κατάστασης.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nή Gk - ένα χιλιοστό του κέρματος XRT, 1 XRT = 1 000 Gk. Ονομάζεται έτσι προς τιμήν του Βίκτορ Γκλούσκοφ, Σοβιετικού μαθηματικού, ενός από τους ιδρυτές της πληροφορικής και της κυβερνοτικής στη Σοβιετική Ένωση.\\n\\n\\n## H\\n\\n### Home Assistant\\nή Hass — ένα λογισμικό συστήματος ελέγχου ανοιχτού κώδικα, σχεδιασμένο να αποτελεί κεντρικό κόμβο για έξυπνες συσκευές.\\n\\n### HRMP\\nή Οριζόντια μετάδοση μηνυμάτων με δρομολόγηση αναμετάδοσης — ένα ασφαλές μήνυμα που περνάει μεταξύ των parachains, το οποίο αποθηκεύει όλα τα μηνύματα στον χώρο αποθήκευσης της Αλυσίδας αναμετάδοσης πριν τα στείλει σε parachains.\\n\\n### HMI\\nή Διεπαφή Ανθρώπου-Μηχανής - μια διεπαφή χρήστη ή πίνακας ελέγχου που συνδέει τον χρήστη με μια μηχανή, ένα σύστημα ή μια συσκευή.\\n\\n\\n## I\\n\\n### Industry 4.0\\nή Τέταρτη Βιομηχανική Επανάσταση - η συνεχιζόμενη αυτοματοποίηση των παραδοσιακών κατασκευαστικών και βιομηχανικών πρακτικών, χρησιμοποιώντας σύγχρονη έξυπνη τεχνολογία.\\n\\n### IPFS\\nή Διαστημικό Αρχείο Αρχείων - ένα λογισμικό από ομότιμους προς ομότιμους για την αποθήκευση και την κοινή χρήση δεδομένων σε ένα κατανεμημένο αρχείο συστήματος.\\n\\n### IoT\\nή Διαδίκτυο των Πραγμάτων - μια σύνδεση με ένα παγκόσμιο δίκτυο δισεκατομμυρίων συσκευών, ικανών να συλλέγουν δεδομένα και να ενσωματωθούν στο περιβάλλον.\\n\\n### IoT Gateway\\nένα σύστημα άκρου, που συγκεντρώνει και μεταδίδει δεδομένα από συσκευές IoT στο δίκτυο και αντίστροφα. Συχνά αυτές οι συσκευές είναι μια πιο πολύπλοκη έκδοση του δρομολογητή WiFi.\\n\\n### IoT Provider\\nένας εξωτερικός υπηρεσία που παρέχει στους χρήστες IoT απομακρυσμένη πρόσβαση σε δεδομένα και αναλύσεις, καθώς και έλεγχο έξυπνων συσκευών μέσω του Διαδικτύου.\\n\\n### IoT Subscription\\nχαρακτηριστικό του Robonomics parachain που επιτρέπει τη χρήση όλων των λειτουργιών του parachain για ένα συγκεκριμένο χρονικό διάστημα χωρίς χρέωση.\\n\\n\\n## K\\n\\n### KSM\\nένα νομισματικό σύμβολο για το δίκτυο Kusama.\\n\\n### Kusama\\nτο \\\"canary network\\\" για το Polkadot που αποτελείται από μια πρώιμη έκδοση του λογισμικού Polkadot που δεν έχει ελεγχθεί.\\n\\n\\n## L\\n\\n### Εκκίνηση (Function)\\nμια λειτουργία του Robonomics parachain που ξεκινά ή σταματά μια συσκευή αποστέλλοντας μια εντολή μέσω του blockchain.\\n\\n### Lease Period\\nένα ποσό χρόνου που μια parachain μπορεί να συνδεθεί με το Relay Chain.\\n\\n### Libp2p\\nμια βιβλιοθήκη ανοικτού κώδικα για τη δημιουργία κρυπτογραφημένων δικτύων από ομότιμους προς ομότιμους.\\n\\n### Lights-out Factory\\nή Έξυπνο Εργοστάσιο - ένα εργοστάσιο που είναι πλήρως αυτοματοποιημένο και δεν απαιτεί ανθρώπινη παρουσία στον τόπο.\\n\\n### Lighthouse\\nένα έξυπνο συμβόλαιο, στον έννοια της οικονομίας των ρομπότ, το οποίο πραγματοποιεί μια συναλλαγή όταν ο Πάροχος καθιερώνει μια αγορά αντιστοίχισης μεταξύ του Υποσχόμενου και του Υποσχομένου.\\n\\n### Υποχρέωση\\nένα έξυπνο συμβόλαιο, που δημιουργείται από κυβερνο-φυσικά συστήματα μεταξύ τους ή με ανθρώπους, για την εκτέλεση μιας εργασίας έναντι πληρωμής.\\n\\n### Υποχρέωση Market\\nμια πλατφόρμα, στο πλαίσιο της έννοιας της οικονομίας των ρομπότ, που αναλαμβάνει την αντιστοίχιση προσφορών και ζητήσεων μεταξύ των κόμβων του συστήματος.\\n\\n\\n## M\\n\\n### MQTT\\nή Message Queuing Telemetry Transport — ένα πρωτόκολλο δημοσίευσης-εγγραφής σχεδιασμένο για χαμηλή εύρος ζώνης, υψηλή καθυστέρηση, αναξιόπιστα δίκτυα για τη λειτουργία υψηλών όγκων μηνυμάτων συσκευών IoT.\\n\\n### MQTT Broker\\nένας υπηρεσία που λαμβάνει όλα τα μηνύματα από τους πελάτες MQTT και στη συνέχεια δρομολογεί τα μηνύματα στους κατάλληλους συνδρομητές πελάτες.\\n\\n\\n## N\\n\\n### NFT\\nή Non-Fungible Token — ένα token που δεν μπορεί να ανταλλαχθεί και να ξεχωρίσει από άλλα tokens που επιτρέπουν την τοκετοποίηση μοναδικών αντικειμένων και παρέχουν αποκλειστική ιδιοκτησία για αυτά τα tokens.\\n\\n### Node (of Robonomics)\\nένα Substrate-based ή Ethereum-based blockchain module με επεκτάσεις Robonomics για σύνδεση με το Robonomics Network.\\n\\n\\n## O\\n\\n### On-chain Governance\\nένας διαδικασία καθορισμού των αλλαγών που επιτρέπονται στο δίκτυο, όπως τροποποιήσεις του κώδικα ή μετακίνηση κεφαλαίων, που υπάρχει στο ίδιο το δίκτυο και μπορεί να το αλλάξει απευθείας.\\n\\n\\n## P\\n\\n### Pallet\\na Substrate module written in Rust that bundles specific logic or algorithm for runtime of Substrate-based blockchain. \\n\\n### Parachain\\nμια προσαρμοσμένη, εφαρμογή-συγκεκριμένη δομή δεδομένων (συνήθως ένα blockchain) που ενσωματώνεται στο Relay Chain και μπορεί να επικυρωθεί από τους επαληθευτές.\\n\\n### Parathread\\nμια parachain χωρίς θέση που μπορεί προσωρινά να συμμετάσχει (κατά βλοκ με αμοιβή) στην ασφάλεια του Relay Chain.\\n\\n### Polkadot\\nένα ανισόρροπο, πολυ-αλυσιδωτό δίκτυο που επιτρέπει σε διάφορα blockchains με διαφορετικά χαρακτηριστικά να πραγματοποιούν αυθαίρετη, διασυνδετική επικοινωνία με κοινή ασφάλεια.\\n\\n### Polkadot/Substrate Portal\\nένα βασικό Substrate UI για την αλληλεπίδραση με ένα δίκτυο Polkadot, Kusama και άλλα δίκτυα Substrate.\\n\\n### Proposal (on Polkadot / Kusama)\\nμια πιθανή πρόσκληση λειτουργίας που θα ψηφιστεί σε δημοψήφισμα Polkadot, Kusama ή parachains.\\n\\n### Proof-of-Work\\nένας μηχανισμός συναίνεσης στον οποίο, για να επιτευχθεί συμφωνία, οι συμμετέχοντες στο δίκτυο απαιτούνται να εκτελέσουν υπολογιστικό έργο.\\n\\n### Proof-of-Stake\\nένας μηχανισμός συναίνεσης στον οποίο, για να επιτευχθεί συμφωνία, οι συμμετέχοντες στο δίκτυο απαιτούνται να καταθέσουν κεφάλαιο του συναφούς κρυπτονομίσματος που λειτουργεί ως ενέχυρο.\\n\\n### Promisee\\nένας κόμβος που τοποθετεί μια παραγγελία για την εκτέλεση μιας εργασίας στον οικονομικό κόσμο των ρομπότ.\\n\\n### Promisor\\nένας κόμβος που συμφωνεί να εκτελέσει μια εργασία για πληρωμή στον οικονομικό κόσμο των ρομπότ.\\n\\n### Provider (Robonomics)\\nένας κόμβος, στην έννοια της οικονομίας ρομπότ, που παρακολουθεί τα μηνύματα της Αγοράς Ευθύνης και ταιριάζει με μια προσφορά και μια ζήτηση για μια μικρή αμοιβή.\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\nμέρος της διακυβέρνησης εντός της αλυσίδας, ψηφίστε για το εάν μια πρόταση πρέπει να γίνει αποδεκτή ή όχι από τους χρήστες του δικτύου.\\n\\n### Relay Chain\\nη κύρια αλυσίδα που συντονίζει τη συναίνεση του Polkadot / Kusama και την επικοινωνία μεταξύ των parachains.\\n\\n### Robofirm\\nμια οργάνωση στην οποία ολόκληρη η κύκλος επιχειρηματικής διαδικασίας είναι πλήρως αυτοματοποιημένη και δεν απαιτεί ανθρώπινη συμμετοχή.\\n\\n### Rococo\\nτο testnet για τη δοκιμή των parachains στο Kusama\\n\\n### robonomics-interface\\nμια βιβλιοθήκη Python που εξειδικεύεται στη διεπαφή με το Robonomics για ευκολότερο προγραμματισμό.\\n\\n### Robonomics στο Ethereum\\nμια έκδοση του Robonomics Network που λειτουργεί πάνω από το Ethereum, κυκλοφόρησε το 2018.\\n\\n### Robot Economy\\nένα οικονομικό σύστημα στο οποίο οι συσκευές λειτουργούν ως ανεξάρτητοι πράκτορες ικανοί να πραγματοποιούν βασικές οικονομικές δραστηριότητες που προηγουμένως ήταν μοναδικές για τους ανθρώπους.\\n\\n### Robot-as-a-Service\\nή RaaS — ένα μοντέλο επιχειρηματικού μοντέλου όπου οι εταιρείες ενοικιάζουν τον εξοπλισμό ρομποτικής σε πελάτες και πελάτες για προσωρινή ή μακροπρόθεσμη χρήση.\\n\\n### ROS\\nή Robot Operating System — ένα πλαίσιο για την ανάπτυξη λογισμικού ρομπότ, που παρέχει υπηρεσίες σχεδιασμένες για ένα ανισόρροπο υπολογιστικό σύμπλεγμα όπως η αφαίρεση υλικού, ο έλεγχος συσκευών χαμηλού επιπέδου, η υλοποίηση κοινώς χρησιμοποιούμενων λειτουργιών, η μετάδοση μηνυμάτων μεταξύ διεργασιών και η διαχείριση πακέτων.\\n\\n### ROS 2\\nμια ενημερωμένη και ανακατασκευασμένη έκδοση του Robot Operating System με νέα χαρακτηριστικά, όπως υποστήριξη για πολλαπλά ρομπότ και μικρά ενσωατωμένα συστήματα και ολοκλήρωση με πραγματικό χρόνο.\\n\\n### ROS 2 Middleware\\nή RMW — ένα πρωτόκολλο που παρέχει τα πρότυπα χαρακτηριστικά του ROS 2, όπως η ανακάλυψη, η σειριοποίηση και η μεταφορά. Το ROS 2 υποστηρίζει πολλαπλές υλοποιήσεις middleware που μπορούν να επιλεγούν για να καλύψουν καλύτερα τις απαιτήσεις του έργου.\\n\\n### RWS\\nή Robonomics Web Services — αποκεντρωμένες υπηρεσίες υποδομής για ρομποτική και IoT που επιτρέπουν την εύκολη σύνδεση των συσκευών και την αλληλεπίδραση με εφαρμογές χρηστών, υπηρεσίες cloud και άλλες συσκευές με ασφάλεια. Διαθέτει το δικό της token που ονομάζεται επίσης RWS, το οποίο παρέχει συνδρομή IoT για ολόκληρη τη διάρκεια ζωής στο Robonomics parachain.\\n\\n### Εκτέλεσηtime\\nμια συνάρτηση μετάβασης κατάστασης ενός blockchain που καθορίζει έναν έγκυρο αλγόριθμο για τον καθορισμό της κατάτασης του επόμενου μπλοκ δεδομένου της προηγούμενης κατάστασης.\\n\\n\\n## S\\n\\n### Seed Phrase\\nένα ανθρωποαναγνώσιμο ιδιωτικό κλειδί που δημιουργείται ως μια ακολουθία τυχαίων λέξεων και απαιτείται για να αποκτήσετε πρόσβαση στη διεύθυνση της αλυσίδας των blockchain και τα tokens της.\\n\\n### Shared Security\\nτο μοντέλο ασφαλείας του Polkadot / Kusama, όπου όλες οι αλυσίδες ασφαλίζονται εξίσου τοποθετώντας αποδείξεις της εγκυρότητας των blocks των parachain στην Relay Chain, έτσι ώστε ένας πιθανός επιτιθέμενος να χρειαστεί να επιτεθεί σε ολόκληρο το σύστημα.\\n\\n### SLS Gateway\\nμια πύλη ανοιχτού κώδικα για συσκευές Zigbee βασισμένη στον μικροελεγκτή ESP32 που αναπτύχθηκε από το Smart Logic System.\\n\\n### Slot (of Parachain)\\nένας πεπερασμένος πόρος στο οικοσύστημα του Polkadot / Kusama, που επιτρέπει στο parachain να συνδεθεί με την Relay Chain χωρίς χρέωση για κάθε block.\\n\\n### Smart Leasing\\nμια παραλλαγή του μοντέλου Robot-as-a-Service, στην οποία η ενοικίαση πληρώνεται όχι ανά χρονική περίοδο, αλλά για συγκεκριμένες λειτουργίες και τον αριθμό τους.\\n\\n### Smart Contract\\nένα πρόγραμμα ή αλγόριθμος που αποθηκεύεται σε ένα blockchain και εκτελείται αυτόματα όταν πληρούνται προκαθοριμένες συνθήκες.\\n\\n### SSH\\nή Secure Shell — ένα πρωτόκολλο δικτύου για ασφαλή λειτουργία υπηρεσιών δικτύου μέσω μη ασφαλούς δικτύου, που χρησιμοποιεί κρυπτογραφία δημόσιου κλειδιού για τον έλεγχο ταυτότητας του απομακρυσμένου υπολογιστή.\\n\\n### Staking\\nτο μέρος της συναίνεσης Proof-of-Stake, μια πράξη δέσμευσης των tokens με την κατάθεσή τους ως ενέχυρο για μια ευκαιρία να παράγει ένα έγκυρο block και να αποκτήσει ανταμοιβή.\\n\\n### Substrate\\nένα ευέλικτο πλαίσιο για τη δημιουργία blockchain όπως το Polkadot και το Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nένα ταμείο πόρων που συλλέγεται μέσω μιας μερίδας από τις ανταμοιβές παραγωγής block, τα τέλη συναλλαγών, το staking κ.λπ., που μπορεί να δαπανηθεί μέσω μιας πρότασης δαπανών. Εάν το Ταμείο λήξει μια περίοδο δαπανών χωρίς να δαπανήσει όλα τα κεφάλαιά του, υποστηρίζει μια καύση ενός ποσοστού των κεφαλαίων.\\n\\n### Transaction Costs\\nτο κόστος συλλογής και επεξεργασίας πληροφοριών λόγω της περιορισμένης λογικής των οικονομικών παραγόντων και της πολυπλοκότητας των διαδικασιών.\\n\\n\\n## V\\n\\n### Validator\\nένας κόμβος που ασφαλίζει την Relay Chain δεσμεύοντας τα tokens του, επαληθεύοντας αποδείξεις από συλλέκτες στις parachain και ψηφίζοντας για τη συναίνεση μαζί με άλλους επαληθευτές.\\n\\n\\n## W\\n\\n### Web3\\nμια ιδέα για μια νέα εκδοχή του Διαδικτύου που ενσωματώνει έννοιες όπως η αποκεντρωμένη διαχείριση, οι τεχνολογίες blockchain και η οικονομία βασισμένη σε tokens.\\n\\n### Wiener (XRT)\\nή Wn - ένα δισεκατομμυριοστό μερίδιο ενός XRT token, 1 XRT = 1 000 000 000 Wn. Ονομάζεται έτσι προς τιμήν του Νόρμπερτ Βίνερ, ενός Αμερικανού μαθηματικού, ενός από τους ιδρυτές της κυβερνοβιολογίας και της θεωρίας της τεχνητής νοημοσύνης.\\n\\n\\n## X\\n\\n### XCM\\nή Cross-Consensus Message Format - ένας τρόπος μεταξύ διαφορετικών συστημάτων blockchain στο Polkadot / Kusama.\\n\\n\\n### XRT\\nένα νομισματικό token για το Robonomics Network, που υπάρχει ανεξάρτητα στα δίκτυα Ethereum και Kusama.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nμια υλοποίηση επικάλυψης δικτύου ενός πλήρως κρυπτογραφημένου σχήματος δρομολόγησης για δίκτυα mesh.\\n\\n\\n## Z\\n\\n### Zigbee\\nένα πρωτόκολλο ασύρματης επικοινωνίας, πολύ συνηθισμένο για τη σύνδεση έξυπνων συσκευών λόγω της χαμηλής κατανάλωσης ενέργειας, της ευκολίας ρύθμισης και ευελιξίας της διαμόρφωσης και της υποστήριξης αυτοοργανωμένης και αυτοανακτούμενης τοπολογίας δικτύου.\\n\\n### Zigbee Adapter\\nμια συσκευή που μεταφέρει δεδομένα μεταξύ του δικτύου Zigbee και ενός άλλου δικτύου (π.χ. Wi-Fi) για τον έλεγχο των συσκευών Zigbee.\\n\\n### Zigbee2MQTT\\nένα λογισμικό που επιτρέπει τη σύνδεση του Zigbee σε δίκτυα MQTT μεταφράζοντας μηνύματα από το ένα δίκτυο στο άλλο.\"}},{\"node\":{\"id\":\"a72ab53d7c02d6077842fecec4859b6a\",\"title\":\"Παγκόσμια Διαχείριση\",\"path\":\"/docs/el/global-administration/\",\"content\":\"\\n**Αυτό το άρθρο θα σας δείξει πώς να δημιουργήσετε ένα νέο χρήστη στο Home Assistant σας.**\\n\\n## Προσθήκη Χρηστών στην Συνδρομή\\n\\nΔεν μπορείτε να χρησιμοποιήσετε προηγομένως δημιουργημένους λογαριασμούς επειδή οι `SUB_OWNER` και `SUB_CONTROLLER` παρέχουν ασφάλεια, και ο πρώτος χρήστης που δημιουργήσατε όταν πρωτοξεκινήσατε το Home Assistant δεν έχει έναν λογαριασμό Robonomics Parachain.\\n\\n1. Δημιουργήστε έναν λογαριασμό στο Robonomics parachain, όπως έκαναν στο [προηγούμενο άρθρο](/docs/sub-activate/).\\n\\n2. Χρησιμοποιώντας τον λογαριασμό `SUB_OWNER` προσθέστε έναν νέο λογαριασμό χρήστη στη συνδρομή στην [εφαρμογή](https://dapp.robonomics.network/#/subscription/devices). Τώρα θα πρέπει να υπάρχουν τρεις διευθύνσεις στη λίστα πρόσβασης: `SUB_OWNER`, `SUB_CONTROLLER` και `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Χορήγηση Πρόσβασης στον Χρήστη\\n\\n1. Πηγαίνετε στην υπηρεσία εφαρμογής που ονομάζεται [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Επιλέξτε τον λογαριασμό που μόλις δημιουργήσατε στη δεξιά πλευρά (ελέγξτε ότι έχετε επιλέξει τν επιθυμητό λογαριασμό πατώντας το εικονίδιο προφίλ).\\n\\n2. Εισαγάγετε τον κωδικό σπόρου `USER` στο απαιτούμενο πεδίο. Προσθέστε τις διευθύνσεις `SUB_OWNER` και `SUB_CONTROLLER` στα πεδία διαπιστευτήρια διαχειριστή. Εάν όλα είναι σωστά, θα δείτε την κατάσταση επαλήθευσης `ΕΠΑΛΗΘΕΥΜΕΝΟ`.\\n\\n3. Δημιουργήστε έναν κωδικό πρόσβασης για έναν νέο χρήστη που μόλις καταχωρήσατε και στη συνέχεια επιβεβαιώστε τη συναλλαγή, η οποία τώρα θα είναι χωρίς χρέωση λόγω της συνδρομής. Αργότερα μπορείτε να ανακτήσετε τον κωδικό πρόσβασης στην καρτέλα Ανάκτηση.\\n\\n4. Μετά τη διαδικασία εγγραφής, συνδεθείτε στο Home Assistant με τη διεύθυνση του χρήστη σας ως σύνδεση και έναν νεοδημιουργημένο κωδικό πρόσβασης.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nΤώρα μπορείτε να χρησιμοποιήσετε την εφαρμογή για να ελέγξετε το σπίτι σας μέσω του Robonomics, ελέγξτε το άρθρο [**\\\"Λήψη Έξυπνης Οικιακής Τηλεμετρίας\\\"**](/docs/smart-home-telemetry/).\\n\\n## Επίλυση Προβλημάτων\\n\\n1. Εάν ξεχάσετε έναν κωδικό πρόσβασης στο Home Assistant από τον λογαριασμό σας Robonomics, [ελέγξτε το Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nΠηγαίνετε στο τμήμα \\\"Your Home Assistant password\\\" και επιλέξτε την καρτέλα \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"b12f24c945ccc14c03fdfe8b0a9e9929\",\"title\":\"Ξεκινώντας\",\"path\":\"/docs/el/getting-started/\",\"content\":\"\\n## Τι είναι το Robonomics\\n\\nΗ πλατφόρμα Robonomics παρέχει εργαλεία για την εργασία με το δίκτυο οικονομίας ρομπότ. Το Robonomics επιτρέπει στους σχεδιαστές έξυπνων πόλεων και ζωνών βιμηχανίας 4.0 να δημιουργήσουν εμπιστοσύνη μεταξύ των [αυτόνομων ρομπότ υπηρεσιών](/docs/glossary#cyber-physical-system), να παρέχουν [άμεση πρόσβαση του χρήστη μέσω dapp](/docs/glossary#dapp) για την παραγγελία προϊόντων από αυτόνομες εργοστασιακές μονάδες και υπηρεσίες αστικών αισθητήρων. Αυτό, από τη σειρά του, θα μας επιτρέψει να θέσουμε σε εφαρμογή ένα αποκεντρωμένο σύστημα που παρακολουθεί παγκοσμίως τις δραστηριότητες των κυβερνοφυσικών συστημάτων.\\n\\nΟ παρακάτω πίνακας περιγράφει τη θέση που καταλαμβάνει το Robonomics στο σενάριο:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nΒρείτε περισσότερα στο [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Γρήγορη εκκίνηση δικτύου Robonomics\\n**Για την ευκολία των νέων χρηστών, οι προγραμματιστές του πυρήνα του Robonomics δημιούργησαν έν [6-μαθημάτων πρόγραμμα μάθησης](/docs/wschool2021-intro/)!**\\n\\nΘα εξερευνήσετε την αρχιτεκτονική IoT χωρίς διακομιστή! Οι Υπηρεσίες Ιστού Robonomics (RWS) είναι η βασική υποδομή για τη ρομποτική και το IoT πάνω από το Polkadot && το IPFS.\\n\\nΟι απόφοιτοι του μαθήματος μπορούν να ξεκινήσουν ένα τοπικό αλυσίδας αναμετάδοσης και να ελέγχουν μια συσκευή συμβατή με ROS μέσω διακρατικών συναλλαγών.\\n\\n**[Συνδεθείτε στο Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) για να συνδεθείτε με την κοινότητα και να λάβετε τεχνική υποστήριξη.**\\n\\n### Οφέλη για τους αποφοίτους της Ακαδημίας Robonomics\\n- Πρακτική άσκηση για τους καλύτερους φοιτητές   Γίνετε μέλος της ομάδας Robonomics και συνεισφέρετε στην ανάπτυξη του επιλεγμένου προϊόντος.\\n- Ενεργή κοινότητα && τακτικές εκδηλώσεις   Γίνετε μέρος της κοινότητας των μαθητών, συζητήστε τις περιπτώσεις χρήσης σας με ειδικούς του κλάδου. Ομαδοποιηθείτε και συμμετάσχετε σε διαγωνισμούς ανάπτυξης!\\n- Πιστοποιητικό ολοκλήρωσης   Προσθέστε ένα πιστοποιητικό για την ολοκλήρωση του μαθήματος για τη δημιουργία DAPPs για το IoT στο βιογραφικό σας.\\n- Βοήθεια στην εισαγωγή στο πανεπιστήμιο ITMO. Είτε είστε πτυχιούχος είτε μεταπτυχιακός φοιτητής, θα λάβετε βοήθεια για την εισαγωγή σας στο πανεπιστήμιο.\\n- Ευκαιρίες χρηματοδότησης && επιτάχυνσης: 1)Υποβάλετε αίτηση για υποστήριξη έως και $50.000 Academia - υποτροφία υποστήριξης. 2)Συμμετάσχετε στο πρόγραμμα επιτάχυνσης των δημιουργών Robonomics που υποστηρίζεται από το Ίδρυμα Web3. 3)Αναπτύξτε τη δική σας αυτόνομη DAPP πάνω από το Robonomics. 4)Μονετοποιήστε το && λάβετε υποστήριξη μάρκετινγκ πό την ομάδα Robonomics.\\n\\n\\n## Τι περιέχει η τεκμηρίωση\\n\\n### Είμαι προγραμματιστής Dapp\\n\\n- [Robonomics-js στο GitHub](https://github.com/airalab/robonomics-js) - απλό SDK Javascript για προγραμματιστές δικτύου Robonomics dApp.\\n- [Πρότυπο dApp](https://github.com/airalab/vue-dapp-robonomics-template) - χρησιμοποιεί το Vue.js\\n- [Τεκμηρίωση Wiki](/docs/robonomics-js/)\\n\\n### Είμαι μηχανικός ρομποτικής\\n\\nΕλέγξτε την ενότητα [περιπτώσεων](/docs/iot-sensors-connectivity/) και ξεκινήστε την ανάπτυξη με [παραδείγματα](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"c83f65fa4f911ce4fcc653699f06941e\",\"title\":\"Πώς να αγοράσετε μια συνδρομή\",\"path\":\"/docs/el/get-subscription/\",\"content\":\"\\n**Η πληρωμή προμήθειας για συναλλαγές στο blockchain είναι ενοχλητική. Φανταστείτε μια συσκευή IoT που στέλνει τηλεμετρία κάθε 5-10 λεπτά. Αυτό θα σας κοστίσι αρκετά πολύ κατά τη διάρκεια του μήνα. Ένα από τα κύρια χαρακτηριστικά του δικτύου Robonomics είναι η συνδρομή RWS - Robonomics Web Service. Πληρώστε μηνιαίως και ξεχάστε το κόστος συναλλαγής! Για θεωρητική βάση ανατρέξτε στο [άρθρο αυτό](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855).**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Προσέξτε ότι αυτός ο οδηγός δείχνει πώς να αγοράσετε μια συνδρομή στο Robonomics Kusama parachain. Μπορείτε επίσης να εκτελέσετε όλα τα ίδια βήματα στον [τοπικό κόμβο](/docs/run-dev-node) σας.\\n\\n  Ένα ακόμα πράγμα πριν ξεκινήσετε. Αυτός είναι ένας \\\"δύσκολος\\\" τρόπος αγοράς μιας συνδρομής. Υπάρχει και ένας συμβατικός τρόπος να το κάνετε αυτό μέσω του [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Προσφέρετε σε μια Δημοπρασία\\n\\nΟι συνδρομές στο Robonomics πωλούνται με ένα μοντέλο δημοπρασίας. Για να αποκτήσετε μια, πρπει να προσφέρετε σε μια δημοπρασία και να την κερδίσετε (μην ανησυχείτε, είναι γρήγορο).\\n\\nΣτο `Developer/Chain state` μπορείτε να δείτε τις διαθέσιμες δημοπρασίες. \\nΕπιλέξτε `rws` και `auctionQueue` και πατήστε το κουμπί `+`, θα δείτε τα αναγνωριστικά των διαθέσιμων δημοπρασιών:\\n\\n![queue](../images/rws/queue.png)\\n\\nΜπορείτε να δείτε πληροφορίες για οποιαδήποτε συνδρομή με την `rws` `auction` και το αναγνωριστικό της δημοπρασίας (το αναγνωριστικό της δημοπρασίας στην εικόνα είναι 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nΣτις πληροφορίες για τη δημοπρασία μπορείτε να δείτε το πεδίο `winner`, αυτή τη στιγμή είναι `null` οπότε κανείς δεν έχει αυτή τη συνδρομή και μπορείτε να την αποκτήσετε. Για να το κάνετε αυτό, πηγαίνετε στο `Developer/Extrinsic`, επιλέξτε τον λογαριασμό σας και `rws -> bid`. Ορίστε επίσης το αναγνωριτικό της δημοπρασίας (79) και το ποσό των μονάδων που θέλετε να προσφέρετε (περισσότερο από 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nΥποβάλετε τη συναλλαγή και ελέγξτε τις πληροφορίες για τη δημοπρασία με αναγνωριστικό 79 (στην `Chain state` επιλέξτε `rws -> auction` και αναγνωριστικό 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nΤώρα στο πεδίο `winner` θα δείτε τη διεύθυνση του λογαριασμού σας, αυτό σημαίνει ότι αυτός ο λογαριασμός έχει τη συνδρομή 79. Μια δημοπρασία ξεκινά με την πρώτη προσφορά και διαρκεί μερικά μπλοκ, οπότε αν κάποιος προσφέρει περισσότερα tokens από εσάς στα επόμενα μερικά μπλοκ, αυτός θα είναι ο νικητής και θα αποκτήσει τη συνδρομή.\\n\\nΤώρα μπορείτε να προσθέσετε συσκευές. Οι συσκευές είναι λογαριασμοί που μπορούν να χρησιμοποιήσουν αυτήν τη συνδρομή και να υποβάλουν εξωτερικές συναλλαγές χωρίς χρέωση.\\nΓια να το δοκιμάσετε, δημιουργήστε έναν νέο λογαριασμό χωρίς διακριτικά και προσθέστε τον σε συσκευές.\\n\\nΓια να προσθέσετε συσκευές, επιλέξτε `rws -> setDevices` στο `Developer/Extrinsic`. Στη συνέχεια, πατήστε το κουμπί `Add Item` και επιλέξτε τον πρόσφατα δημιουργημένο λογαριασμό χωρίς τοκετά:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nΥποβάλετε τη συναλλαγή. Τώρα μπορείτε να ελέγξετε τη λίστα των συσκευών στην  `Chain state` με το `rws -> devices`. Εκεί θα δείτε τη διεύθυνση του λογαριασμού σας χωρίς τοκετά. Επιλέξτε τον λογαριασμό που αγόρασε τη συνδρομή και πατήστε `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nΤώρα μπορείτε να δοκιμάσετε να [στείλετε εξωτερική εντολή εκκίνησης](/docs/subscription-launch) χρησιμοποιώντας τη συνδρομή.\"}},{\"node\":{\"id\":\"53c47558ed9c5c16434ffec13c3f8976\",\"title\":\"Ρύθμιση και εγκατάσταση λογισμικού Gaka-Chu\",\"path\":\"/docs/el/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**Σε αυτό το άρθρο θα περάσουμε μερικά βήματα εγκατάστασης και εκκίνησης για να ρυθμίσουμε ένα ρομπότ-ζωγράφο. Απαιτήσεις:**\\n- KUKA KR6 R900 sixx με KRC4 και SmartPad·\\n- Intel NUC με εγκατεστημένο [ROS melodic](http://wiki.ros.org/melodic/Εγκατάστασηation/Ubuntu)·\\n- Τραπέζι, χρώμα, πινέλο, νερό. \\n\\n## Εγκατάσταση λογισμικού στο KRC4\\nΑπαιτείται διεπαφή EKI και στα δύο, KRC4 και NUC. Λεπτομερείς πληροφορίες για το πώς να το ρυθμίσετε στο KRC4 παρουσιάζονται [εδώ](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Εκκινήστε το στον ελεγκτή του ρομπότ.\\n\\n## Εγκατάσταση λογισμικού στο NUC\\nΔημιουργήστε έναν χώρο εργασίας catkin:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nΛήψη πακέτων ROS. Όλα τα σενάρια αποθηκεύονται [εδώ](https://github.com/airalab/robot_painter/tree/test_branch). Κλωνοποιήστε το αποθετήριο:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nΜπορεί να χρειαστείτε μερικά αρχεία κεφαλίδων και βιβλιοθήκες για να λειτουργήσει σωστά. Κατεβάστε τα:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nΠροσθέστε την εντολή πηγής στο αρχείο `.bashrc`:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nΜέχρι στιγμής, θα πρέπει να μπορείτε να κκινήσετε τα σενάρια. Εάν κάτι πάει στραβά, δοκιμάστε μερικές [διορθώσεις προβλημάτων](https://github.com/airalab/robot_painter/issues)\\n\\n## Συμπλήρωση σταθερών\\nΚαταρχάς, το ρομπότ πρέπει να γνωρίζει τη θέση και τον προσανατολισμό του καμβά, καθώς και τη θέση του κουτιού με το χρώμα. Όλα αυτά καθορίζονται στο `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Ας το ρίξουμε μια ματιά.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nΑυτές είναι οι σταθερές εξισώσεων επιπέδου που καθορίζουν τη θέση του καμβά στον 3D χώρο. Πρέπει να ληφθούν κατά τη διάρκεια ενός διαδικασίας βαθμονόμησης που περιγράφεται παρακάτω. Στη συνέχεια ακολουθεί το χρώμα.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nΑυτές είναι οι συντεταγμένες του κουτιού με το χρώμα. Μπορούν επίσης να καθοριστούν κατά τη βαθμονόμηση. Οι διαστάσεις του καμβά καθορίζονται στο\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nΑποθηκεύονται και άλλες σημαντικές σταερές στο `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nΤα ονόματά τους λένε όλα, οπότε συμπληρώστε τα ανάλογα με την κατάσταση.\\n\\n## Βαθμονόμηση Gaka-Chu\\nΗ ίδια η διαδικασία βαθμονόμησης είναι αρκετά απλή.\\n\\n1) Εκκίνηση διεπαφής EKI στο KRC4:\\n\\nΣυνδεθείτε σε λειτουργία 'AUT', ενεργοποιήστε τους οδηγούς και εκκινήστε το σενάριο `eki_hw_interface`\\n\\n2) Εκκίνηση διεπαφής EKI στο NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nΘα πρέπει να εμφανίζει ατελείωτα αρχεία καταγραφής.\\n\\n3) Εκκίνηση RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nΘα πρέπει να δείτε το εξής:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nΔοκιμάστε να μετακινήσετε τον τερματικό εκτελεστή και κάντε κλικ στο 'Σχεδιασμός και Εκτέλεση'. Ο ρομπότ θα πρέπει να κινηθεί. Στο SmartPad πηγαίνετε σε **Display -> Actual position** και παρατηρήστε τις συντεταγμένες του τερματικού εκτελεστή. Τοποθετήστε ένα καμβά οριζόντια στη βάση του ρομπότ. Συνδέστε ένα πινέλο στον κάτοχο πινέλου και μετακινήστε το προσεκτικά μέχρι να ακουμπήσει ελάχιστα τον καμβά. Σε αυτή τη θέση, αποθηκεύστε τις συντεταγμένες του τερματικού εκτελεστή. Επαναλάβετε 12-15 φορές. Επίσης, αποθηκεύστε τις συντεταγμένες του κέντρου του καμβά και του κουτιού με την μπογιά.\\nΌταν έχετε ένα σύνολο συντεταγμένων, χρησιμοποιήστε [αυτά](https://github.com/nakata5321/Matlab_scripts_gaka-chu) τα Matlab scripts για να επιλύσετε τις λείπουσες σταθερές και το quaternion. Επικολλήστε τα. Ανακατασκευάστε τον χώρο εργασίας σας με\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Δοκιμή της βαθμονόμησης Gaka-Chu\\nΌταν έχει βαθμονομηθεί, η Gaka-Chu πρέπει να δοκιμαστεί σχεδιάζοντας τα όρια του καμβά. Για να τον κάνετε να το κάνει, εκτελέστε τα παρακάτω σε νέο τερματικό:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nΜετά από αυτό, θα πρέπει να δείτε ένα περίγραμμα του καμβά στο RViz:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nΠατήστε \\\"S\\\" στο τερματικό για να πραγματοποιήσετε τη δοκιμή. Ο τερματικός εκτελεστής του ρομπότ θα πρέπει να μετακινηθεί ακριβώς πάνω από τα όρια του καμβά και το πινέλο θα πρέπει να ακουμπάει απαλά τον καμβά κατά τη διάρκεια ολόκληρης της κίνησης. Αν δεν συμβαίνει αυτό, δοκιμάστε να ξαναβαθμονομήσετε. Αν το μοντέλο του καμβά είναι περιστραμμένο λάθος, μπορείτε να το περιστρέψετε αλλάζοντας το quaternion στο Matlab.\\n\\n## Δημιουργία τέχνης\\nΧρειάζεστε 6 βασικά ενότητες για να λειτουργήσει όλο αυτό:\\n- Διεπαφή EKI;\\n- MOVEit + RViz;\\n- Μετάδοση πλαισίων περιβάλλοντος;\\n- Υπηρεσία μετατροπής εικόνας;\\n- Ενότητα σχεδίασης τροχιών;\\n- Εκκίνηση ενεργοποιητή.\\n\\nΑς τις εκκινήσουμε μία-μία.\\n\\n### Διεπαφή Eki\\nΣτο KRC4 εκκινήστε το `eki_hw_interface`, στο NUC σε ένα νέο τερματικό κάντε:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz και MOVEit\\nΧρειάζεστε έναν σχεδιαστή και μια προσομοίωση. Εκκινήστε τα με\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Περιβάλλον\\nΠείτε στο ρομπότ πού βρίσκονται το κουτί με τη μπογιά και ο καμβάς. Σημειώστε ότι δεν είναι απαραίτητο να εκκινήσετε τον κόμβο `draw workspace`, ο `tf_broadcaster` μοιράζεται το μέγεθος του καμβά. Απλώς δεν το εμφανίζει στο RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Επεξεργαστής εικόνων\\nΌλες οι εισερχόμενες εικόνες πρέπει να επεξεργαστούν. Εκκινήστε την υπηρεσία.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nΌταν λαμβάνει την κλήση, επεξεργάζεται μια εικόνα με ένα φίλτρο HP και δημιουργεί ένα αρχείο rosbag με τις τροχιές.\\n\\n### Ενότητα σχεδίασης τροχιών\\nΤο κυριότερο σενάριο εδώ είναι ο ίδιος ο σχεδιασής τροχιών. Αναμένει την εικόνα, καλεί την υπηρεσία TextConverter και σχεδιάζει τη ζωγραφική.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Στείλτε στο ρομπότ μια εικόνα για να σχεδιάσει\\nΤο ρομπότ ακούει ένα συγκεκριμένο ROS-θέμα όπου πρέπει να περάσετε τη διαδρομή προς μια επιθυμητή εικόνα. Η εικόνα πρέπει να είναι τετράγωνη (πλάτος ίσο με ύψος) και να αποτελείται από γραμμές. Στείλτε τη διαδρομή:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nΜετά από αυτό, εμφανίζονται δύο παράθυρα που δείχνουν τα περίγραμματα και τις τροχιές. Κλείστε τα και δείτε τον Gaka-Chu να σχεδιάζει. Να είστε προσεκτικοί για την ασφάλεια και να είστε πάντα έτοιμοι να πατήσετε το κουμπί έκτακτης ανάγκης.\\nΌταν ο Gaka-Chu τελειώσει την τέχνη του, μπορείτε να στείλετε μια άλλη διαδρομή για εικόνα και ο ζωγράφος επαναλαμβάνει ολόκληρη τη διαδικασία.\\n\"}},{\"node\":{\"id\":\"aaad3374dcff921d88deb421a33432dc\",\"title\":\"Συνδέστε μια συσκευή Amazon FreeRTOS στο Robonomics μέσω MQTT\",\"path\":\"/docs/el/freertos-mqtt/\",\"content\":\"\\nΕδώ είναι η επίδειξη του πώς ένας μικροελεγκτής που εκτελεί το [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) μπορεί να συνδεθεί στο δίκτυο Robonomics μέσω MQTT. Παρακαλούμε ελέγξτε [αυτό το αποθετήριο](http://github.com/khssnv/freertos_mqtt_robonomics_example) για τον πηγαίο κώδικα του έργου.\\n\\nΧρησιμοποιούμε το [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) με την διανομή FreeRTOS και την υλοποίηση MQTT που παρέχεται από το [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) ενώ η Espressif είναι ο προμηθευτής του μικροελεγκτή που χρησιμοποιείται.\\n\\nΕπίσης, υπάρχει ένας αισθητήρας [PMS-3003](http://www.plantower.com/en/content/?107.html) για σκοπούς επίδειξης. Ο αισθητήρας μετρά την παρουσία σωματιδίων στον αέρα και μπορεί να χρησιμοποιηθεί για να εκτιμηθεί η ποιότητα του αέρα.\\n\\nΗ ποιότητα του αέρα δεν είναι θέμα του άρθρου, μπορείτε να βρείτε περισσότερες πληροφορίες στην ιστοσελίδα του ΠΟΥ: [Περιβαλλοντική (εξωτερική) ατμοσφαιρική ρύπανση](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). Ένας στόχος του συστήματος είναι να δημοσιεύει τις μετρήσεις του αισθητήρα στο δίκτυο Robonomics της Airalab.\\n\\n## Ρύθμιση υλικού\\n\\nΣυνδέουμε το PMS3003 TXD PIN5 στο ESP32 DevKitC IO17 για να μεταφέρουμε τις μετρήσεις μέσω UART.\\nΚαι οι δύο συσκευές απαιτούν τροφοδοσία και κοινή γείωση.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Ροή Δεδομένων\\n\\nΓια να παραδώσουμε τις μετρήσεις του αισθητήρα στο δίκτυο Robonomics, σε επίπεδο firmware, ο στόχος μας είναι να λάβουμε δεδομένα από έναν αισθητήρα μέσω του ενσωματωμένου πρωτοκόλλου επικοινωνίας που υποστηρίζει (UART στην περίπτωσή μας) και να τα περάσουμε στην περίπτωση του AIRA μέσω MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nΣτο παράδειγμά μας χρησιμοποιούμε την αναπτυξιακή πλατφόρμα AIRA που είναι διαθέσιμη με δημόσια διεύθυνση IP και όνομα τομέα.\\nΣτην περίπτωση τυ AIRA, ρυθμίζουμε τον μεσολαβητή MQTT `mosquitto` και εγγραφόμαστε στο θέμα `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` για να λάβουμε μηνύματα από το MQTT.\\n\\nΣτη συνέχεια, περνάμε τα μηνύματα στον `robonomics io` writer μέσω αγωγού.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nΤώρα τα δεδομένα είναι διαθέσιμα στο δίκτυο Robonomics και μπορούμε να τα διαβάσουμε ξανά με το `robonomics io`.\\n\\n## Λογισμικό ενσωματωμένου συστήματος\\n\\nΧρησιμοποιούμε την [εφαρμογή δείγματος ESP-MQTT με μεταφορά TCP](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) ως βάση.\\n\\nΜόνο τροποποιούμε το `main/app_main.c` για τη σύνδεση UART με τον αισθητήρα, τον χρονικό συγχρονισμό SNTP και την περιοδική δημοσίευση MQTT.\\n\\nΕάν προσπαθείτε να επαναλάβετε το έργο και είναι το πρώτο έργο σας βασισμένο στο ESP IDF, παρακαλούμε ακολουθήστε αρχικά τον [οδηγό προγραμματισμού ESP-IDF της Espressif](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) για να εξοικειωθείτε με τις λειτουργίες του firmware όπως οι ρυθμίσεις, η δημιουργία και η μεταφόρτωση με το εργαλείο `idf.py`.\\n\\n### Ρύθμιση Wi-Fi\\n\\nΓια να επικοινωνήσει ο μικροελεγκτής μας με το AIRA που είναι εγκατεστημένο στο cloud, απαιτείται σύνδεση στο Internet.\\nΧρησιμοποιούμε το Wi-Fi του ESP32 για αυτό.\\nΗ Espressif παρέχει εργαλεία για τη ρύθμιση του ενσωματωμένου Wi-Fi.\\nΣτο παράδειγμά μας χρησιμοποιούμε περιβάλλον ανάπτυξης με Ubuntu 20.04 GNU/Linux.\\nΓια να ρυθμίσουμε το Wi-Fi, πηγαίνουμε στον φάκελο του έργου και εκτελούμε το εργαλείο ρύθμισης του SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nΣτη συνέχεια, ορίζουμε το SSID και τον κωδικό πρόσβασης του σημείου πρόσβασης Wi-Fi στην ενότητα `Example Σύνδεσηion Διαμόρφωση`.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### Ρύθμιση Τελικού Σημείου MQTT\\n\\nΥπάρχουν δύο πράγματα που πρέπει να ρυθμίσουμε για το MQTT.\\nΤο πρώτο είναι η διεύθυνση του μεσολαβητή MQTT.\\nΜπορεί να ρυθμιστεί με το εργαλείο ρύθμισης του SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nΟρίστε το `Broker URL` στην ενότητα `Example Διαμόρφωση`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nΤο δεύτερο πράγμα είναι το θέμα MQTT.\\nΤο ορίζουμε στο firmware με το πρόθεμα του ονόματος του έργου ακολουθούμενο από τη διεύθυνση MAC του ESP32.\\nΑυτό μας δίνει `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` για το συγκεκριμένο μικροτσίπ.\\n\\n## Από το MQTT στο Robonomics\\n\\nΑς ελέγξουμε αρχικά αν λαμβάνουμε δεδομένα μέσω MQTT.\\nΜπορούμε να εγγραφούμε στο θέμα του μεσολαβητή MQTT Mosquitto που δημοσιεύει η συσκευή.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nΕδώ φέρνουμε το πακέτο `mosquitto` στο περιβάλλον μας για να χρησιμοποιήσουμε το εργαλείο `mosquitto_sub`.\\nΣτη συνέχεια εγγραφόμαστε στο θέμα που έχει οριστεί στο firmware.\\nΈχουμε τις μετρήσες μας, που σημαίνει ότι η AIRA λαμβάνει τα δεδομένα μέσω MQTT σωστά.\\nΤώρα ας διαβιβάσουμε αυτά τα μηνύματα στο Δίκτυο Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nΕδώ χρησιμοποιούμε το εργαλείο `robonomics` για να δημοσιεύσουμε μηνύματα στο κανάλι pubsub `/freertos_mqtt_robonomics_example`.\\nΚαθορίζουμε τα `bootnodes` για να διασφαλίσουμε την εγκαθίδρυση τουλάχιστον μίας σύνδεσης.\\n\\nΤώρα διαβάζουμε αυτά τα μηνύματα από το ίδιο κανάλι pubsub.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Αρχικοί πόροι που χρησιμοποιήθηκαν\\n\\n* Διάταξη ακίδων ESP32 DevKitC από το ιστολόγιο του GoJimmy https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* Δομή δεδομένων και αποκωδικοποιητής PSM3003 από το OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Σας ευχαριστούμε όλους!**\\n\"}},{\"node\":{\"id\":\"8cf060599dbe2a38a38fa3a5dbf9d65e\",\"title\":\"Πώς να επεξεργαστείτε το Wiki\",\"path\":\"/docs/el/edit-wiki/\",\"content\":\"\\n**Το Robonomics Wiki είναι ανοιχτού κώδικα. Οποιαδήποτε διόρθωση είναι ευπρόσδεκτη: διόρθωση σφαλμάτων, τυπογραφικών λαθών, ορισμένων ασαφών ή ξεπερασμένων πληροφοριών, μετάφραση σε οποιαήποτε γλώσσα. Θα χρειαστείτε ένα [GitHub](https://github.com/) λογαριασμό.**\\n\\n\\n## Πώς να επεξεργαστείτε\\n\\nΕάν χρειάζεστε να επεξεργαστείτε τα έγγραφα του Robonomics Wiki, παρακαλούμε ακολουθήστε αυτά τα βήματα\\n\\nΒεβαιωθείτε ότι έχετε [Node.js](https://nodejs.org/en/download/package-manager/) και [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) εγκατεστημένο.\\n\\n### 1. Κλωνοποίηση αποθετηρίου\\n\\nΑρχικά, πρέπει να κλωνοποιήσετε το αποθετήριο του wiki:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nΜεταβείτε στον κατάλογο του αποθετηρίου και εκτελέστε τις παρακάτω εντολές:\\n\\n`χρησιμοποιώντας το npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`χρησιμοποιώντας το yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Τοπική εκτέλεση (develop, develop-m1)\\n\\nΣτη συνέχεια, αναπτύξτε το έργο τοπικά: \\n\\n```\\ngridsome develop\\n```\\n\\n> Εάν αντιμετωπίζετε το σφάλμα `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`, εκτελέστε την παρακάτω εντολή:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Δημιουργία PR\\n\\n[Δημιουργία αίτησης εξαγωγής (pull request)](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) προς [αποθετήριο wiki](https://github.com/airalab/robonomics-wiki)\\n\\n## Συστατικά\\n\\n### Asciinema\\nΤο Robonomics Wiki υποστηρίζει το Asciinema. Για να εισάγετε το Asciinema, παρακλούμε ακολουθήστε αυτές τις οδηγίες:\\n* Εισαγάγετε το συστατικό μετά το μπλοκ frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* Εισαγάγετε ως ξεχωριστό παράγραφο `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, όπου το vid είναι το αναγνωριστικό του συγκεκριμένου asciicast\\n\\n> Μπορείτε να λάβετε τον κώδικα ενσωμάτωσης για ένα συγκεκριμένο asciicast κάνοντας κλικ στον σύνδεσμο “Ενσωμάτωση” στη σελίδα του asciicast.\\n> Φαίνεται έτσι:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Τεκμηρίωση Asciinema](https://asciinema.org/docs/embedding)\\n\\nΣτο παράδειγμα παραπάνω, το vid είναι το 14.\\n\\n### Κώδικας\\n\\nΜπορείτε να προσθέσετε χρήσιμα πρόσθετα στον κώδικά σας:\\n\\n`κώδικας με κουμπί αντιγραφής`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nή `κωδικός με πρόσθετη γραμμή`.\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Ιδιότητες για τον code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nΤα έγγραφα στο Robonomics Wiki περιέχουν μπλοκ frontmatter. Πρέπει να βρίσκεται στην κορυφή του αρχείου Markdown και πρέπει να έχει τη μορφή έγκυρου YAML που βρίσκεται ανάμεσα σε τριπλά παύλες. Μεταξύ των τριπλών παύλων, μπορείτε να ορίσετε ή να επεξεργαστείτε τις παρακάτω επιλογές:\\n\\n```YAML\\n---\\ntitle: How to contribute # Τίτλος για τη σελίδα, δεν χρειάζεται να τον επαναλάβετε στο κείμενο\\ncontributors: [positivecrash] # Κύριοι συνεισφέροντες (όσοι επιμελούνται ενεργά αυτήν τη σελίδα). Απαιτείται το ψευδώνυμο του GitHub, χωρίς κανένα επιπλέον σύμβολο\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Εγκατάστασηation\\n    # Εργαλεία που χρησιμοποιήθηκαν για τη δοκιμή της τεχνολογίας\\n---\\n```\\n\\n### Grid \\nΒοηθά να προστεθεί διάταξη πλέγματος στα στοιχεία:\\n\\n- Χρησιμοποιήστε πρώτα το συστατικό περιτύλιξης πλέγματος: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- Και στη συνέχεια χρησιμοποιήστε όσα στοιχεία πλέγματος επιθυμείτε μέσα στο περιτύλιγμα:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Ιδιότητες για τον robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Εικόνες\\n\\n#### Πώς να ανεβάσετε \\nΑνεβάστε την εικόνα στον φάκελο `/docs/images/url-of-your-doc`\\n* Εάν η εικόνα χρειάζεται να τοποθετηθεί τοπικ, εισαγάγετε όλες σε έναν φάκελο\\n* Χρησιμοποιήστε πρόθεμα τοπικοποίησης στο όνομα των εικόνων εάν είναι τοπικοποιημένες, π.χ. `image_en.jpg`\\n* Βεβαιωθείτε ότι η εικόνα σας είναι βελτιστοποιημένη για τον ιστό και ταυτόχρονα φαίνεται καλή\\n\\n#### Πώς να εισάγετε \\n\\nΥπάρχουν δύο τρόποι για να εισάγετε εικόνες στα έγγραφά σας:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nΣυνιστάται να εισάγετε εικόνες με την ενσωματωμένη ετικέτα `<robo-wiki-picture>`, αλλά μπορείτε επίσης να χρησιμοποιήσετε τον κανονικό τρόπο για αρχεία Markdown.\\n\\n</robo-wiki-note>\\n\\n`με λεζάντα`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`ή χωρίς λεζάντα` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`ή απλή εικόνα` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`ή απλή εικόνα με λεζάντα`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`εικόνα με εναλλακτικό κείμενο`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Ιδιότητες για την robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Σημειώσεις και προειδοποιήσεις\\nΜπορείτε να προσθέσετε σημειώσεις και να τους δώσετε συγκεκριμένους τύπους:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`σημείωση με τίτλο`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`σημείωση με περιεχόμενο`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`σημείωση με τίτλο και περιεχόμενο`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Ιδιότητες για το robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nΜπορείτε να προσθέσετε καρτέλες στο έγγραφο:\\n\\n- Χρησιμοποιήστ τον περιτύλιξης συστατικό για καρτέλες: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- Και στη συνέχεια χρησιμοποιήστε όσα στοιχεία καρτέλας θέλετε μέσα στον περιτύλιξης:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`οριζόντιες καρτέλες`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`κατακόρυφες καρτέλες`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`στοιχείο καρτέλας με περίγραμμα`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Ιδιότητες για το robo-wiki-tabs (περιτύλιξη)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Ιδιότητες για το robo-wiki-tab (στοιχείο)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Τίτλος με αγκύλες\\nΜπορείτε να δημιουργήσετε προσαρμοσμένους τίτλους με αγκύλες και να τους δώσετε συγκεκριμένη τιμή\\n\\n`τίτλος με αγκύλη`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nor\\n\\n`title without anchor`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Ιδιότητες για το robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Βίντεο\\n\\nΥπάρχουν δύο τρόποι για την εισαγωγή βίντεο στα έγγραφά σας:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nΣυνιστάται να εισάγετε βίντεο με την ενσωματωμένη ετικέτα `<robo-wiki-video>`, αλλά μπορείτε επίσης να χρησιμοποιήσετε τον κανονικό τρόπο για αρχεία Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nΠρέπει να καθορίσετε τ μορφή του βίντεο\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Ιδιότητες\\n\\n- Εάν προσθέτετε ένα αρχείο με μέγεθος μεγαλύτερο από <span style=\\\"color:#af1c1c\\\">10MB</span>, Παρακαλώ, ανεβάστε το στον διακομιστή, όχι στο repo.\\n\\n- Μπορείτε να χρησιμοποιήσετε οποιεσδήποτε ιδιότητες για [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Αποδεκτές μορφές - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nΜπορείτε να ενσωματώσετε οποιοδήποτε βίντεο YouTube στο έγγραφο εισάγοντας τον σύνδεσμο κοινοποίησης ως ξεχωριστό παράγραφο χωρίς καμία επιπλέον παράθεση ή ετικέτα, π.χ .: `https://youtu.be/kQaSwNYHJQ8`\\n\\nΩστόσο, εάν χρειάζεστε αυτόματη αναπαραγωγή, πρέπει να χρησιμοποιήσετε ειδικό στοιχείο:\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Ιδιότητες για το robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Πώς να επεξεργαστείτε την πλοήγηση πλευρικής γραμμής\\n\\nΕάν θέλετε να επεξεργαστείτε την πλοήγηση πλευρικής γραμμής του Robonomics Wiki, ακολουθήστε αυτά τα βήματα:\\n\\n* Επεξεργαστείτε το αρχείο `/data/sidebar_docs.yaml`.\\n\\n* Αποφασίστε πού θα τοποθετήσετε το έγγραφό σας\\n\\n* Χρησιμοποιήστε έγκυρο YAML για το `/data/sidebar_docs.yaml` και βασιστείτε στην υπάρχουσα δομή του αρχείου\\n\\n* **ΣΗΜΑΝΤΙΚΗ ΣΗΜΕΙΩΣΗ:** εάν χρησιμοποιείτε το ίδιο έγγραφο σε διάφορες ενότητες/υποενότητες, π.χ .: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Προεγκατεστημένη εικόνα για το Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nΒΕΒΑΙΩΘΕΙΤΕ ΟΤΙ ΠΡΟΣΘΕΣΑΤΕ ΤΗ ΠΑΡΑΜΕΤΡΟ `topic` ΕΤΣΙ: \\n\\n(για να λειτουργεί σωστά η πλοήγηση)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## Πώς να προσθέσετε προσαρμοσμένη πλοήγηση για έγγραφα\\n\\n* Επεξεργασία αρχείου `/data/sidebar_docs.yaml`.\\n\\n* Βρείτε το σωστό έγγραφο και προσθέστε τις παραμέτρους \\\"prev\\\" και \\\"next\\\" ως εξής:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Εάν θέλετε να αφαιρέσετε εντελώς την πλοήγηση, προσθέστε την παράμετρο `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Εάν θέλετε να αφαιρέσετε μόνο την πλοήγηση `προηγούμενη σελίδα` ή `επόμενη σελίδα`, προσθέστε τις παραμέτρους `withoutPrev` ή `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nή\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"1f1cacf99e99c395aa6d3fb5a095d6a0\",\"title\":\"Λάβετε ειδοποίηση όταν ανοίγει η πόρτα\",\"path\":\"/docs/el/door-notification/\",\"content\":\"\\nΣε αυτό το άρθρο θα εγκαταστήσετε την ολοκλήρωση του ειδοποιητή Telegram bot και θα διαμορφώσετε μια αυτοματοποίηση, η οποία θα στέλνει στον λογαριασμό σας στο Telegram ειδοποίηση όταν ανοίγει μια πόρτα.\\n\\n## Ειδοποιήσεις Telegram Bot\\n\\nΠρώτα, πρέπει να δημιουργήσετε ένα προσωπικό Telegram bot. Για αυτό πηγαίνετε στο [ειδικό Telegram bot @BotFather](https://t.me/botfather) και ακολουθήστε τις οδηγίες. \\nΑποθηκεύστε το τοκέν σας για πρόσβαση στο HTTP API.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nΔιατηρήστε το τοκέν **ασφαλές** και αποθηκεύστε το **ασφαλώς**, μπορεί να χρησιμοποιηθεί από οποιονδήποτε για να ελέγξει το bot σας \\n\\n</robo-wiki-note>\\n\\nΕπόμενο βήμα είναι να βρείτε το ***User Chat ID***. Για αυτό χρησιμοποιήστε το επόμενο [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nΤώρα ας εγκαταστήσουμε την ολοκλήρωση \\\"Telegram broadcast\\\". Αυτή η ολοκλήρωση θα στέλνει μηνύματα στο Telegram σας.\\n\\nΓια την προεγκατεστημένη εικόνα Robonomics, το Home Assistant Docker ή το Home Assistant Core πρέπει να επεξεργαστείτε το `configuration.yaml`. Συνδεθείτε στο Raspberry Pi σας μέσω `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nΕπικολλήστε τις επόμενες γαμμές στο τέλος του αρχείου. Εισαγάγετε το **bot API key** και **your User Chat ID**. Δημιουργήστε επίσης ένα όνομα για την υπηρεσία ειδοποίησής σας:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Αποθηκεύστε τη διαμόρφωση και επαναφορτώστε το Home Assistant.**\\n\\n\\nΩς αποτέλεσμα, στην υπηρεσία Home Assistant σας θα δημιουργηθεί μια υπηρεσία, η οποία θα στέλνει οποιοδήποτε μήνυμα στη συνομιλία Telegram με εσάς. \\nΜπορείτε να το ελέγξετε στο μενού Εργαλεία Προγραμματιστή στη διεπαφή ιστού του Home Assistant. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Ειδοποίηση Ανοιχτής Πόρτας\\n\\nΤώρα είναι η στιγμή να δημιουργήσετε μια αυτοματοποίηση. Πρώτα, εισαγάγετε το πρότυπο στο Home Assistant σας από αυτόν τον σύνδεσμο:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nΚαι δημιουργήστε την αυτοματοποίηση:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nΤώρα θα λαμβάνετε μήνυμα από το Telegram bot κάθε φορά που ανοίγει η πόρτα.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nΜπορείτε να χρησιμοποιήσετε αυτήν την αυτοματοποίηση με οποιεσδήποτε πόρτες/παράθυρα στο σπίτι σας.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"ff5b1176bd89d28afd2370569e494299\",\"title\":\"Ψηφιακά Δίδυμα\",\"path\":\"/docs/el/digital-twins/\",\"content\":\"  \\n**Φανταστείτε να έχετε ένα περίπλοκο συσκευή ή σύστημα που έχει αρκετά αρθρώματα για συντήρηση και απαιτεί λίγους λογαριασμούς για να χρησιμοποιηθεί. Για να τα κραήσετε όλα σε ένα μέρος ή να κωδικοποιήσετε μερικές λειτουργίες με ξεχωριστούς λογαριασμούς ή, για παράδειγμα, να ορίσετε διάφορες πηγές δεδομένων για διάφορες ροές πληροφοριών, χρησιμοποιείται το αρθρώμα Διπλού Ψηφιακού.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Παρακαλώ να προσέξετε ότι αυτά και τα επόμενα μαθήματα παρουσιάζονται σε ένα τοπικό παράδειγμα του κόμβου Robonomics. Δημιουργήστε το δικό σας με [αυτές τις οδηγίες](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Επισκόπηση θεωρίας\\nΟποιοσδήποτε λογαριασμός μπορεί να δημιουργήσει και να διαχειριστεί ένα Διπλό Ψηφιακό. Το Δίδυμο μπορεί να φανταστεί ως μια είδους πίνακας με τα ακόλουθα περιεχόμενα:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nΌπου:\\n* **DT id** είναι μοναδικός ακέραιος αριθμός Διπλού Ψηφιακού.\\n* **Topic name** είναι δεδομένα hex `H256` ή ASCII μήκους 32 bytes, ίδια με [`Εκκίνηση`](/docs/launch) εξωτερική παράμετρος. \\nΓια παράδειγμα: `0x1234....FF` ή  `hello.parachain.robonomics.world`.\\n* **Source** - είναι κάποια διεύθυνση λογαριασμού.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Όπως έχει συζητηθεί προηγουμένως στην επισκόπηση της εξωτερικής εκτέλεσης, το `H256` μπορεί να αναπαρασταθεί ς ένα κωδικοποιημένο IPFS CID (δείτε το\\n  [εργαλείο Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) για αυτό).\\n  Επομένως, τα θέματα μπορούν να χρησιμοποιηθούν και ως αποθήκευση δεδομένων, για παράδειγμα, μια περιγραφή του αρθρώματος Διπλού.\\n\\n</robo-wiki-note>\\n\\n\\n## Δημιουργία Διπλού Ψηφιακού\\n\\n### 1. Μεταβείτε στον Developer -> Extrinsics \\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Επιλέξτε digitalTwin -> create από την αναπτυσσόμενη λίστα πιθανών εξωτερικών εκτελέσεων\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nΥποβάλετε τη συναλλαγή. Εδώ, δεν απαιτούνται παράμετροι για τη δημιουργία ενός Διπλού. Θα του αποδοθεί ένας δείκτης και μόνο ο ιδιοκτήτης του Διπλού Ψηφιακού θα μπορεί από εδώ και στο εξής να προσθέτει/τροποποιεί θέματα του Διπλού.\\n\\nΟ αριθμός ταυτότητας του Διπλού μπορεί να βρεθεί στη σελίδα επισκόπησης του Εξερευνήστεr.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Προσθήκη Θέματος\\n\\n### Επιλέξτε digitalTwin -> setSource από την αναπτυσσόμενη λίστα πιθανών εξωτερικών εκτελέσεων\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Ψηφιακό Twin ID, το οποίο έχει ληφθεί στη σελίδα Explorer.\\n* `topic` - προηγουμένως συζητηθέν όνομα θέματος `H256`. Σε αυτήν την εικόνα είναι μια συμβολοσειρά 32 συμβόλων.\\n* `source` - διεύθυνση λογαριασμού που θα συσχετιστεί με το θέμα.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Προσέξτε ότι το θέμα μπορεί να αντικατασταθεί με μια άλλη πηγή διεύθυνσης αν χρειαστεί.\\n\\n</robo-wiki-note>\\n\\nΥπογράψτε και υποβάλετε την εξωτερική εκτέλεση.\\n\\n## Explore\\n\\nΜπορείτε να βρείτε όλες τις πληροφορίες για τα υπάρχοντα Διπλά Ψηφιακά στο αποθηκευτικό αρθρώμα `digitalTwin` του μοντέλου αποθήκευσης `Developer -> Chain state`.\\n\\n- Συνολικός αριθμός Διπλών - `total()`;\\n- Ιδιοκτήτης Διπλού Ψηφιακού - `owner(u32)`;\\n- Πληροφορίες για τα θέματα ενός Διπλού Ψηφιακού - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"78967b0c1468be295dbf3042d4d35364\",\"title\":\"Δημιουργία ψηφιακής ταυτότητας που λειτουργεί με το Ethereum\",\"path\":\"/docs/el/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nΈνα από τα υπηρεσίες του Robonomics είναι [Εγγραφή ψηφιακού διαβατηρίου](https://dapp.robonomics.network/#/passport/) για αυθαίρετα δεδομένα. Η υπηρεσία σας επιτρέπει ν δημιουργήσετε μια ψηφιακή ταυτότητα αποθηκεύοντας τις κατακερματισμένες τιμές των δεδομένων στο δημόσιο blockchain και αναθέτοντας ένα μοναδικό αναγνωριστικό.\\n\\nΜπορείτε να βρείτε την υπηρεσία \\\"Εγγραφή ψηφιακού διαβατηρίου\\\" στην [Robonomics DApp](https://dapp.robonomics.network/) στην ενότητα \\\"Υπηρεσίες\\\" ή απλά ακολουθήστε αυτόν τον [άμεσο σύνδεσμο](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Βίντεο οδηγός\\n\\nΤο παρακάτω βίντεο δείχνει τη διαδικασία εγγραφής στο Robonomics Whitepaper:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Βήμα-προς-βήμα σε εικόνες\\n\\n### 1. Ανοίξτε την υπηρεσία\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Προσθέστε τις απαραίτητες πληροφορίες και αρχεία\\n\\nΣημειώστε ότι είναι δυνατή η προσθήκη πολλαπλών εικόνων.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Υπογράψτε την αίτηση\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Εγκρίνετε τα tokens\\n\\nΗ υπηρεσία χρεώνει μια μικρή χρέωση. Πρώτα όμως πρέπει να εγκρίνετε το απαιτούμενο ποσό tokens που θα χρησιμοποιηθεί από τον λογαριασμό σας.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Αποδεχτείτε την προσφορά και υπογράψτε ξανά το μήνυμα\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Ρίξτε μια ματιά στο δημιουργημένο διαβατήριο\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nΗ διαδικασία εγγραφής απαιτεί κάποιο χρόνο. Στο τέλος θα δείτε ένα σύνδεσμο προς τη δημιουργημένη ταυτότητα.\\n\"}},{\"node\":{\"id\":\"aa20198efef8839e3d58c9c6c6d0e126\",\"title\":\"Αρχείο καταγραφής δεδομένων\",\"path\":\"/docs/el/datalog/\",\"content\":\"\\n**Τώρα που έχετε κάποια κεφάλαια στον λογαριασμό σας, μπορείτε να υποβάλετε εξωτερικές συναλλαγές. Το πρώτο που μπορείτε να δοκιμάσετε είναι ένα Datalog. Σας επιτρέπει να αποθηκεύετε δεομένα με μόνιμο τρόπο στο blockchain. Φανταστείτε ένα κατανεμημένο και κρυπτοπροστατευμένο αποθηκευτικό χώρο για τα δεδομένα σας και αυτό είναι αυτό!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nΠαρακαλώ να προσέξετε ότι αυτά και τα επόμενα μαθήματα παρουσιάζονται σε ένα τοπικό παράδειγμα του κόμβου Robonomics. Δημιουργήστε το δικό σας με [αυτές τις οδηγίες](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Πλοηγηθείτε στο Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Επιλέξτε datalog -> record από την αναπτυσσόμενη λίστα πιθανών extrinsics\\n\\nΕπίσης, επιλέξτε έναν λογαριασμό με τον οποίο θέλετε να υποβάλετε το extrinsic. Συμπληρώστε το πεδίο καταγραφής.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Το Datalog υποστηρίζει ένα συμβολοσειρά με μέγιστο μέγεθος 512 bytes. Για να αποθηκεύσετε μεγάλο όγκο δεδομένων, μπορείτε να χρησιμοποιήσετε [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Υποβολή συναλλαγής\\n\\nΥπογράψτε και υποβάλετε τη συναλλαγή με έναν λογαριασμό που δημιουργήθηκε προηγουμένως χρησιμοποιώντας την επέκταση ή τη DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  Μπορείτε επίσης να διαγράψετε **ΟΛΑ** τα αρχεία καταγραφής σας με την *datalog -> erase* κλήση.\\n\\n</robo-wiki-note>\\n\\n## 4. Επισκόπηση του αρχείου καταγραφής δεδομένων στην αποθήκη\\n\\nΓια αυτό, πλοηγηθείτε στο *Developer -> Chain state*, επιλέξτε *datalog -> datalogIndex*, καθορίστε τον λογαριασμό σας και πατήστε το \\n\\\"+\\\" κουμπί γι να λάβετε τους δείκτες των αρχείων καταγραφής του λογαριασμού σας και στη συνέχεια εξερευνήστε αυτό που χρειάζεστε με τη χρήση του *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Εξερευνήστεr\\\">\\n\\n  Όλα τα γεγονότα, συμπεριλαμβανομένης της καταγραφής δεδομένων, μπορούν να παρακολουθηθούν στη ροή γεγονότων στο *Explorer*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"d9d26ccdd3454ded1f0cb03d5d2d7263\",\"title\":\"Create Account for Robonomics Parachaστην\",\"path\":\"/docs/el/create-account-in-dapp/\",\"content\":\"\\n**In order to interact αντίστοιχα. Ωστόσο, αυτές οι διαδρομές μπορεί να διαφέρουν ανάλογα με την συγκεκριμένη εγκατάστασή σας. operate with Robonomics Parachain, developers and users need to create an account on the Polkadot / Substrate Portal. The account performs basic functions for the network: your public network address(the public key), the access control to the address and funds (the private key), sending transactions to the network, showing your tokens and their amount, etc. Below are two main ways to create an account for Robonomics Parachain.**\\n\\n## 1. Χρησιμοποιώντας την Επέκταση Περιηγητή Polkadot{.js}\\n\\nΗ Επέκταση Polkadot παρέχει ένα μηχανισμό για τη δημιουργία λογαριασμού και την αλληλεπίδραση με όλα τα έργα Polkadot / Kusama, συμπεριλαμβανομένου του Robonomics Parachain. Αυτός δεν είναι ο ασφαλέστερος τρόπος διαχείρισης του λογαριασμού σας, αλλά είναι ο πιο βολικός από άποψη ισορροπίας ασφάλειας / χρηστικότητας.\\n\\n## 1.1. Εγκατάσταση Επέκτασης Περιηγητή\\n\\nΗ επέκταση περιηγητή είναι διαθέσιμη για [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) and [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (συμπεριλαμβανομένων των περιηγητών που βασίζονται στο Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Άνοιγμα Εφαρμογής Robonomics Parachain\\n\\nΠηγαίνετε στο [Εφαρμογή Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) στο Portal του Polkadot / Substrate. Εάν αυτή είναι η πρώτη φορά που εισέρχεστε στο portal, θα ζητηθεί πρόσβαση στην επέκταση περιηγητή, οπότε επιτρέψτε την πρόσβαση. \\n\\nΜόλις ανοίξετε την εφαρμογή, ρίξτε μια ματιά στην επάνω αριστερή γωνία. Το όνομα του δικτύου, το εικονίδιό του και ο αριθμός του τελευταίου μπλοκ εμφανίζονται εκεί. Κάνοντας κλικ σε αυτήν την περιοχή θα ανοίξει μια λίστα με όλα τα δίκτυα Polkadot / Kusama, συμπεριλαμβανομένων των δοκιμαστικών δικτύων και των τοπικών κόμβων. Μπορείτε να κάνετε εναλλαγή μεταξύ δικτύων επιλέγοντας το απαιτούμενο και πατώντας το κουμπί `Switch`. **Βεβαιωθείτε ότι είστε συνδεδεμένοι στο Robonomics Parachain τώρα**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Ενημέρωση Μεταδεδομένων Επέκτασης \\n\\nΕίναι πολύ πιθανό η εφαρμογή να σας ζητήσει να ενημερώσετε τα μεταδεδομένα για την επέκταση ώστε να εμφανίζονται τα σωστά στοιχεία για την αλυσίδα στην οποία είστε συνδεδεμένοι. Πηγαίνετε στο **Settings -> Metadata**, πατήστε το κουμπί `Update metadata` και στη συνέχεια, στο αναδυόμενο παράθυρο, επιτρέψτε στην επέκταση να το κάνει. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Δημιουργία Λογαριασμού στην Επέκταση   \\n\\nΑνοίξτε την επέκταση περιηγητή Polkadot{.js}. Κάντε κλικ στο μεγάλο κουμπί συν, ή επιλέξτε `Create new account` από το μικρό εικονίδιο συν στην πάνω δεξιά γωνία. Θα πρέπει να δείτε το παρακάτω μενού, με τον δημιουργημένο μνημονικό σπόρο σε μορφή δώδεκα λέξεων και τη διεύθυνση. \\n\\n \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nΟ σπόρος είναι το κλειδί για τον λογαριαμό. Με τη γνώση του σπόρου, μπορείτε (ή οποιοσδήποτε άλλος γνωρίζει το σπόρο) να αποκτήσετε έλεγχο σε αυτόν τον λογαριασμό και ακόμα να τον ανακτήσετε, αν ξεχάσετε τον κωδικό πρόσβασης.   **Είναι πολύ σημαντικό να το αποθηκεύσετε κάπου με ασφάλεια**, προτιμητέον σε χαρτί ή άλλη μη ψηφιακή συσκευή, όχι σε ψηφιακή αποθήκευση ή σε υπολογιστή. \\n\\nΑποθήκευση του σπόρου και πίεση `Next step`. Θα πρέπει να δείτε το ακόλουθο μενού.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* σας επιτρέπει να επιλέξετε σε ποιο από τα δίκτυα θα χρησιμοποιηθεί αποκλειστικά αυτός ο λογαριασμός. Μπορείτε να χρησιμοποιήσετε την ίδια διεύθυνση σε πολλά δίκτυα, ωστόσο, για λόγους απορρήτου, συνιστάται να δημιουργήσετε μια νέα διεύθυνση για κάθε δίκτυο που χρησιμοποιείτε. \\nΕπιλέξτε το δίκτυο Robonomics από την αναπτυσσόμενη λίστα. Εάν δεν μπορέσατε να βρείτε το δίκτυο Robonomics, τότε πιθανότατα δεν ενημερώσατε τα μεταδεδομένα, πηγαίνετε πίσω και κάντε το.\\n\\n    - Θα παρατηρήσετε ότι η μορφή της διεύθυνσης και το εικονίδιο του λογαριασμού θα αλλάξουν - αυτό είναι φυσιολογικό. Οι διάφορες μορφές δικτύου είναι απλώς άλλες αναπαραστάσεις του ίδιου δημόσιου κλειδιού. \\n\\n- *Name* είναι απλώς το όνομα του λογαριασμού για τη δική σας χρήση. Δεν αποθηκεύεται στο blockchain και δεν θα είνα ορατό σε άλλους χρήστες. \\n\\n- *Password* χρησιμοποιείται για την κρυπτογράφηση των πληροφοριών του λογαριασμού σας. Θα χρειαστεί να το ξαναεισάγετε όταν υπογράφετε συναλλαγές στην πύλη. Δημιουργήστε ένα και θυμηθείτε το.\\n\\nΩς αποτέλεσμα, μετά τη δημιουργία ενός λογαριασμού, θα τον δείτε στη λίστα των λογαριασμών στην επέκταση Polkadot{.js}. Κάνοντας κλικ στις τρεις τελείες, μπορείτε να μετονομάσετε τον λογαριασμό, να τον εξαγάγετε, να τον αφαιρέσετε από την επέκταση και να αλλάξετε το δίκτυο που χρησιμοποιείται για τον λογαριασμό. \\n\\nΕπίσης, ο λογαριασμός θα εμφανιστεί στο μενού **Accounts -> Accounts** στην πύλη, όπου θα σημειωθεί ότι έγινε ένεση με χρήση της επέκτασης.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Απευθείας στην εφαρμογή Robonomics Parachain\\n\\nΜπορείτε να χρησιμοποιήσετε τη διεπαφή χρήστη στην Πύλη Polkadot / Substrate για να δημιουργήσετε έναν λογαριασμό. Μπορεί να χρησιμοποιηθεί για ανάπτυξη και δοκιμές. \\n\\n## 2.1. Ανοίξτε την εφαρμογή Robonomics Parachain\\n\\nΠαω σε [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) στην Πύλη Polkadot / Substrate. **Ελέγξτε στην πάνω αριστερή γωνία ότι είστε συνδεδεμένοι με το Robonomics Parachain**.  \\n\\nΠαω σε **Accounts -> Accounts** και πατήστε το κουμπί `Add account`. \\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Δημιουργία Λογαριασμού\\n\\nΘα πρέπει να δείτε το ακόλουθο αναδυόμενο μενού με τον σπόρο του λογαριασμού. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nΈχει δύο μορφές: *Mnemonic* (αναγνώσιμη από ανθρώπους) και *Raw* (μια ακολουθία από ψηφία και γράμματα). Αποθηκεύστε με ασφάλεια τη φράση σπόρου και πατήστε `Next`.\\n\\n> Επίσης, μπορείτε να αλλάξετε τον τύο κρυπτονομίσματος για τη δημιουργία λογαριασμού, ανοίξτε `Advanced creation options` και επιλέξτε τον τύπο (`ed25519` στην εικόνα).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nΣτο επόμενο μενού, πρέπει να ορίσετε το όνομα του λογαριασμού και τον κωδικό πρόσβασης, παρόμοια με τις οδηγίες της επέκτασης που περιγράφονται παραπάνω.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nΚάνοντας κλικ στο κουμπί `Next` θα σας οδηγήσει στο τελευταίο παράθυρο. Κάντε κλικ `Save` για να ολοκληρώσετε τη δημιουργία λογαριασμού. Θα δημιουργηθούν επίσης αρχεία JSON αντιγράφου ασφαλείας που πρέπει να αποθηκεύσετε με ασφάλεια. Αργότερα μπορείτε να χρησιμοποιήσετε αυτό το αρχείο για να ανακτήσετε τον λογαριασμό σας αν θυμάστε τον κωδικό πρόσβασης.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Προσθήκη λογαριασμού ed25519 στην επέκταση Polkadot\\n\\nΜπορεί να χρειαστεί να προσθέσετε τον δημιουργημένο λογαριασμό στην επέκταση Polkadot.js (γι λογαριασμό ed25519 μπορείτε να το κάνετε μόνο με αρχείο JSON αντιγράφου ασφαλείας). Για αυτό χρειάζεστε να δημιουργήσετε αρχείο αντιγράφου ασφαλείας του λογαριασμού. Πατήστε στις τρεις τελείες στον λογαριασμό σας και επιλέξτε `Create a backup file for this account` και γράψτε τον κωδικό πρόσβασής σας.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nΣτη συνέχεια, ανοίξτε μια επέκταση και πατήστε το κουμπί `+` στην επάνω δεξιά γωνία, και στη συνέχεια επιλέξτε `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nΣτο ανοιχτό παράθυρο αποθέστε το αποθηκευμένο αρχείο, εισαγάγετε τον κωδικό πρόσβασης και πατήστε `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Ο λογαριασμός δημιουργήθηκε με επιτυχία \\n\\nΤώρα μπορείτε να λειτουργήσετε πλήρως με τον πρόσφατα δημιουργημένο λογαριασμό σας. Αποστολή και λήψη κρυπτονομισμάτων, μηνύματα, εγγραφή datalog και πολλά άλλα. Μη διστάσετε να εξερευνήσετε όλες τις δυνατότητες της εφαρμογής. Για να αντιγράψετε τη διεύθυνση του λογαριασμού σας, απλά κάντε κλικ στο εικονίδιο του, η διεύθυνση θα αντιγραφεί στο πρόχειρο. \\n\\nΕάν θέλετε να μάθετε περισσότερα για τους λογαριασμούς Polkadot / Kusama και επιπλέον τρόπους δημιουργίας τους, μπορείτε να βρείτε περισσότερες πληροφορίες [εδώ](https://wiki.polkadot.network/docs/learn-accounts) και [εδώ](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"6b0a94ed60d31718b15c4a6e42727eeb\",\"title\":\"Πώς να συνεισφέρετε στους πόρους του Robonomics\",\"path\":\"/docs/el/contributing/\",\"content\":\"\\nΤο Robonomics Network είναι ένα έργο ανοιχτού κώδικα και θέλουμε να διευκολύνουμε οποιονδήποτε να συνεισφέρει. Μπορείτε να δημιουργήσετε άρθρα, να προτείνετε αλλαγές, να βελτιώσετε την τεκμηρίωση ή να εκτελέσετε δοκιμές. Εάν θέλετε να συνεισφέρετε, ανοίξτε ένα νέο τεύχος ή δημιουργήστε ένα αίτημα έλξης στο ίδιο αποθετήριο.\\n\\n## Κύρια αποθετήρια Robonomics \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Κύριο έργο wiki\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Official main website of Robonomics Network \\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Αρχική για τις υπηρεσίες του Robonomics\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Επίσημη εφαρμογή\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Επίσημη ιστοσελίδα της Robonomics Academy\\n\\n### Κανόνες για την αναφορά\\n\\nΌταν ανοίγετε ένα νέο θέμα, μην ξεχάσετε μερικούς βασικούς κανόνες για την αναφορά:\\n\\n1. Επιλέξτε το ακριβές αποθετήριο στο οποίο θέλετε να υποβάλετε ένα θέμα.\\n\\n2. Εάν αναφέρετε ένα σφάλμα, βεβαιωθείτε ότι το σφάλμα δεν έχει ήδη αναφερθεί.\\n\\n3. Βεβαιωθείτε ότι περιλαμβάνετε τίτλο και σαφή περιγραφή, όσο το δυνατόν περισσότερες σχετικές πληροφορίες.\\n\\n4. Παρακαλούμε, προσθέστε ένα από τα παρακάτω προθέματα στο θέμα σας: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Αιτήματα εξαγωγής (Pull Requests)\\n\\nΟποιοδήποτε αποθετήριο Robonomics ενδέχεται να υπόκειται σε αιτήματα έλξης ή αλλαγές από τους συντελεστές, καθώς πιστεύετε ότι έχετε κάτι πολύτιμο να προσθέσετε ή να αλλάξετε. Παρακαλώ, μην ξεχνάτε τους βασικούς κανόνες για τους συντελεστές.\\n\\n### Κανόνες για τη συνεισφορά\\n\\n1. Τα αιτήματα εξαγωγής είναι προτιμώμενα από τα θέματα, εάν έχετε κάποιες διορθώσεις, ιδίως για μικρές αλλαγές όπως τυπογραφικά λάθη.\\n\\n2. Βεβαιωθείτε ότι η περιγραφή του αιτήματος εξαγωγής περιγράφει σαφώς το πρόβλημα και τη λύση. Συμπεριλάβετε τον αντίστοιχο αριθμό θέματος εάν είναι εφαρμόσιμο.\\n\\n3. Παρακαλούμε, μην διορθώνετε τα κενά, τον κώδικα μορφοποίησης ή να κάνετε μια αποκλειστικά κοσμητική επιδιόρθωση.\\n\\n4. Παρακαλούμε, προσπαθήστε να τηρήσετε τον επικρατούντα στυλ, τη γλώσσα και τη διάταξη του Markdown.\\n\\n\\n\"}},{\"node\":{\"id\":\"eb5f67b402867052562fd5ff7bd87d71\",\"title\":\"Υπηρεσίες Αντιγράφου Ασφαλείας\",\"path\":\"/docs/el/backup-services/\",\"content\":\"\\n**Σε αυτό το άρθρο, θα μάθετε πώς να δημιουργήσετε αντίγραφα ασφαλείας της διαμόρφωσης του Home Assistant και πώς να την ανακτήσετε όταν χρειαστεί. Για να δημιουργήσετε αντίγραφα ασφαλείας, καλείται μια υπηρεσία που δημιουργεί ένα ασφαλές αρχείο με τα αρχεία διαμόρφωσης. Επίσης, η υπηρεσία προσθέτει τη διαμόρφωση του Mosquitto brocker και του Zigbee2MQTT στο αντίγραφο ασφαλείας, αν υπάρχουν. Στη συνέχεια, η υπηρεσία προσθέτει το αρχείο στο IPFS και αποθηκεύει το αποτέλεσμα CID στο Robonomics Digital Twin.**\\n## Δημιουργία Αντιγράφου Ασφαλείας της Διαμόρφωσης του Home Assistant\\n\\nΗ δημιουργία ενός αντιγράφου ασφαλείας σας επιτρέπει να ανακτήσετε εύκολα τη διαμόρφωση του Home Assistant σε περίπτωση αποτυχίας.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ΠΡΟΕΙΔΟΠΟΙΗΣΗ\\\">\\n\\nΓια να δημιουργήσετε αντίγραφα ασφαλείας και να ανακτήσετε τη διαμόρφωσή σας, είναι απαραίτητο να χρησιμοποιήσετε ένα **προσαρμοσμένο πύλη IPFS** όπως το Pinata. Χωρίς αυτό, το αντίγραφο ασφαλείας θα αποθηκευτεί αποκλειστικά σον τοπικό κόμβο IPFS σας, πράγμα που μπορεί να σας εμποδίσει να ανακτήσετε τη διαμόρφωση του Home Assistant σε περίπτωση αποτυχίας του τοπικού κόμβου.\\n\\n</robo-wiki-note>\\n\\n1. Στη διεπαφή χρήστη του Home Assistant, μεταβείτε στο `Developer Tools` -> `Services`. Αναζήτηση για `Robonomics: Save Backup to Robonomics` και πατήστε `CALL SERVICE`.\\n\\n2. Περιμένετε μέχρι να εμφανιστεί η ειδοποίηση `Backup was updated in Robonomics` στο `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ΠΡΟΕΙΔΟΠΟΙΗΣΗ\\\">\\n\\nΜην προσπαθήσετε να δημιουργήσετε ένα αντίγραφο ασφαλείας ή να ανακτήσετε τη διαμόρφωση αμέσως μετά τη φόρτωση του Home Assistant και της Ενσωμάτωσης Robonomics. Παρακαλώ, **περιμένετε περίπου 5 λεπτά** για να επιτραπεί η αρχική ρύθμιση.\\n\\n</robo-wiki-note>\\n\\nΠαράμετροι υπηρεσίας:\\n- **Πλήρες Αντίγραφο Ασφαλείας**  (default: False) - προσθέστε τη βάση δεδομένων στο αντίγραφο ασφαλείας, έτσι ώστε να αποθηκεύονται και οι ιστορικοί καταγραφής των καταστάσεων των οντοτήτων.\\n- **Διαδρομή προς το αρχείο κωδικού πρόσβασης του mosquitto** (default: `/etc/mosquitto`) - Εάν χρησιμοποιήσατε τις μεθόδους εγκατάστασης Home Assistant Core ή Docker και δεν έχετε την προεπιλεγμένη διαδρομή προς τον Mosquitto brocker, θα πρέπει να αλλάξετε αυτήν την παράμετρο. *Δεν απαιτείται για το Home Assistant OS ή το Superviser*.\\n\\n## Ανάκτηση της Διαμόρφωσης του Home Assistant από Αντίγραφο Ασφαλείας\\n\\nΓια να ανακτήσετε τη διαμόρφωσή σας, θα χρειαστεί να έχετε εγκατεστημένο το Home Assistant και την Ενσωμάτωση Robonomics. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"ΠΡΟΕΙΔΟΠΟΙΗΣΗ\\\">\\n\\nΓια να διασφαλίσετε την επιτυχή ανάκτηση της διαμόρφωσής σας στις μεθόδους εγκατάστασης Home Assistant Core και Docker, πρέπει να εκτελέσετε επιπλέον βήματα ρύθμισης όπως περιγράφεται στο τέλος της σελίδας.\\n\\n</robo-wiki-note>\\n\\n1. Εγκαταστήστε το Home Assisntant με την Ενσωμάτωση Robonomics (εάν δεν έχει εγκατασταθεί ακόμα), ακολουθώντας τα βήματα από το άρθρο για την [επιθυμητή μέθοδο εγκατάστασης](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-εδώ-your-smart-home).\\n\\n2.  [Ρύθμιση Ενσωμάτωσης Robonomics](https://wiki.robonomics.network/docs/robonomics-hass-integration) χρησιμοποιώντας **τους ίδιους κωδικούς σπόρων** που χρησιμοποιήσατε στην προηγούμενη ρύθμιση Robonomics. Εάν η συνδρομή σας έχει λήξει, [επανενεργοποιήστε την](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. Στην διεπαφή ιστού του Home Assistant πηγαίνετε στην `Developer Tools` -> `Services`. Search for `Robonomics: Restore from the Backup in Robonomics` αντίστοιχα. Ωστόσο, αυτές οι διαδρομές μπορεί να διαφέρουν ανάλογα με την συγκεκριμένη εγκατάστασή σας. και στη συνέχεια, στο αναδυόμενο παράθυρο, επιτρέψτε στην επέκταση να το κάνει. `CALL SERVICE`. Πλοηγηθείτε στην `Overview` σελίδα, για να ελέγξετε την κατάσταση του αντιγράφου ασφαλείας σας.\\n\\n4. Μετά την αποκατάσταση, το Home Assistant θα επανεκκινήσει αυτόματα. Εάν για οποιονδήποτε λόγο το Home Assistant δεν επανεκκινηθεί, μπορείτε να ελέγξετε την κατάσταση της αποκατάστασης παρακολουθώντας την κατάσταση του `robonomics.backup` οντότητας. Εάν η κατάσταση είναι `restored` θα πρέπει να επανεκκινήσετε το Home Assistant χειροκίνητα πηγαίνοντας στην `Settings` > `System` και κάνοντας κλικ στο κουμπί `RESTART` που βρίσκεται στην πάνω δεξιά γωνία.\\n\\n5. Εάν το αντίγραφο ασφαλείας σας περιλαμβάνει την ρύθμιση του Zigbee2MQTT ή Mosquitto, θα πρέπει να επανεκκινήσετε αυτές τις υπηρεσίες για να ενεργοποιήσετε τη νέα ρύθμιση. Μπορείτε να το κάνετε αυτό χειροκίνητα επανεκκινώτας τις υπηρεσίες ξεχωριστά, ή μπορείτε απλά να επανεκκινήσετε τον υπολογιστή του Home Assistant για να βεβαιωθείτε ότι όλες οι υπηρεσίες επανεκκινούν.\\n\\nΕπιχειρήματα υπηρεσίας:\\n- **Path to mosquitto αρχείο κωδικού πρόσβασης** (default: `/etc/mosquitto`) - Εάν χρησιμοποιήσατε τις μεθόδους εγκατάστασης Home Assistant Core ή Docker και δεν έχετε την προεπιλεγμένη διαδρομή για τον Mosquitto brocker, θα πρέπει να αλλάξετε αυτήν την παράμετρο. *Δεν απαιτείται για το Home Assistant OS ή το Superviser*.\\n- **Διαδρομή για την ρύθμιση του Zigbee2MQTT**  (default: `/opt/zigbee2mqtt`) - Εάν χρησιμοποιήσατε τις μεθόδους εγκατάστασης Home Assistant Core ή Docker και δεν έχετε την προεπιλεγμένη διαδρομή για το Zigbee2MQTT, θα πρέπει να αλλάξετε αυτήν την παράμετρο. *Δεν απαιτείται για το Home Assistant OS ή το Superviser*.\\n\\n## Αποκατάσταση Ρυθμίσεων Mosquitto και Zigbee2MQTT για την Μέθοδο Εγκατάστασης Home Assistant Core\\n\\nΕάν το αντίγραφο ασφαλείας περιλαμβάνει την ρύθμιση για το Mosquitto ή το Zigbee2MQTT, κατά τη διαδικασία αποκατάστασης, θα τοποθετηθούν στην προεπιλεγμένη διαδρομή ή στη διαδρομή που καθορίζεται στα ορίσματα. Ωστόσο, εάν εγκαταστήσατε την ενσωμάτωση Robonomics σε ένα υπάρχον Home Assistant Core *(όχι από την προεγκατεστημένη εικόνα Robonomics)*, the `homeassistant` ο χρήστης μπορεί να μην έχει πρόσβαση σε αυτήν τη διαδρομή.\\n\\nΈτσι, για να αποκαταστήσετε τη ρύθμιση του Mosquitto και του Zigbee2MQTT, θα πρέπει να χορηγήσετε τα απαραίτητα δικαιώματα ανάγνωσης στον χρήστη `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Αντίγραφο Ασφαλείας Ρυθμίσεων Mosquitto και Zigbee2MQTT για την Μέθοδο Εγκατάστασης Home Assistant Docker\\n\\nΓια να δημιουργήσετε αντίγραφα ασφαλείας των ρυθμίσεων Mosquitto και Zigbee2MQTT από έναν δοχείο Docker, θα πρέπει να δημιουργήσετε όγκους για τις αντίστοιχες ρυθμίσεις τους. Αυτό μπορεί να επιτευχθεί εκτελώντας τον δοχείο του Home Assistant με επιπλέον ορίσματα:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nή να κάνετε αλλαγές στο αρχείο σας `compose.yaml`.\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nΛάβετε υπόψη ότι οι προεπιλεγμένες διαδρομές για τις διαμορφώσεις Mosquitto και Zigbee2MQTT είναι `/etc/mosquitto` και `/opt/zigbee2mqtt`, αντίστοιχα. Ωστόσο, αυτές οι διαδρομές ενδέχεται να διαφέρουν ανάλογα με τη συγκεκριμένη ρύθμιση.\\n\\n</robo-wiki-note>\\n\\n\\n## Κουμπιά Αντιγράφου Ασφαλείας \\n\\nΕκτός από τη χρήση υπηρεσιών για την εργασία με αντίγραφα ασφαλείας, μπορείτε να απλοποιήσετε τη διαδικασία χρησιμοποιώντας τα κουμπιά από την ενσωμάτωση Robonomics. Αυτά τα κουμπιά καλούν τις αντίστοιχες υπηρεσίες με προεπιλεγμένες παραμέτρους (το κουμπί αντιγράφου ασφαλείας δημιουργεί ένα αντίγραφο ασφαλείας χωρίς ιστορικό). Βεβαιωθείτε ότι είστε συνδεδεμένοι με το Robonomics Parachain τώρα `create_backup` and `button.restore_from_backup`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nΓια να προσθέσετε κουμπιά στον πίνακα ελέγχου σας, ακολουθήστε αυτά τα βήματα:\\n\\n1. Κάντε κλικ στις τρεις τελείες στην πάνω δεξιά γωνία του πίνακα ελέγχου.\\n2. Επιλέξτε `Edit Dashboard`\\n3. Κάνε κλικ στο κουμπί `Add Card` κάρτα στην κάτω δεξιά γωνία. \\n4. Επιλέξτε το `Entities` \\n5. Στο πεδίο `Entities` αναζήτησης, αναζητήστε τις οντότητες `button.create_backup `και `button.restore_from_backup`. \\n6. Πατήστε `Save` για να προσθέσετε τις οντότητες στην κάρτα. \\n7. Ολοκληρώστε την επεξεργασία κάνοντας κλικ `Done` στο κουμπί στην πάνω δεξιά γωνία. \"}},{\"node\":{\"id\":\"5640e7e3ed386e82e3ec42b2f60f4372\",\"title\":\"Υπηρεσία αντιστάθμισης\",\"path\":\"/docs/el/carbon-footprint-service/\",\"content\":\"\\nΠαράδειγμα εργασίας βρίσκεται στο βίντεο:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nΥπηρεσία για την αντιστάθμιση του αποτυπώματος CO2 καίγοντας τα πιστοποιητικά στο δίκτυο Statemine. \\nΤο παραγόμενο CO2 υπολογίζεται ως εξής: τα δεδομένα από τη σσκευή σε Wh πολλαπλασιάζονται με συντελεστές που εξαρτώνται από την περιοχή. 1 τόνος CO2 καλύπτεται από την κατανάλωση 1 πιστοποιητικού. [Εδώ](/docs/carbon-footprint-sensor) είναι οι οδηγίες για τη σύνδεση της συσκευής.\\n\\n## Σενάριο\\n\\n1. Καταχωρίστε μια νέα συσκευή στο Digital Twin στο δίκτυο Robonomics\\n2. Μια φορά σε ένα διάστημα λαμβάνετε τα τελευταία δεδομένα από όλες τις συσκευές και πολλαπλασιάζετε με τον συντελεστή ανάλογα με την περιοχή\\n3. Συνολίζοντας τα δεδομένα και μετατρέποντάς τα σε τόνους CO2\\n4. Αφαιρώντας τον συνολικό αριθμό των καίγοντων πιστοποιητικών από τα τρέχοντα δεδομένα \\n5. Καύση ακέραιου αριθμού πιστοποιητικών στο δίκτυο Statemine \\n6. Αποθήκευση του συνολικού αριθμού των καίγοντων πιστοποιητικών στην τοπική βάση δεδομένων και στο Αρχείο καταγραφής δεδομένων \\n\\n\\n## Εγκατάσταση\\n\\nΚλωνοποίηση του αποθετηρίου και επεξεργασία του αρχείου ρυμίσεων.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Διαμόρφωση description\\n\\nΝα μην τροποποιηθεί `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network wεδώ Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nΟι συντελεστές για τη μη ανανεώσιμη ενέργεια έχουν ληφθεί από το [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) και αποθηκεύονται στο `utils/coefficients.py`. \\n\\n## Εκτόξευση\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"5ede0f0ea493c864b0409679c50d1682\",\"title\":\"Σύνδεση αισθητήρα\",\"path\":\"/docs/el/carbon-footprint-sensor/\",\"content\":\"\\nΠαράδειγμα εργασίας βρίσκεται στο βίντεο:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Απαιτήσεις\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (ή ένα από [υποστηριζόμενο](https://www.zigbee2mqtt.io/στηνformation/supported_adapters.html))\\n\\nService is running on Raspberry Pi αντίστοιχα. Ωστόσο, αυτές οι διαδρομές μπορεί να διαφέρουν ανάλογα με την συγκεκριμένη εγκατάστασή σας. contact the smart plug via zigbee protocol.\\n\\n## Στικ Zigbee\\n\\nΕάν έχετε το JetHome USB JetStick Z2, ήδη διαθέτει τον απαραίτητο firmware, οπότε δεν χρειάζεται να τον αναβαθμίσετε. Αλλά εάν έχετε έναν άλλο προσαρμογέα, πρέπει πρώτα να τον αναβαθμίσετε με το λογισμικό zigbee2MQTT. Μπορείτε να βρείτε οδηγίες για τη συσκευή σας [εδώ](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nΣυνδέστε τον προσαρμογέα και επαληθεύστε τη διεύθυνση του προσαρμογέα (μπορεί επίσης να είναι `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nYou might need to get access to the USB port first. Add your user to `dialout` ομάδα (λειτουργεί για ubuntu, αλλά το όνομα της ομάδας μπορεί να είναι διαφορετικό σε άλλα λειτουργικά συστήματα).\\n\\nΓια το ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nΓια το arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nΣτη συνέχεια, αποσυνδεθείτε και συνδεθείτε ξανά ή επανεκκινήστε τον υπολογιστή.\\n\\n## Εγκατάσταση\\n\\nΚλωνοποιήστε το αποθετήριο:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Διαμόρφωση\\n\\nΠηγαίνετε στο `data/configuration.yaml` και ορίστε `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nΕπίσης, μπορεί ν θέλετε να συμπληρώσετε τα πεδία `server` και `port` με τις αντίστοιχες πληροφορίες. Στο `server` πεδίο χρησιμοποιήστε τη διεύθυνση IP της `docker0` γέφυρας για να εγκαθιδρύσετε τη σύνδεση: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nΕδώ η διεύθυνσή σας είναι `172.17.0.1`.\\n\\nΣτη συνέχεια, δημιουργήστε το αρχείο config/config.yaml με τις παρακάτω πληροφορίες και ορίστε την τοποθεσία σας (μπορείτε να ανατρέξετε στο https://countrycode.org/ για το 3-γράμματο ISO-κωδικό):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Συνδέστε το Plug\\n\\nΠρώτη εκτέλεση:\\n\\n```\\ndocker-compose up     \\n```\\n\\nΓια να μεταβείτε στη λειτουργία σύζευξης στο βύσμα, πατήστε παρατεταμένα το κουμπί λειτουργίας για μερικά δευτερόλεπτα έως ότου το φως αρχίσει να αναβοσβήνει γρήγορα μπλε. \\n\\nΣτα αρχεία καταγραφής θα πρέπει να δείτε τώρα το βύσμα σας άρχισε να δημοσιεύεται στο mqtt.\\n\\n\\n## Μετά τη σύζευξη\\n\\nΕάν δεν θέλετε να επιτρέψετε σε άλλες συσκευές να συζεύξουν με το ραβδί σας, τώρα πρέπει να πάτε στο `data/configuration.yaml` και να θέσει `permit_join: false`.Επανεκκινήστε την υπηρεσία (χρησιμοποιήστε «Ctrl+C» και\\n\\n```bash\\ndocker-compose up     \\n```\\nξανά για να υποβάλετε τις αλλαγές).\\n\\n## Εκτέλεση\\nΚατά την πρώτη εκκίνηση, θα δημιουργηθεί ο λογαριασμός για το plug. \\n> Εάν έχετε ήδη λογαριασμό, θα πρέπει να προσθέσετε τον αρχικό του λογαριασμό `config.config.yaml` αρχείο στην ενότητα`device_seed`:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nΜετά τη δημιουργία του λογαριασμού, θα δείτε τη διεύθυνση στα logs (το seed θα προστεθεί στο `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nΠρέπει να μεταφέρετε μερικ tokens σε αυτόν τον λογαριασμό για τα τέλη συναλλαγής, μπορείτε να το κάνετε στο [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nΗ υπηρεσία θα δει ότι έχετε αρκετά tokens, στα logs θα δείτε:\\n```\\nplug               | Balance is OK\\n```\\nΗ υπηρεσία θα δει τα μηνύματα mqtt από το plug και θα διασφαλίσει την ασφαλή χρήση ισχύος. Κάθε ώρα (μπορείτε να αλλάξετε το χρονικό όριο στο `config/config.yaml` και `sending_timeout` ενότητα, το χρονικό όριο είναι σε δευτερόλεπτα) θα δημιουργηθεί ημερολόγιο δεδομένων με τις παρακάτω πληροφορίες:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"a0356d7eea4503f69e559ae2d0638b02\",\"title\":\"Addστηνg funds to your account on Robonomics Portal\",\"path\":\"/docs/el/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Μετά την επιτυχή δημιουργία των λογαριασμών σας στο portal του Robonomics, είναι ώρα να προσθέσετε κεφάλαια σε αυτούς, ώστε να μπορείτε να πραγματοποιήσετε συναλλαγές.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nΠαρακαλούμε να προσέξετε ότι αυτά και τα επόμενα εκπαιδευτικά προγράμματα παρουσιάζονται σε μια τοπική εκδοχή του Robonomics Node. Δημιουργήστε τη δική σας με [αυτές τις οδηγίες](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Πλοηγηθείτε στην ενότητα Λογαριασμοί στο portal του Robonomics \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Επιλέξτε τον λογαριασμό από τον οποίο θέλετε να μεταφέρετε κεφάλαια\\n\\nΣτη λειτουργία ανάπτυξης, υπάρχουν αρκετοί λογαριασμοί, με 10000 μονάδες κεφαλαίου έκαστος, που μπορούν να χρησιμοποιηθούν για να μεταφερθούν κεφάλαια σε άλλους λογαριασμούς που δημιουργήθηκαν στο δίκτυο ανάπτυξης. Αυτοί οι λογαριασμοί υποδηλώνονται από εικονίδια κατσαβιδιού <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> δίπλα σε αυτούς.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Κάντε κλικ στο κουμπί \\\"αποστολή\\\" του λογαριασμού από τον οποίο θέλετε να μεταφέρετε κεφάλαια, για παράδειγμα BOB\\n\\n## 3. Επιλέξτε τον λογαριασμό στον οποί θέλετε να μεταφέρετε κεφάλαια\\nΜετά το κλικ στο κουμπί \\\"αποστολή\\\", θα σας ζητηθεί να εισάγετε τα στοιχεία της \\\"παραθύρου αποστολής κεφαλαίων\\\". Στο παραθυράκι που εμφανίζεται:\\n\\n- Από τη λίστα των διαθέσιμων λογαριασμών, επιλέξτε τον λογαριασμό στον οποίο θέλετε να στείλετε κεφάλαια.\\n- Εισάγετε τον αριθμό των μονάδων που θέλετε να στείλετε.\\n- Πατήστε \\\"κάντε μεταφορά\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Εξουσιοδοτήστε τη συναλλαγή\\n\\nΜετά το πάτημα του \\\"κάντε μεταφορά\\\" στο προηγούμενο στάδιο, θα σας ζητηθεί να εξουσιοδοτήσετε τη συναλλαγή στο \\\"παράθυρο εξουσιοδότησης συναλλαγής\\\".<br/>\\nΕλέγξτε τα στοιχεία της συναλλαγής και κάντε κλικ στο κουμπί \\\"υπογραφή και υποβολή\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nΣε αυτό το παράδειγμα, μεταφέραμε 500 μονάδες κεφαλαίου από τον \\\"BOB\\\" στον \\\"EMPLOYER\\\". Μπορείτε να δείτε ότι ο λογαριασμός του EMPLOYER, που αρχικά δεν είχε καθόλου κεφάλαιο, έχει τώρα 500 μονάδες κεφαλαίου.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Βεβαιωθείτε ότι έχετε αρκετά κεφάλαια στους λογαριασμούς που θέλετε να χρησιμοποιήσετε στο περιβάλλον παιχνιδιού.**\"}},{\"node\":{\"id\":\"e15158fc8bb365ee0158289d0a5ed5b0\",\"title\":\"Zigbee-Adapter mit Zigbee2MQTT für vorinstalliertes Image\",\"path\":\"/docs/de/zigbee-to-mqtt-image/\",\"content\":\"\\n**In diesem Artikel werden intelligente Geräte gekoppelt.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nÖffnen Sie einen Webbrowser und gehen Sie zu `http://%RASPBERRY_IP_ADDRESS%:8099`. Sie können die IP-Adresse des Raspberry Pi mit der [Fing Mobile App](https://www.fing.com/products) oder dem [nmap CLI-Tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) finden.\\n\\nSie sehen die Web-Benutzeroberfläche von Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nEs ist Zeit, Ihr intelligentes Gerät zu verbinden. \\nDrücken Sie zuerst die Schaltfläche `Permit join (All)` oben in der Web-Benutzeroberfläche von Zigbee2MQTT. \\n\\nDann beginnen Sie, Geräte zu koppeln. Die häufigste Methode, ein Gerät in den Verbindungsmodus zu versetzen, besteht darin, die Ein-/Aus-Taste gedrückt zu halten oder sie 5-mal ein- und auszuschalten. Stellen Sie sicher, dass Zigbee2MQTT läuft.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nWenn das Gerät verbunden ist, sehen Sie es in der Web-Benutzeroberfläche:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nJetzt sollten Sie diesen Sensor in Ihrer Home Assistant WebUI sehen. Gehen Sie zu `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nNachdem Sie alle Sensoren hinzugefügt haben, können Sie die Web-Benutzeroberfläche von Zigbee2MQTT schließen.\\n\"}},{\"node\":{\"id\":\"9dfa15bda0cd41f3c0e3b7f66d3dfa23\",\"title\":\"Wie man Blueprints verwendet\",\"path\":\"/docs/de/use-blueprints/\",\"content\":\"\\nIn diesem Artikel erfahren Sie, wie Sie Automatisierungs-Blueprints zu Ihrem Home Assistant hinzufügen und konfigurieren können.\\n\\n## Blueprint-Automatisierungen\\n\\nEinige Blueprints sind bereits installiert. Automatisierungen, die auf solchen Blueprints basieren, müssen nur konfiguriert werden. In der Web-Oberfläche finden Sie vorinstallierte Blueprints unter `Settings/Automations & Scenes`. Öffnen Sie `Blueprints` und suchen Sie den gewünschten Blueprint. In diesem Beispiel wird `Motion-activated Light` verwendet. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nKlicken Sie auf `Create Automation`, um den Automatisierungseditor zu öffnen. Geben Sie einen Namen ein, wählen Sie einen Blueprint aus (`Motion-activated Light` in unserem Fall). Danach müssen Sie einen Bewegungssensor und eine Lampe auswählen. Wenn die Konfiguration abgeschlossen ist, klicken Sie auf `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Konfiguration\\\" />\\n\\nWenn Sie Änderungen vornehmen möchten, finden Sie diese unter `Settings/Automations & Scenes` und dann `Automations`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Importieren von Blueprints\\n\\nHome Assistant kann Blueprints aus den Home Assistant Foren, GitHub und GitHub Gists importieren. Eine Liste aller Blueprints finden Sie unter [Blueprints Exchange](https://community.home-assistant.io/c/blueprints-exchange/53). Nachdem Sie einen Blueprint ausgewählt haben, gehen Sie zu `Settings/Automations & Scenes` und öffnen Sie `Blueprints`. Klicken Sie auf `Import Blueprint` und fügen Sie die URL des ausgewählten Blueprints ein. Klicken Sie dann auf `PREVIEW BLUEPRINT`. In diesem Fall verwenden wir [Erkennung und Benachrichtigung bei niedrigem Batteriestand für alle Batteriesensoren](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nDadurch wird der Blueprint geladen und eine Vorschau im Importdialog angezeigt. Sie können den Namen ändern und den Import abschließen. Klicken Sie auf `Create Automation`, um den Automatisierungseditor zu öffnen. Hier können Sie die Parameter der Automatisierung konfigurieren und Aktionen hinzufügen, um Benachrichtigungen zu erhalten.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"5a103d47585e2af130441295953000d1\",\"title\":\"Substrate Cumulus Parachain Testsuite für Cross-Chain-Messaging\",\"path\":\"/docs/de/xcm-robobank/\",\"content\":\"\\n\\nDas Hauptziel dieses Projekts ist die Vereinfachung der Entwicklung von Parachain-Laufzeitumgebungen bei Verwendung von Cross-Chain-Nachrichten. \\nEs ermöglicht die Entwicklung von Laufzeitcode mit Integrationstests mit hoher Wiederholbarkeit und einfacher Verwendung.\\nEs automatisiert den Aufbau, die Konstruktion einer voreingestellten Netzwerkkonfiguration (d. h. 1 Relay-Chain + 2 Parachains), die Einrichtung von Nachrichtenkanälen zwischen Parachains und die Durchführung von Messaging-Tests, das Senden von Nachrichten unter Verwendung eines Aufrufs an die Laufzeitumgebung, alles in Python konstruiert und zusammengesetzt.\\n\\nDie XCM-Testsuite wird zur Prüfung des Produktionszyklus von Robobank verwendet - der Satz von Substrate-Paletten, die es Robotern ermöglichen, sich auf externen Parachains zu registrieren, vorab bezahlte Bestellungen zu erhalten, diese auszuführen und Zahlungen unter Verwendung externer Token zu erhalten. Dies ermöglicht es Robotern, innerhalb des Robonomics-Netzwerks mit der gesamten erforderlichen Infrastruktur zu arbeiten, gleichzeitig aber ihre Dienste auf jedem anderen Parachain anzubieten.\\n\\nEin Beispielvideo ist auf [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM) verfügbar.\\n\\nDie wichtigsten Schritte im Demo-Szenario sind:\\n- Starten Sie Relay-Chain und zwei Parachains in einem Paket von 6 Prozessen.\\n- Richten Sie XCM-Nachrichtenkanäle zwischen Parachains ein.\\n- Registrieren Sie einen Roboter in beiden Parachains.\\n- Erstellen Sie eine Bestellung für diesen Roboter im Client-Parachain (Reservierung der Zahlung für die Fertigstellung der Bestellung).\\n- Senden Sie eine XCM-Nachricht an das Robonomics-Parachain.\\n- Erstellen des \\\"gespiegelten\\\" Bestellungsdatensatzes auf dem Robonomics-Parachain.\\n- Der Roboter akzeptiert die Bestellung auf dem Robonomics-Parachain.\\n- Senden Sie eine XCM-Nachricht über die Bestellannahme zurück an das Client-Parachain.\\n- Akzeptieren Sie die Bestellung auf dem Client-Parachain (Reservierung einer Strafgebühr für die Nichterfüllung der Bestellung bis zum Bestellungsdeadline).\\n- Der Roboter erfüllt die Bestellung auf dem Robonomics-Parachain.\\n- Senden Sie eine XCM-Nachricht über die Bestellfertigstellung an das Client-Parachain.\\n- Abwicklung aller Zahlungen (Kundenzahlung wird an den Roboter übertragen sowie die ungenutzte Strafgebühr).\\n- Schließen Sie die Bestellung1 ab.\\n\\n\\n## Upstream\\nDieses Projekt ist ein Fork des\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nEs enthält den Code der getesteten Laufzeitpaletten.\\nWie im Originalknotencode befinden sich die Parachain-Codes in den Verzeichnissen \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\".\\n\\nUnterschiede zum Original \\\"substrate-node-template\\\":\\n- Diese Collator-Laufzeitumgebung verfügt über ein HRMP-Handlermodul und kann Nachrichten von benachbarten Parachains verarbeiten.\\n- Mock-Test-Laufzeitumgebung, die für interne XCM-Tests bereit ist.\\n\\n## Build & Run\\nEmpfohlene (sehr) Einrichtung: \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[HINWEIS] Der erste Build kann viel Zeit in Anspruch nehmen, bis zu mehreren Stunden auf suboptimalen Maschinen.\\n\\n[HINWEIS] Das Skript funktioniert mit den festen Versionen (Commit-Hashes) von Polkadot(Rococo) in der Relay-Chain und den Parachains.\\n\\n[HINWEIS] Standardmäßig erstellt das Skript bei jedem Start die gleiche Umgebung, indem es alle vorherigen Zustände entfernt. Dieses Verhalten kann in \\\"config.sh\\\" mit dem Parameter \\\"PERSISTENT\\\" geändert werden.\\n\\n\\nFühren Sie das Build- und Setup-Skript aus.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nGrundlegende Aktionen des Skripts \\\"init.sh\\\":\\n - Konfiguration lesen (Datei \\\"config.sh\\\" mit Revisionsnummer, initialen Knotenschlüsseln und -identifikatoren, Chaindata-Persistenzparameter usw.)\\n - Setup von OS-Paketen, Rust und Python\\n - Erstellen separater Binärdateien für die Relay-Chain sowie für beide Parachains\\n    - Die Binärdateien werden im Unterverzeichnis ./bin generiert. \\n - (optional) Entfernen aller vorherigen Chain-Daten für alle Chains\\n    - Deaktiviert, wenn \\\"PERSISTENT=1\\\" in \\\"config.sh\\\" festgelegt ist\\n - Als separate Prozesse ausführen (mit separaten PIDs und I/O-Pipes):\\n    - Validatoren der Relay-Chain (d. h. 4 Validatoren, die eine stabile Rococo-Revision ausführen)\\n    - Collatoren für Parachain-100 (d. h. ein einzelner Collator für den ersten Parachain, den Sie entwickeln)\\n    - Collatoren für Parachain-200 (d. h. ein einzelner Collator für den zweiten Parachain, den Sie entwickeln)\\n - Alle Endpunkte und Ports werden in der Konsole gedruckt, sodass Sie jede Chain mit Frontend-Apps (Explorer, DApp) untersuchen können.\\n - Alle Ausgabedaten aller Chains werden weiterhin in der Konsole gedruckt.\\n\\n[WARNUNG] Warten Sie nach dem Starten, bis das Netzwerk hochgefahren ist, stellen Sie sicher, dass die Blockfinalisierung begonnen hat und die Parachains registriert sind. Diese Prozesse sollten etwa 5 Minuten dauern (50 Blöcke x 6 Sekunden).\\n\\n## Überprüfen, ob die anfängliche Einrichtung funktioniert \\n\\nVerwenden Sie das Standard-Polkadot-Frontend und die generierten \\\"--ws-port\\\"-Endpunkte, um eine Verbindung zu jedem Knoten herzustellen.\\nÖffnen Sie [Polkadot-Anwendung](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/), um die Chains zu überwachen. \\n\\n### Beispiel:\\nLocalhost, 4 Relay-Chain-Validatoren, ein Parachain-100-Collator, ein Parachain-200-Collator:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nWenn alles funktioniert und der Konsens gestartet ist, können wir mit dem Ausführen unserer Testfälle fortfahren (in einem neuen Terminal).\\n\\n### UMP-Nachrichtenübermittlungstest\\n```bash\\n./scripts/init.sh ump\\n```\\nEs erstellt eine `Balance.transfer`-Nachricht in `Parachain-100` und leitet sie an die Relay-Kette weiter.\\nWenn die Relay-Kette die Nachricht empfängt, werden 15 Token vom Konto `Para 100` auf das Konto von Charlie übertragen.\\n\\n\\n### HRMP-Nachrichtenübermittlungstest\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nEs erstellt eine `Balance.transfer`-Nachricht in `Parachain-100` und leitet sie an die `Sibling 200` weiter.\\nDavor stattet es das Konto `Subl 100` mit 1000 Token aus und richtet eine Kommunikationsverbindung zwischen den Parachains ein.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nWeitere Nachrichten können gesendet werden, indem der Befehl `hrmpm` ausgeführt wird. Es erstellt keinen Kanal und läuft daher schneller.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### Weitere Optionen\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Lokales Testnetz\\n\\n### Erstellen einer benutzerdefinierten Ketten-Spezifikation\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nBearbeiten Sie die Datei rococo_local.json und ersetzen Sie die Parameter für Guthaben und Behörden durch Ihre eigenen.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nPolkadot-Adresse für //Alice//Stash (sr25519-Kryptographie).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nPolkadot-Grandpa-Sitzungsschlüssel für //Alice (ed25519-Kryptographie).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nPolkadot-Adresse für //Alice (sr25519-Kryptographie).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nKonvertieren Sie rococo_local.json in das Rohformat.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nUm die neue Ketten-Spezifikation zu verwenden, ersetzen Sie die Datei rococo.json im Verzeichnis ./config/ durch diese neue und führen Sie die Kette erneut aus.\\n```bash\\n./scripts/init.sh run\\n```\\nSie können den Code frei bearbeiten. Der obige Befehl erstellt das Projekt neu und aktualisiert den Collator-Knoten vor dem Start.\\nCumulus ist eine Vorabversion der Software, die sich noch in der intensiven Entwicklung befindet.\\nWir verwenden einen bestimmten Commit von Polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18. März 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nSie können neuere Versionen der Software verwenden. Ändern Sie dazu POLKADOT_COMMIT in ./scipt/config.sh\\nauf den neuesten Commit des `rococo-v1`-Zweigs, löschen Sie ./bin/polkadot und führen Sie aus \\n```bash\\n./scripts/init.sh run\\n```\\n\\nAktualisieren Sie die Abhängigkeiten des Collator-Projekts \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nEinige Abhängigkeiten erfordern wahrscheinlich neue Funktionen der Rust-Toolchain. Dieses Projekt basiert auf Rust `nightly-2021-01-26`\\nAktualisieren Sie die Version der Rust-Toolchain in ./scripts/config.sh vor dem Build.\\n\\n## Parachain hacken\\n[Externe Palette hinzufügen](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - sollte es wahrscheinlich in \\\"Weitere Informationen\\\" sein?\\n## Learn More\\n\\nWeitere Informationen zur Struktur dieses Projekts, den darin enthaltenen Fähigkeiten und der Art und Weise, wie diese Fähigkeiten implementiert sind, finden Sie im Upstream [Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template). Weitere Informationen zum [Pfad eines Parachain-Blocks](https://polkadot.network/the-path-of-a-parachain-block/) finden Sie im offiziellen Polkadot-Blog. [Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"a391bc160740abae82442d567130597b\",\"title\":\"Wie man einen Start mit Abonnement sendet\",\"path\":\"/docs/de/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Beachten Sie, dass dieses Tutorial die Verwendung eines Abonnements auf der Robonomics Kusama Parachain demonstriert. Sie können alle Schritte auch auf Ihrem [lokalen Knoten](/docs/run-dev-node) durchführen.\\n\\n</robo-wiki-note>\\n\\nWenn Ihre Adresse ein aktives Abonnement hat, können Geräte, die mit dem geheimen Konto eingerichtet sind, Extrinsiken ohne Gebühr senden. \\nLassen Sie uns versuchen, den Befehl `launch` zu senden.\\n\\nGehen Sie zur Seite `Developer/Extrinsics` , wählen Sie dann Ihr Konto (das aus der Geräteliste) aus und wählen Sie `rws -> call(subscriptionId, call)`. \\nGeben Sie dann im Feld `subscriptionId` die Adresse des Besitzers des Abonnements ein (derjenige, der die Auktion geboten hat) und wählen Sie im nächsten Feld `launch -> launch(robot, param)`. Geben Sie im Feld `robot` die Adresse ein, an die Sie die `launch`-Transaktion senden möchten, und fügen Sie den Befehl ein (für eine Beschreibung des Startbefehls siehe [hier](/docs/launch)). Senden Sie dann die Transaktion ab:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\nGehen Sie nun zur Seite `Network/Explorer`, und im Bereich `Recent Events` sehen Sie zwei Ereignisse, die Sie erstellt haben: `rws.NewCall` und `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"ed4c096f387a4ecee541dfa38808b55f\",\"title\":\"Abonnement aktivieren\",\"path\":\"/docs/de/sub-activate/\",\"content\":\"\\nIn diesem Artikel erstellen Sie Robonomics Parachain-Konten und kaufen ein IoT-Abonnement. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nUm Home Assistant mit Robonomics zu steuern, benötigen Sie 2 Konten auf der Robonomics Parachain. Für eines der Konten (`sub_owner`) kaufen Sie ein Robonomics-Abonnement. Das zweite Konto (`sub_controller`) steuert alle Home Assistant-Prozesse (wie Telemetrie) und gewährt anderen Benutzern Zugriff. Diese Konten bieten Sicherheit für Ihren Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nBeide Konten müssen mit **ed25519**-Verschlüsselung erstellt werden. Aus diesem Grund müssen Sie über die Polkadot-JS-Benutzeroberfläche ein Konto erstellen und die erforderliche Verschlüsselung auswählen. \\n\\nDiese Funktion ist standardmäßig in der Polkadot-JS-Benutzeroberfläche deaktiviert. Um sie zu aktivieren, navigieren Sie zu `Settings` -> `General` -> `account options` und wählen Sie `Allow local in-browser account storage` im Dropdown-Menü `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Erstellen Sie Eigentümer- und Controller-Konten\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Gehen Sie zur [Robonomics Parachain-App](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) auf dem Polkadot / Substrate-Portal. ** Überprüfen Sie die linke obere Ecke, um sicherzustellen, dass Sie mit Robonomics Parachain verbunden sind. **\\n\\n2. Gehen Sie zu `Accounts` -> `Accounts` und klicken Sie auf die Schaltfläche `Konto hinzufügen`. Es wird das Popup-Menü mit dem Kontoschlüssel angezeigt. Es hat zwei Formen: *Mnemonic* (lesbar für Menschen) und *Raw* (eine Folge von Zahlen und Buchstaben). \\n\\n3. Öffnen Sie `Advanced creation options`, ändern Sie den Kryptotyp zur Kontoerstellung in `Edwards - ed25519` und klicken Sie auf `Next`.\\n\\n\\n4. Speichern Sie den mnemonischen Seed-Satz sicher und klicken Sie auf `Next`.\\n\\n5. Geben Sie im nächsten Menü den Kontonamen und das Passwort ein. Geben Sie ihm aus Bequemlichkeit den Namen `sub_owner`. Klicken Sie auf `Next`.\\n\\n6. Klicken Sie im letzten Fenster auf `Save`, um die Kontenerstellung abzuschließen. Es wird auch eine Sicherungskopie der JSON-Dateien generiert, die Sie sicher aufbewahren sollten. Sie können diese Datei später verwenden, um Ihr Konto wiederherzustellen, wenn Sie das Passwort kennen.\\n\\n7. Wiederholen Sie diese Schritte für ein Konto mit dem Namen `sub_controller`.\\n\\n\\n## Fügen Sie Konten zu Polkadot.js hinzu\\n\\nFür Ihre Bequemlichkeit sollten Sie die [Polkadot.js-Erweiterung](https://polkadot.js.org/extension/) verwenden und diese neu erstellten Konten hinzufügen. Für ein ed25519-Konto können Sie dies nur mit einer Sicherungs-JSON-Datei tun. Sie können die Dateien verwenden, die beim Erstellen der Konten gespeichert wurden.\\n\\nSie können diese Dateien erneut erhalten, indem Sie eine Sicherungsdatei des Kontos erstellen. Klicken Sie auf drei Punkte neben Ihrem Konto, wählen Sie `Create a backup file for this account` und geben Sie Ihr Passwort ein.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Öffnen Sie eine Erweiterung und klicken Sie oben rechts auf die Schaltfläche `+`, wählen Sie dann `Restore account from backup JSON file`.\\n\\n2. Laden Sie in einem geöffneten Fenster die JSON-Datei hoch, geben Sie das Passwort ein und klicken Sie auf `Restore`.\\n\\n3. Stellen Sie sicher, dass das Robonomics-Netzwerk für Konten in der Polkadot.js-Erweiterung ausgewählt ist. Gehen Sie auf dem Polkadot / Substrate-Portal zu `Setting` -> `Metadata` und klicken Sie auf die Schaltfläche `Update metadata`.\\n\\n4. Bestätigen Sie die Metadatenaktualisierung im Popup. Die Erweiterung zeigt nun das Netzwerketikett an, für das die Adresse verwendet wird.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Robonomics-Abonnement aktivieren \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nFür diesen Schritt müssen Sie über ausreichend XRT-Token (mindestens 2-3 XRTs) auf Ihrem `sub_owner`-Konto verfügen.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Gehen Sie zur Robonomics-Dapp zur [Abonnementseite](https://dapp.robonomics.network/#/subscription) und klicken Sie auf der rechten Seitenleiste auf `Konto verbinden`.\\n\\n2. Verbinden Sie in dem folgenden Popup-Menü die Polkadot.js-Erweiterung. Sie sehen Ihre Kontoadresse mit Guthaben.\\n\\n3. Überprüfen Sie vor dem Kauf, ob Sie das `sub_owner`-Konto ausgewählt haben. Klicken Sie auf das Adressprofil-Symbol, Sie sollten das `sub_owner`-Konto unter dem Feld `Check owner account` sehen.\\n\\n4. Drücken Sie abschließend die Schaltfläche `SUBMIT` und geben Sie das Passwort für Ihr Konto ein. Warten Sie dann, bis der Aktivierungsprozess abgeschlossen ist. Sie sehen den Status Ihres Abonnements nach einer Weile.\\n\\n\\n## Fügen Sie Konten zum Abonnement hinzu\\n\\nJetzt müssen Sie der **Zugriffsliste** ein `sub_controller`-Konto hinzufügen.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Öffnen Sie die Erweiterung und klicken Sie auf das Symbol neben dem Kontonamen. Dadurch wird die Kontoadresse kopiert.\\n\\n\\n2. Fügen Sie diese Adresse in das Feld `Robonomics parachain address` im Abschnitt **Zugriff verwalten** ein. Geben Sie ihm einen Namen und klicken Sie auf die Schaltfläche `+`. \\n\\n3. Wiederholen Sie die Schritte 1 und 2 für das `sub_owner`-Konto.\\n\\n4. Drücken Sie `Save`. Geben Sie Ihr `sub_owner`-Passwort im Popup-Fenster ein und warten Sie, bis der Aktivierungsprozess abgeschlossen ist.\\n\"}},{\"node\":{\"id\":\"47049c30f358ff4c947217325ea3a8a8\",\"title\":\"Erhalten Sie Smart Home Telemetrie\",\"path\":\"/docs/de/smart-home-telemetry/\",\"content\":\"\\n**In diesem Artikel verwenden Sie den Robonomics-Dienst, der die Telemetrie von Smart-Home-Geräten abfragt.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Gehen Sie zur Dapp und wählen Sie den [SmartHome Telemetrie](https://dapp.robonomics.network/#/smarthome-telemetry)-Dienst aus.\\n\\n2. Geben Sie im Controller-Feld die Adresse des `SUB_CONTROLLER` ein. Geben Sie die Seed-Phrase ein, um die Daten zu verschlüsseln.\\n\\n3. Wählen Sie im Block `Get telemetry`  einen Zeitstempel aus der Dropdown-Liste aus und drücken Sie die Schaltfläche `DOWNLOAD TELEMETRY`.\\n\\n4. Das Herunterladen der Telemetrie kann einige Zeit dauern. Nach Abschluss sehen Sie die Informationen von Ihren Geräten und Sensoren.\\n\\n\\n<!---\\n## Start devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Launch\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"0ff1e224e79d7a289b540718c7334ea9\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/de/sls-gateway/\",\"content\":\"\\n**In diesem Artikel richten Sie das Robonomics SLS Gateway ein. Sie installieren die erforderliche Software für das Gateway, konfigurieren es und verbinden es mit Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nZuerst müssen Sie die Mikrocontroller-Firmware des Gateways installieren. Bereiten Sie das Gateway vor, indem Sie die Schalter `1` und `3` im unteren Teil des SLS Gateways auf `ON` stellen, die anderen müssen `OFF` sein.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nVerbinden Sie das Gateway über den USB-Typ-C-Anschluss am Gateway mit Ihrem Raspberry Pi.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nKlonen Sie das Repository mit der Firmware auf Ihren Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nGehen Sie zu `robonomics-hass-utils/esp_firmware/linux`. Um das SLS Gateway zu flashen, müssen Sie die Skripte `Clear` und `Flash_16mb` ausführen.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Fehlerbehebung\\n\\nWenn Sie Probleme beim Aktualisieren der Gateway-Firmware haben, müssen Sie zusätzliche Schritte unternehmen:\\n\\n1. Stellen Sie sicher, dass das pySerial-Modul installiert ist.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Geben Sie Ihrem Benutzer Zugriffsrechte auf den USB-Port und starten Sie den Computer neu.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. In einigen Fällen ist es erforderlich, die Bandbreiteneinstellung im Skript zu ändern, um die Firmware zu aktualisieren. Öffnen Sie das Skript `Flash_16mb.sh` mit dem Editor `nano` und ändern Sie den Baud-Parameter von `921600` auf einen kleineren Wert (z. B. `115200`).\\n\\n## Konfiguration\\n\\n1. Trennen Sie das SLS Gateway vom Computer. Stellen Sie die Schalter auf der Rückseite des Gateways in die richtige Position. Schalter `5` (RX Zigbee zu ESP) und `6` (TX Zigbee zu ESP) müssen sich in der Position `ON` befinden, die anderen müssen `OFF` sein. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Schließen Sie das Typ-C-Netzkabel an. Die Anzeigeleuchte in der Mitte sollte grün leuchten.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. Beim ersten Start wird das Gateway Wi-Fi mit der SSID `zgw****` freigeben. Verbinden Sie sich mit diesem Netzwerk. Beachten Sie, dass das Signal möglicherweise recht schwach ist, daher ist es besser, das SLS Gateway näher an Ihrem Computer zu halten. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. Wenn die Verbindung erfolgreich ist, wird die Web-Benutzeroberfläche geöffnet (oder Sie finden sie unter der Adresse 192.168.1.1). \\n\\n5. Sie sehen die Seite `Wi-Fi Settings` . Wählen Sie Ihr Wi-Fi aus und geben Sie das Passwort ein. Drücken Sie die Schaltfläche `Apply`. Das Gateway wird neu gestartet und mit Ihrem Wi-Fi-Netzwerk verbunden. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Suchen Sie die lokale IP des SLS Gateways, um auf die Web-Benutzeroberfläche zuzugreifen. Sie können dazu die [Fing Mobile App](https://www.fing.com/products) oder das [nmap CLI-Tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) verwenden. Der Gateway-Name sollte wie folgt aussehen: `zgw****`. Öffnen Sie die Web-Benutzeroberfläche des Gateways, indem Sie die Gateway-IP in einen Browser einfügen.\\n\\n7. Gehen Sie zu `Setting` -> `Hardware` und stellen Sie sicher, dass die Einstellungen wie auf dem Bild aussehen. Korrigieren Sie die Einstellungen bei Bedarf und klicken Sie auf die Schaltfläche `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nDie Tabelle mit den erforderlichen Werten:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Starten Sie dann das Gateway neu. Wählen Sie `Actions` -> `Reboot system` in der rechten oberen Ecke.\\n\\n9. Stellen Sie sicher, dass das Gateway im Zigbee-Infofenster ordnungsgemäß funktioniert. Der Gerätestatus sollte `OK` sein.\\n\\n10. Konfigurieren Sie das automatische Hinzufügen von Geräten zu Home Assistant. Gehen Sie zu `Zigbee` -> `Config` und wählen Sie `Home Assistant MQTT Discovery` und `Clear States`. Speichern Sie die Änderungen und starten Sie das SLS Gateway erneut.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nWenn Sie bereits ein aktives SLS Gateway in Ihrem Zuhause haben und nun ein weiteres konfigurieren, werden sie sich gegenseitig stören. Um dieses Problem zu lösen, müssen Sie den Kanal auf dem neuen Gerät ändern. Gehen Sie zu `Zigbee` -> `Config` und ändern Sie den Kanal auf einen anderen (z. B. Kanal 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Koppeln von SLS mit MQTT\\n\\nNachdem Sie das SLS Gateway konfiguriert haben, müssen Sie das SLS Gateway mit Home Assistant verbinden. Öffnen Sie die SLS Gateway-Web-Benutzeroberfläche und gehen Sie zu `Settings/Link` -> `MQTT Setup`:\\n\\n\\nFügen Sie Ihre Broker-Adresse hinzu (Adresse des Raspberry Pi mit Home Assistant im lokalen Netzwerk, Sie können sie mit der [Fing Mobile App](https://www.fing.com/products) oder dem [nmap CLI-Tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) finden), Port (Standard ist `1883`), Ihren Broker-Benutzernamen und Ihr Passwort (das Sie zuvor erstellt haben) sowie den Themen-Namen (Sie können beliebige wählen). Außerdem muss die IP-Adresse des Raspberry Pi statisch sein. Klicken Sie auf `Enable` und `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nSpeichern Sie die Änderungen. Jetzt werden die Geräte automatisch in Home Assistant angezeigt.\\n\\n## Geräte verbinden\\n\\nVerbinden Sie Ihre Geräte, indem Sie zu `Zigbee` -> `Join` gehen. Setzen Sie Ihre Sensoren in den Pairing-Modus. Die gängigste Methode, ein Gerät in den Verbindungsmodus zu versetzen, besteht darin, die Ein-/Aus-Taste gedrückt zu halten oder sie 5-mal ein- und auszuschalten. Drücken Sie die Schaltfläche `Enable Join`, um nach Zigbee-Geräten zu suchen. Sie sehen aktive Sensoren.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nJetzt können Sie zum Abschnitt [**IoT-Abonnement**](/docs/sub-activate) gehen und das Robonomics-Abonnement aktivieren.\\n\"}},{\"node\":{\"id\":\"b7b7e71f2983545dd920f8871b14c646\",\"title\":\"Dezentrales Sensorsnetzwerk\",\"path\":\"/docs/de/sensors-network-introduction/\",\"content\":\"\\nDie Artikel über das dezentrale Sensorsnetzwerk wurden an die Robonomics Academy übertragen: https://robonomics.academy/de/online-kurse/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"e6aef8c8188b2d2284f691646dad052a\",\"title\":\"Sichere Verbindung von Cloud-KI zur Fabrikhalle\",\"path\":\"/docs/de/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nRobonomics-Technologien können bereits die Herausforderungen lösen, denen die Industrie 4.0 gegenübersteht, und sie werden bereits in realen Szenarien in der industriellen Umgebung angewendet.\\n\\nEine große Anzahl von KI-Unternehmen entwickelt Lösungen zur Optimierung der Prozesse auf der Fabrikhalle, um den Pflanzen zu ermöglichen, mehr mit geringeren Kosten zu produzieren. Die meisten Pflanzen zögern jedoch, ihre Infrastruktur direkt mit der Cloud zu verbinden, da dies zu potenziellen Cybersicherheitsrisiken führt, die zu Millionenschäden und sogar zum Verlust von Menschenleben führen könnten.\\n\\n[MerkleBot](https://merklebot.com) hat [Robonomics Network](https://robonomics.network) verwendet, um eine Lösung für industrielle Kunden zu entwickeln, um ihre Fabrik auf sichere Weise mit der Cloud-basierten KI zu verbinden.\\n\\nDieser Artikel wurde im Anschluss an ein Experiment verfasst, das wir mit [Veracity Protocol](https://www.veracityprotocol.org/) durchgeführt haben, das Algorithmen verwendet, um einen nicht-invasiven Schutz eines physischen Objekts auf der Grundlage von Fotos von einem mobilen Gerät zu erstellen.\\n\\nDieser Anwendungsfall zeigt den Prozess des Scannens von industriellen Teilen mithilfe eines Roboterarms.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Schritt-für-Schritt-Prozess\\n\\n### DApp als Benutzeroberfläche\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp fungiert als Benutzeroberfläche für den Bediener. Sie wird verwendet, um den Start des Roboters zur Erfassung der Fotos anzufordern, und ihr Zweck besteht darin, eine sichere Kommunikation zwischen der Fabrikumgebung und der Cloud-basierten KI zu ermöglichen.\\n\\n### Starten des Roboters\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nDer Bediener startet den robotischen Scan, indem er die Transaktion in der DApp signiert. Dieser Schritt garantiert, dass der Prozess auf der Fabrikhalle nur auf der Grundlage der Transaktion in der öffentlichen Blockchain gestartet werden kann.\\n\\nDer Roboter erhält einen Befehl von der Blockchain über das Robonomics Network und beginnt den Scan. Die Technologien des Robonomics Network ermöglichen es uns, die Lücke zwischen dem Geschäftsziel und dem Robotikbetrieb zu schließen.\\n\\n### Datensammlung und Übermittlung an die Cloud-basierte KI\\n\\nIn der DApp sieht der Bediener die Bestätigung und der Roboter beginnt mit dem Scannen der auf dem Tisch platzierten Gegenstände, wie in diesem Anwendungsfall, oder direkt auf der Fabriklinie, wenn es erforderlich ist.\\n\\n<!-- ![](../images/Veracity_Protocol_Launch.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nWenn der Roboter die Daten sammelt, speichert er sie lokal und stellt sie über das IPFS-Protokoll der Cloud-basierten KI zur Verfügung. Durch die Verschlüsselung der Daten und die Organisation des Datenaustauschs über eine Blockchain-Transaktion können wir den Zugriff auf die Cloud-basierte KI autorisieren und gleichzeitig sicherstellen, dass die Daten sicher und an ihrem Platz bleiben.\\n\\nDer in Robonomics eingebaute Sicherheitsmechanismus, der auf der gemeinsamen Sicherheit öffentlicher Blockchains basiert, ermöglicht es, das Sicherheitsniveau zu erreichen, das für die meisten Fabriken zu teuer ist, um es selbst zu organisieren.\\n\\n### Erstellung eines digitalen Passports\\n\\nWenn die Cloud-basierte KI die Daten analysiert, werden das Protokoll und die Empfehlungen automatisch als [Digitaler Reisepass](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/) aufgezeichnet. Jeder Vorgang und Scan kann zurückverfolgt werden, da der Blockchain-Eintrag den Hash zu all diesen Dateien über das IPFS-Protokoll enthält.\\n\\n## Kommentare zum Anwendungsfall\\n\\nIn diesem Anwendungsfall wurde der Universal Robot UR3 Industriearm verwendet. Dank der Unterstützung von Robonomics für ROS können jedoch die meisten großen Industriemanipulatoren sicher mit der Cloud-basierten KI verbunden werden, einschließlich KUKA, Fanuc und Yaskawa.\\n\\nWenn Sie mehr über die Bereitstellung und Integration von Cloud-basierten KI-Instrumenten auf sichere Weise erfahren möchten, kontaktieren Sie uns bitte unter [reach out](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"7466c82d7d257a566bf0171d33e99b85\",\"title\":\"Wie man den SDS011-Sensor zu Home Assistant hinzufügt\",\"path\":\"/docs/de/sds-sensor-hass/\",\"content\":\"\\nDieser Artikel erklärt, wie man den SDS-Luftqualitätssensor mit der [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) & [Robonomics](https://github.com/airalab/sensors-software) Firmware mit Home Assistant verbindet.\\n\\n## Installation \\nEs gibt zwei Installationsmöglichkeiten:\\n\\n### Option 1: HACS\\n\\nDer einfachste Weg, einen lokalen Luftdaten-Sensor hinzuzufügen, ist über HACS. [Hier](https://hacs.xyz/docs/setup/download/) finden Sie eine kurze Erklärung, wie Sie HACS einrichten können.\\n\\nSobald HACS installiert ist, navigieren Sie zu HACS -> Integrationen und suchen Sie nach der Integration `Local Luftdaten Sensor`. Klicken Sie auf die Download-Schaltfläche und starten Sie Home Assistant neu, sobald die Integration heruntergeladen ist.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Option 2: Manuelle Installation\\n\\nUnter dem Benutzer homeassistant klonen Sie das Projekt-Repository:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nWenn Sie bereits benutzerdefinierte Integrationen haben, kopieren Sie `custom_components/local_luftdaten/` in Ihr `custom_components`-Verzeichnis. Zum Beispiel:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nWenn Sie keine benutzerdefinierten Integrationen haben, kopieren Sie das gesamte `custom_components`-Verzeichnis in Ihr Home Assistant-Konfigurationsverzeichnis. Zum Beispiel:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Konfiguration\\n\\nErstellen Sie einen neuen Sensor-Eintrag in Ihrer `configuration.yaml` und passen Sie den Hostnamen oder die IP-Adresse an. Um die lokale IP-Adresse Ihres Sensors zu finden, können Sie die [Fing Mobile App](https://www.fing.com/products) oder das [nmap CLI-Tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) verwenden. Der Name kann beliebig sein.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> Eine Liste aller unterstützten Sensoren finden Sie im [Repository](https://github.com/lichtteil/local_luftdaten).\\n\\nStarten Sie Home Assistant neu.\\nDanach können Sie den Sensor zu Ihrem Dashboard hinzufügen. Der Name der Entität entspricht dem Namen, den Sie in `configuration.yaml` hinzugefügt haben.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"0150825888a125a323d3d1f5be1833a5\",\"title\":\"Wie man den SDS011 Sensor anschließt\",\"path\":\"/docs/de/sds-sensor-connect/\",\"content\":\"\\n** Hier ist eine Schritt-für-Schritt-Anleitung, wie Sie Ihren Sensor mit dem Robonomics Sensors Network verbinden können. Unsere Sensoren verwenden die Robonomics-Firmware, die eine verbesserte Version der sensor.community-Firmware ist. Sie enthält zusätzliche Sensoren und hat einen modifizierten Datenübertragungsmechanismus. **\\n\\n1. Stecken Sie den Sensor in die Steckdose, um ihn mit Strom zu versorgen.\\n2. Das Board erstellt ein Wi-Fi-Netzwerk mit dem Namen `RobonomicsSensor-xxxxxxxxx`. Verbinden Sie sich von Ihrem Telefon oder Computer damit: Sie sehen das Autorisierungsfenster (falls nicht, öffnen Sie den Browser und gehen Sie zu `192.168.4.1`).\\n3. Wählen Sie Ihr Wi-Fi-Netzwerk aus der Liste aus (oder geben Sie es selbst ein, wenn es nicht auf der Liste steht) und füllen Sie das Passwortfeld aus.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nDer Sensor kann nur mit einem 2,4-GHz-WLAN-Netzwerk verbunden werden.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Geben Sie die Koordinaten des Ortes ein, an dem der Sensor installiert wird. Sie können sie von beliebigen Karten erhalten oder sie über die Adresse mit [diesem Link](https://www.latlong.net/convert-address-to-lat-long.html) erhalten.\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nDie Sensor-Koordinaten werden dann auf einer öffentlich verfügbaren Karte angezeigt. Wenn Sie Ihre privaten Informationen nicht anzeigen möchten, geben Sie eine nahe, aber nicht genaue Koordinate ein.\\n</robo-wiki-note> \\n5. Klicken Sie auf `Save configuration and restart`. Das Board wird neu starten und sich mit dem angegebenen Wi-Fi-Netzwerk verbinden.\\n6. Öffnen Sie [Robonomics Sensors Map](https://sensors.robonomics.network/#/) und finden Sie Ihren Installationsort des Sensors. In ein paar Minuten können Sie Ihren Sensor mit Daten auf der Karte sehen.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"ef9681f1a236a26c4eda0345af4a2538\",\"title\":\"Wie man einen Robonomics Dev Node ausführt\",\"path\":\"/docs/de/run-dev-node/\",\"content\":\"\\n**Um Ihre Anwendungen auf Robonomics zu testen, möchten Sie sie möglicherweise im Entwicklungsmodus ausführen. Dieser Artikel zeigt Schritt für Schritt\\nAnweisungen, wie Sie Ihre eigene lokale Testinstanz von Robonomics erhalten.**\\n\\n\\n## Node-Binärdatei erhalten\\n\\n1. Zuerst benötigen Sie eine Binärdatei. Laden Sie das Archiv mit dieser von der neuesten [Version](https://github.com/airalab/robonomics/releases) herunter.\\n\\n2. Navigieren Sie zum Archivordner, entpacken Sie die Binärdatei und ändern Sie die Berechtigungen:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Ausführen\\n\\nFühren Sie den Node mit folgendem Befehl aus:\\n\\n```bash\\n./robonomics --dev\\n```\\nSie sehen die folgende Ausgabe:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  Wenn Sie vorhandene Blöcke löschen möchten, können Sie dies tun, indem Sie RocksDB unter `/tmp/substrate******/chains/dev/db/full` entfernen.\\n  Ersetzen Sie `******` durch einen entsprechenden in den Protokollen angezeigten Bezeichner.\\n\\n  Wenn Sie den Node jedes Mal von Grund auf starten möchten, verwenden Sie die Option `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## Verbinden\\n\\nJetzt können Sie sich über das [Polkadot-Portal](https://polkadot.js.org/apps/#/explorer) mit Ihrem lokalen Node verbinden.\\n\\nÄndern Sie das Netzwerk in der oberen linken Ecke auf `Local Node` und klicken Sie auf `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nWillkommen zur lokalen Instanz von Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"b44b80918007df0a324d2e09ae696059\",\"title\":\"Robonomics Video Service\",\"path\":\"/docs/de/robonomics-video/\",\"content\":\"\\nDieser Artikel zeigt, wie Sie eine IP-Kamera zu Home Assistant hinzufügen und Videos an den Robonomics Web Service senden können.\\n\\nUm eine Kamera mit Home Assistant zu verbinden, müssen Sie ihre IP-Adresse kennen und ein lokales Kamerakonto erstellen, um den RTSP-Stream zu verbinden.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nDa dies für jede Kamera unterschiedlich erfolgt, wird dieser Prozess in diesem Artikel nicht behandelt.\\n</robo-wiki-note>\\n\\nAnforderungen:\\n- IP-Kamera\\n- Konfiguriertes lokales Kamerakonto\\n- IP-Adresse der Kamera\\n- Konfiguriertes Home Assistant\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nDieser Artikel geht davon aus, dass Sie eine allgemeine IP-Kamera ohne RTZ (Drehen, Neigen, Zoomen) Optionen haben. \\nWenn Sie eine RTZ-Kamera haben, überprüfen Sie den [\\\"RTZ-Kamera\\\"-Artikel](/docs/ptz-camera). Und dann kommen Sie zurück zum zweiten Schritt hier.\\n\\n</robo-wiki-note>\\n\\n## Verbinden Sie die Kamera\\n\\nZunächst müssen Sie die URL für den RTSP-Stream der Kamera herausfinden. \\nGeben Sie dazu den folgenden Befehl im Internet ein: \\\"<KAMERA_NAME> RTSP-Stream\\\".\\nDie Stream-URL muss mit `rtsp://<IP_Adresse>...` beginnen. \\n\\nIn diesem Artikel wird eine \\\"Tapo\\\"-Kamera verwendet und der Stream-Pfad lautet `rtsp://<IP_Adresse>/stream1`.\\n\\nÖffnen Sie Home Assistant und gehen Sie zu  \\\"Settings\\\"-> \\\"Devices & Services\\\".. Drücken Sie die Schaltfläche \\\"ADD INTEGRATION\\\" und\\nbeginnen Sie mit der Eingabe der Integration \\\"Generic Camera\\\". Wählen Sie sie aus.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nGeben Sie im Konfigurationsfenster die folgenden Informationen ein:\\n- Stream Source URL - Die URL des RTSP-Streams der Kamera\\n- Username - geben Sie einen Benutzernamen für Ihr lokales Kamerakonto ein\\n- Password - geben Sie ein Passwort für Ihr lokales Kamerakonto ein\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nScrollen Sie nach unten zu den Einstellungen und drücken Sie die Schaltfläche \\\"Submit\\\".\\n\\nAktivieren Sie im Vorschaufenster das Kontrollkästchen \\\"This image looks good.\\\" und drücken Sie die Schaltfläche \\\"Submit\\\". Dann - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Zum Dashboard hinzufügen\\n\\nDarüber hinaus können Sie den Stream zu Ihrem Dashboard hinzufügen. Gehen Sie dazu zum Dashboard und erstellen Sie eine neue Karte \\n\\\"Bildübersicht\\\". Weitere Schritte:\\n- geben Sie den gewünschten \\\"Titel\\\" ein\\n- löschen Sie die Daten aus \\\"Image path\\\"\\n- 2ählen Sie die Kamera in „Camera Entity“ aus.\\n- wählen Sie in der \\\"Camera view\\\" \\\"live\\\", damit es weniger Verzögerung gibt\\n\\nUnd speichern Sie es.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Überprüfen Sie den Medienordner\\n\\nBevor das Video an den Robonomics-Videodienst gesendet wird, muss es in einem Ordner gespeichert werden und Home Assistant muss Zugriff auf diesen Ordner haben. \\nDie einfachste Option in diesem Fall ist die Verwendung eines Medienpakets, in dem Home Assistant alle Medien speichert.\\n\\n- Wenn Sie HAOS oder ein vorinstalliertes Image verwenden, hat Ihr Home Assistant bereits einen Medienordner.\\n- Wenn Sie Home Assistant Core verwenden, sollten Sie zum `.homeassistant`-Ordner gehen und darin einen `media`-Ordner erstellen.\\n- Wenn Sie Home Assistant Docker verwenden, fügen Sie der Docker-Befehlszeile die Zeile ` -v /PFAD_ZU_IHREM_MEDIA:/media \\\\` hinzu.\\n\\nUm zu überprüfen, ob alles richtig eingerichtet ist, gehen Sie zu “Media” -> “local media”  in Ihrem Home Assistant. \\nSie sollten einen leeren Ordner sehen (keine Fehler):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Serviceaufruf\\n\\nUm ein Video an Robonomics zu senden, sollten Sie einen dedizierten Service in Home Assistant aufrufen. \\nIn diesem Artikel wird dies manuell gemacht, aber Sie können dafür eine Automatisierung erstellen.\\n\\nGehen Sie dazu zu \\\"Developer tools\\\" -> \\\"Services\\\" und suchen Sie \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nWählen Sie in \\\"Targets\\\" Ihre Kamera-Entität aus.\\nGeben Sie in \\\"Path to save the recording\\\" einen absoluten Pfad zum Ordner an,\\nin dem Home Assistant das Video speichern kann:\\n- Für vorinstalliertes Image - `/home/homeassistant/.homeassistant/media`;\\n- Für HA OS oder Home Assistant Docker- `/media`;\\n- Für Home Assistant Core - Pfad zum zuvor erstellten Medienordner.\\n\\nZusätzlich können Sie die Aufnahmedauer wählen. \\n\\nFüllen Sie die Daten aus und rufen Sie den Service mit der Schaltfläche \\\"CALL SERVICE\\\" auf.\\n\\n## DAPP\\n\\nUm das resultierende Video anzuzeigen, gehen Sie zu [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nFügen Sie die Kontoadresse Ihres Controllers ein und klicken Sie auf die Schaltfläche unten. Warten Sie auf den \\\"Search for Twins\\\"-Prozess. \\nAls Ergebnis erhalten Sie eine IPFS CID mit allen aufgezeichneten Videos.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nWählen Sie anschließend das Controller-Konto (oder ein anderes) aus der Dropdown-Liste aus und signieren Sie eine Nachricht zur Autorisierung in\\ndem Web3 IPFS-Gateway, um alle Videos herunterzuladen. Als Ergebnis erhalten Sie alle Videos, die von Ihrem Smart Home aufgezeichnet wurden.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nDa alle Videos im Ordner mit dem Controller-Schlüssel verschlüsselt sind, müssen Sie ihn einfügen, um die Videos zu entschlüsseln.\\nDanach wird die Wiedergabetaste für das Video aktiviert. Klicken Sie darauf, um das Video herunterzuladen.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"0b4f6e5d2f0bf4e4b21e312550153ab5\",\"title\":\"Robonomics Smart Home Übersicht\",\"path\":\"/docs/de/robonomics-smart-home-overview/\",\"content\":\"\\n## Sicheres IoT mit Blockchain \\n\\nFür Ihr Smart Home bietet der moderne IoT-Markt eine Vielzahl von Lösungen. Aber in der Regel sind Sie an zentralisierte Cloud-Anbieter oder teure proprietäre Gateways gebunden. Als Benutzer sind Sie daher immer von der Hardware- und Infrastrukturanbieter abhängig, um Ihr intelligentes System zu betreiben. Gleichzeitig kann Ihr Smart Home ohne Cloud-Statistiken und -Analysen nicht wirklich intelligent sein.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**Wir sehen zwei Hauptprobleme bei aktuellen Smart Homes:**\\n\\n1. Sie haben keine Kontrolle darüber, welche Daten Sie mit dem Anbieter oder Dritten teilen.\\n2. Ihr Smart Home ist anfällig für Ausfälle zentralisierter Cloud-Server. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nUm beide Probleme zu lösen, empfehlen wir Ihnen, Robonomics auszuprobieren, unsere **sichere**, **serverlose** und **zukunftsweisende** dezentralisierte Cloud.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Schritte zur unternehmensfreien Cloud\\n\\nHier sind einige einfache Schritte, um ein erschwingliches Smart Home mit Home Assistant als Gerätekommunikationsanwendung und Robonomics als unternehmensfreier, dezentralisierter Cloud-Plattform zu erstellen. Robonomics nutzt moderne und sichere Web3-Technologien, um eine verbesserte Sicherheit während des gesamten Prozesses zu gewährleisten..\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Starten Sie hier Ihr Smart Home\\n\\nWir haben detaillierte Anleitungen zur Einrichtung eines Smart Homes auf Robonomics vorbereitet. Die Schritte können je nach Ihrer spezifischen Situation variieren: ob Sie bereits einen betriebsbereiten Home Assistant mit gekoppelten Geräten haben oder ob Sie von Grund auf ein Smart Home einrichten möchten.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/de/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/de/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"c4ad4328c6b8cb14fe27cdda41dc4d29\",\"title\":\"Robonomics Integration Setup\",\"path\":\"/docs/de/robonomics-hass-integration/\",\"content\":\"\\n**In diesem Artikel fügen Sie Robonomics zu Home Assistant hinzu. Dadurch kann Home Assistant Datalogs mit verschlüsselten Daten auf Robonomics Parachain aufzeichnen und Startbefehle von der Parachain empfangen, um intelligente Geräte zu steuern. Die Integration verwendet IPFS, um Daten zu speichern und IPFS-Hashes an Datalog- oder Startfunktionen zu senden.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. Gehen Sie im Webinterface von Home Assistant zu `Settings` -> `Device & Services` und klicken Sie auf `ADD INTEGRATION`. Suchen Sie nach `Robonomics`.\\n\\n2. Klicken Sie auf Robonomics und füllen Sie die Konfiguration aus: \\n\\n- Fügen Sie den Seed des `SUB_CONTROLLER`-Kontos zum Controller-Kontoseed hinzu.\\n- Fügen Sie die öffentliche Adresse des `SUB_OWNER`-Kontos zur Abonnementbesitzeradresse hinzu.\\n- Legen Sie das Intervall für das Senden von Daten fest (standardmäßig 10 Minuten).\\n- (Optional) Sie können Anmeldeinformationen für den Pinning-Dienst Pinata oder ein anderes benutzerdefiniertes Gateway hinzufügen, um Ihre Daten breiter im IPFS-Netzwerk zu verteilen.\\n\\n3. Drücken Sie nach Abschluss der Konfiguration `SUBMIT`. Wenn Sie alles korrekt ausgefüllt haben, sehen Sie das Erfolgsfenster.\\n\\nDas ist alles! Sie haben Robonomics Integration vollständig in Home Assistant eingerichtet. Jetzt können Sie alle Robonomics-Webdienste nutzen. Um mehr darüber zu erfahren, gehen Sie zum [\\\"Verwendung\\\"-Abschnitt](/docs/global-administration). \\n\"}},{\"node\":{\"id\":\"4ad5fb9398a0306a88fcfb1f40323cf4\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/de/robonomics-prometheus-grafana/\",\"content\":\"\\n**Die folgende Anleitung stammt von [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**Der Originalartikel befindet sich [hier](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-Metriken-mit-Prometheus-und-Grafana)**\\n\\n## Einführung\\nUm Robonomics-Knoten besser überwachen und warten zu können, ist es ratsam, eine Überwachung auf Basis von Prometheus Server und Grafana einzurichten. Dieses Dokument zeigt, wie Sie jedes einzelne davon konfigurieren können, um Ihren Knoten vollständig zu überwachen.\\n\\n##  Voraussetzungen\\n* [Servereinrichtung mit Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Robonomics-Parachain-Collator installiert](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Stellen Sie sicher, dass robonomics.service auf Ihrem Gerät funktioniert und Port 9615 erreichbar ist. \\n\\n## Schritt 1 - Erstellen von Service-Benutzern\\n\\nAus Sicherheitsgründen beginnen wir damit, zwei neue Benutzerkonten, prometheus und node_exporter, zu erstellen. Erstellen Sie diese beiden Benutzer und verwenden Sie die Optionen _--no-create-home_ und _--shell /bin/false_, damit sich diese Benutzer nicht am Server anmelden können.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nBevor wir die Prometheus-Binärdateien herunterladen, erstellen wir die erforderlichen Verzeichnisse zum Speichern der Dateien und Daten von Prometheus. Gemäß den Standardkonventionen von Linux erstellen wir ein Verzeichnis in _/etc_ für die Konfigurationsdateien von Prometheus und ein Verzeichnis in _/var/lib_ für seine Daten.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nLegen Sie nun den Benutzer- und Gruppenbesitz auf den neuen Verzeichnissen auf den Benutzer prometheus fest.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Schritt 2 - Herunterladen von Prometheus\\n\\nLaden Sie zunächst die aktuelle stabile Version von Prometheus herunter und entpacken Sie sie in Ihr Home-Verzeichnis. Die neuesten Binärdateien finden Sie auf der [Prometheus-Downloadseite.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nEntpacken Sie nun das heruntergeladene Archiv.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nDies erstellt ein Verzeichnis namens prometheus-2.21.0.linux-amd64, das zwei Binärdateien (prometheus und promtool), die Verzeichnisse _consoles_ und _console_libraries_ mit den Dateien der Web-Benutzeroberfläche, eine Lizenz, einen Hinweis und mehrere Beispieldateien enthält.\\n\\nKopieren Sie die beiden Binärdateien in das Verzeichnis _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nLegen Sie den Benutzer- und Gruppenbesitz auf den Binärdateien auf den in Schritt 1 erstellten Benutzer prometheus fest.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nKopieren Sie die Verzeichnisse consoles und _console_libraries_ nach _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nLegen Sie den Benutzer- und Gruppenbesitz auf den Verzeichnissen auf den Benutzer prometheus fest. Mit der Option -R wird sichergestellt, dass der Besitz auch auf die Dateien innerhalb des Verzeichnisses angewendet wird.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nJetzt, da Prometheus installiert ist, erstellen wir seine Konfigurations- und Service-Dateien zur Vorbereitung des ersten Starts.\\n\\n## Schritt 3 - Konfigurieren von Prometheus\\n\\nErstellen Sie im Verzeichnis _/etc/prometheus_ mit nano oder Ihrem bevorzugten Texteditor eine Konfigurationsdatei namens _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nDefinieren Sie in den globalen Einstellungen das Standardintervall zum Abrufen von Metriken. Beachten Sie, dass Prometheus diese Einstellungen auf jeden Exporter anwendet, es sei denn, die eigenen Einstellungen des Exporters überschreiben die globalen Einstellungen.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nDieser Wert für scrape_interval gibt an, dass Prometheus Metriken von seinen Exportern alle 15 Sekunden sammeln soll, was für die meisten Exporter ausreichend ist.\\nFügen Sie nun Prometheus selbst zur Liste der Exporter hinzu, von denen gescraped werden soll, mit der folgenden scrape_configs-Anweisung:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus verwendet den _job_name_, um Exporter in Abfragen und auf Diagrammen zu kennzeichnen. Stellen Sie also sicher, dass Sie hier etwas Beschreibendes auswählen.\\n\\nUnd da Prometheus wichtige Daten über sich selbst exportiert, die Sie zur Überwachung der Leistung und zur Fehlerbehebung verwenden können, haben wir die globale scrape_interval-Direktive von 15 Sekunden auf 5 Sekunden überschrieben, um häufigere Aktualisierungen zu ermöglichen.\\n\\nSchließlich verwendet Prometheus die Direktiven _static_configs_ und _targets_, um festzustellen, wo Exporter ausgeführt werden. Da dieser Exporter auf demselben Server wie Prometheus selbst läuft, können wir localhost anstelle einer IP-Adresse zusammen mit dem Standardport 9090 verwenden.\\n\\nIhre Konfigurationsdatei sollte jetzt wie folgt aussehen:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nSpeichern Sie die Datei und beenden Sie Ihren Texteditor.\\n\\nLegen Sie nun die Benutzer- und Gruppenbesitzrechte für die Konfigurationsdatei auf den in Schritt 1 erstellten prometheus-Benutzer fest.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nMit der Konfiguration abgeschlossen sind wir bereit, Prometheus zum ersten Mal auszuführen.\\n\\n## Schritt 4 - Prometheus ausführen\\n\\nStarten Sie Prometheus als Benutzer _prometheus_ und geben Sie den Pfad zur Konfigurationsdatei und zum Datenverzeichnis an.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nDie Ausgabe enthält Informationen zum Ladevorgang von Prometheus, zur Konfigurationsdatei und zu verwandten Diensten. Sie bestätigt auch, dass Prometheus auf Port _9090_ lauscht.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nWenn Sie eine Fehlermeldung erhalten, überprüfen Sie, ob Sie die YAML-Syntax in Ihrer Konfigurationsdatei verwendet haben, und befolgen Sie dann die Bildschirmanweisungen zur Behebung des Problems.\\n\\nHalten Sie nun Prometheus an, indem Sie _STRG+C_ drücken, und öffnen Sie dann eine neue _systemd_-Service-Datei.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nDie Service-Datei gibt _systemd_ an, Prometheus als Benutzer prometheus auszuführen, wobei die Konfigurationsdatei im Verzeichnis _/etc/prometheus/prometheus.yml_ und die Daten im Verzeichnis _/var/lib/prometheus_ gespeichert werden sollen. Kopieren Sie den folgenden Inhalt in die Datei:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nSpeichern Sie die Datei schließlich und schließen Sie Ihren Texteditor. Um den neu erstellten Service zu verwenden, laden Sie systemd neu.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nSie können Prometheus jetzt mit dem folgenden Befehl starten:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nUm sicherzustellen, dass Prometheus läuft, überprüfen Sie den Status des Dienstes.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nDie Ausgabe gibt Ihnen Informationen über den Status von Prometheus, die Hauptprozesskennung (PID), den Speicherverbrauch und mehr.\\n\\nWenn der Status des Dienstes nicht aktiv ist, befolgen Sie die Anweisungen auf dem Bildschirm und gehen Sie die vorherigen Schritte erneut durch, um das Problem zu beheben, bevor Sie das Tutorial fortsetzen.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nWenn Sie bereit sind, fahren Sie fort, indem Sie _Q_ drücken, um den Statusbefehl zu beenden. Aktivieren Sie abschließend den Dienst, um beim Start zu starten.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nJetzt, da Prometheus läuft, können wir einen zusätzlichen Exporter installieren, um Metriken über die Ressourcen unseres Servers zu generieren.\\n\\n## Schritt 5 - Herunterladen des Node Exporters\\n\\nUm Prometheus über Metriken nur über sich selbst hinaus zu erweitern, installieren wir einen zusätzlichen Exporter namens Node Exporter. Node Exporter liefert detaillierte Informationen über das System, einschließlich CPU-, Festplatten- und Speichernutzung. Laden Sie die aktuelle stabile Version von Node Exporter in Ihr Home-Verzeichnis herunter. Die neuesten Binärdateien finden Sie auf der [Prometheus-Downloadseite.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nEntpacken Sie nun das heruntergeladene Archiv.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nDadurch wird ein Verzeichnis namens _node_exporter-1.0.1.linux-amd64_ erstellt, das eine Binärdatei namens _node_exporter_, eine Lizenz und einen Hinweis enthält.\\n\\nKopieren Sie die Binärdatei in das Verzeichnis _/usr/local/bin_ und setzen Sie die Benutzer- und Gruppenbesitzrechte auf den node_exporter-Benutzer, den Sie in Schritt 1 erstellt haben.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nJetzt, da Sie Node Exporter installiert haben, testen wir es, indem wir es ausführen, bevor wir eine Dienstdatei dafür erstellen, damit es beim Starten gestartet wird.\\n\\n## Schritt 6 - Ausführen des Node Exporters\\n\\nDie Schritte zum Ausführen des Node Exporters ähneln denen zum Ausführen von Prometheus selbst. Beginnen Sie damit, die Systemd-Dienstdatei für den Node Exporter zu erstellen.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nKopieren Sie den folgenden Inhalt in die Dienstdatei:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nSpeichern Sie die Datei und schließen Sie Ihren Texteditor. Aktualisieren Sie schließlich systemd, um den neu erstellten Dienst zu verwenden.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nSie können Node Exporter jetzt mit dem folgenden Befehl ausführen:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nÜberprüfen that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nWie zuvor gibt Ihnen diese Ausgabe Informationen über den Status von Node Exporter, die Hauptprozess-ID (PID), den Speicherverbrauch und mehr. Wenn der Status des Dienstes nicht aktiv ist, folgen Sie den Bildschirmanweisungen und gehen Sie die vorherigen Schritte erneut durch, um das Problem zu beheben, bevor Sie fortfahren.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nSchließlich aktivieren Sie Node Exporter, um beim Start zu starten.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nNachdem Node Exporter vollständig konfiguriert und wie erwartet ausgeführt wird, teilen wir Prometheus mit, dass es die neuen Metriken abrufen soll.\\n\\n## Schritt 7 - Konfigurieren von Prometheus zum Abrufen von Node Exporter\\n\\nDa Prometheus nur Exporter abruft, die in der scrape_configs-Sektion seiner Konfigurationsdatei definiert sind, müssen wir einen Eintrag für Node Exporter hinzufügen, genau wie wir es für Prometheus selbst getan haben. Öffnen Sie die Konfigurationsdatei.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nFügen Sie am Ende des scrape_configs-Blocks einen neuen Eintrag namens node_exporter hinzu.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nDa dieser Exporter auch auf demselben Server wie Prometheus selbst läuft, können wir erneut localhost anstelle einer IP-Adresse verwenden, zusammen mit dem Standardport von Node Exporter, 9100. Ihre gesamte Konfigurationsdatei sollte wie folgt aussehen:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nSpeichern Sie die Datei und beenden Sie Ihren Texteditor, wenn Sie bereit sind, fortzufahren. Starten Sie schließlich Prometheus neu, um die Änderungen wirksam zu machen.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nÜberprüfen Sie erneut mit dem Befehl status, ob alles korrekt ausgeführt wird.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nWenn der Status des Dienstes nicht auf aktiv gesetzt ist, folgen Sie den Bildschirmanweisungen und gehen Sie Ihre vorherigen Schritte erneut durch, bevor Sie fortfahren.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nWir haben jetzt Prometheus und Node Exporter installiert, konfiguriert und laufen lassen.\\n\\n## Schritt 8 - Hinzufügen des Robonomic-Builds in node_exporter\\n\\nNach erfolgreicher Installation von Prometheus und node_exporter müssen wir den integrierten Prometheus-Exporter in jedem Substratprojekt verwenden. Um dies zu erreichen, müssen wir einen zusätzlichen Eintrag zu _/etc/prometheus/prometheus.yml_ hinzufügen.. \\nÖffnen Sie die Konfigurationsdatei.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nFügen Sie am Ende des scrape_configs-Blocks einen neuen Eintrag namens robonomic_exporter hinzu.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nSpeichern Sie die Datei und beenden Sie Ihren Texteditor. Ihre gesamte Konfigurationsdatei sollte wie folgt aussehen:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nStarten Sie schließlich Prometheus neu, um die Änderungen wirksam zu machen.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nÜberprüfen Sie noch einmal mit dem Statusbefehl, ob alles korrekt läuft.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nWir haben jetzt _Prometheus_ und _Node Exporter_ sowie _Robonomic Exporter_ installiert, konfiguriert und laufen. Gehen Sie nun zu Grafana\\n\\n## Schritt 9 - Einrichten von Grafana\\n\\nDer letzte Schritt besteht darin, Prometheus als Datenquelle in Grafana zu verbinden. Für dieses Tutorial verwenden wir eine kostenlose Cloud-basierte Grafana, die bis zu 5 Dashboards sowie ein dediziertes [Robonomics-Dashboard](https://grafana.com/grafana/dashboards/13015) ermöglicht. Gehen Sie einfach zu [grafana.com](https://grafana.com/), erstellen Sie ein neues Konto und melden Sie sich bei Ihrer neu erstellten Grafana-Instanz an.\\n\\nZu Beginn müssen wir Grafana eine neue _**Datenquelle**_ hinzufügen, die in unserem Fall der Prometheus-Server sein wird.\\nGehen Sie zu Datenquelle:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nKlicken Sie dann auf **_Datenquelle hinzufügen_**\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext auswählen _**Prometheus**_\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nGeben Sie im neuen Bildschirm Ihre **_Prometheus-Server-IP-Adresse mit Port 9090_** ein\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nDanach _**Speichern & Testen**_, wenn Sie alle Schritte durchgeführt haben, sollte alles grün sein und bereit sein, das Dashboard zu importieren. Klicken Sie auf der Hauptseite auf **+** und dann auf **Importieren**, wie im Bild unten gezeigt:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nDann sollten Sie die Importseite sehen:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nGeben Sie in der _Grafana.com Dashboard-URL oder ID_ _**13015**_ ein (da dies die ID des Robonomic-Dashboards ist)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nNach dem Laden des externen Dashboards erhalten Sie diesen Bildschirm:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nDer letzte Schritt besteht darin, die zuvor erstellte **_Datenquelle_** auszuwählen und auf _**Importieren**_ zu klicken\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nDAS IST ES! An diesem Punkt sollten Sie das importierte Dashboard sehen. \\n\\n\\n## Referenzen\\n\\n* [Anleitung zur Installation von Prometheus auf Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Erstellen eines Überwachungsdashboards mit Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Grafana-Unterstützung für Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Überwachung von Linux-Hostmetriken mit dem Node Exporter](https://prometheus.io/docs/guides/node-exporter/)\\n* [Abfragen von Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Visualisierung von Knotenmetriken](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Polkadot-Knotenmetrik](https://grafana.com/grafana/dashboards/12425)\\n* [Node Exporter für Prometheus Dashboard](https://grafana.com/grafana/dashboards/11074)\\n* [Grafana ROBONOMICS (XRT) Metriken](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"3990be7058f884b50668a507f9858ac6\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/de/robonomics-opengov/\",\"content\":\"\\n## Einführung\\n\\nRobonomics hat das Governance-Modell der Parachain auf Polkadots ausgeklügelten OpenGov-Mechanismus umgestellt, der es der Kette ermöglicht, sich im Laufe der Zeit weiterzuentwickeln, letztendlich unter der Kontrolle der Token-Inhaber.\\nDer Übergang von Robonomics zu OpenGov stellt sicher, dass die DAO der Token-Inhaber, die die Mehrheit der Anteile kontrolliert, immer die Richtung der Robonomics Parachain bestimmen kann und jede Änderung im Netzwerk umsetzen kann, die sie für angemessen hält.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov gilt nur für die Robonomics Parachain, die eine auf Substrate basierende Kette ist, die mit der Kusama Relay Chain verbunden ist. OpenGov ist nicht für die Robonomics Ethereum-Implementierung anwendbar, da das Ethereum-Hauptnetz derzeit keine ausgeklügelten Governance-Systeme wie OpenGov unterstützt.\\n</robo-wiki-note>\\n\\nOpenGov verändert, wie die täglichen Betriebsabläufe und Entscheidungsprozesse auf der Parachain durchgeführt werden. Es bietet eine größere Klarheit über den Umfang von Referenden und hat das Potenzial, die Durchsatzrate der auf der Parachain getroffenen Entscheidungen dramatisch zu erhöhen.\\n\\nOpenGov ist seit einigen Monaten auf der Kusama Relay Chain live und hat gezeigt, dass es die Anzahl der Entscheidungen (individuelle und diskrete Referenden), die die DAO der Token-Inhaber vorschlagen, abstimmen und letztendlich durch Abstimmung kontrollieren kann, dramatisch erhöht.\\n\\n**Der folgende Inhalt in diesem Abschnitt des Wikis erläutert die Kernprinzipien von OpenGov auf der Robonomics Parachain und soll Ihnen helfen, die Konzepte hinter OpenGov besser zu verstehen.**\\n\\n*Es ist wichtig zu beachten, dass Governance ein sich ständig weiterentwickelnder Mechanismus im Protokoll ist, insbesondere in den frühen Implementierungsphasen.*\\n\\nFür diejenigen, die sich ausschließlich für die Robonomics OpenGov Track-Parameter interessieren, siehe [hier](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## Über Referenden\\n\\nReferenden sind einfache, inklusive und stake-basierte Abstimmungssysteme. Jedes Referendum ist mit einem spezifischen Vorschlag verbunden, der in Form eines privilegierten Funktionsaufrufs in der Laufzeit der Ketten erfolgt. Dies kann auch den mächtigsten Aufruf `set_code` enthalten, das die Möglichkeit hat, den gesamten Code der Laufzeit der Ketten auszutauschen – dies ist einzigartig für Substrate-basierte Ketten und macht die Notwendigkeit einer „Hard Fork“ der Kette bei der Aktualisierung des Kettengeschäfts überflüssig Logik (Laufzeit).\\n\\nReferenden sind diskrete Ereignisse, die eine feste Abstimmungsperiode haben (mehr über die verschiedenen Phasen während des Lebenszyklus eines Referendums später). Individuelle Token-Inhaber können auf Referenden auf eine von drei Arten abstimmen - ZUSTIMMEN (zustimmen/ja), ABLEHNEN (ablehnen/nein) oder sich vollständig von der Abstimmung enthalten.\\n\\nAlle Referenden haben eine Verzögerung bei der Umsetzung. Dies ist der Zeitraum zwischen dem Ende des Referendums und der Umsetzung der Änderungen im Netzwerk, vorausgesetzt, das Referendum wurde genehmigt. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  Es gibt eine **Mindest**-Umsetzungsfrist, die speziell für jeden verschiedenen Typ von Ursprung festgelegt ist, aber der Urheber eines bestimmten Referendums kann die Aufgaben dieses spezifischen Referendums so einstellen, dass sie viele Blöcke in der Zukunft ausgeführt werden.\\n\\n</robo-wiki-note>\\n\\nReferenden gelten als \\\"gebacken\\\", wenn sie geschlossen sind und die Stimmen gezählt wurden. Wenn das Referendum genehmigt wurde, wird es zur Umsetzung im Netzwerk geplant (im Zeitplan der Ketten). Referenden gelten als \\\"ungebacken\\\", wenn das Ergebnis aussteht - zum Beispiel, wenn das Referendum noch abgestimmt wird.\\n\\nMit der Einführung von OpenGov kann jeder zu jeder Zeit ein Referendum starten und dies beliebig oft tun. OpenGov beseitigt die Beschränkung, dass nur 1 Referendum gleichzeitig verarbeitet werden kann (beachten Sie, dass in Gov v1 nur 1 Referendum gleichzeitig abgestimmt werden kann. Die einzige Ausnahme ist ein zusätzliches Notfall-Referendum des beschleunigten Technischen Ausschusses, das auch gleichzeitig von der Gemeinschaft abgestimmt werden kann).\\n\\nOpenGov führt mehrere neue Funktionen/Konzepte ein, die als Ursprünge und Tracks bekannt sind, und diese werden eingeführt, um den Fluss und die Verarbeitung von Referenden im Protokoll zu unterstützen.\\n\\nJeder Ursprung ist mit einer einzigen Referendumsklasse verbunden, und jede Klasse ist mit einem Track verbunden. Der Track umreißt den Lebenszyklus für das Referendum und ist spezifisch für den jeweiligen Ursprung, aus dem das Referendum stammt. Durch das Vorhandensein von Tracks mit ihren eigenen spezifischen Parametern kann das Netzwerk den Lebenszyklus von Referenden dynamisch modifizieren, basierend auf ihrem Privilegieniveau (Sie können sich das Privilegieniveau als die Stärke eines Referendums vorstellen / welche Arten von Änderungen es am Protokoll vornehmen kann).\\n\\n*Denken Sie an Ursprünge als die mit einem Referendum verbundene Macht und denken Sie an Tracks als die Abstimmungsparameter, wie die Länge der Perioden und die Kriterien für Zustimmung und Unterstützung.*\\n\\nEin Upgrade der Laufzeit hat zum Beispiel nicht die gleichen Auswirkungen auf das Protokoll wie ein kleiner Schatzmeistertipp, und daher sind unterschiedliche Ursprünge erforderlich, bei denen unterschiedliche Wahlbeteiligungen, Zustimmungen, Einlagen und Umsetzungszeiträume (Tracks) im Pallet der Ketten vorbestimmt werden.\\n\\n## Ein Referendum vorschlagen und den Lebenszyklus eines Referendums \\n\\n### Vorbereitungszeit\\n\\nIn OpenGov kann ein Referendum, sobald es erstellt wurde, sofort von der Token-Inhaber-Gemeinschaft abgestimmt werden. Es befindet sich jedoch nicht sofort in einem Zustand, in dem es beendet werden kann oder seine Stimmen gezählt, genehmigt und summarisch umgesetzt werden können. Stattdessen müssen Referenden eine Reihe von Kriterien erfüllen, bevor sie in den Entscheidungszeitraum überführt werden. Bis Referenden in den Entscheidungszeitraum eintreten, bleiben sie unentschieden und laufen schließlich nach dem insgesamt festgelegten Lebenszykluszeitraum in der jeweiligen Spur ab.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nDie Kriterien für ein Referendum, um in den Entscheidungszeitraum einzutreten, lauten wie folgt:\\n1. Eine Vorbereitungszeit, die angibt, wie viel Zeit vergehen muss, bevor der Entscheidungszeitraum beginnen kann. Diese Vorbereitungszeit soll das Risiko von \\\"Entscheidungsschnappschüssen\\\" mindern, bei denen ein Angreifer, der einen erheblichen Anteil an Abstimmungsmacht kontrolliert, versucht, seinen großen Anteil zu nutzen, um ein Referendum unmittelbar nach dem Vorschlag zu bestehen und so die Möglichkeit für die anderen Mitglieder des Token-Inhaber-DAO zu umgehen, angemessen Zeit für die Prüfung des Referendums und die Teilnahme an der Abstimmung zu haben. Deshalb haben Ursprünge mit höheren Privilegien erheblich längere Vorbereitungszeiten.\\n\\n2. Es muss Platz für die Entscheidung vorhanden sein. Jede Spur hat ihre eigenen Grenzen für die Anzahl der Referenden, die gleichzeitig entschieden werden können (max_deciding). Spuren mit höheren Privilegien haben niedrigere Grenzwerte. Zum Beispiel wird der Ursprung auf Root-Ebene im Vergleich zu Ursprüngen mit niedrigeren Privilegien wie dem Small Tipper-Ursprung eine deutlich geringere Anzahl von Referenden haben, die gleichzeitig entschieden werden können.\\n\\n3. Die Entscheidungseinlage muss eingereicht werden. Das Erstellen eines Referendums ist anfangs recht günstig, und der Wert der Einreichungseinlage (die bei der Erstellung des Referendums reserviert wird) ist recht niedrig und besteht hauptsächlich aus den Kosten für die On-Chain-Speicherung, die mit dem Referendum verbunden ist. Entscheidungseinlagen sind erheblich höher, was erforderlich ist, um Spam zu bekämpfen und in das wirtschaftliche Spiel einzusteigen, das OpenGov mit sich bringt, auf das wir später eingehen werden.\\n\\nSobald alle diese drei oben genannten Kriterien erfüllt sind, wird das Referendum in den Entscheidungszeitraum übergehen. Die Stimmen zum Referendum werden dann auf das Ergebnis gezählt.\\n\\n### Entscheidungszeitraum\\n\\n*Für eine schnelle Video-Demonstration des Entscheidungszeitraums siehe [dieses Video](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nSobald ein Referendum alle in dem oben beschriebenen Abschnitt detaillierten Kriterien erfüllt hat, tritt es in den Entscheidungszeitraum ein.\\n\\nDer Entscheidungszeitraum dreht sich um zwei Hauptkonzepte, nämlich die Zustimmungs- und Unterstützungskriterien. \\n\\nZustimmung wird definiert als der Anteil des Zustimmungsgewichts (JA gegen NEIN) im Vergleich zum Gesamtstimmgewicht (alle JA- und NEIN-Stimmen zusammen). Die Überzeugung jeder Stimme zählt zum Gesamtgewicht der JA/NEIN-Stimmen (mehr über Überzeugungsabstimmung / freiwillige Sperrung in einem späteren Abschnitt).\\n\\nUnterstützung ist die Gesamtzahl der Stimmen (Token), die an der Abstimmung teilgenommen haben (und wird nicht für Überzeugung angepasst) im Vergleich zur Gesamtzahl der möglichen Stimmen im System (denken Sie daran als die Gesamtausgabe von XRT auf der Parachain - beachten Sie, dass die Gesamtumlaufmenge von XRT hier nicht der Hauptfaktor ist, da ein Teil dieser Zahl als ERC-20-Token auf Ethereum existiert).\\n\\n**Stimmen, die in die ABSTAIN-Richtung gehen, tragen NICHT zu den Zustimmungskriterien bei, werden jedoch in die Unterstützungskriterien einbezogen / gezählt**\\n\\nEin Referendum muss während des Entscheidungszeitraums die Zustimmungs- UND Unterstützungskriterien erfüllen, um in den Bestätigungszeitraum überzugehen.\\n\\nFür Details zu den einzelnen Unterstützungs- und Zustimmungskriterien für jede Spur siehe diese [Tabelle](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Bestätigungszeitraum\\n\\nJede Spur hat eine eigene spezifische Dauer für ihren Bestätigungszeitraum. Spuren mit höheren Privilegien (wie Root) haben deutlich längere Bestätigungszeiträume als solche mit niedrigeren Privilegien (wie Small Tipper).\\n\\nReferenden müssen während der gesamten Dauer des Bestätigungszeitraums die Zustimmungs- und Unterstützungskriterien erfüllen, sonst gehen sie erneut in den Entscheidungszeitraum zurück (Hinweis: Der Entscheidungszeitraum wird während des Bestätigungszeitraums nicht angehalten, sodass es durchaus möglich ist, dass ein Entscheidungszeitraum während des Bestätigungszeitraums abläuft, was bedeutet, dass ein Referendum, das nicht mehr die Zustimmungs- und Unterstützungskriterien erfüllt, aus dem Bestätigungszeitraum herausgedrängt wird und dann als gescheitertes Referendum betrachtet und nicht umgesetzt wird).\\n\\n**Es ist möglich, die Genehmigungs- und Unterstützungskriterien für einzelne Tracks durch ein Referendum mit Root-Origin-Privilegien anzupassen.**\\n\\nUrsprünge mit niedrigeren Privilegien haben wesentlich einfachere Genehmigungs- und Unterstützungskriterien (festgelegt vom Track), die erfüllt werden müssen, als solche mit höheren Privilegien. Ebenso haben Ursprünge mit höheren Privilegien weniger steile Kurven als solche mit weniger Privilegien (wie im Track definiert), um sicherzustellen, dass das Token-Inhaber-DAO das Referendum tatsächlich genehmigt und Referendum-Sniping für Referenden mit hohem Privilegienursprung zu vermeiden.\\n\\nIn OpenGov werden Referenden, die nach Ablauf der Entscheidungsfrist nicht genehmigt werden, standardmäßig als abgelehnt betrachtet, und sowohl die Einreichungs- als auch die Entscheidungseinlagen werden an ihre Urheber zurückerstattet (Hinweis: Die Entscheidungseinlage kann von jemand anderem als dem Urheber des Referendums eingereicht werden).\\n\\nWenn ein Referendum während des gesamten Bestätigungszeitraums kontinuierlich die Genehmigungs- und Unterstützungskriterien erfüllt, gilt es als genehmigt und wird zur Ausführung vom vorgeschlagenen Ursprung geplant, aber das Referendum wird erst nach Ablauf der Mindestverkündungsfrist ausgeführt.\\n\\n### Verkündungsfrist\\n\\nDie Verkündungsfrist wird vom Urheber festgelegt, wenn das Referendum vorgeschlagen wird, unterliegt jedoch der Mindestverkündungsfrist, die in jedem Track festgelegt ist. Mächtigere Ursprünge haben eine viel längere Mindestverkündungsfrist als solche mit weniger Privilegien. Dies stellt sicher, dass das Netzwerk ausreichend Zeit hat, sich auf etwaige Änderungen vorzubereiten, die ein mächtiges Referendum verursachen kann.\\n\\n## Freiwillige Sperrung / Überzeugung\\n\\nRobonomics verwendet ein Konzept namens freiwillige Sperrung oder Überzeugungsabstimmung. Dadurch können Token-Inhaber ihre Stimmkraft erhöhen, indem sie festlegen, wie lange sie bereit sind, ihre Token für eine bestimmte Abstimmung zu sperren. Dieser Mechanismus betrifft nur die Zustimmungskriterien für jede Abstimmung, und die Überzeugungsabstimmung hat keinen Einfluss auf die Unterstützungskriterien.\\n\\nDie Überzeugungsabstimmung kann mit folgender Formel berechnet werden:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nIn dieser Tabelle sehen Sie, wie jede zunehmende Sperrdauer Ihre Stimme für die Zustimmungskriterien multipliziert:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nDie maximale Überzeugung, die ein Token-Inhaber verwenden kann, beträgt 6-fache Überzeugung. Sie können die Überzeugung nur gemäß der obigen Tabelle festlegen und beispielsweise keine 5,5-fache Überzeugung verwenden.\\n\\nWährend ein Token aufgrund einer Abstimmung gesperrt ist, kann es immer noch verwendet werden, um in anderen Abstimmungen abzustimmen. Es wird jedoch nicht Teil Ihres übertragbaren Guthabens sein (Sie können es nicht an ein anderes Konto senden) - und das Guthaben wird erst wieder übertragbar, wenn die gesamte Sperrdauer abgelaufen ist.\\n\\n## Stimmdelegation\\n\\nIn OpenGov wurde ein Mechanismus hinzugefügt, um Token-Inhabern, die möglicherweise nicht genügend Zeit haben, um jede Abstimmung zu überprüfen, dennoch zu ermöglichen, dass ihre Token Teil des Governance-Systems werden. Dies wird als Stimmdelegation bezeichnet.\\n\\nToken-Inhaber können wählen, ihre Stimmkraft einem anderen Wähler im System (einem anderen Konto) zu delegieren. Wähler können ihre Stimmkraft agil delegieren und ihre Stimmkraft für jeden einzelnen Ursprung einem anderen Konto zuweisen. Wähler können auch eine unterschiedliche Menge an Stimmkraft für jeden Ursprung (Anzahl der Token und Überzeugungsstufe) festlegen.\\n\\nDiese Delegationsfunktion hat ein Ziel: die Wahlbeteiligung zu erhöhen und sicherzustellen, dass die erforderlichen Beteiligungen zur Erfüllung der Zustimmungs- und Unterstützungskriterien erfüllt werden.\\n\\nUm Ihre Stimmkraft zu delegieren, können Sie die Funktion \\\"Delegieren\\\" verwenden, die Sie im Bereich Governance -> Abstimmung des [Robonomics-Portals](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer) finden können. Alternativ können Benutzer die convictionVoting(Delegate)-Extrinsik über den Bereich Entwickler -> Extrinsiken des Robonomics-Portals einreichen. Die Verwendung der \\\"Delegieren\\\"-Funktion des Abstimmungsbereichs des Portals ist jedoch viel einfacher.\\n\\n## Abbrechen / Beenden von Abstimmungen und das Governance-Wirtschaftsspiel\\n\\nIn OpenGov gibt es Ursprünge, die darauf abzielen, laufende Abstimmungen abzulehnen, unabhängig von ihrem Status. Diese werden als Governance Canceller und Governance Killer-Tracks bezeichnet.\\n\\nDiese Ursprünge greifen in eine bereits abgestimmte Abstimmung ein. Diese Ursprünge lehnen eine laufende Abstimmung sofort ab, unabhngig von ihrem Status, wenn die Abstimmung von ihnen stammt und genehmigt wurde. \\n\\nDie Stornierung selbst ist eine Art von Abstimmung, über die die Token-Inhaber abstimmen müssen, um ausgeführt zu werden. Die Stornierung hat ihren eigenen Ursprung und Track, die eine kürzere Vorlaufzeit (Entscheidungszeitraum usw.) haben und eine steilere Kurve für Zustimmung und Unterstützung aufweisen (dh ihre Kriterien im Laufe der Zeit viel einfacher zu erfüllen sind) als andere Ursprünge. Dies liegt daran, dass die Stornierung einer Abstimmung in der Regel mit einem gewissen Dringlichkeitsgefühl einhergeht.\\n\\nDas Ziel des Governance Canceller ist es, eine bereits laufende Abstimmung sofort abzulehnen. Wenn eine Abstimmung von diesem Ursprung abgebrochen wird, werden sowohl die Einreichungs- als auch die Entscheidungseinlage an ihre Urheber zurückerstattet. Ein Beispiel dafür, wann eine Abstimmung als abgebrochen betrachtet werden könnte, ist, wenn der Urheber einen menschlichen Fehler in den Inhalten seiner Abstimmung gemacht hat und nicht unbedingt etwas Böswilliges versucht hat.\\n\\nDas Ziel des Governance Killer ist es, eine bereits laufende Abstimmung sofort abzulehnen. Hier kommt das Governance-Wirtschaftsspiel ins Spiel. Ursprünge mit hohen Privilegien, wie Root, haben eine Entscheidungseinlage, für die eine hohe Menge an Kapital (XRT-Token) hinterlegt werden muss, damit die Abstimmung in den Entscheidungszeitraum eintritt. \\n\\nWenn ein bösartiger Akteur eine Abstimmung einreicht, z. B. eine Abstimmung mit Root-Ursprüngen, die darauf abzielt, den Laufzeitcode der Kette auf etwas zu setzen, das die Erzeugung von Blöcken stoppt, kann die Token-Inhaber-DAO eine Gegen-Governance-Killer-Abstimmung erheben, um diese Aktion zu bestrafen. Wenn die bösartige Abstimmung über den Governance Killer-Ursprung abgelehnt wird, werden sowohl die Einreichungs- als auch die Entscheidungseinlagen gekürzt, was bedeutet, dass der Urheber (die Konten, die diese Einlagen hinterlegt haben) diese Mittel verlieren wird. \\n\\nDies bedeutet, dass es für bösartige Akteure schwerwiegende wirtschaftliche Konsequenzen hat, eine Abstimmung zu erheben, die schwerwiegende negative Auswirkungen auf die Kette hätte, was in der Theorie jeden bösartigen Akteur davon abhalten wird, dies zu versuchen.\\n\\nDie Entscheidungseinlage für den Governance Killer-Track selbst ist ziemlich hoch, um zu verhindern, dass ebenso bösartige Akteure versuchen, Einlagen von ansonsten guten Referenden zu kürzen. **Ein bestehendes Governance Killer-Referendum kann durch ein nachfolgendes Governance Killer-Referendum beendet werden.**\\n\\n## Robonomics Technical Committee & Whitelisted Origin\\n\\nDiese Gruppe ist ein selbstverwaltendes Expertengremium, das das Hauptziel hat, Menschen zu repräsentieren, die das technische Wissen des Robonomics-Netzwerkprotokolls verkörpern und besitzen. \\n\\nDiese Gruppe (und nur diese Gruppe) ist in der Lage, Referenden aus dem Whitelist-Paket zu initiieren. Dieses Paket erlaubt es einem Ursprung, das Privilegenniveau eines anderen Ursprungs für eine bestimmte Operation zu eskalieren. \\n\\nDiese Gruppe kann Referenden von einem Ursprung namens Whitelisted-Root autorisieren, und diese Referenden können mit Root-Level-Privilegien ausgeführt werden, aber diese Referenden funktionieren nur erfolgreich mit bestimmten spezifizierten Befehlen, die von der Gruppe autorisiert wurden. Das Whitelist-Paket überprüft zwei Dinge:\\n1. Der Ursprung ist wirklich der Whitelisted-Root (d.h. das Referendum wurde durch den Track dieses Ursprungs geleitet).\\n2. Der Vorschlag wurde tatsächlich von der Gruppe auf die Whitelist gesetzt.\\n\\nWenn beide Bedingungen erfüllt sind, wird die Operation mit Root-Level-Privilegien ausgeführt.\\n\\nDieses System ermöglicht die Möglichkeit, einen neuen parallelen Track (Whitelisted-Root Origin) zu haben, dessen Parameter eine kürzere Abstimmungsdauer ermöglichen (Genehmigungs- und Unterstützungskriterien sind etwas einfacher zu erfüllen als Root). Dieser offene und transparente Prozess ermöglicht es diesem Expertengremium für das Robonomics Network Protocol, Referenden vorzuschlagen, die sie als sicher und zeitkritisch erachtet haben.\\n\\nEs sollte beachtet werden, dass die Unterstützungskriterien für Referenden, die mit dem Whitelisted-Root-Ursprung initiiert wurden, nicht wie bei vielen anderen Ursprüngen/Tracks gegen 0 tendieren. Dies stellt sicher, dass diese Gruppe nicht die Kontrolle über das gesamte Robonomics Network Protocol hat und erfordert ein Mindestmaß an Unterstützung (Wählerbeteiligung) von den Gesamt-Token-Inhabern.\\n\\n\\n## Referendumsdauern \\n\\nEs ist wichtig zu verstehen, dass die Dauer jedes einzelnen Referendums keine feste Sache ist, sie ist nicht in Stein gemeißelt. Einige Perioden im Lebenszyklus des Referendums, wie die Mindestumsetzungsfrist, haben tatsächlich eine feste Dauer, andere, einschließlich der Entscheidungsfrist, nicht. Es ist zum Beispiel nicht korrekt, die maximalen Dauern für die Vorbereitungs-, Entscheidungs-, Bestätigungs- und Mindestumsetzungsperioden zusammenzurechnen und zu sagen, dass \\\"jedes Referendum X Tage dauern wird\\\", es ist viel fließender als das.\\n\\nBetrachten wir dies aus der Perspektive einiger separater Referenden, die alle vom selben Ursprung stammen, in diesem Fall dem Root-Ursprung. \\n\\nDer Root-Ursprung hat seinen eigenen Track, in dem die Dauern für jede Periode festgelegt sind, sowie die Genehmigungs- und Unterstützungskurven.\\n\\nEs ist wichtig zu bedenken, dass Referenden nur dann in die nächste Phase ihres Lebenszyklus übergehen, wenn bestimmte Bedingungen erfüllt sind. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nSie sollten davon ausgehen, dass in den folgenden Abbildungen die Bedingungen, wie sie im obigen Bild beschrieben sind, erfüllt sein müssten, damit ein Referendum in die nächste Phase seines Lebenszyklus übergeht (sofern nicht anders angegeben).\\n\\n\\n### Maximale mögliche Dauer bei sehr geringer Wählerbeteiligung\\n\\nDas folgende Bild ist eine Darstellung des maximal möglichen Zeitplans für ein Referendum. Denken Sie dabei an ein Referendum, das:\\n1. Seine Entscheidungseinlage hinterlegt hat und daher in die Entscheidungsphase eingetreten ist.\\n2. Eine einzige Stimme hat, zum Beispiel 1 XRT, in Richtung AYE - dies bedeutet, dass es die erforderliche Unterstützung (Wählerbeteiligung) erst am Ende der Entscheidungsphase erreichen wird (da die Gesamtunterstützung extrem niedrig ist), aber 100% Zustimmung hat und daher letztendlich die Anforderungen für den Eintritt in die Bestätigungsphase erfüllen wird.\\n3. Während der Bestätigungsphase weiterhin die oben genannten Kriterien erfüllt.\\n4. Der von dem Referendum vorgeschlagene Vorschlag wird genau im selben Block umgesetzt, in dem die Mindestumsetzungsfrist endet - technisch gesehen kann der Initiator des Referendums die Netzwerkänderungen, wie sie im Referendum detailliert sind, viele Blöcke in die Zukunft setzen, sodass der tatsächliche Lebenszyklus eines einzelnen Referendums über viele Tage, Wochen, Monate oder Jahre hinweg reichen könnte.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nWir können sehen, dass in diesem Beispiel der Lebenszyklus des Referendums (ungefähr) 17 Tage betragen würde.\\n\\n\\n### Dauer mit hoher Wählerbeteiligung (mit einer großen Anzahl von AYE-Stimmen)\\n\\nSchauen wir uns nun ein Referendum an, bei dem das XRT-Token-Inhaber-DAO großes Interesse gezeigt hat. In diesem Beispiel nehmen wir an, dass insgesamt ~248.771 XRT an Wählerbeteiligung stattgefunden hat und alle Wähler in Richtung AYE abstimmen (Hinweis: Technisch gesehen müssen zu diesem Zeitpunkt gemäß der Strecke nur 60% der Stimmen in Richtung AYE sein, damit ein Referendum die Zustimmungskriterien erfüllt).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Konsultieren Sie immer die aktuellsten Informationen zur Strecke, um genaue Informationen zu jeder Strecke zu erhalten. Weitere Informationen finden Sie in diesem [Spreadsheet](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nIn diesem Beispiel:\\n1. Die Entscheidungseinlage wurde während der Vorbereitungsphase veröffentlicht und konnte daher am Ende der Vorbereitungsphase in die Entscheidungsphase übergehen.\\n2. Viele Wähler haben an diesem Referendum teilgenommen und in relativ kurzer Zeit eine Wahlbeteiligung von ~248.771 XRT erreicht.\\n3. Die Mehrheit der Stimmen war in Richtung AYE (mehr als 60% AYE).\\n4. Das Referendum erfüllt während seiner gesamten Bestätigungsphase kontinuierlich die Kriterien der Bestätigungsphase (Hinweis: Wenn ein Referendum die Kriterien der Bestätigungsphase nicht mehr erfüllt, wird es zurück in die Entscheidungsphase versetzt).\\n5. Der vom Referendum vorgeschlagene Vorschlag wird genau im selben Block umgesetzt, in dem die Mindestumsetzungsfrist endet.\\n\\nAufgrund der Tatsache, dass eine Wahlbeteiligung von ~248.771 XRT stattgefunden hat, erfüllt das Referendum die Kriterien, um nach ~168 Stunden (7 Tage) in seine Bestätigungsphase einzutreten.\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nWir können sehen, dass in diesem zweiten Beispiel aufgrund der relativ hohen Wahlbeteiligung die Entscheidungsphase tatsächlich zur Hälfte ihrer maximalen Zeit endete. Dies führt zu einem Referendum, das in ~10 Tagen umgesetzt werden kann.\\n\\n\\n### Dauer, wenn die Entscheidungseinlage nie veröffentlicht wird\\n\\nSchauen wir uns nun ein Referendum an, das zwar gestartet wurde, aber nie seine Entscheidungseinlage veröffentlicht hat. Solche Referenden befinden sich in einer Art \\\"Schwebezustand\\\", in dem ihre Vorbereitungsphase abgelaufen ist, aber da die Entscheidungseinlage nicht veröffentlicht wurde, bleibt das Referendum im \\\"Vorbereitungsstatus\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nWir können sehen, dass in diesem dritten Beispiel aufgrund der Tatsache, dass die Entscheidungseinlage nie veröffentlicht wurde, das Referendum tatsächlich nie in die Entscheidungsphase eintreten wird, sondern im \\\"Vorbereitungsstatus\\\" bleibt. Dies bedeutet, dass das Referendum schließlich, wenn keine Entscheidungseinlage veröffentlicht wird, nach Ablauf der in der Konstante timeOut des Paletts angegebenen Dauer abläuft.\\n\\nDies ist auf Kusama bereits zuvor passiert, als ein Referendum mit Root-Ursprung veröffentlicht wurde, aber aufgrund der hohen Kapitalanforderungen zur Veröffentlichung der Entscheidungseinlage das Referendum nie in die späteren Phasen seines Lebenszyklus eingetreten ist. Solche Referenden enden mit der Kennzeichnung \\\"abgelaufen\\\".\\n\\n\\n### Dauer, wenn die Entscheidungseinlage spät veröffentlicht wird\\n\\nSchließlich werfen wir einen Blick auf ein Beispiel, bei dem die Entscheidungseinlage erst lange Zeit nach der Entstehung des Referendums veröffentlicht wurde. Dies ist auf Kusama bereits zuvor passiert, als ein Referendum mit Root-Ursprung veröffentlicht wurde, aber der Urheber Zeit benötigte, um jemanden mit einer großen Menge Kapital zu finden, der die Entscheidungseinlage stellvertretend veröffentlicht.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nIn diesem letzten Beispiel ist aufgrund der Tatsache, dass die Entscheidungseinlage nach Ablauf der Vorbereitungsphase, aber vor Ablauf des Referendums veröffentlicht wurde, der Lebenszyklus des Referendums tatsächlich viel länger als normal, da es nach einer längeren Zeit in die Entscheidungsphase eintritt.\\n\\nEs ist wichtig zu beachten, dass das Token-Inhaber-DAO in der Lage ist, in der Vorbereitungsphase oder im \\\"Vorbereitungsstatus\\\" über Referenden mit AYE/NAY abzustimmen.\\n\"}},{\"node\":{\"id\":\"6424ab17afb5889dd2741e6226606028\",\"title\":\"Robonomics auf Ethereum\",\"path\":\"/docs/de/robonomics-ethereum/\",\"content\":\"\\nAlle Informationen über Robonomics auf Ethereum wurden in das GitHub-Repository verschoben. Alle erforderlichen Informationen können [hier gefunden werden.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"6ee8d086b5f1bbd3871a01437013c2ea\",\"title\":\"Python-Schnittstelle und Robonomics IO\",\"path\":\"/docs/de/rinterface/\",\"content\":\"\\n**Einige Extrinsiken, die in Robonomics-Paletten implementiert sind, können nicht über die Polkadot-App übermittelt werden. Darüber hinaus besteht \\ndie Notwendigkeit, mithilfe von Programmiersprachen mit dieser Funktionalität zu interagieren. Zu diesem Zweck wurde ein einfaches Python-Tool entwickelt\\nnamens [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface). Es ist ein Wrapper über Polkascan-gepflegt\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface).Nachfolgend finden Sie eine kurze Beschreibung dieses Pakets\\nund einige nützliche Links und Beispiele. Auch CLI-Tools werden diskutiert.**\\n\\n## robonomics-interface\\n\\nAuf [PyPi](https://pypi.org/project/robonomics-interface/) steht ein Paket zum Download und zur Einrichtung bereit.\\nEs gibt auch eine detaillierte durch Docstring generierte [Dokumentation](https://multi-agent-io.github.io/robonomics-interface/) zur Verfügung.\\n\\nAlles in allem handelt es sich um ein Werkzeug für Entwickler, die über Programmierungstools mit der Robonomics-Blockchain interagieren möchten. Fast \\nalle Python-Projekte des Robonomics-Teams, die mit der Parachain interagieren, verwenden diese Schnittstelle.\\n\\n### Installieren\\n\\nDer Installationsprozess erfordert, dass der Benutzer mindestens Python 3.8 installiert hat. Weder `x86`, noch `arm7`, noch `arm8`\\nArchitekturen erfordern einen Kompilierungsprozess. Alle Wheels werden von den Abhängigkeitsverwaltern erstellt und veröffentlicht.\\n\\n`pip` wird als Installationswerkzeug verwendet:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Beispielverwendung\\n\\nDie Hauptidee besteht darin, eine `Account`-Instanz zu erstellen und sie dann zu verwenden, um palettenbezogene Instanzen zu erstellen.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  Es ist auch möglich, benutzerdefinierte Endpunkte zu verwenden (z. B. einen lokalen Knoten zum Testen):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nExtrinsiken können ebenfalls übermittelt werden:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  Wie bereits erwähnt, sind weitere Beispiele auf der [Dokumentationsseite](https://multi-agent-io.github.io/robonomics-interface/) verfügbar.\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` enthält auch ein Python `click` CLI-Tool, das für Prototyping und schnelle Tests verwendet werden kann. Es wird\\nmit dem Paket installiert und im Terminal verfügbar:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nSie können es mit einem lokalen Knoten ausprobieren. Die Pipeline-Philosophie wird übernommen:\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"b49cbcd00d5d783c2d45fc726c0a1413\",\"title\":\"PTZ-Kamerasteuerung in Home Assistant\",\"path\":\"/docs/de/ptz-camera/\",\"content\":\"\\nDieser Artikel behandelt den Prozess der Einrichtung einer PTZ-Kamera in Home Assistant. \\nEs wird das ONVIF-Protokoll verwendet. Dafür wird ein lokales Kamerakonto benötigt.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nDer Prozess zur Einrichtung des lokalen Kamerakontos wird in diesem Artikel nicht behandelt.\\n</robo-wiki-note>\\n\\nAnforderungen:\\n- PTZ-Kamera\\n- Lokales Kamerakonto\\n- Kamera-IP-Adresse\\n- Konfiguriertes Home Assistant\\n\\n## ONVIF-Integration\\n\\nBeginnen wir mit der Installation der **ONVIF-Integration**. \\n\\nGehe zu \\\"Devices & Services\\\" in den \\\"Settings\\\" und drücke den \\\"ADD INTEGRATION\\\"-Button.\\nGib \\\"ONVIF\\\" ein und wähle die Integration aus. Du wirst das nächste Fenster sehen.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nDrücke den \\\"Sudmit\\\"-Button. Es wird versuchen, automatisch nach deiner Kamera zu suchen. Wenn erfolgreich, \\nwähle deine Kamera aus der Liste aus und fülle leere Felder aus. \\nAndernfalls musst du alle Felder manuell ausfüllen. Du wirst das folgende Fenster sehen.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nFülle die Lücken aus:\\n- Name - gib deiner Kamera einen Namen\\n- Host - gib die IP-Adresse deiner Kamera an\\n- Port - meistens ist es 2020, aber dein Kamerahersteller kann es ändern\\n- Username - schreibe den Benutzernamen deines Kamera-Lokalkontos\\n  - Password - schreibe ein Passwort für dein Kamera-Lokalkonto\\n\\nund drücke \\\"Sudmit\\\". Wähle einen Bereich für deine Kamera aus und klicke auf \\\"Finish\\\".\\n\\n## Füge die Kamerasteuerung zum Dashboard hinzu\\n\\nJetzt, da du die Kamera vollständig eingerichtet hast, kannst du ihren Stream und die Steuerungstasten zum Dashboard hinzufügen.\\n\\nGehe zum Dashboard und erstelle eine neue Karte. Wähle die \\\"Picture Glance\\\" aus.\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nFülle die Daten aus:\\n- Title - wähle einen Titel für das Kamerabild\\n- Camera Entity - wähle eine Kamera-Entität aus der Dropdown-Liste\\n- Camera View - wähle \\\"live\\\", um weniger Verzögerung zu erhalten\\n\\nWechsle dann in den \\\"Code-Editor\\\"-Modus, indem du den Button unten links drückst. Du wirst den folgenden Code sehen:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nErsetze den Inhalt von `entities: []` gemäß dem folgenden Beispiel (`<DEINE_KAMERA_ENTITÄT>` entspricht dem `camera_image`-Parameter):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nDas ist alles. Jetzt solltest du die PTZ-Kamerakarte auf dem Dashboard zusammen mit den Steuerungstasten sehen..\\n\\n## Fehlerbehebung\\nWenn Sie Home Assistant Core verwenden und keinen Stream von der Kamera sehen, sollten Sie die Integrationen \\\"stream\\\" und \\\"FFMPEG\\\" installieren. \\nUm dies zu tun, solltest du die Zeichenfolgen `stream: ` und `ffmpeg: ` am Ende der configuration.yaml hinzufügen.\"}},{\"node\":{\"id\":\"ec230e22ecc8f9345fcf1822b3b8058a\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/de/notifications/\",\"content\":\"\\nSie können Benachrichtigungen auf Ihrem Smartphone mit [notify](https://notify.events/) erhalten. Registrieren Sie sich zunächst dort und erstellen Sie auf dem `Control Panel` einen neuen Kanal:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nGeben Sie einen Titel ein und klicken Sie auf `Save`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nKlicken Sie dann auf `Add Source` und wählen Sie `Home Assistant` im Tab `IoT and Smart Home` aus:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nGeben Sie einen Titel ein und klicken Sie auf `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nDort sehen Sie den Token, den Sie zu Ihrer Konfigurationsdatei für Home Assistant hinzufügen müssen. Speichern Sie ihn an einem sicheren Ort und klicken Sie auf `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nKlicken Sie dann auf `Subscribe`, um Abonnenten hinzuzufügen:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nWählen Sie den gewünschten Abonnenten aus und befolgen Sie die Anweisungen.\\n\\nJetzt müssen Sie die Konfiguration auf Ihrem Computer mit Home Assistant bearbeiten. Öffnen Sie unter dem Benutzer `homeassistant` die Datei `configuration.yaml`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nFügen Sie diese Zeilen hinzu:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nFügen Sie auch nach der Zeile `automation:` eine neue Automatisierung hinzu:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nDiese Automatisierung sendet die Nachricht `Door was changed to on/off`, nachdem sich der Sensor mit der Entitäts-ID `binary_sensor.contact_sensor_contact` vom Zustand `off` auf `on` geändert hat.\\n\\nUnd starten Sie Home Assistant neu:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"e4c520102fa629185ec7e0f2d008fb5f\",\"title\":\"Haftung\",\"path\":\"/docs/de/liability/\",\"content\":\"\\n**Um Roboter zu wirtschaftlichen Akteuren zu machen, benötigt man ein Vertragstool dafür. Hier ist Haftung - Robonomics-Palette, die Verträge zwischen Parachain-Konten implementiert!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Bitte beachten Sie, dass dieses Tutorial auf einer lokalen Instanz von Robonomics Node demonstriert wird. Richten Sie Ihre eigene mit [diesen Anweisungen](/docs/run-dev-node) ein.\\n\\n</robo-wiki-note>\\n\\n## Theorieüberblick\\n\\nAuf Ethereum gab es eine ziemlich komplizierte Struktur der Haftungsinteraktion. Sie können sich [hier](/docs/robonomics-how-it-works) damit vertraut machen. Heutzutage ist es mit Kusama etwas einfacher!\\n\\n### Verhandlungen\\n\\nUm einen Vertrag zu unterzeichnen, müssen die beiden Seiten zunächst verhandeln. Dies kann auf verschiedene Weise erfolgen, einschließlich [IPFS PubSub ](https://blog.ipfs.tech/25-pubsub/) oder Robonomics PubSub. Ein Beispiel für Python-Code mit Robonomics PubSub wird [hier] vorgestellt (https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub).\\n\\nAngebot und Nachfrage sind Nachrichten, die zwei Hauptmerkmale eines Vertrags enthalten: **Jobbeschreibung** und **Preis**. Das Nachrichtenformat muss vom Benutzer für jede spezifische Anwendung entworfen werden. Es ist nicht so wichtig, im Verhandlungsprozess eine strikte Formatregel zu befolgen. Der mögliche Ablauf wird im folgenden Bild dargestellt.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Beachten Sie, dass PubSub ein offenes Protokoll ist, daher sollten keine sensiblen Daten übertragen werden. Dafür sollten Sie andere Protokolle verwenden.\\n\\n</robo-wiki-note>\\n\\n\\n### Signaturen\\n\\nWhen negotiations are successfully over, each side needs to sign its so-called agreement named a signature. This is a message containing job description and price **in a specific format** signed with a private key of the Konto brauchen. \\nAuch dafür gibt es ein [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability).\\n - Die Jobbeschreibung wird als **Technik** bezeichnet. Dies ist ein 32 Byte langer String, der wie ein IPFS CID codiert sein kann.\\n - Der Preis wird als **Wirtschaft** bezeichnet. Dies ist eine XRT-Dezimalzahl - Weiner. 1 Weiner = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Mit der [Python-Bibliothek](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) kann man einen IPFS CID in einem geeigneten Format erhalten.\\n  Bei Verwendung der Funktion `sign_liability` ist keine Transformation des Hash-Werts erforderlich, dies wird automatisch erledigt.\\n\\n</robo-wiki-note>\\n\\nNachfolgend das Beispiel mit Kaffee:\\n\\n1. Die Aufgabe ist ein JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Der IPFS CID lautet `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. Die **Technik** (transformierter CID) lautet also `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **Wirtschaft** beträgt `1,5 XRT`.\\n\\nWenn es unterschrieben ist, ist es an der Zeit, eine Haftung zu erstellen! Dies kann von einer der Seiten (entweder dem Versprechenden oder dem Verpflichteten) oder von einem Drittkonto eines sogenannten Anbieters durchgeführt werden.\\n\\n## Haftung erstellen\\n\\n### Vorbereitungen\\n\\nWie bereits erwähnt, sind mindestens zwei Seiten am Prozess beteiligt. Für dieses Beispiel verwenden wir drei und machen einen separaten Anbieter dafür. Nehmen Sie an, dass die Verhandlungen bereits irgendwie stattgefunden haben.\\n\\n### 1. Erstellen Sie drei Konten und fügen Sie ihnen Geld hinzu\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nHier haben wir dem Anbieter 100 XRT zur Unterzeichnung von Haftungsextrinsiken zur Verfügung gestellt, dem Verpflichteten wurden 2 XRT gegeben, um für die Arbeit zu bezahlen.\\nDem Versprechenden wurden keine Geldmittel gewährt (außer einer existenziellen Einzahlung von mindestens 1 mXRT).\\n\\n### 1. Navigieren Sie zu Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Wählen Sie liability -> create aus der Dropdown-Liste der möglichen Extrinsiken\\n\\nWählen Sie auch ein Konto aus, mit dem Sie das Extrinsische einreichen möchten. Füllen Sie alle Parameter aus.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signaturen\\\">\\n\\n  Da hier ein Anbieter verwendet wird, müssen die Seeds der Teilnehmer nicht bekannt sein. Es werden nur ihre Signaturen benötigt.\\n\\n</robo-wiki-note>\\n\\n### 3. Übermitteln Sie die Transaktion\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Überprüfen Sie Ihre Haftung in den Ereignissen\\n\\nHierzu navigieren Sie zu `Network -> Explorer` und finden eine Liste der Ereignisse auf der rechten Seite. Klicken Sie auf ein Dreieckssymbol, um es zu erweitern.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  Der Hash kann mit demselben [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash) in eine IPFS-CID umgewandelt werden.\\n\\n</robo-wiki-note>\\n\\n### 5. Speichererkundung\\n\\nSie können auch einige Merkmale der Haftungen im Speichermodul `liability` erkunden.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  Die Speicherfunktion `Next Index` zeigt den neuesten Haftungsindex +1 an, daher wird auch dann, wenn er `1` ist, Haftung `0` erkundet.\\n\\n</robo-wiki-note>\\n\\n## Berichte\\n\\nStellen Sie sich vor, dass ein Kaffee zubereitet wurde und die Kaffeemaschine ihn irgendwie melden muss. Hier kommen Haftungsberichte ins Spiel. Als Arbeitsnachweis fügt das Konto einen weiteren IPFS CID als Berichtsinhalt hinzu, wenn die bestehende Haftung abgeschlossen wird. Dafür ist erneut eine Unterschrift des Verpflichteten erforderlich.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  Die signierte Nachricht enthält den vorhandenen Haftungsindex und die IPFS CID des Berichts, die in einer 32-Byte-Darstellung codiert sind. Noch einmal, das [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) kann helfen, den Bericht zu signieren.\\n\\n</robo-wiki-note>\\n\\nIm Beispiel mit der Kaffeemaschine:\\n\\n1. Der Bericht ist ein JSON.\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Seine IPFS CID lautet `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`.\\n3. Die **Nutzlast** (transformierte CID) ist also „0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2“.\\n4. **Index** ist `0`, es handelt sich um den vorhandenen Haftungsindex.\\n\\n### 1. Navigieren Sie zu Extrinsics, Haftung -> abschließen(Bericht).\\n\\nGeben Sie die Parameter ein und senden Sie extrinsisch. Auch dies kann über ein Drittanbieterkonto erfolgen.\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Beachten Sie, dass das Versprechenskonto nicht \\\"tot\\\" sein darf - es sollte eine Existenzablagerung von mindestens 1 mXRT haben.\\n\\n</robo-wiki-note>\\n\\nDen Bericht signieren und einreichen. Wenn Sie fertig sind, können Sie ihn in den Ereignissen erkunden.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Berichte erkunden\\n\\nSie können den Bericht auch im Speicher beobachten. Gehen Sie zu `Developer -> Storage` und wählen Sie `liability` aus der Dropdown-Liste.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Kontostände überprüfen\\n\\nAuf dem Bild ist zu sehen, dass der Versprecher jetzt das \\\"Gehalt\\\" erhalten hat. Die wirtschaftliche Beziehung ist entstanden!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  Derzeit gibt es keine Möglichkeit, die erledigte Arbeit zu überprüfen, daher werden die Token sofort auf das Konto des Versprechers übertragen, sobald dieser berichtet. \\n  Die Überprüfungsfunktion wird in Zukunft hinzugefügt werden.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"8ebf0dbdedbcd4fe47a1d2743273afa8\",\"title\":\"Start\",\"path\":\"/docs/de/launch/\",\"content\":\"\\n**Eine weitere grundlegende Funktion der Robonomics-Parachain ist das Start-Paket. Es ermöglicht Ihnen, Befehle an die Konten/Entitäten dahinter zu senden. Diese Befehle enthalten Parameter, um die auszuführende Aufgabe zu spezifizieren.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Bitte beachten Sie, dass diese und die folgenden Anleitungen an einer lokalen Instanz des Robonomics-Knotens demonstriert werden. Richten Sie Ihren eigenen mit [diesen Anweisungen](/docs/run-dev-node) ein.\\n\\n</robo-wiki-note>\\n\\n## 1. Navigieren Sie zu Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Wählen Sie launch -> launch Sie aus der Dropdown-Liste der möglichen Extrinsischen Funktionen\\n\\nWählen Sie auch ein Konto aus, mit dem Sie das Extrinsische senden möchten. Füllen Sie das Zielfeld und das Parameterfeld aus.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Launch unterstützt 32 Byte lange Zeichenfolgen als Befehle ([Quelle](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)), Hier gibt es also Raum zum Improvisieren:\\n  - Für grundlegende Befehle wie das Umschalten können Sie „0x00000000000000000000000000000000000000000000000000000000000000001“ oder verwenden „0x000000000000000000000000000000000000000000000000000000000000000“.\\n  – Für erweiterte Befehle, einschließlich JSON-ähnlicher Befehle, können Sie [IPFS](https://ipfs.tech/) CID im Format a verwenden\\n  [richtiger Weg](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Übermitteln Sie die Transaktion\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Überprüfen Sie Ihren Start in den Ereignissen\\n\\nDazu navigieren Sie zu *Network -> Explorer* und finden eine Liste der Ereignisse auf der rechten Seite. Klicken Sie auf ein Dreieckssymbol, um es zu erweitern.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"2db61e69a7dd1811a74dadd083be685b\",\"title\":\"Wie man die Robonomics Collator Node Version aktualisiert\",\"path\":\"/docs/de/how-to-update-collator-node-version/\",\"content\":\"\\nEs wird empfohlen, vor dem Lesen dieses Beitrags die folgenden Artikel gelesen zu haben: [\\\"Wie man Collator Node erstellt\\\"](/docs/how-to-build-collator-node) & [\\\"Wie man den Robonomics Collator startet\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nDieser Artikel enthält die Befehle, die zum Aktualisieren einer Robonomics Collator Node (unter Ubuntu) erforderlich sind, und gibt anschließend ein Beispiel.\\n\\n## **Erforderliche Befehle**\\n\\n0. Bevor Sie beginnen, wird empfohlen, dass Sie als `root` angemeldet sind. Wenn nicht, empfehle ich Ihnen, folgendes zu verwenden:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Stoppen Sie den Robonomics-Dienst:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Entfernen Sie die vorherige Version von Robonomics (stellen Sie sicher, dass Sie sich im richtigen Verzeichnis befinden):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Holen Sie sich die [neueste Version](https://github.com/airalab/robonomics/releases) von Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Extrahieren Sie die Datei:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Verschieben Sie die Datei:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nSie müssen diese Datei in das richtige Verzeichnis verschieben, in dem Sie die Robonomics-Node installiert haben)\\n\\n</robo-wiki-note>\\n\\n6. Starten Sie Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nBeispiel zum Aktualisieren der Collator Node auf Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Ändern der Kusama Relay Chain-Datenbank ohne festgelegten Basispfad**\\n\\nEs gibt Zeiten, in denen bestimmte Snapshots der Kusama Relay Chain dazu führen, dass Ihre Node Fehler aufweist. Dies führt oft dazu, dass Ihre Node nicht mehr funktioniert. Beispiel für einen Fehler, der durch eine beschädigte Relay Chain-Datenbank verursacht wird:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nUm diesen Fehler zu beheben, sollten Sie Ihre vorhandene Kusama Relay Chain-Datenbank (wahrscheinlich RocksDb) entfernen und durch eine andere Db wie ParityDb ersetzen. Führen Sie die folgenden Befehle aus:\\n\\n1. Finden Sie das Verzeichnis der Robonomics-Node und überprüfen Sie die Dateien:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Bestätigen Sie, dass Sie das polkadot-Verzeichnis sehen, und navigieren Sie dann zum chains-Verzeichnis:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Löschen Sie das Verzeichnis `ksmcc3`:\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Erstellen Sie ein neues `ksmcc3`-Verzeichnis.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Jetzt müssen Sie einen neuen Snapshot herunterladen. In diesem Beispiel wird ein stark beschnittener Relay Chain-Snapshot verwendet, aber Sie können ihn gegen einen beliebigen Snapshot austauschen, den Sie bevorzugen.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Während der Snapshot heruntergeladen wird, öffnen Sie eine neue Sitzung und bearbeiten Sie Ihre Service-Datei:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nÄndern Sie Zeilen in der Service-Datei, die sich auf die Datenbank und das Beschneiden beziehen:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nVerwenden Sie `Strg + S` und dann `Strg + X`, um die Service-Datei zu speichern und zu verlassen.\\n\\n7. Jetzt müssen Sie Ihren Daemon neu laden.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. Zu diesem Zeitpunkt sollte in Ihrer anderen Sitzung hoffentlich die neue Db heruntergeladen worden sein, also extrahieren Sie die Datei:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. Nach Abschluss des Entpackens führen Sie Folgendes aus:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Jetzt können Sie den Dienst starten, ihn auf Fehler überwachen und überprüfen, ob er sowohl mit der Relay Chain als auch mit der Parachain verbunden ist:\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"3c10eaec1e73e003b5b9f7e9f8ddffb9\",\"title\":\"Wie man den Robonomics-Collator startet\",\"path\":\"/docs/de/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  In der Screencast und den Screenshots dieses Artikels haben wir Version 1.4.0 von Robonomics verwendet. Sie müssen dieselben Befehle verwenden, aber die Version von Robonomics durch die aktuelle ersetzen.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nDerzeit wird das Robonomics-Netzwerk hauptsächlich von den ursprünglichen Entwicklern gewartet, aber jeder kann das Projekt unterstützen. Jeder zusätzliche Vollknoten der Blockchain trägt dazu bei, dass sie nachhaltiger und fehlertoleranter wird. Robonomics-Knoten-Binärdateien sind in [Release](https://github.com/airalab/robonomics/releases) Assets verfügbar oder können aus dem Quellcode erstellt werden (/docs/how-to-build-collator-node/).\\n\\n## Was ist ein Collator\\n\\nEin Collator ist Teil der Robonomics-Parachain. Diese Art von Knoten erstellt neue Blöcke für die Robonomics-Kette.\\n\\n>Collators pflegen Parachains, indem sie Parachain-Transaktionen von Benutzern sammeln und Zustandsübergangsproben für Relay Chain-Validatoren erstellen. Mit anderen Worten, Collators pflegen Parachains, indem sie Parachain-Transaktionen zu Parachain-Blockkandidaten aggregieren und Zustandsübergangsproben für Validatoren basierend auf diesen Blöcken erstellen.\\n\\nWeitere Informationen zu Collatoren finden Sie auf der entsprechenden [Polkadot-Wiki-Seite](https://wiki.polkadot.network/docs/learn-collator).\\n\\nIn der Robonomics-Parachain erhält jeder Collator eine Belohnung von (**0,001598184 XRT**) für jeden Block, den der Collator erstellt (Belohnungen treten auf, wenn Blöcke an die Kette gebunden werden).\\nAuch der Collator, der den Block erstellt, erhält **50% der Transaktionsgebühren**, die sich im von ihnen erstellten Block befinden.\\n\\n## Anforderungen\\n\\nEs wird empfohlen, einen Collator mit den **Standard-Hardwareanforderungen** für [Polkadot-Validatoren](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware) zu starten:\\n+ x86-64 kompatibel.\\n+ Intel Ice Lake oder neuer (Xeon oder Core-Serie); AMD Zen3 oder neuer (EPYC oder Ryzen).\\n+ 4 physische Kerne @ 3,4 GHz.\\n+ Simultaneous Multithreading deaktiviert (Hyper-Threading bei Intel, SMT bei AMD).\\n+ Speicher - Eine NVMe-SSD mit 1 TB (da sie vernünftig dimensioniert sein sollte, um mit dem Wachstum der Blockchain umzugehen).\\n+ Speicher - 32 GB DDR4 ECC\\n\\n\\nIn diesem Artikel verwenden wir folgende Spezifikationen:\\n+ 4 vCPU\\n+ 700 GB NVMe-Speicherplatz für die Datenbanken des Collators. Die Möglichkeit, diesen Festplattenspeicher zu erweitern, ist erforderlich.\\n+ 8 GB RAM\\n\\n\\n## Wichtige Informationen\\n1. Wir verwenden einige Variablen in diesen Anweisungen, und Sie müssen die Werte in allen Befehlen durch Ihre eigenen ersetzen:\\n    + **%NODE_NAME%** ist der Knotenname. Beispiel: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** ist der Pfad zum eingebundenen Volume. Beispiel: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** ist die Kontoadresse im Polkadot-Ökosystem im SS58-Format. Beispiel: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Beachten Sie, dass Sie *--state-cache-size=0* in den Start des Collator-Dienstes aufnehmen müssen. Dieser Parameter ist wichtig für die Stabilität des Collators.\\nWeitere Informationen finden Sie in der entsprechenden [Issue](https://github.com/airalab/robonomics/issues/234) auf GitHub.\\n\\n## Erstmaliges einfaches Starten eines Robonomics-Collators\\n\\nSie können einen Collator einfach direkt in der Befehlszeile starten, um nach Fehlern zu suchen.\\nNachdem Sie dies getan haben, wird dringend empfohlen, den Robonomics-Collator als Dienst zu starten (siehe nächsten Schritt).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Starten Sie den Robonomics-Collator als Dienst\\n\\n1. Erstellen Sie den Benutzer für den Dienst mit dem Home-Verzeichnis\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Laden Sie das Robonomics-Binary herunter, extrahieren Sie es und verschieben Sie es in das Verzeichnis */usr/local/bin/*. Sie müssen *$ROBONOMICS_VERSION* in den Befehlen in diesem Abschnitt durch die aktuelle Version von Robonomics ersetzen. Die aktuelle Version finden Sie auf der [Releases-Seite des Robonomics-Repositorys auf GitHub](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Erstellen Sie die systemd-Service-Datei mit dem Namen *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    Und fügen Sie die folgenden Zeilen in die Service-Datei ein:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Speichern Sie diese Datei, aktivieren Sie dann den Dienst und starten Sie ihn:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nTelemetrie-URL: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nCollator-Protokolle können mit „journalctl -u robonomics.service -f“ überwacht werden\\n\\nSobald der Robonomics-Collator gestartet ist, beginnt er mit der Synchronisierung mit der Kusama-Relay-Kette. Dies kann je nach Netzwerkgeschwindigkeit und Systemspezifikationen eine beträchtliche Zeit in Anspruch nehmen. Wir empfehlen daher, einen Kusama-Snapshot herunterzuladen.\\n\\n\\n## Beschleunigen des Synchronisierungsprozesses mit einem Kusama-Snapshot\\n\\nWir empfehlen, dies unmittelbar nach Erstellung und Start des Robonomics-Dienstes durchzuführen. Weitere Informationen zu Snapshots und Anweisungen zur Verwendung finden Sie auf der folgenden Seite: https://ksm-rocksdb.polkashots.io/\\n\\nAnweisungen:\\n\\n1. Stoppen Sie den Robonomics-Dienst und entfernen Sie das aktuelle Kusama-Datenbankverzeichnis:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Laden Sie den aktuellen Snapshot herunter und extrahieren Sie ihn:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    Nach erfolgreichem Entpacken können Sie das heruntergeladene Archiv entfernen:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Setzen Sie das richtige Eigentum für den Datenbankordner:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Starten Sie den Robonomics-Dienst erneut:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Überprüfen Sie die Protokolle des Dienstes:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Fehlerbehebung\\n### Fehler: \\\"State Database error: Too many sibling blocks inserted\\\"\\nUm diesen Fehler zu beheben, können Sie Ihren Collator einfach im Archivmodus starten:\\n\\n1) Zunächst muss der Robonomics-Dienst gestoppt werden: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Fügen Sie dann den Parameter `--state-pruning=archive` zum Parachain-Teil der Service-Datei hinzu. Beispiel für die bearbeitete Service-Datei:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Laden Sie die Systemd-Manager-Konfiguration neu:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Entfernen Sie die vorhandene Parachain-Datenbank:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Starten Sie den Robonomics-Dienst:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    Danach müssen Sie auf die Synchronisierung der Parahain-Datenbank warten.\\n\\n### Fehler: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nDieser Fehler betrifft die Virtualisierungsparameter. Sie müssen den emulierten Prozessortyp \\\"host-model\\\" verwenden. Dies können Sie auf dem Virtualisierungshost einrichten.\\n\\nWenn Sie diesen Fehler jedoch bei einem beliebigen Hosting-Anbieter erhalten, müssen Sie den technischen Support nur nach diesem Problem fragen.\\n\"}},{\"node\":{\"id\":\"9fa388ab076c7f7fca0c68bcb72a17eb\",\"title\":\"Wie man einen Collator-Knoten aus dem Quellcode erstellt\",\"path\":\"/docs/de/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  In der Screencast und den Screenshots dieses Artikels haben wir Version 1.4.0 von Robonomics verwendet. Sie müssen dieselben Befehle verwenden, aber die Version von Robonomics durch die aktuelle ersetzen.\\n</robo-wiki-note>\\n\\n## Was ist ein Collator\\n\\nCollator ist Teil der Robonomics-Parachain. Dieser Knotentyp erstellt neue Blöcke für die Kette..\\n\\n>Collators pflegen Parachains, indem sie Parachain-Transaktionen von Benutzern sammeln und Zustandsübergangsproben für Relay Chain-Validatoren erstellen. Mit anderen Worten, Collators pflegen Parachains, indem sie Parachain-Transaktionen zu Parachain-Blockkandidaten aggregieren und Zustandsübergangsproben für Validatoren basierend auf diesen Blöcken erstellen.\\n\\nWeitere Informationen zum Collator finden Sie auf der entsprechenden [Polkadot-Wiki-Seite](https://wiki.polkadot.network/docs/learn-collator).\\n\\nIn der Robonomics-Parachain erhält jeder Collator Belohnungen (**0,000380520 XRT**) für jeden Block, den er erstellt hat, wenn dieser Block an die Kette gebunden war.\\nAußerdem erhält der Zusammensteller **50 % Transaktionsgebühren** aus diesem Block.\\n\\n## Bauprozess\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nStellen Sie sicher, dass Sie Rust und die erforderliche Support-Software installiert haben. Der Rust-Installer fragt Sie nach den aktuellen Installationsoptionen. Sie sollten die Option `1) Mit der Installation fortfahren (Standard)` wählen.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Installierenieren Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nInstallieren Sie die erforderliche Nightly-Toolchain und das wasm-Ziel.\\nDie nächsten Befehle gelten für Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nSie müssen auch die folgenden Pakete installieren:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nJetzt können Sie den Robonomics-Knoten aus der Git-Quelle installieren.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nNach diesem Befehl befindet sich die kompilierte Robonomics-Binärdatei im Verzeichnis `~/.cargo/bin`.\\n\\nDer nächste Schritt besteht darin, den Collator-Knoten zu starten. Informationen dazu finden Sie in dem Artikel [\\\"Wie man den Robonomics-Collator startet\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"513788b1cadbd90fd689474c2e633943\",\"title\":\"Upgrade Your Home Assistant OS\",\"path\":\"/docs/de/hass-os-upgrade/\",\"content\":\"\\n**Dieser Artikel enthält Anweisungen zum Upgrade Ihres bestehenden Home Assistant OS mit Robonomics Integration.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Installierenieren IPFS Add-on\\n\\n\\nRobonomics Integration speichert die Daten mit Hilfe des lokalen IPFS-Daemons, daher müssen Sie ihn zuerst installieren. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. Es gibt ein [IPFS Add-on für Home Assistant](https://github.com/airalab/ipfs-addon). Um es zu installieren, gehen Sie zu `Settings` -> `Add-ons` und drücken Sie die Schaltfläche `ADD-ON STORE` in der unteren rechten Ecke.\\n\\n2. Drücken Sie auf die drei Punkte in der oberen rechten Ecke und wählen Sie `Repositories`. Fügen Sie dort den folgenden Link hinzu:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Drücken Sie die Schaltfläche `ADD`.\\n\\n4. Schließen Sie den Repository-Manager und aktualisieren Sie die Seite. Jetzt können Sie am Ende der Seite das IPFS Daemon Add-on sehen.\\n\\n5. Öffnen Sie das Add-on und drücken Sie `INSTALL`. Nach der Installation drücken Sie `START`.\\n\\n## Installieren Sie HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) ermöglicht Ihnen die Installation von benutzerdefinierten Integrationen.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Bevor Sie beginnen, müssen Sie das Add-on für die Verbindung mit dem Home Assistant-Gerät über SSH installieren. Suchen Sie im Add-on Store nach `ssh`. Wir empfehlen die Installation des Add-ons `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Wenn das SSH-Add-on nicht gefunden wird, versuchen Sie, den erweiterten Modus in Ihren Benutzerprofil-Einstellungen zu aktivieren. Klicken Sie dazu auf das Profilsymbol in der unteren linken Ecke und suchen Sie die Option Erweiterter Modus.\\n\\n</robo-wiki-note>\\n\\n2. Wählen Sie das Add-on aus und drücken Sie `INSTALL`. Nach Abschluss der Installation gehen Sie zum Tab `Konfiguration` und fügen Sie `password` oder `authorized_keys` hinzu. Vergessen Sie nicht, diesen Teil der Konfiguration zu speichern.\\n\\n3. Drücken Sie im Tab `Info` auf `START`. Wenn Sie das Add-on in der Seitenleiste sehen möchten, vergessen Sie nicht, `Show in sidebar` zu aktivieren.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Öffnen Sie das SSH Add-on und führen Sie den folgenden Befehl aus:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Starten Sie Home Assistant neu (Sie können dies unter `Settings`->`System`). \\n\\n6. Jetzt steht die HACS Integration im Menü `Integrations` zur Verfügung. Gehen Sie zu `Settings`->`Devices & Services`, drücken Sie `Add Integration`  und suchen Sie HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  Um HACS zu verwenden, benötigen Sie ein Github-Konto.\\n\\n</robo-wiki-note>\\n\\n7. Klicken Sie darauf und folgen Sie den Installationsanweisungen. \\n\\n## Installieren Sie Robonomics Integration\\n\\nJetzt können Sie Robonomics Integration mit HACS installieren.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nÖffnen Sie HACS im Seitenmenü und navigieren Sie zu `Integrations`. Klicken Sie auf `Explore & Download Repositories`, suchen Sie nach `Robonomics` und klicken Sie auf die Schaltfläche `Download` in der unteren rechten Ecke. Sobald der Download abgeschlossen ist, starten Sie Home Assistant neu.\"}},{\"node\":{\"id\":\"8f59f38514ff3c169e0d77c98cf93114\",\"title\":\"Home Assistant-Initialisierung\",\"path\":\"/docs/de/hass-init/\",\"content\":\"\\n**Nach der Installation von Home Assistant muss es initialisiert werden.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nSie beginnen mit der Erstellung des Eigentümerkontos von Home Assistant. Dieses Konto ist ein Administrator und kann Änderungen vornehmen. Öffnen Sie einen Webbrowser und gehen Sie zu `http://%RASPBERRY_IP_ADDRESS%:8123`. Sie können die IP-Adresse des Raspberry Pi mit der [Fing Mobile App](https://www.fing.com/products) oder dem [nmap CLI-Tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) finden.\\n\\n<robo-wiki-note type=\\\"note\\\">Die Raspberry Pi-Adresse kann sich im Laufe der Zeit ändern, aufgrund von Router-Einstellungen.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. Geben Sie auf der ersten Seite einen Namen, Benutzernamen, ein Passwort ein und klicken Sie auf die Schaltfläche `CREATE ACCOUNT`.\\n\\n2. Geben Sie auf dem nächsten Bildschirm einen Namen für Ihr Zuhause ein und legen Sie Ihren Standort und Ihr Einheitensystem fest. Klicken Sie auf `DETECT`, um Ihren Standort zu finden und Ihre Zeitzone und Ihr Einheitensystem entsprechend diesem Standort festzulegen. Wenn Sie Ihren Standort nicht senden möchten, können Sie diese Werte manuell festlegen.\\n\\n3. Anschließend zeigt Home Assistant alle Geräte an, die es in Ihrem Netzwerk entdeckt hat. Machen Sie sich keine Sorgen, wenn Sie weniger Elemente sehen als unten gezeigt; Sie können jederzeit manuell Geräte hinzufügen. Klicken Sie vorerst einfach auf `FINISH` und Sie gelangen zum Hauptbildschirm von Home Assistant.\\n\\n4. Schließlich sehen Sie die Home Assistant-Webbenutzeroberfläche, auf der alle Ihre Geräte angezeigt werden. \\n\\n\\n## Fehlerbehebung\\n\\n1. Wenn Sie Ihren Benutzernamen oder Ihr Passwort für den lokalen Benutzer vergessen haben, [überprüfen Sie diesen Artikel](https://www.home-assistant.io/docs/locked_out/), um Ihre Anmeldeinformationen wiederherzustellen.\\n\"}},{\"node\":{\"id\":\"73d86d438473787cb8572c9563cb988d\",\"title\":\"Vorinstalliertes Image für Raspberry Pi\",\"path\":\"/docs/de/hass-image-install/\",\"content\":\"\\n**Willkommen zum Leitfaden zur Installation von Home Assistant mit Robonomics-Integration auf einem Raspberry Pi. Home Assistant ist ein Open-Source-Heimautomatisierungssystem, das eine zentrale Schnittstelle zur Steuerung intelligenter Geräte in Ihrem Heimnetzwerk bietet. Durch die Integration mit Robonomics, einem dezentralen Cloud-Dienst, können Sie die Funktionalität und Sicherheit Ihres Smart Homes verbessern. In diesem Artikel werden wir Ihnen schrittweise Anleitungen zur Installation von Home Assistant mit Robonomics auf einem Raspberry Pi geben, um Ihnen die Möglichkeit zu geben, verschiedene Aspekte Ihres Zuhauses mithilfe einer sicheren und dezentralen Lösung zu automatisieren und zu steuern. Fangen wir an!**\\n\\n## Hardware, die Sie für die Installation benötigen\\n\\nWenn Sie Home Assistant noch nicht in Ihr Smart Home-Setup integriert haben, ist es wichtig, sich über die Ausrüstung bewusst zu sein, die Sie benötigen, um ein vollständiges Smart Home-System von Grund auf aufzubauen.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Robonomics vorinstalliertes Image herunterladen\\n\\nDas vorinstallierte Robonomics-Image enthält:\\n- Home Assistant Core\\n- IPFS\\n- MQTT-Broker und Integration\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nSie können den Quellcode überprüfen und die neueste Version des Images auf [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases) herunterladen.\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Konfigurieren des Images\\n\\nInstallieren Sie [Raspberry Pi Imager](https://www.raspberrypi.com/software/) auf Ihrem Computer. Legen Sie dann die SD-Karte ein.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nFühren Sie das Raspberry Pi Imager-Programm aus. Wählen Sie das erforderliche Image als Betriebssystem und stellen Sie sicher, dass Sie Ihre SD-Karte aus dem Speicher-Dropdown-Menü auswählen.\\nIn den Einstellungen:\\n- Legen Sie Benutzername und Passwort fest (speichern Sie den Standard-Benutzernamen \\\"pi\\\", um ihn leicht zu merken),  \\n- geben Sie Ihren WLAN-Namen und Ihr Passwort ein, \\n- wählen Sie Ihr Land aus der Dropdown-Liste\\nund klicken Sie dann auf `Write` (Schreiben). \\n                   \\n<robo-wiki-note type=\\\"note\\\">Bewahren Sie Benutzername und Passwort sorgfältig auf, da diese Anmeldeinformationen im Fehlerbehebungsfall benötigt werden.</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nSie können Ländercodes [hier](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes) finden.\\n\\n## 3. Erster Start\\n\\n**Werfen Sie die SD-Karte sicher aus**, legen Sie sie in den Raspberry Pi ein. Stecken Sie dann den Zigbee-Adapter in den Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">Es ist wichtig, den Zigbee-Adapter vor dem ersten Start des Raspberry Pi einzustecken! \\nEr wird für die automatische Konfiguration des Zigbee-Netzwerks benötigt.</robo-wiki-note>\\n\\n**Wenn Sie den [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (der alle erforderlichen Firmware hat) haben, können Sie einfach mit diesen Anweisungen fortfahren. Wenn Sie jedoch einen anderen Adapter haben, müssen Sie ihn zuerst mit der Zigbee2MQTT-Software flashen. Anweisungen für Ihr Gerät finden Sie [hier](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nVerbinden Sie anschließend das Stromkabel mit Ihrem Gerät. Es sollte sich mit Ihrem WLAN-Netzwerk verbinden. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nSobald Ihr Raspberry Pi angeschlossen ist, leuchtet die rote LED und die grüne LED blinkt für einige Zeit. Warten Sie bis zu 5 Minuten, bis der Raspberry Pi hochfährt und sich im Netzwerk registriert.\\n\\nSuchen Sie nun die IP-Adresse des Raspberry Pi. Sie können dazu die [Fing Mobile App](https://www.fing.com/products) oder \\ndas [nmap CLI-Tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) verwenden. Suchen Sie den `robots-home` (optionaler Name könnte `Home(homeassistant)` sein) \\nNamen der Hostmaschine in der IP-Liste. \\n\\nIn diesem Beispiel lautet die Adresse `192.168.43.56`. \\n\\nUm zu überprüfen, ob alles funktioniert, öffnen Sie einen Webbrowser und gehen Sie zur Webseite `http://%RASPBERRY_IP_ADDRESS%:8123`. In diesem Beispiel lautet sie `192.168.43.56:8123`.\\nWenn alles in Ordnung ist, sehen Sie die Home Assistant-Webbenutzeroberfläche. Wenn die Webseite nicht geöffnet wird, warten Sie bis zu 5 Minuten, bis der Raspberry Pi hochgefahren ist, und versuchen Sie es erneut. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Fehlerbehebung\\n\\n1. Um die Wi-Fi-Einstellungen später zu ändern, melden Sie sich über den `ssh`-Befehl bei Ihrem Raspberry Pi an. Öffnen Sie dazu das Terminal auf Ihrem Computer\\nund geben Sie den `ssh`-Befehl mit Ihrem Benutzernamen ein, den Sie im Schritt \\\"Konfigurieren des Images\\\" erstellt haben (Standardwert ist \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\nund verwenden Sie dann den Befehl `sudo raspi-config`. Weitere Informationen zu diesem Befehl finden Sie auf [der offiziellen Website.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"6f13c26adcb5d51628f0f66bfc891c12\",\"title\":\"Aktualisieren Sie Ihren Home Assistant Docker für Unix-ähnliche Betriebssysteme\",\"path\":\"/docs/de/hass-docker-upgrade/\",\"content\":\"\\n**Dieser Artikel enthält Anweisungen zum Upgrade Ihres bestehenden Home Assistant Docker (auf einem Unix-ähnlichen Betriebssystem) mit der Robonomics-Integration.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Es wird angenommen, dass die Standard-Docker-Images und der Container von Home Assistant mit dem Namen <u>homeassistant</u> verwendet werden.\\n  2. IPFS wird als <u>systemd</u>-Dienst auf dem Host-Computer installiert und ausgeführt.\\n  3. Es wird angenommen, dass Sie [Python3.9](https://www.python.org/downloads/) oder höher installiert haben.\\n\\n</robo-wiki-note>\\n\\n## Installierenieren\\n\\nLaden Sie das Installationsskript herunter und führen Sie es im Terminal aus:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nSie sehen die folgende Ausgabe:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Es kann ein Fehler wie `mkdir: can't create directory 'custom_components': File exists` auftreten. Dies bedeutet, dass Sie bereits diesen Ordner mit einigen benutzerdefinierten Komponenten installiert haben. Ignorieren Sie einfach diese Meldung.\\n\\n</robo-wiki-note>\\n\\nContainer neu starten:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Überprüfen\\n\\nÜberprüfen Sie, ob der IPFS-Dienst aktiv und ausgeführt ist:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nSie sehen die folgende Ausgabe:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"1d58d079a46059ab8f2194139bed24e7\",\"title\":\"Rüsten Sie Ihren Home Assistant Core auf\",\"path\":\"/docs/de/hass-core-upgrade/\",\"content\":\"\\n**Dieser Artikel enthält Anweisungen zum Upgrade Ihres bestehenden Home Assistant Core mit der Robonomics-Integration.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. Es wird angenommen, dass die Installierenierenation Ihres Home Assistant Core gemäß den [offiziellen Anweisungen](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) abgeschlossen wurde und ein <u>homeassistant</u>-Benutzer sowie die `venv`-Umgebung vorhanden sind. Falls dies nicht der Fall ist, befolgen Sie die Anweisungen unten, **aber bearbeiten Sie das Skript entsprechend**.\\n  2. IPFS wird als <u>systemd</u>-Dienst auf dem Host-Computer installiert und ausgeführt.\\n  3. Es wird davon ausgegangen, dass Sie [Python3.10](https://www.python.org/downloads/) oder höher installiert haben.\\n\\n</robo-wiki-note>\\n\\n## Installieren\\n\\nLaden Sie das Installationsskript herunter und führen Sie es im Terminal aus:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nSie sehen die folgende Ausgabe:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nWährend des Vorgangs werden Sie aufgefordert, die Neustartbestätigung für mehrere Dienste zu bestätigen. Navigieren Sie mit `Tab` zur Option `yes`.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  Es kann ein Fehler wie `mkdir: can't create directory 'custom_components': File exists` auftreten. Dies bedeutet, dass Sie bereits diesen Ordner mit einigen benutzerdefinierten Komponenten installiert haben. Ignorieren Sie einfach diese Meldung.\\n\\n</robo-wiki-note>\\n  \\nNach Abschluss starten Sie Ihren Home Assistant neu.\\n\\n## Verifizieren\\n\\nÜberprüfen Sie, ob der IPFS-Dienst aktiv und ausgeführt ist:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nSie sehen die folgende Ausgabe:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"1882c3b8241f95ab05ca89d5281b4211\",\"title\":\"Glossary\",\"path\":\"/docs/de/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\neine Verknüpfung eines öffentlich-privaten Schlüsselpaars, bei dem der öffentliche Teil die öffentliche Adresse des Benutzers ist und der private Teil der geheime Schlüssel für den Zugriff auf die Kontrolle dieser Adresse ist.\\n\\n\\n### Auction (of Parachains)\\nMechanismus zur Vermietung von Slots für Parachains in den Polkadot- und Kusama-Ökosystemen; eine Parachain muss eine Kerzenauktion gewinnen, um einen Slot zu erhalten.\\n\\n### Autonomous Agent\\nein Rechensystem, das sensorische Daten aus seiner Umgebung empfängt und entscheidet, wie es auf externe Reize reagieren soll, um seine Ziele zu erreichen.\\n\\n### AIRA\\noder Autonomous Intelligent Robot Agent - eine Software, die 2015 vom Robonomics-Team entwickelt wurde und den Standard für die wirtschaftliche Interaktion zwischen Mensch und Maschine sowie zwischen Maschinen durch einen intellektuellen Haftungsvertrag umsetzt.\\n\\n\\n## B\\n\\n### Blockchain\\nim weiteren Sinne ein verteiltes Netzwerk, das Kryptographie verwendet, um eine Gruppe von Teilnehmern in die Lage zu versetzen, sich vertrauensvoll auf den sich ändernden Zustand eines Systems zu einigen.\\n\\n### Blockchain Erkundenr\\neine Anwendung, die es ermöglicht, die verschiedenen Blöcke, Transaktionen und Adressen auf einer Blockchain zu erkunden (z.B. Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\neine vorgefertigte Automatisierungslogik, die leicht zu einer Home Assistant-Instanz hinzugefügt werden kann.\\n\\n### Bridge\\neine Technologie und Methoden, mit denen zwei wirtschaftlich souveräne und technologisch unterschiedliche Ketten miteinander kommunizieren können. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nor Cs — a millionth share of one XRT token, 1 XRT = 1 000 000 Cs; named after Ronald Coase, a British economist, one of the founders of institutional economics, a laureate of the Nobel Memorial Prize in Economic Sciences. \\n\\n### Collator\\nein Knoten, der eine Parachain pflegt, indem er Parachain-Transaktionen sammelt und Zustandsübergangsproben für die Validatoren erstellt.\\n\\n### Consensus\\nein Prozess, bei dem Knoten eines Blockchain-Netzwerks eine Einigung über den aktuellen Zustand der Daten im Netzwerk erzielen (z. B. Proof-of-Work, Proof-of-Stake).\\n\\n### Crowdloan\\neine Crowdfunding-Kampagne zur Sammlung von Token, um an der Slot-Auktion im Polkadot/Kusama-Ökosystem teilzunehmen.\\n\\n### Cybernetics\\ndie Untersuchung von Kontrolle und Kommunikation im Tier und in der Maschine, gemäß der Definition von N. Wiener.\\n\\n### Cyber-Physical System\\noder CPS - eine starke Vereinigung und gegenseitige Integration mehrerer rechnerischer, netzwerktechnischer und physikalischer Prozesse.\\n\\n\\n## D\\n\\n### DAO\\neine kollektiv besessene, blockchain-gesteuerte Organisation, bei der die Ressourcenverwaltung gemäß einer vorab vereinbarten und formalisierten Satzung automatisch erfolgt.\\n\\n### Datenprotokoll (Function)\\neine Robonomics-Parachain-Funktion, die Gerätedaten auf der Blockchain speichert.\\n\\n### Dapp\\noder dezentrale Anwendung - eine Anwendung, die als Teil eines verteilten Netzwerks ausgeführt wird und den Zugriff auf ihre Funktionen auf benutzerfreundliche Weise ermöglicht.\\n\\n### Decentralized Cloud\\nein Cloud-Computing-Dienst, der auf einem dezentralen Peer-to-Peer-Netzwerk basiert, dem Benutzer beitreten können, um entweder Dienste zu nutzen oder ihre Ressourcen wie Rechenleistung, Netzwerk, Speicher usw. bereitzustellen.\\n\\n### Digital Twin\\neine digitale Version realer Geräte, die deren technische Merkmale und historische Daten kopiert.\\n\\n\\n## E\\n\\n### Edge-system\\nein IoT-Gerät, das als Verbindung zwischen lokal zugänglichen eingebetteten Systemen und dem globalen Netzwerk fungiert und in der Regel Kommunikationsprotokolle unterstützt und Telemetrie- und Steuersignale überträgt.\\n\\n### Embedded System\\nein IoT-Gerät mit begrenzten Rechen- und Kommunikationsressourcen, das grundlegende Funktionen (Sensoren, Aktoren, Tasten) auf niedrigster Ebene bereitstellt, normalerweise ohne Benutzeroberflächen.\\n\\n### Ethereum\\nein dezentrales Open-Source-Blockchain-System, das als Plattform für zahlreiche andere Kryptowährungen sowie für die Ausführung dezentraler Smart Contracts fungiert.\\n\\n### Ethereum Upgrade\\nfrüher bekannt als Ethereum 2.0 oder Eth2 - ein Upgrade des Ethereum-Protokolls, das das Netzwerk skalierbarer, sicherer und nachhaltiger machen soll; zu diesem Zweck wird vorgeschlagen, den Konsens auf Proof-of-Stake umzustellen und einen Sharding-Mechanismus hinzuzufügen, um die Netzwerkkapazität zu erhöhen.\\n\\n### Exodus\\nProzess des Transfers von XRT-Token vom Ethereum-Netzwerk zur Robonomics-Parachain.\\n\\n### Extrinsic\\neine Funktion im Polkadot- und Kusama-Netzwerk, die Netzwerkzustandsübergänge von außerhalb des Zustands auslösen kann.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\noder Gk - ein Tausendstel eines XRT-Tokens, 1 XRT = 1 000 Gk; benannt nach Victor Glushkov, einem sowjetischen Mathematiker und einem der Begründer der Informationstechnologie und Kybernetik in der Sowjetunion.\\n\\n\\n## H\\n\\n### Home Assistant\\nor Hass — an open source control system software, designed to be a central hub for smart devices. \\n\\n### HRMP\\nor Horizontal Relay-routed Message Passing — a secure message passing between parachains, that stores all messages in the Relay Chain storage before sending it to parachains. \\n\\n### HMI\\noder Human-Machine Interface - eine Benutzeroberfläche oder ein Dashboard, das den Benutzer mit einer Maschine, einem System oder einem Gerät verbindet.\\n\\n\\n## I\\n\\n### Industry 4.0\\noder die Vierte Industrielle Revolution - die fortlaufende Automatisierung traditioneller Fertigungs- und Industrieverfahren mit moderner intelligenter Technologie.\\n\\n### IPFS\\noder InterPlanetary File System - eine Peer-to-Peer-Software zum Speichern und Teilen von Daten in einem verteilten Dateisystem.\\n\\n### IoT\\noder Internet der Dinge - eine Verbindung zu einem globalen Netzwerk von Milliarden von Geräten, die in der Lage sind, Daten zu sammeln und in die Umgebung integriert zu werden.\\n\\n### IoT Gateway\\nein Edge-System, das Daten von IoT-Geräten zum Netzwerk aggregiert und überträgt und umgekehrt; oft handelt es sich bei diesen Geräten um eine komplexere Version des WLAN-Routers.\\n\\n### IoT Provider\\nein externer Dienst, der IoT-Benutzern den Remotezugriff auf Daten und Analysen sowie die Steuerung von intelligenten Geräten über das Internet ermöglicht.\\n\\n### IoT Subscription\\nRobonomics-Parachain-Funktion, die es ermöglicht, alle Funktionen der Parachain für einen bestimmten Zeitraum ohne Gebühr zu nutzen.\\n\\n\\n## K\\n\\n### KSM\\nein nativer Token für das Kusama-Netzwerk.\\n\\n### Kusama\\ndas \\\"Kanariennetzwerk\\\" für Polkadot, das aus einer frühzeitigen, nicht überprüften Version der Polkadot-Software besteht.\\n\\n\\n## L\\n\\n### Start (Function)\\neine Robonomics-Parachain-Funktion, die ein Gerät durch Senden eines Befehls über die Blockchain startet oder stoppt.\\n\\n### Lease Period\\neine Zeitspanne, in der eine Parachain eine Verbindung zur Relay Chain herstellen kann.\\n\\n### Libp2p\\neine Open-Source-Bibliothek zur Erstellung verschlüsselter Peer-to-Peer-Netzwerke.\\n\\n### Lights-out Factory\\noder Smart Factory - eine Fabrik, die vollständig automatisiert ist und keine menschliche Präsenz vor Ort erfordert.\\n\\n### Lighthouse\\nein Smart Contract im Konzept der Roboterwirtschaft, der eine Transaktion durchführt, wenn der Anbieter eine Marktübereinstimmung zwischen dem Versprecher und dem Versprechenden herstellt.\\n\\n### Haftung\\nein Smart Contract, der von cyber-physischen Systemen untereinander oder mit Menschen erstellt wird, um eine Aufgabe gegen Bezahlung auszuführen.\\n\\n### Haftung Market\\neine Plattform im Konzept der Roboterwirtschaft, die für die Abstimmung von Angeboten und Nachfragen zwischen den Knotenpunkten des Systems zuständig ist.\\n\\n\\n## M\\n\\n### MQTT\\noder Message Queuing Telemetry Transport - ein Publish-Subscribe-Protokoll, das für Netzwerke mit geringer Bandbreite, hoher Latenz und unzuverlässiger Verbindung entwickelt wurde, um hohe Mengen an IoT-Gerätenachrichten zu verarbeiten.\\n\\n### MQTT Broker\\nein Dienst, der alle Nachrichten von den MQTT-Clients empfängt und dann die Nachrichten an die entsprechenden abonnierenden Clients weiterleitet.\\n\\n\\n## N\\n\\n### NFT\\noder Non-Fungible Token - ein Token, das nicht austauschbar ist und sich nicht von anderen Tokens unterscheiden lässt, was die Tokenisierung einzigartiger Gegenstände ermöglicht und exklusiven Besitz für diese Tokens bietet.\\n\\n### Node (of Robonomics)\\nein auf Substrate oder Ethereum basierendes Blockchain-Modul mit Robonomics-Erweiterungen zur Verbindung mit dem Robonomics-Netzwerk.\\n\\n\\n## O\\n\\n### On-chain Governance\\nein Prozess zur Bestimmung, welche Änderungen im Netzwerk zulässig sind, wie z.B. Änderungen am Code oder die Bewegung von Geldern, der im Netzwerk selbst existiert und es direkt verändern kann.\\n\\n\\n## P\\n\\n### Pallet\\nEin in Rust geschriebenes Substrate-Modul, das spezifische Logik oder Algorithmen für die Laufzeit einer Substrate-basierten Blockchain bündelt.\\n\\n### Parachain\\neine benutzerdefinierte, anwendungsspezifische Datenstruktur (in der Regel eine Blockchain), die in die Relay Chain integriert ist und von den Validatoren validiert werden kann.\\n\\n### Parathread\\neine Parachain ohne Slot, die vorübergehend (blockweise gegen Gebühr) an der Sicherheit der Relay Chain teilnehmen kann.\\n\\n### Polkadot\\nein heterogenes, Multi-Chain-Netzwerk, das verschiedenen Blockchains mit unterschiedlichen Eigenschaften ermöglicht, beliebige, plattformübergreifende Kommunikation unter gemeinsamer Sicherheit durchzuführen.\\n\\n### Polkadot/Substrate Portal\\neine grundlegende Substrate-Benutzeroberfläche zur Interaktion mit einem Polkadot-, Kusama- und anderen Substrate-Netzwerk.\\n\\n### Proposal (on Polkadot / Kusama)\\nein potenzieller Funktionsaufruf, über den in einem Polkadot-, Kusama- oder Parachains-Referendum abgestimmt werden soll. \\n\\n### Proof-of-Work\\nein Konsensmechanismus, bei dem die Netzwerkteilnehmer zur Erzielung einer Einigung erforderlich sind, um Berechnungsarbeit durchzuführen.\\n\\n### Proof-of-Stake\\nein Konsensmechanismus, bei dem die Netzwerkteilnehmer zur Erzielung einer Einigung verpflichtet sind, Kapital der zugehörigen Kryptowährung als Sicherheit einzusetzen.\\n\\n### Promisee\\nein Knoten, der eine Bestellung zur Ausführung einer Aufgabe im Konzept der Robot Economy aufgibt.\\n\\n### Promisor\\nein Knoten, der sich bereit erklärt, eine Aufgabe gegen Bezahlung im Konzept der Robot Economy auszuführen.\\n\\n### Provider (Robonomics)\\nEin Knotenpunkt im Konzept der Roboterökonomie, der die Nachrichten des Haftungsmarktes überwacht und gegen eine geringe Gebühr ein Angebot und eine Nachfrage zusammenbringt.\\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\nAls Teil der On-Chain-Governance stimmen sie darüber ab, ob ein Vorschlag von den Netzwerkbenutzern angenommen werden soll oder nicht.\\n\\n### Relay Chain\\ndie Hauptkette, die den Konsens von Polkadot / Kusama koordiniert und die Kommunikation zwischen Parachains ermöglicht.\\n\\n### Robofirm\\neine Organisation, bei der der gesamte Geschäftsprozesszyklus vollständig automatisiert ist und keine menschliche Beteiligung erfordert.\\n\\n### Rococo\\ndas Testnetz zum Testen von Parachains auf Kusama\\n\\n### robonomics-interface\\neine Python-Bibliothek, die sich auf die Schnittstelle mit Robonomics spezialisiert, um eine bequeme Programmierung zu ermöglichen.\\n\\n### Robonomics auf Ethereum\\neine Version des Robonomics-Netzwerks, das auf Ethereum läuft und 2018 veröffentlicht wurde.\\n\\n### Robot Economy\\nein Wirtschaftssystem, in dem Geräte als unabhängige Agenten agieren und in der Lage sind, wichtige wirtschaftliche Aktivitäten durchzuführen, die zuvor nur Menschen vorbehalten waren.\\n\\n### Robot-as-a-Service\\noder RaaS - ein Geschäftsmodell, bei dem Unternehmen ihre Robotikgeräte an Kunden vermieten und für den kurz- oder langfristigen Einsatz zur Verfügung stellen.\\n\\n### ROS\\noder Robot Operating System - ein Framework für die Entwicklung von Robotersoftware, das Dienste für einen heterogenen Computercluster wie Hardwareabstraktion, Gerätesteuerung auf niedriger Ebene, Implementierung von häufig verwendeten Funktionen, Nachrichtenübermittlung zwischen Prozessen und Paketverwaltung bietet.\\n\\n### ROS 2\\neine aktualisierte und neu entwickelte Version des Robot Operating System mit neuen Funktionen wie Unterstützung für Multi-Robot- und kleine Embedded-Systeme sowie Integration mit Echtzeitfunktionen.\\n\\n### ROS 2 Middleware\\noder RMW - ein Protokoll, das standardmäßige ROS 2-Funktionen wie Discovery, Serialisierung und Transport bereitstellt; ROS 2 unterstützt mehrere Middleware-Implementierungen, die je nach Projektanforderungen ausgewählt werden können.\\n\\n### RWS\\noder Robonomics Web Services - dezentrale Infrastrukturdienste für Robotik und IoT, die eine einfache Verbindung von Geräten und die Interaktion mit Benutzeranwendungen, Cloud-Diensten und anderen Geräten ermöglichen; es hat auch seinen eigenen Token namens RWS, der ein lebenslanges IoT-Abonnement in der Robonomics-Parachain ermöglicht.\\n\\n### Ausführentime\\neine Zustandsübergangsfunktion einer Blockchain, die einen gültigen Algorithmus zur Bestimmung des Zustands des nächsten Blocks anhand des vorherigen Zustands definiert.\\n\\n\\n## S\\n\\n### Seed Phrase\\nein menschenlesbarer privater Schlüssel, der als Sequenz zufälliger Wörter erstellt wird und zum Zugriff auf eine Blockchain-Adresse und deren Tokens erforderlich ist.\\n\\n### Shared Security\\ndas Sicherheitsmodell von Polkadot / Kusama, bei dem alle Chains gleichermaßen durch das Platzieren von Nachweisen über die Gültigkeit von Parachain-Blöcken in die Relay Chain gesichert sind, sodass ein potenzieller Angreifer das gesamte System angreifen müsste.\\n\\n### SLS Gateway\\nein Open-Source-IoT-Gateway für Zigbee-Geräte, das auf dem ESP32-Mikrocontroller von Smart Logic System entwickelt wurde.\\n\\n### Slot (of Parachain)\\neine knappe Ressource im Polkadot / Kusama-Ökosystem, die es einer Parachain ermöglicht, ohne Gebühr für jeden Block mit der Relay Chain verbunden zu werden.\\n\\n### Smart Leasing\\neine Variante des Robot-as-a-Service-Modells, bei dem die Miete nicht nach Zeit, sondern für bestimmte Operationen und deren Anzahl bezahlt wird.\\n\\n### Smart Contract\\nein Programm oder Algorithmus, der auf einer Blockchain gespeichert ist und automatisch ausgeführt wird, wenn vordefinierte Bedingungen erfüllt sind.\\n\\n### SSH\\noder Secure Shell – ein Netzwerkprotokoll für den sicheren Betrieb von Netzwerkdiensten über ein ungesichertes Netzwerk, das Public-Key-Kryptografie zur Authentifizierung des Remotecomputers verwendet.\\n\\n### Staking\\nder Teil des Proof-of-Stake-Konsenses, bei dem Tokens als Sicherheit hinterlegt werden, um eine Chance auf die Produktion eines gültigen Blocks und den Erhalt einer Belohnung zu erhalten.\\n\\n### Substrate\\nein modulares Framework zum Aufbau von Blockchains wie Polkadot und Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nein Topf von Mitteln, die durch einen Teil der Blockproduktionsbelohnungen, Transaktionsgebühren, Staking usw. gesammelt werden und durch einen Ausgabevorschlag ausgegeben werden können; wenn das Treasury am Ende eines Ausgabenzeitraums nicht alle seine Mittel ausgegeben hat, wird ein Prozentsatz der Mittel verbrannt.\\n\\n### Transaction Costs\\ndie Kosten für die Sammlung und Verarbeitung von Informationen aufgrund der begrenzten Rationalität der Wirtschaftsteilnehmer und der Komplexität der Prozesse.\\n\\n\\n## V\\n\\n### Validator\\nEin Knoten, der die Relay Chain durch den Einsatz seiner Token sichert, Beweise von Collators auf Parachains validiert und zusammen mit anderen Validatoren über den Konsens abstimmt.\\n\\n\\n## W\\n\\n### Web3\\nEine Idee für eine neue Iteration des Webs, die Konzepte wie Dezentralisierung, Blockchain-Technologien und tokenbasierte Wirtschaftsmodelle integriert.\\n\\n### Wiener (XRT)\\noder Wn - ein milliardstel Anteil eines XRT-Tokens, 1 XRT = 1 000 000 000 Wn; benannt nach Norbert Wiener, einem amerikanischen Mathematiker, einem der Begründer der Kybernetik und der Theorie der künstlichen Intelligenz.\\n\\n\\n## X\\n\\n### XCM\\noder Cross-Consensus Message Format - ein Format für die Kommunikation zwischen verschiedenen Blockchain-Systemen in Polkadot / Kusama.\\n\\n\\n### XRT\\nEin nativer Token für das Robonomics Network, der unabhängig auf den Ethereum- und Kusama-Netzwerken existiert.\\n\\n\\n## Y\\n\\n### Yggdrasil\\neine Overlay-Netzwerkimplementierung eines vollständig end-to-end verschlüsselten Routing-Schemas für Mesh-Netzwerke.\\n\\n\\n## Z\\n\\n### Zigbee\\nEin drahtloses Kommunikationsprotokoll, das aufgrund des geringen Stromverbrauchs, der einfachen Konfigurierbarkeit und Flexibilität sowie der Unterstützung einer selbstorganisierenden und selbstwiederherstellenden Netzwerktopologie sehr häufig zur Verbindung intelligenter Geräte verwendet wird.\\n\\n### Zigbee Adapter\\nEin Gerät, das Daten zwischen dem Zigbee-Netzwerk und einem anderen Netzwerk (z. B. Wi-Fi) überträgt, um Zigbee-Geräte zu steuern.\\n\\n### Zigbee2MQTT\\nEine Software, die es ermöglicht, Zigbee mit MQTT-Netzwerken zu verbinden, indem Nachrichten von einem Netzwerk in ein anderes übersetzt werden.\"}},{\"node\":{\"id\":\"2a03df5235945994e1fbab505ede5e63\",\"title\":\"Globale Verwaltung\",\"path\":\"/docs/de/global-administration/\",\"content\":\"\\n**In diesem Artikel wird Ihnen gezeigt, wie Sie einem neuen Benutzer zu Ihrem Home Assistant hinzufügen.**\\n\\n## Benutzer zur Abonnement hinzufügen\\n\\nSie können keine zuvor erstellten Konten verwenden, da `SUB_OWNER` und `SUB_CONTROLLER` Sicherheit bieten und der erste Benutzer, den Sie beim ersten Start von Home Assistant erstellt haben, kein Robonomics Parachain-Konto hat.\\n\\n1. Erstellen Sie ein Konto auf der Robonomics-Parachain, wie Sie es im [vorherigen Artikel](/docs/sub-activate/) getan haben.\\n\\n2. Fügen Sie mit dem Konto `SUB_OWNER` ein neues Benutzerkonto zum Abonnement in der [Dapp](https://dapp.robonomics.network/#/subscription/devices) hinzu. Jetzt sollten drei Adressen in der Zugriffsliste stehen: `SUB_OWNER`, `SUB_CONTROLLER` und `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Zugriff für Benutzer gewähren\\n\\n1. Gehen Sie zum Dapp-Dienst namens [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Wählen Sie das Konto, das Sie gerade im rechten Seitenbereich erstellt haben (überprüfen Sie, ob Sie das beabsichtigte Konto ausgewählt haben, indem Sie auf das Profilsymbol klicken).\\n\\n2. Geben Sie den `USER`-Seed in das erforderliche Feld ein. Fügen Sie die Adressen `SUB_OWNER` und `SUB_CONTROLLER` in die Felder für die Administratorberechtigungen ein. Wenn alles korrekt ist, sehen Sie den Verifizierungsstatus `VERIFIED`.\\n\\n3. Erstellen Sie ein Passwort für einen neuen Benutzer, den Sie gerade registriert haben, und bestätigen Sie dann die Transaktion, die jetzt aufgrund des Abonnements gebührenfrei ist. Später können Sie das Passwort im Wiederherstellungs-Tab wiederherstellen.\\n\\n4. Melden Sie sich nach dem Registrierungsprozess bei Home Assistant mit Ihrer Benutzeradresse als Login und einem neu erstellten Passwort an.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nJetzt können Sie die Dapp verwenden, um Ihr Zuhause über Robonomics zu steuern. Lesen Sie den Artikel [**\\\"Erhalten Sie Smart Home Telemetrie\\\"**](/docs/smart-home-telemetry/), um weitere Informationen zu erhalten.\\n\\n## Fehlerbehebung\\n\\n1. Wenn Sie ein Passwort für Home Assistant in Ihrem Robonomics-Konto vergessen haben, [überprüfen Sie die Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nGehen Sie zum Abschnitt \\\"Your Home Assistant password\\\" und wählen Sie den Tab \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"5e9228b34399d13335d790fddd2e5eb4\",\"title\":\"Erste Schritte\",\"path\":\"/docs/de/getting-started/\",\"content\":\"\\n## Was ist Robonomics\\n\\nDie Robonomics-Plattform bietet Tools für die Arbeit mit dem Robot Economy Network. Robonomics ermöglicht es den Designern von Smart Cities und Industrie 4.0-Zonen, Vertrauen unter den [autonomen Roboterdiensten](/docs/glossary#cyber-physical-system) aufzubauen, [direkten Benutzerzugriff über Dapp](/docs/glossary#dapp) für die Bestellung von Produkten aus autonomen Fabriken und Dienstleistungen von städtischen Sensorsystemen bereitzustellen. Dadurch wird es uns ermöglicht, ein dezentrales System einzurichten, das die Aktivitäten von Cyber-Physical-Systemen weltweit überwacht.\\n\\nDie folgende Tabelle beschreibt, welchen Platz Robonomics in dem Szenario einnimmt:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nWeitere Informationen finden Sie in [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Robonomics Network Schnellstart\\n**Für die Bequemlichkeit von Neulingen haben die Kernentwickler von Robonomics eine [6-Lektionen-Lernkurve](/docs/wschool2021-intro/) entwickelt!**\\n\\nSie werden die serverlose IoT-Architektur erkunden! Robonomics Web Services (RWS) ist der grundlegende Infrastrukturdienst für Robotik und IoT auf Basis von Polkadot && IPFS.\\n\\nAbsolventen des Kurses können eine lokale Relay-Kette starten und ein ROS-kompatibles Gerät über Cross-Chain-Transaktionen steuern.\\n\\n**[Treten Sie dem Robonomics Developers Discord bei](https://discord.gg/jTxqGeF5Qy), um sich mit der Community zu verbinden und technischen Support zu erhalten.**\\n\\n### Vorteile für Absolventen der Robonomics Academy\\n- Praktikum für die besten Studenten   Werden Sie Mitglied des Robonomics-Teams und tragen Sie zur Entwicklung des gewählten Produkts bei.\\n- Aktive Community && regelmäßige Veranstaltungen   Werden Sie Teil der Lerner-Community, diskutieren Sie Ihre Anwendungsfälle mit Branchenexperten. Teamen Sie sich zusammen und nehmen Sie an Hackathons teil!\\n- Zertifikat über den Abschluss   Fügen Sie Ihrem Portfolio ein Zertifikat für den Abschluss des Kurses zum Aufbau von DAPPs für IoT hinzu.\\n- Unterstützung bei der Zulassung zur ITMO-Universität. Egal, ob Sie Bachelor oder Master sind, Sie erhalten Unterstützung bei Ihrer Zulassung zur Universität.\\n- Finanzierung && Beschleunigungsmöglichkeiten: 1)Bewerben Sie sich um einen Unterstützungszuschuss von bis zu 50.000 USD für die Akademie; 2)Nehmen Sie am Robonomics Builders Acceleration Program teil, das von der Web3 Foundation unterstützt wird; 3)Bauen Sie Ihre eigenständige DAPP auf Robonomics auf; 4)Monetarisieren Sie sie && erhalten Sie Marketingunterstützung vom Robonomics-Team.\\n\\n\\n## Was die Dokumentation enthält\\n\\n### Ich bin ein Dapp-Entwickler\\n\\n- [Robonomics-js auf GitHub](https://github.com/airalab/robonomics-js) - einfaches Javascript-SDK für Robonomics Network dApp-Entwickler.\\n- [dApp-Vorlage](https://github.com/airalab/vue-dapp-robonomics-template) - verwendet Vue.js\\n- [Wiki-Dokumentation](/docs/robonomics-js/)\\n\\n### Ich bin ein Robotikingenieur\\n\\nSchauen Sie sich den Abschnitt [Fälle](/docs/iot-sensors-connectivity/) an und beginnen Sie mit der Entwicklung anhand von [Beispielen](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"52e0b37c50d349c460aa2003bebb5175\",\"title\":\"Wie man ein Abonnement kauft\",\"path\":\"/docs/de/get-subscription/\",\"content\":\"\\n**Das Bezahlen von Provisionen für Transaktionen in der Blockchain ist lästig. Stellen Sie sich ein IoT-Gerät vor, das alle 5-10 Minuten Telemetrie sendet. Dadurch müssen Sie im Laufe des Monats ziemlich viel bezahlen. Eine der Hauptfunktionen des Robonomics-Netzwerks ist RWS - Robonomics Web Service-Abonnement. Zahlen Sie monatlich und vergessen Sie die Transaktionskosten! Für theoretische Hintergrundinformationen siehe [diesen](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) Artikel.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Beachten Sie, dass dieses Tutorial den Kauf eines Abonnements auf der Robonomics Kusama-Parachain demonstriert. Sie können auch alle Schritte auf Ihrem [lokalen Knoten](/docs/run-dev-node) durchführen.\\n\\n  Noch eine Sache vor dem Start. Dies ist eine \\\"schwierige\\\" Art, ein Abonnement zu kaufen. Es gibt auch eine herkömmliche Möglichkeit, dies über [Robonomics DApp](https://dapp.robonomics.network/#/) zu tun.\\n\\n</robo-wiki-note>\\n\\n## Bieten Sie bei einer Auktion\\n\\nDie Abonnements bei Robonomics werden nach dem Auktionsmodell verkauft. Um eins zu bekommen, müssen Sie bei einer Auktion bieten und gewinnen (keine Sorge, es geht schnell).\\n\\nIn `Developer/Chain state`  können Sie verfügbare Auktionen sehen. \\nWählen Sie `rws` und `auctionQueue` und drücken Sie die `+`-Taste, dann sehen Sie die IDs der verfügbaren Auktionen:\\n\\n![queue](../images/rws/queue.png)\\n\\nSie können Informationen über ein beliebiges Abonnement mit `rws` `auction` und der ID der Auktion sehen (die ID der Auktion auf dem Bild ist 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nIn den Informationen über die Auktion sehen Sie das Feld `winner`, im Moment ist es `null`, also hat niemand dieses Abonnement und Sie können es bekommen. Gehen Sie dazu zu `Developer/Extrinsic`, wählen Sie Ihr Konto und `rws -> bid`. Setzen Sie auch die Auktions-ID (79) und die Anzahl der zu bietenden Einheiten (mehr als 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nSenden Sie die Transaktion ab und überprüfen Sie die Informationen über die Auktion mit der ID 79 (wählen Sie in `Chain state` `rws -> auction` und ID 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nJetzt sehen Sie in dem Feld `winner` Ihre Kontoadresse, das bedeutet, dass dieses Konto das Abonnement 79 hat. Eine Auktion beginnt mit dem ersten Gebot und dauert einige Blöcke, also wenn jemand in den nächsten Blöcken mehr Token bietet als Sie, wird dieser das Abonnement erhalten und gewinnen.\\n\\nJetzt können Sie Geräte hinzufügen. Geräte sind Konten, die dieses Abonnement nutzen und Extrinsiken ohne Gebühr senden können.\\nUm es zu testen, erstellen Sie ein neues Konto ohne Token und fügen Sie es zu Geräten hinzu.\\n\\nUm Geräte hinzuzufügen, wählen Sie `rws -> setDevices` in `Developer/Extrinsic`. Drücken Sie dann die Schaltfläche `Add Item` und wählen Sie das kürzlich erstellte Konto ohne Token aus:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nSenden Sie die Transaktion ab. Jetzt können Sie die Liste der Geräte in `Chain state` mit `rws -> devices` überprüfen. Dort sehen Sie die Adresse Ihres Kontos ohne Token. Wählen Sie das Konto aus, das das Abonnement gekauft hat, und drücken Sie `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nJetzt können Sie versuchen, eine [Start-Extrinsik](/docs/subscription-launch) mit dem Abonnement zu senden.\"}},{\"node\":{\"id\":\"6c0beab06ba44299a4c8edf3837e11a7\",\"title\":\"Gaka-Chu Einrichtung und Softwareinstallation\",\"path\":\"/docs/de/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**In diesem Artikel werden wir einige Installierenierenations- und Startschritte durchgehen, um einen Roboter-Maler einzurichten. Anforderungen:**\\n- KUKA KR6 R900 sixx mit KRC4 und einem SmartPad;\\n- Intel NUC mit [ROS melodic](http://wiki.ros.org/melodic/Installation/Ubuntu) installiert;\\n- Tisch, Farbe, Pinsel, Wasser.\\n\\n## Softwareinstallation auf KRC4\\nEKI-Schnittstelle ist sowohl auf KRC4 als auch auf NUC erforderlich. Detaillierte Informationen zur Einrichtung auf KRC4 finden Sie [hier](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Starten Sie es auf dem Controller des Roboters.\\n\\n## Softwareinstallation auf NUC\\nErstellen Sie einen Catkin-Arbeitsbereich:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nLaden Sie ROS-Pakete herunter. Alle Skripte sind [hier](https://github.com/airalab/robot_painter/tree/test_branch) gespeichert. Klonen Sie das Repository:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nSie benötigen möglicherweise einige Header-Dateien und Bibliotheken, um alles korrekt funktionieren zu lassen. Laden Sie sie herunter:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nFügen Sie den Quellbefehl zur Datei `.bashrc` hinzu:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nBis jetzt sollten Sie in der Lage sein, die Skripte zu starten. Wenn etwas schief geht, versuchen Sie einige [Fehlerbehebung](https://github.com/airalab/robot_painter/issues)\\n\\n## Ausfüllen von Konstanten\\nZunächst muss der Roboter den Standort und die Ausrichtung der Leinwand sowie die Position der Farbdose kennen. All dies wird in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp` angegeben. Schauen wir uns das an.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nDies sind die Konstanten der Ebenengleichung, die die Position der Leinwand im 3D-Raum angeben. Sie werden während eines Kalibrierungsprozesses ermittelt, der unten beschrieben wird. Als nächstes kommt die Farbe.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nDies sind die Koordinaten der Farbdose. Sie können auch während der Kalibrierung angegeben werden. Die Größe der Leinwand ist angegeben in\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nEinige weitere wichtige Konstanten sind in `local_task_planner/src/Drawing.cpp` gespeichert:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nIhre Namen sagen alles, füllen Sie sie entsprechend der Situation aus.\\n\\n## Kalibrierung von Gaka-Chu\\nDer Kalibrierungsprozess selbst ist ziemlich einfach.\\n\\n1) Starten Sie die EKI-Schnittstelle auf dem KRC4:\\n\\nMelden Sie sich im 'AUT'-Modus an, schalten Sie die Treiber ein und starten Sie das Skript `eki_hw_interface`\\n\\n2) Starten Sie die EKI-Schnittstelle auf dem NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nEs sollte endlose Protokolle ausgeben.\\n\\n3) Starten Sie RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nSie sollten Folgendes sehen:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nVersuchen Sie, den Endeffektor zu bewegen und auf 'Planen und Ausführen' zu klicken. Der Roboter sollte sich bewegen. Gehen Sie auf dem SmartPad zu **Display -> Actual position** und beobachten Sie die Koordinaten des Endeffektors. Platzieren Sie eine Leinwand horizontal zur Roboterbasis. Stecken Sie einen Pinsel in den Pinselhalter und bewegen Sie ihn vorsichtig, bis er die Leinwand kaum berührt. Speichern Sie in dieser Position die Koordinaten des Endeffektors. Wiederholen Sie dies 12-15 Mal. Speichern Sie auch die Koordinaten des Leinwandzentrums und der Farbdose.\\nWenn Sie eine Reihe von Koordinaten haben, verwenden Sie [diese](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab-Skripte, um die fehlenden Konstanten und Quaternionen zu berechnen. Fügen Sie sie ein. Erstellen Sie Ihren Arbeitsbereich neu mit\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Testen der Gaka-Chu-Kalibrierung\\nWenn kalibriert, muss Gaka-Chu durch das Zeichnen der Grenzen der Leinwand getestet werden. Um dies zu tun, führen Sie jeweils in einem neuen Terminal aus:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nDanach sollten Sie eine Leinwandkontur in RViz sehen:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nDrücken Sie in der Konsole \\\"S\\\", um den Test durchzuführen. Der Endeffektor des Roboters sollte sich direkt über den Grenzen der Leinwand bewegen und der Pinsel sollte die Leinwand während der gesamten Bewegung sanft berühren. Wenn dies nicht der Fall ist, versuchen Sie eine erneute Kalibrierung. Wenn das Leinwandmodell falsch gedreht ist, können Sie es durch Ändern des Quaternions in Matlab drehen.\\n\\n## Kunst machen\\nSie benötigen 6 grundlegende Module, um alles zum Laufen zu bringen:\\n- EKI-Schnittstelle;\\n- MOVEit + RViz;\\n- Umgebungsfelderübertragung;\\n- Bildkonverterdienst;\\n- Trajektorienzeichnungsmodul;\\n- Startauslöser.\\n\\nLassen Sie uns sie nacheinander starten.\\n\\n### Eki-Schnittstelle\\nStarten Sie auf KRC4 `eki_hw_interface`, auf NUC in einem neuen Terminal:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz und MOVEit\\nSie benötigen einen Planer und eine Simulation. Starten Sie sie mit\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Umgebung\\nSagen Sie dem Roboter, wo sich die Farbdose und die Leinwand befinden. Beachten Sie, dass es nicht notwendig ist, den Knoten `draw workspace` zu starten, der `tf_broadcaster` teilt die Größe der Leinwand mit. Es zeigt es nur nicht in RViz an.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Bilderprozessor\\nAlle eingehenden Bilder müssen verarbeitet werden. Starten Sie den Dienst.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nWenn es den Anruf erhält, verarbeitet es ein Bild mit einem HP-Filter und erstellt eine rosbag-Datei mit Trajektorien.\\n\\n### Trajektorien-Zeichner\\nDas Hauptskript hier ist der Trajektorien-Zeichner selbst. Es wartet auf das Bild, ruft den TextConverter-Service auf und zeichnet das Gemälde.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Schicken Sie dem Roboter ein Bild zum Zeichnen\\nDer Roboter hört auf ein bestimmtes ROS-Thema, in dem Sie den Pfad zu einem gewünschten Bild übergeben müssen. Das Bild sollte quadratisch sein (Breite entspricht Höhe) und aus Linien bestehen. Senden Sie den Pfad:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nDanach öffnen sich zwei Fenster, die die Konturen und die Spuren zeigen. Schließen Sie sie und sehen Sie Gaka-Chu beim Zeichnen zu. Achten Sie auf Sicherheit und seien Sie immer bereit, den Not-Aus-Knopf zu drücken.\\nWenn Gaka-Chu seine Kunst beendet hat, können Sie einen anderen Pfad zum Bild senden und der Maler wiederholt den gesamten Prozess.\\n\"}},{\"node\":{\"id\":\"169b87d1ba251bb5f83c740d13de7aee\",\"title\":\"Verbinden Sie ein Amazon FreeRTOS-Gerät über MQTT mit Robonomics\",\"path\":\"/docs/de/freertos-mqtt/\",\"content\":\"\\nHier ist die Demonstration, wie ein Mikrocontroller, der [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) ausführt, über MQTT mit dem Robonomics-Netzwerk verbunden werden kann. Bitte überprüfen Sie [dieses Repository](http://github.com/khssnv/freertos_mqtt_robonomics_example) für den Quellcode des Projekts.\\n\\nWir verwenden [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) mit der FreeRTOS-Distribution und der MQTT-Implementierung von [Espressif IoT Development Framework](https://github.com/espressif/esp-idf), während Espressif ein Anbieter des verwendeten Mikrocontrollers ist.\\n\\nEs gibt auch einen [PMS-3003](http://www.plantower.com/en/content/?107.html) Sensor zu Demonstrationszwecken. Der Sensor misst das Vorhandensein von Partikeln in der Luft und man kann ihn verwenden, um die Luftqualität abzuschätzen.\\n\\nDie Luftqualität ist kein Thema des Artikels, weitere Informationen dazu finden Sie auf der Website der WHO: [Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). Das Ziel des Systems ist es, Sensormessungen im Robonomics-Netzwerk zu veröffentlichen.\\n\\n## Hardware-Setup\\n\\nWir verbinden PMS3003 TXD PIN5 mit ESP32 DevKitC IO17, um Messungen über UART zu übertragen.\\nBeide Geräte benötigen auch Strom und eine gemeinsame Masse.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## Datenfluss\\n\\nUm Sensormessungen an das Robonomics-Netzwerk zu übermitteln, ist unser Ziel auf Firmware-Ebene, Daten von einem Sensor über das eingebettete Kommunikationsprotokoll, das er unterstützt (UART in unserem Fall), zu erhalten und an eine AIRA-Instanz über MQTT / TCP zu übergeben.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nIn unserem Beispiel verwenden wir die AIRA-Cloud-Bereitstellung, die über eine öffentliche IP-Adresse und einen zugewiesenen Domainnamen verfügbar ist.\\nAuf der AIRA-Instanz richten wir den `mosquitto` MQTT-Broker ein und abonnieren den Topic `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4`, um Nachrichten von MQTT zu erhalten.\\n\\nDann leiten wir die Nachrichten an den `robonomics io`-Writer weiter.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nJetzt sind die Daten im Robonomics-Netzwerk verfügbar und wir können sie erneut mit `robonomics io` lesen.\\n\\n## Firmware\\n\\nWir verwenden die [ESP-MQTT-Beispielanwendung mit TCP-Transport](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) als Basis.\\n\\nWir ändern nur `main/app_main.c` für die UART-Verbindung zum Sensor, die SNTP-Zeitsynchronisation und die periodische MQTT-Publisher-Routine.\\n\\nWenn Sie versuchen, das Projekt zu wiederholen und es Ihr erstes ESP-IDF-basiertes Projekt ist, folgen Sie bitte zunächst der [ESP-IDF-Programmieranleitung von Espressif](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step), um sich mit Firmware-Operationen wie Konfiguration, Build und Upload mit dem `idf.py`-Tool vertraut zu machen.\\n\\n### Wi-Fi-Konfiguration\\n\\nUm mit der in der Cloud bereitgestellten AIRA-Instanz zu kommunizieren, benötigt unser Mikrocontroller eine Internetverbindung.\\nWir verwenden das Wi-Fi des ESP32 dafür.\\nEspressif stellt Dienstprogramme zur Konfiguration des Onboard-Wi-Fi zur Verfügung.\\nIn unserem Beispiel verwenden wir eine Entwicklungsumgebung mit Ubuntu 20.04 GNU/Linux.\\nUm Wi-Fi zu konfigurieren, gehen wir zum Projektordner und starten das SDK-Konfigurationstool.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nDann setzen wir den SSID und das Passwort des Wi-Fi-Zugangspunkts in der `Example Verbindenion Konfiguration`-Sektion.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### MQTT-Endpunkt-Konfiguration\\n\\nEs gibt zwei Dinge, die für MQTT konfiguriert werden müssen.\\nDas erste ist die Adresse des MQTT-Brokers.\\nEs ist mit dem SDK-Konfigurationstool konfigurierbar.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nSetzen Sie `Broker URL` in der `Example Konfiguration`-Sektion.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nDas zweite ist das MQTT-Topic.\\nWir setzen es in der Firmware mit dem Projektnamen-Prefix gefolgt von unserer ESP32-MAC-Adresse.\\nDas ergibt `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` für unseren bestimmten Mikrochip.\\n\\n## Von MQTT zu Robonomics\\n\\nZuerst überprüfen wir, ob wir Daten per MQTT empfangen.\\nWir können uns für unseren Mosquitto MQTT-Broker-Topic anmelden, auf das das Gerät veröffentlicht.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nHier bringen wir das `mosquitto`-Paket in unsere Umgebung, um das `mosquitto_sub`-Dienstprogramm zu verwenden.\\nDann abonnieren wir das Thema, das in der Firmware festgelegt ist.\\nWir haben unsere Messungen erhalten, das bedeutet, dass AIRA die Daten über MQTT korrekt empfängt.\\nJetzt lassen Sie uns diese Nachrichten an das Robonomics-Netzwerk weiterleiten.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nHier verwenden wir das `robonomics`-Dienstprogramm, um Nachrichten im Pubsub-Kanal `/freertos_mqtt_robonomics_example` zu veröffentlichen.\\nWir geben `bootnodes` an, um sicherzustellen, dass mindestens eine Verbindung hergestellt wird.\\n\\nJetzt lesen wir diese Nachrichten aus demselben Pubsub-Kanal.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Verwendete ursprüngliche Ressourcen\\n\\n* ESP32 DevKitC-Pinbelegung von GoJimmys Blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* PSM3003-Datenstruktur und Decoder von OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Vielen Dank an alle!**\\n\"}},{\"node\":{\"id\":\"22bc4b6aebb16e04ce4f72f573202601\",\"title\":\"So bearbeiten Sie ein Wiki\",\"path\":\"/docs/de/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki ist Open Source. Korrekturen sind willkommen: Fehler beheben, Tippfehler, einige unklare oder veraltete Informationen, Übersetzung in jede Sprache. Du wirst ein [GitHub](https://github.com/) Konto brauchen.**\\n\\n\\n## Wie man bearbeitet\\n\\nWenn du Dokumente des Robonomics Wiki bearbeiten möchtest, folge bitte diesen Schritten\\n\\nStell sicher dass du hast [Node.js](https://nodejs.org/en/download/package-manager/) und [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) installiert.\\n\\n### 1. Repository klonen\\n\\nZuerst musst du das Wiki-Repository klonen:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nGehe zum Verzeichnis des Repositories und führe die folgenden Befehle aus:\\n\\n`mit npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`mit yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Lokal bereitstellen (entwickeln, entwickeln-m1)\\n\\nDann das Projekt lokal bereitstellen: \\n\\n```\\ngridsome develop\\n```\\n\\n> Wenn du den Fehler `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS` hast, führe den folgenden Befehl aus:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Pull Request erstellen\\n\\n[Pull Request erstellen](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) für [Wiki-Repo](https://github.com/airalab/robonomics-wiki)\\n\\n## Komponenten\\n\\n### Asciinema\\nDas Robonomics Wiki unterstützt Asciinema. Um Asciinema einzufügen, folge bitte diesen Anweisungen:\\n* Importiere die Komponente nach dem Frontmatter-Block `import Asciinema from '~/components/Asciinema.vue'`\\n* Füge sie als separaten Absatz ein `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, wobei vid die ID des spezifischen Asciicasts ist\\n\\n> Du kannst das Widget-Skript für einen bestimmten Asciicast erhalten, indem du auf den Link \\\"Einbetten\\\" auf der Asciicast-Seite klickst.\\n> Es sieht so aus:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Asciinema-Dokumentation](https://asciinema.org/docs/embedding)\\n\\nIm obigen Beispiel ist vid 14.\\n\\n### Code\\n\\nSie können Ihrem Code hilfreiche Extras hinzufügen: \\n\\n`Code mit Kopierbutton`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\noder `Code mit zusätzlicher Zeile`.\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Eigenschaften für Code-Helfer**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nDie Dokumentation im Robonomics Wiki enthält einen Frontmatter-Block. Er muss oben in der Markdown-Datei stehen und die Form eines gültigen YAML zwischen drei Bindestrichen haben. Zwischen den drei Bindestrichen kannst du folgende Optionen festlegen oder bearbeiten:\\n\\n```YAML\\n---\\ntitle: How to contribute # Titel für die Seite, du musst ihn nicht im Text duplizieren\\ncontributors: [positivecrash] # Hauptbeiträger (die diese Seite aktiv betreuen). GitHub-Benutzername erforderlich, ohne zusätzliche Symbole\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Installierenierenation\\n    # Verwendete Tools für Technologie-Tests\\n---\\n```\\n\\n### Grid \\nHilft, ein Rasterlayout für Elemente hinzuzufügen:\\n\\n- Verwende zuerst die Raster-Wrapper-Komponente: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- Und dann verwende so viele Raster-Element-Komponenten wie du möchtest innerhalb des Wrappers:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Eigenschaften für robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Bilder\\n\\n#### Wie man hochlädt \\nLade das Bild in den Ordner `/docs/images/url-deines-dokuments` hoch\\n* Wenn das Bild lokalisiert werden muss, füge sie alle in einen Ordner ein\\n* Verwende eine lokale Ergänzung im Namen der Bilder, wenn sie lokalisiert sind, z.B. `image_en.jpg`\\n* Stelle sicher, dass dein Bild weboptimiert ist und gleichzeitig gut aussieht\\n\\n#### Wie man einfügt \\n\\nEs gibt zwei Möglichkeiten, Bilder in deine Dokumente einzufügen:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nEs wird empfohlen, Bilder mit dem integrierten Tag `<robo-wiki-picture>` einzufügen, du kannst jedoch auch den Standardweg für Markdown-Dateien verwenden.\\n\\n</robo-wiki-note>\\n\\n`mit Beschriftung`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`oder ohne Beschriftung` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`oder einfaches Bild` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`oder einfaches Bild mit Beschriftung`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`Bild mit Alt-Text`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Eigenschaften für robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Notizen & Warnungen\\nDu kannst Notizen hinzufügen und ihnen bestimmte Typen zuweisen:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`Notiz mit Titel`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`Notiz mit Inhalt`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`Notiz mit Titel und Inhalt`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Eigenschaften für robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nDu kannst Tabs zu dem Dokument hinzufügen:\\n\\n- Verwende die Tabs-Wrapper-Komponente: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- Und dann verwende so viele Tab-Element-Komponenten wie du möchtest innerhalb des Wrappers:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`horizontale Tabs`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`vertikale Tabs`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`Tab-Element mit Rahmen`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Eigenschaften für robo-wiki-tabs (Wrapper)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Eigenschaften für robo-wiki-tab (Element)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Titel mit Anker\\nDu kannst benutzerdefinierte Titel mit Anker erstellen und ihnen einen bestimmten Wert geben\\n\\n`Titel mit Anker`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\noder\\n\\n`Titel ohne Anker`.\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Eigenschaften für robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Videos\\n\\nEs gibt zwei Möglichkeiten, Videos in deine Dokumente einzufügen:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nEs wird empfohlen, Videos mit dem integrierten Tag `<robo-wiki-video>` einzufügen, du kannst jedoch auch den Standardweg für Markdown-Dateien verwenden.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nDu musst das Format des Videos angeben\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Eigenschaften\\n\\n- Wenn du eine Datei mit einer Größe von mehr als <span style=\\\"color:#af1c1c\\\">10MB</span>, Bitte laden Sie es auf den Server hoch, nicht im Repo.\\n\\n- Du kannst beliebige Eigenschaften für [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Akzeptable Formate - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nDu kannst jedes YouTube-Video in das Dokument einbetten, indem du den Freigabelink als separaten Absatz ohne zusätzliche Anführungszeichen oder Tags einfügst, z.B.: `https://youtu.be/kQaSwNYHJQ8`\\n\\nWenn Sie jedoch eine automatische Wiedergabe benötigen, müssen Sie eine spezielle Komponente verwenden:\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Eigenschaften für robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## Wie man die Seitenleiste bearbeitet\\n\\nWenn du die Seitenleiste der Robonomics Wiki bearbeiten möchtest, folge bitte diesen Schritten:\\n\\n* Bearbeiten Sie die Datei `/data/sidebar_docs.yaml`.\\n\\n* Entscheiden Sie, wo Sie Ihre Dokumentation platzieren möchten.\\n\\n* Verwenden Sie gültiges YAML für `/data/sidebar_docs.yaml` und verlassen Sie sich auf die vorhandene Dateistruktur.\\n\\n* **WICHTIGER HINWEIS:** Wenn Sie dasselbe Dokument in verschiedenen Abschnitten/Unterabschnitten verwenden, z.B.: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Vorinstalliertes Image für Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nSTELLEN SIE SICHER, DASS SIE DEN `topic` PARAMETER WIE FOLGT HINZUFÜGEN: \\n\\n(damit die Navigation richtig funktioniert)\\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## So fügen Sie eine benutzerdefinierte Navigation für Dokumente hinzu \\n\\n* Bearbeiten Sie die Datei `/data/sidebar_docs.yaml`.\\n\\n* Suchen Sie das richtige Dokument und fügen Sie die Parameter `prev` und `next` wie folgt hinzu:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* Wenn Sie die Navigation vollständig entfernen möchten, fügen Sie den `withoutNav` Parameter hinzu:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* Wenn Sie nur die Navigation `vorherige Seite` oder `nächste Seite` entfernen möchten, fügen Sie den `withoutPrev` oder `withoutNext` Parameter hinzu:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\noder\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"65038870e35b86f24763767af03946fc\",\"title\":\"Benachrichtigt werden, wenn die Tür geöffnet wird\",\"path\":\"/docs/de/door-notification/\",\"content\":\"\\nIn diesem Artikel installieren Sie die Integration des Telegram-Bot-Benachrichtigers und konfigurieren eine Automatisierung, die Ihnen eine Benachrichtigung auf Ihr Telegram-Konto sendet, wenn eine Tür geöffnet wird.\\n\\n## Telegram Bot Benachrichtigungen\\n\\nZuerst müssen Sie einen persönlichen Telegram-Bot erstellen. Gehen Sie dazu zum [speziellen Telegram-Bot @BotFather](https://t.me/botfather) und folgen Sie den Anweisungen. \\nSpeichern Sie Ihren Token zum Zugriff auf die HTTP-API.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nBewahren Sie Ihren Token **sicher** auf und speichern Sie ihn **sicher**, er kann von jedem verwendet werden, um Ihren Bot zu steuern. \\n\\n</robo-wiki-note>\\n\\nDer nächste Schritt besteht darin, Ihre ***User Chat ID***. Zu diesem Zweck verwenden Sie das folgende [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nInstallierenierenieren Sie nun die Integration \\\"Telegram Broadcast\\\". Diese Integration sendet Nachrichten an Ihr Telegram.\\n\\nFür das vorinstallierte Robonomics-Image, Home Assistant Docker oder Home Assistant Core müssen Sie `configuration.yaml` bearbeiten. Verbinden Sie sich über `ssh` mit Ihrem Raspberry Pi:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nFügen Sie die folgenden Zeilen am Ende der Datei ein. Geben Sie Ihre **bot API key** und **your User Chat ID** ein. Erstellen Sie auch einen Namen für Ihren Benachrichtigungsdienst:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Speichern Sie die Konfiguration und laden Sie Home Assistant neu.**\\n\\n\\nAls Ergebnis wird in Ihrem Home Assistant-Dienst ein Dienst erstellt, der jede Nachricht an den Telegram-Chat mit Ihnen sendet. \\nSie können dies im Menü Entwicklertools auf der Home Assistant-Web-Oberfläche überprüfen. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Benachrichtigung bei geöffneter Tür\\n\\nJetzt ist es an der Zeit, eine Automatisierung zu erstellen. Importieren Sie zuerst das Blueprint in Ihren Home Assistant von diesem Link:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nUnd erstellen Sie die Automatisierung:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nJetzt erhalten Sie jedes Mal eine Nachricht vom Telegram-Bot, wenn die Tür geöffnet wird.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nSie können diese Automatisierung mit beliebigen Türen/Fenstern in Ihrem Zuhause verwenden.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"6aa63e87e78c621f601bf0d989f3e683\",\"title\":\"Datenprotokoll\",\"path\":\"/docs/de/datalog/\",\"content\":\"\\n**Jetzt, da Sie etwas Geld auf Ihrem Konto haben, können Sie Extrinsiken einreichen. Der erste Versuch ist ein Datalog. Es ermöglicht Ihnen, Daten dauerhaft in der Blockchain zu speichern. Stellen Sie sich einen verteilten und kryptogeschützten Speicher für Ihre Daten vor, und das ist es!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nBitte beachten Sie, dass dieses und die folgenden Tutorials auf einer lokalen Instanz von Robonomics Node demonstriert werden. Richten Sie Ihr eigenes mit ein [diesen Anweisungen](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navigieren Sie zu  Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Wählen Sie datalog -> record aus der Dropdown-Liste der möglichen Extrinsics\\n\\nWählen Sie auch ein Konto aus, mit dem Sie den Extrinsischen übermitteln möchten. Füllen Sie das Feld record aus.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog unterstützt einen String mit maximal 512 Bytes. Um eine große Menge an Daten zu speichern, kann man [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Übermitteln Sie die Transaktion\\n\\nUnterzeichnen und übermitteln Sie die Transaktion mit einem zuvor erstellten Konto über die Erweiterung oder die DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  Sie können auch **ALLE** Ihre Aufzeichnungen mit *datalog -> erase* aufrufen.\\n\\n</robo-wiki-note>\\n\\n## 4. Überprüfen Sie Ihr Datalog im Speicher\\n\\nDazu navigieren Sie zu *Developer -> Chain state*, auswählen *datalog -> datalogIndex*, geben Sie Ihr Konto an und drücken Sie die \\n\\\"+\\\" Taste, um die Indizes Ihrer Konten aufzurufen und dann denjenigen zu erkunden, den Sie benötigen mit *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erkundenr\\\">\\n\\n  Alle Ereignisse, einschließlich des Datalog-Eintrags, können im Ereignisfluss im *Explorer* gesehen werden..\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"266f34ea8ac49afc63293bac54603e12\",\"title\":\"Digitale Zwillinge\",\"path\":\"/docs/de/digital-twins/\",\"content\":\"  \\n**Stellen Sie sich vor, Sie haben ein kompliziertes Gerät oder System mit mehreren Modulen, die gewartet werden müssen und für die mehrere Konten verwendet werden müssen. Um alle an einem Ort zu halten oder bestimmte Funktionen mit separaten Konten zu codieren oder zum Beispiel unterschiedliche Datenspeicherquellen für unterschiedliche Informationsflüsse festzulegen, wird das Modul Digital Twin verwendet.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Bitte beachten Sie, dass diese und die folgenden Tutorials an einer lokalen Instanz des Robonomics Node demonstriert werden. Richten Sie Ihre eigene mit [diesen Anweisungen](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Theorieübersicht\\nJedes Konto kann einen Digitalen Zwilling erstellen und verwalten. Der Zwilling kann als eine Art Tabelle mit folgendem Inhalt betrachtet werden:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nWo:\\n* **DT id** ist eine eindeutige Ganzzahl, die den Digitalen Zwilling indexiert.\\n* **Topic name** ist eine hexadezimale `H256` oder ASCII-Daten mit einer Länge von 32 Bytes, genauso wie [`Start`](/docs/launch) extrinsischer Parameter. \\nZum Beispiel: `0x1234....FF` oder `hello.parachain.robonomics.world`.\\n* **Source** - ist eine Kontoadresse.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  Wie bereits in der Übersicht über den Start-Extrinsik besprochen, kann die `H256` als codierte IPFS CID dargestellt werden (siehe\\n  [Python-Tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) dafür).\\n  Daher können Themen auch als Datenspeicher verwendet werden, zum Beispiel eine Modulbeschreibung eines Zwillings.\\n\\n</robo-wiki-note>\\n\\n\\n## Digitalen Zwilling erstellen\\n\\n### 1. Gehe zu Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Wähle digitalTwin -> create aus der Dropdown-Liste der möglichen Extrinsiken\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nSende die Transaktion ab. Hier sind keine Parameter erforderlich, um einen Zwilling zu erstellen. Ihm wird ein Index zugewiesen und nur der Besitzer des Digitalen Zwillings kann ab sofort Themen des Zwillings hinzufügen/ändern.\\n\\nDie Zwilling-ID kann auf der Übersichtsseite des Erkundenrs gefunden werden.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Thema hinzufügen\\n\\n### Wähle digitalTwin -> setSource aus der Dropdown-Liste der möglichen Extrinsiken\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID, die auf der Explorer-Seite abgerufen wurde.\\n* `topic` - zuvor diskutierter `H256` Thema-Name. In diesem Bild ist es eine Zeichenkette mit 32 Symbolen.\\n* `source` - Kontoadresse, die mit dem Thema verknüpft werden soll.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Beachten Sie, dass das Thema bei Bedarf mit einer anderen Quelladresse überschrieben werden kann.\\n\\n</robo-wiki-note>\\n\\nUnterschreiben und senden Sie den Extrinsik.\\n\\n## Explore\\n\\nSie können alle Informationen über vorhandene Digitale Zwillinge im Speichermodul `digitalTwin` unter `Developer -> Chain State` finden.\\n\\n- Gesamtzahl der Zwillinge - `total()`;\\n- Besitzer des Digitalen Zwillings - `owner(u32)`;\\n- Informationen zu Themen eines Digitalen Zwillings - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"cd3d11c660ac15c0bc08fa7d142a98c5\",\"title\":\"Erstellen Sie eine digitale Identität, die von Ethereum betrieben wird\",\"path\":\"/docs/de/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nEiner der Robonomics-Dienste ist [Digitale Passregistrierung](https://dapp.robonomics.network/#/passport/) für beliebige Daten. Der Dienst ermöglicht es Ihnen, eine digitale Identität zu erstellen, indem Sie die Hashes der Daten in die öffentliche Blockchain speichern und eine eindeutige Adresse zuweisen.\\n\\nSie finden den Service \\\"Digitale Reisepassregistrierung\\\" im [Robonomics DApp](https://dapp.robonomics.network/) Abschnitt \\\"Dienstleistungen\\\" oder folgen Sie einfach diesem [Direktlink](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Video-Anleitung\\n\\nDas folgende Video zeigt den Fortschritt der Robonomics-Whitepaper-Registrierung:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Schritt-für-Schritt in Bildern\\n\\n### 1. Öffnen Sie den Service\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Folgen Sie die erforderlichen Informationen und Dateien hinzu\\n\\nBitte beachten Sie, dass es möglich ist, mehrere Bilder hinzuzufügen.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Unterschreiben Sie die Anforderung\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Genehmigen Sie Tokens\\n\\nDer Service berechnet eine geringe Gebühr. Aber zuerst müssen Sie die erforderliche Anzahl von Tokens genehmigen, die von Ihrem Konto ausgegeben werden sollen.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Akzeptieren Sie das Angebot und unterschreiben Sie die Nachricht erneut\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Werfen Sie einen Blick auf den erstellten Reisepass\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nDer Registrierungsprozess dauert einige Zeit. Am Ende erhalten Sie einen Link zur erstellten Identität.\\n\"}},{\"node\":{\"id\":\"251c6556efbfc6a9353aec6fdaaf5b53\",\"title\":\"Konto für Robonomics Parachain erstellen\",\"path\":\"/docs/de/create-account-in-dapp/\",\"content\":\"\\n**Um mit Robonomics Parachain interagieren und arbeiten zu können, müssen Entwickler und Benutzer ein Konto auf dem Polkadot/Substrat-Portal erstellen. Das Konto führt grundlegende Funktionen für das Netzwerk aus: Ihre öffentliche Netzwerkadresse (der öffentliche Schlüssel), die Zugriffskontrolle auf die Adresse und Gelder (der private Schlüssel), das Senden von Transaktionen an das Netzwerk, die Anzeige Ihrer Token und deren Betrag usw. Nachfolgend finden Sie diese Es gibt zwei Hauptmethoden, um ein Konto für Robonomics Parachain zu erstellen.**\\n\\n## 1. Verwendung der Polkadot{.js} Browser-Erweiterung\\n\\nDie Polkadot-Erweiterung bietet einen Mechanismus zur Generierung des Kontos und zur Interaktion mit allen Polkadot / Kusama-Projekten, einschließlich Robonomics Parachain. Dies ist nicht der sicherste Weg, Ihr Konto zu verwalten, aber er ist in Bezug auf Sicherheit / Benutzerfreundlichkeit am bequemsten ausbalanciert.\\n\\n## 1.1. Browser-Erweiterung installieren\\n\\nDie Browser-Erweiterung ist verfügbar für [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) and [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (plus Chromium-basierte Browser).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Robonomics Parachain-App öffnen\\n\\nGehe zu [Robonomics Parachain-App](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) im Polkadot / Substrate-Portal. Wenn Sie zum ersten Mal das Portal betreten, wird es um Zugriff auf die Browser-Erweiterung bitten, also erlauben Sie den Zugriff. \\n\\nNachdem Sie die App geöffnet haben, werfen Sie einen Blick in die obere linke Ecke. Darin werden der Name des Netzwerks, sein Symbol und die Nummer des letzten Blocks angezeigt. Wenn Sie auf diesen Bereich klicken, wird eine Liste aller Polkadot-/Kusama-Netzwerke geöffnet, einschließlich Testnetzwerke und lokaler Knoten. Sie können zwischen den Netzwerken wechseln, indem Sie das gewünschte Netzwerk auswählen  und klicken Sie aufing the `Switch` Taste drücken. **Stellen Sie sicher, dass Sie jetzt mit Robonomics Parachain verbunden sind**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Erweiterungsmetadaten aktualisieren\\n\\nEs ist sehr wahrscheinlich, dass die App Sie auffordert, die Metadaten für die Erweiterung zu aktualisieren, um die korrekten Informationen über die mit Ihnen verbundene Kette anzuzeigen. Gehen Sie zu **Settings -> Metadata**, drücken Sie die `Update metadata` Taste und erlauben Sie dann in dem Popup-Fenster der Erweiterung, dies zu tun. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Konto in der Erweiterung erstellen\\n\\nÖffnen Sie die Polkadot{.js} Browser-Erweiterung. Klicken Sie auf die große Plus-Taste oder wählen Sie `Create new account` aus dem kleinen Plus-Symbol oben rechts aus. Sie sollten das folgende Menü sehen, mit generiertem mnemonischen Seed in Form von zwölf Wörtern und der Adresse. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nDer Seed ist Ihr Schlüssel zum Konto. Wenn Sie den Seed kennen (oder jemand anderes, der den Seed kennt), können Sie die Kontrolle über dieses Konto übernehmen und es sogar neu erstellen, wenn Sie das Passwort vergessen. **Es ist sehr wichtig, ihn sicher aufzubewahren**, am besten auf Papier oder einem anderen nicht-digitalen Gerät, nicht in digitaler Speicherung oder auf einem Computer. \\n\\nSpeichern Sie den Seed und drücken Sie `Next step`. Sie sollten das folgende Menü sehen.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* ermöglicht es Ihnen, auszuwählen, für welches Netzwerk dieses Konto ausschließlich verwendet werden soll. Sie können dieselbe Adresse in mehreren Netzwerken verwenden, es wird jedoch aus Datenschutzgründen empfohlen, für jedes verwendete Netzwerk eine neue Adresse zu erstellen. \\nWählen Sie das Robonomics-Netzwerk aus der Dropdown-Liste aus. Wenn Sie das Robonomics-Netzwerk nicht finden konnten, haben Sie wahrscheinlich die Metadaten nicht aktualisiert. Gehen Sie zurück und tun Sie dies.\\n\\n    - Sie werden feststellen, dass sich das Format der Adresse und das Kontosymbol ändern - das ist normal. Unterschiedliche Netzwerkformate sind lediglich andere Darstellungen desselben öffentlichen Schlüssels. \\n\\n- *Name* ist nur der Kontoname für Ihren eigenen Gebrauch. Er wird nicht auf der Blockchain gespeichert und für andere Benutzer nicht sichtbar sein. \\n\\n- *Password* wird verwendet, um die Informationen Ihres Kontos zu verschlüsseln. Sie müssen es erneut eingeben, wenn Sie Transaktionen im Portal signieren. Erstellen Sie einen und merken Sie ihn sich.\\n\\nNach dem Erstellen eines Kontos sehen Sie es in der Liste der Konten in der Polkadot{.js}-Erweiterung. Durch Klicken auf drei Punkte können Sie das Konto umbenennen, exportieren, aus der Erweiterung entfernen und das für das Konto verwendete Netzwerk ändern. \\n\\nAußerdem wird das Konto in der **Accounts -> Accounts** Menü auf dem Portal, wo vermerkt wird, dass die Erweiterung unter Verwendung der gleichen Seeds injiziert wurde.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Direkt in der Robonomics Parachain App\\n\\nSie können die Benutzeroberfläche im Polkadot / Substrate Portal verwenden, um ein Konto zu erstellen. Es kann für Entwicklung und Tests verwendet werden. \\n\\n## 2.1. Öffnen Sie die Robonomics Parachain App\\n\\nGehe zu [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) im Polkadot / Substrate Portal. **Überprüfen Sie oben links, ob Sie mit Robonomics Parachain verbunden sind**.  \\n\\nGehe zu **Accounts -> Accounts** und klicken Sie auf die Schaltfläche „Konto hinzufügen“.\\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Konto erstellen\\n\\nSie sollten das folgende Popup-Menü mit dem Kontosamen sehen. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nEs hat zwei Formen: *Mnemonic* (lesbar für Menschen) und *Raw* (eine Sequenz von Zahlen und Buchstaben). Speichern Sie den Seed-Satz sicher und drücken Sie `Next`.\\n\\n> Sie können auch den Kryptotyp für die Kontoerstellung ändern, indem Sie `Advanced creation options` öffnen und den Typ (`ed25519` auf dem Bild auswählen).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nIm nächsten Menü müssen Sie den Kontonamen und das Passwort festlegen, ähnlich den oben beschriebenen Anweisungen für die Erweiterung.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nDurch Klicken auf die Schaltfläche `Next` gelangen Sie zum letzten Fenster. Klicken Sie auf `Save` um die Kontoerstellung abzuschließen. Es wird auch eine Sicherung der JSON-Dateien generiert, die Sie sicher aufbewahren sollten. Sie können diese Datei später verwenden, um Ihr Konto wiederherzustellen, wenn Sie sich an das Passwort erinnern.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Fügen Sie dem Polkadot-Extension-Konto ein ed25519-Konto hinzu\\n\\nMöglicherweise müssen Sie das erstellte Konto zur Polkadot.js-Erweiterung hinzufügen (für ein ed25519-Konto können Sie dies nur mit der Sicherungs-JSON-Datei tun). Dazu müssen Sie eine Sicherungsdatei des Kontos erstellen. Klicken Sie auf die drei Punkte neben Ihrem Konto und wählen Sie `Create a backup file for this account` und geben Sie Ihr Passwort ein.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nÖffnen Sie dann eine Erweiterung und klicken Sie oben rechts auf die Schaltfläche `+` und wählen Sie `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nIm geöffneten Fenster ziehen Sie die gespeicherte Datei, geben Sie das Passwort ein und klicken Sie auf `Restore`.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. Konto erfolgreich erstellt \\n\\nJetzt können Sie vollständig mit Ihrem frisch erstellten Konto arbeiten. Senden und empfangen Sie Tokens, Nachrichten, schreiben Sie Datenprotokoll und vieles mehr. Erkunden Sie alle Funktionen der App. Um die Adresse Ihres Kontos zu kopieren, klicken Sie einfach auf das Symbol, die Adresse wird in die Zwischenablage kopiert. \\n\\nWenn Sie mehr über Polkadot / Kusama-Konten und zusätzliche Möglichkeiten, sie zu erstellen, erfahren möchten, finden Sie weitere Informationen [hier](https://wiki.polkadot.network/docs/learn-accounts) und [hier](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"6a1c54b2291cb732a861570efa2732f7\",\"title\":\"Wie man zu Robonomics-Ressourcen beiträgt\",\"path\":\"/docs/de/contributing/\",\"content\":\"\\nRobonomics Network ist ein Open-Source-Projekt und wir möchten es jedem leicht machen, einen Beitrag zu leisten. Sie können Artikel erstellen, Änderungen vorschlagen, die Dokumentation verbessern oder Tests durchführen. Wenn Sie einen Beitrag leisten möchten, öffnen Sie bitte ein neues Problem oder erstellen Sie eine Pull-Anfrage im selben Repository.\\n\\n## Haupt-Robonomics-Repositories \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Haupt-Wiki-Projekt\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Offizielle Hauptwebsite des Robonomics Network\\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Start für Robonomics-Webdienste\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Offizielle Dapp\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Offizielle Website der Robonomics Academy\\n\\n### Regeln für die Berichterstattung\\n\\nWenn Sie ein neues Problem öffnen, vergessen Sie nicht ein paar grundlegende Regeln für die Berichterstattung:\\n\\n1. Wählen Sie das genaue Repository aus, für das Sie ein Problem melden möchten.\\n\\n2. Stellen Sie sicher, dass der Fehler nicht bereits gemeldet wurde.\\n\\n3. Geben Sie unbedingt einen Titel und eine klare Beschreibung sowie so viele relevante Informationen wie möglich an.\\n\\n4. Bitte kennzeichnen Sie Ihr Problem mit einem der folgenden Präfixe: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Pull-Anfragen\\n\\nJedes Robonomics-Repository kann Pull-Requests oder Änderungen von Mitwirkenden unterliegen, wenn Sie der Meinung sind, dass Sie etwas Wertvolles hinzufügen oder ändern möchten. Bitte vergessen Sie nicht die Grundregeln für Mitwirkende.\\n\\n### Regeln für die Mitwirkung\\n\\n1. Pull-Anfragen werden bevorzugt, wenn Sie Korrekturen haben, insbesondere für kleine Änderungen wie Tippfehler.\\n\\n2. Stellen Sie sicher, dass die Beschreibung der Pull-Anfrage das Problem und die Lösung klar beschreibt. Geben Sie die relevante Problemnummer an, falls zutreffend.\\n\\n3. Bitte beheben Sie keine Leerzeichen, formatieren Sie den Code oder führen Sie einen rein kosmetischen Patch durch.\\n\\n4. Bitte versuchen Sie, dem vorherrschenden Markdown-Stil, der Sprache und dem Layout zu folgen.\\n\\n\\n\"}},{\"node\":{\"id\":\"ce97bd87d6b0503a93bd58946aa7bdae\",\"title\":\"Offsetting-Dienst\",\"path\":\"/docs/de/carbon-footprint-service/\",\"content\":\"\\nBeispiel für die Arbeit ist im Video:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nDienst zur Kompensation des CO2-Fußabdrucks durch Verbrennen von Token im Statemine-Netzwerk. \\nDer produzierte CO2-Wert wird wie folgt berechnet: Daten vom Gerät in Wh multipliziert mit Koeffizienten, die von der Region abhängen. 1 Tonne CO2 wird durch den Verbrauch von 1 Token abgedeckt. [Hier](/docs/carbon-footprint-sensor) sind die Anweisungen zum Anschließen des Geräts.\\n\\n## Szenario\\n\\n1. Registrieren Sie ein neues Gerät im Digital Twin im Robonomics-Netzwerk\\n2. Einmal in einem Intervall werden die letzten Daten von allen Geräten abgerufen mit dem Koeffizienten je nach Region multiplizieren\\n3. Daten summieren und in CO2-Tonnen umrechnen\\n4. Die Gesamtzahl der verbrannten Token von den aktuellen Daten abziehen \\n5. Eine ganze Zahl von Token im Statemine-Netzwerk verbrennen \\n6. Die Gesamtzahl der verbrannten Token in der lokalen Datenbank und im Datenprotokoll speichern \\n\\n\\n## Installierenierenation\\n\\nDas Repository klonen und die Konfigurationsdatei bearbeiten.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Konfiguration description\\n\\nNicht bearbeiten `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network whier Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nDie Koeffizienten für nicht erneuerbare Energie wurden von Eurostat übernommen und in Start gespeichert. [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) und gespeichert in `utils/coefficients.py`. \\n\\n## Start\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"cad12c8b5dda2eef4cfa42e5e2943d56\",\"title\":\"Sensor verbinden\",\"path\":\"/docs/de/carbon-footprint-sensor/\",\"content\":\"\\nBeispiel für die Arbeit ist im Video:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Anforderungen\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (oder eine von [unterstützt](https://www.zigbee2mqtt.io/information/supported_adapters.html))\\n\\nDer Dienst läuft auf Raspberry Pi und kontaktiert den Smart Plug über das ZigBee-Protokoll.\\n\\n## Zigbee-Stick\\n\\nWenn Sie den JetHome USB JetStick Z2 haben, verfügt er bereits über die erforderliche Firmware, sodass Sie ihn nicht flashen müssen. Wenn Sie jedoch einen anderen Adapter haben, müssen Sie ihn zuerst mit der zigbee2MQTT-Software flashen. Anweisungen für Ihr Gerät finden Sie [hier](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nVerbinden Sie den Adapter und überprüfen Sie die Adapteradresse (es kann auch sein `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nMöglicherweise müssen Sie zuerst Zugriff auf den USB-Anschluss erhalten. Fügen Sie Ihren Benutzer hinzu `dialout` Gruppe (funktioniert für Ubuntu, aber der Name der Gruppe kann auf anderen Betriebssystemen unterschiedlich sein).\\n\\nFür Ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\n\\nFür Arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nMelden Sie sich dann ab und wieder an oder starten Sie den Computer neu.\\n\\n## Installierenierenation\\n\\nKlonen Sie das Repository:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Konfiguration\\n\\nGehe zu `data/configuration.yaml` und setze `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nMöglicherweise möchten Sie auch die Felder `server` and `port` mit entsprechenden Informationen ausfüllen. Im `server` Feld verwenden Sie die IP der `docker0` Bridge, um die Verbindung herzustellen: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nHier ist Ihre Adresse `172.17.0.1`.\\n\\nErstellen Sie dann die Datei config/config.yaml mit folgenden Informationen und setzen Sie Ihren Standort (Sie können unter https://countrycode.org/ nach dem 3-Buchstaben-ISO-Code suchen):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Stecker verbinden\\n\\nErster Start:\\n\\n```\\ndocker-compose up     \\n```\\n\\nUm in den Pairing-Modus am Stecker zu wechseln, drücken Sie einige Sekunden lang die Ein-/Aus-Taste, bis das Licht schnell blau zu blinken beginnt.\\n\\nIn den Protokollen sollten Sie nun sehen, dass Ihr Plug mit der Veröffentlichung in mqtt begonnen hat.\\n\\n\\n## Nach dem Pairing\\n\\nWenn Sie nicht möchten, dass andere Geräte sich mit Ihrem Stick verbinden können, sollten Sie jetzt erneut zu `data/configuration.yaml` und set `permit_join: false`. Restart service (use 'Ctrl+C' und \\n\\n```bash\\ndocker-compose up     \\n```\\ngehen um die Änderungen zu übermitteln).\\n\\n## Laufen\\nBeim ersten Start wird das Konto für den Stecker erstellt. \\n> Wenn Sie bereits ein Konto haben, sollten Sie dessen Seed hinzufügen `config.config.yaml` Datei in `device_seed` Abschnitt:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nNachdem das Konto erstellt wurde, sehen Sie die Adresse in den Protokollen (der Seed wird hinzugefügt, um `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nSie müssen einige Token auf dieses Konto übertragen, um Transaktionsgebühren zu bezahlen. Sie können dies auf der [Robonomics-Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nDer Dienst erkennt, dass Sie genügend Token haben. In den Protokollen sehen Sie:\\n```\\nplug               | Balance is OK\\n```\\nDer Dienst empfängt MQTT-Nachrichten vom Stecker und überwacht den Stromverbrauch. Alle Stunden (Sie können den Timeout in `config/config.yaml` in `sending_timeout` Abschnitt ändern, der Timeout erfolgt in Sekunden) wird ein Datenprotokoll mit folgenden Informationen erstellt:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"395bf4af3d463c2b7bd295f5c0f1a285\",\"title\":\"Backup-Dienste\",\"path\":\"/docs/de/backup-services/\",\"content\":\"\\n**In diesem Artikel erfahren Sie, wie Sie Backups Ihrer Home Assistant-Konfiguration erstellen und diese bei Bedarf wiederherstellen können. Um Backups zu erstellen, wird ein Dienst aufgerufen, der ein sichiers Archiv mit Konfigurationsdateien generiert. Der Dienst fügt außerdem die Mosquitto-Broker- und Zigbee2MQTT-Konfiguration zum Backup hinzu, sofern vorhsind. Diese Pfade können jedoch je nach Ihrer spezifischen Konfiguration variieren.en. Anschließend wird das Archiv zu IPFS hinzugefügt und die resultierende CID im Robonomics Digital Twin gespeichert.**\\n\\n## Erstellen eines Backups der Home Assistant-Konfiguration\\n\\nDurch das Erstellen eines Backups können Sie Ihre Home Assistant-Konfiguration bei einem Ausfall problemlos wiederherstellen.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNUNG\\\">\\n\\nUm Ihre Konfiguration zu sichern und wiederherzustellen, ist es erforderlich, einen **benutzerdefinierten IPFS-Gateway** wie Pinata zu verwenden. Ohne dies wird Ihr Backup ausschließlich auf Ihrem lokalen IPFS-Knoten gespeichert, was Sie daran hindern kann, Ihre Home Assistant-Konfiguration im Falle eines Ausfalls des lokalen Knotens wiederherzustellen.\\n\\n</robo-wiki-note>\\n\\n1. Gehen Sie in der Web-Oberfläche von Home Assistant zu `Developer Tools` -> `Services`. Suchen Sie nach `Robonomics: Save Backup to Robonomics` und klicken Sie auf `CALL SERVICE`.\\n\\n2. Warten Sie, bis die Benachrichtigung `Backup was updated in Robonomics` in `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNUNG\\\">\\n\\nVersuchen Sie nicht, sofort nach dem Laden von Home Assistant und Robonomics Integration ein Backup zu erstellen oder die Konfiguration wiederherzustellen. Bitte **warten Sie etwa 5 Minuten** um die anfängliche Einrichtung abzuschließen.\\n\\n</robo-wiki-note>\\n\\nDienstargumente:\\n- **Vollständiges Backup**  (default: False) - fügt die Datenbank dem Backup hinzu, sodass der Verlauf der Entitätszustände ebenfalls gespeichert wird.\\n- **Pfad zur Mosquitto-Passwortdatei** (default: `/etc/mosquitto`) - Wenn Sie die Home Assistant Core- oder Docker-Installierenierenationsmethoden verwendet haben und keinen Standardpfad zum Mosquitto-Broker haben, sollten Sie diesen Parameter ändern. *Für Home Assistant OS oder Superviser nicht erforderlich*.\\n\\n## Wiederherstellen der Home Assistant-Konfiguration aus dem Backup\\n\\nUm Ihre Konfiguration wiederherzustellen, benötigen Sie eine installierte Home Assistant- und Robonomics-Integration. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNUNG\\\">\\n\\nUm eine erfolgreiche Wiederherstellung Ihrer Konfiguration in Home Assistant Core und Docker-Installationsmethoden zu gewährleisten, müssen Sie zusätzliche Einrichtungsschritte durchführen, wie am Ende der Seite beschrieben.\\n\\n</robo-wiki-note>\\n\\n1. Installieren Sie Home Assisntant mit Robonomics Integration (falls noch nicht installiert), indem Sie den Schritten aus dem Artikel für die [gewünschte Installationsmethode](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2. [Richten Sie die Robonomics-Integration ein](https://wiki.robonomics.network/docs/robonomics-hass-integration) unter Verwendung der gleichen Seeds **die Sie in der vorherigen Robonomics-Konfiguration verwendet haben. Wenn Ihr Abonnement abgelaufen ist,** reaktivieren Sie es [3. Gehen Sie in der Web-Oberfläche von Home Assistant zu](https://wiki.robonomics.network/docs/sub-activate).\\n\\nNavigieren Sie zur `Developer Tools` -> `Services`. Suchen `Robonomics: Restore from the Backup in Robonomics` and drücken Sie die `CALL SERVICE`. Seite, um den Status Ihres Backups zu überprüfen. `Overview` Seite, um den Status Ihres Backups zu überprüfen.\\n\\n4. Nach der Wiederherstellung wird Home Assistant automatisch neu gestartet. Wenn aus irgendeinem Grund Home Assistant nicht neu startet, können Sie den Wiederherstellungsstatus überwachen, indem Sie den Zustand der `robonomics.backup` Entity überwachen. Wenn der Status `restored` ist, müssen Sie Home Assistant manuell neu starten, indem Sie zu `Settings` > `System` und klicken Sie auf `RESTART` Schaltfläche in der oberen rechten Ecke klicken.\\n\\n5. Wenn Ihr Backup die Konfiguration von Zigbee2MQTT oder Mosquitto enthält, müssen Sie diese Dienste neu starten, um die neue Konfiguration zu aktivieren. Sie können dies manuell tun, indem Sie die Dienste einzeln neu starten, oder Sie können einfach den Home Assistant-Computer neu starten, um sicherzustellen, dass alle Dienste neu gestartet werden.\\n\\nService-Argumente:\\n- **Pfad zur Mosquito-Passwortdatei** (default: `/etc/mosquitto`) - Pfad zur Zigbee2MQTT-Konfiguration *Für Home Assistant OS oder Superviser nicht erforderlich*.\\n- **Pfad zur Zigbee2MQTT-Konfiguration**  (default: `/opt/zigbee2mqtt`) - Wenn Sie die Home Assistant Core- oder Docker-Installationsmethoden verwendet haben und keinen Standardpfad zu Zigbee2MQTT haben, sollten Sie diesen Parameter ändern. *Für Home Assistant OS oder Superviser nicht erforderlich*.\\n\\n\\n## Wiederherstellen der Mosquitto- und Zigbee2MQTT-Konfiguration für die Home Assistant Core-Installationsmethode\\n\\nWenn das Backup die Konfiguration für Mosquitto oder Zigbee2MQTT enthält, werden sie während des Wiederherstellungsprozesses im Standardpfad oder im in den Argumenten angegebenen Pfad abgelegt. Wenn Sie jedoch die Robonomics-Integration in einem vorhandenen Home Assistant Core installiert haben *(nicht aus dem vorinstallierten Robonomics-Image)*, `homeassistant` kann der Benutzer möglicherweise keinen Zugriff auf diesen Pfad haben.\\n\\n(nicht aus dem vorinstallierten Robonomics-Image) *kann der Benutzer möglicherweise keinen Zugriff auf diesen Pfad haben.*, the `homeassistant` Um die Konfiguration von Mosquitto und Zigbee2MQTT wiederherzustellen, müssen Sie dem Benutzer die erforderlichen Leseberechtigungen gewähren\\n\\nUm die Konfiguration von Mosquitto und Zigbee2MQTT wiederherzustellen, müssen Sie dem Benutzer die erforderlichen Leseberechtigungen gewähren `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Backup der Mosquitto- und Zigbee2MQTT-Konfiguration für die Home Assistant Docker-Installationsmethode\\n\\nUm die Mosquitto- und Zigbee2MQTT-Konfigurationen aus einem Docker-Container zu sichern, müssen Sie Volumes für ihre jeweiligen Konfigurationen erstellen. Dies kann erreicht werden, indem Sie Ihren Home Assistant-Container mit zusätzlichen Argumenten ausführen:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\noder Änderungen in Ihrer `compose.yaml` File.\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nBitte beachten Sie, dass die Standardpfade für die Mosquitto- und Zigbee2MQTT-Konfigurationen `/etc/mosquitto` und `/opt/zigbee2mqtt` sind. Diese Pfade können jedoch je nach Ihrer spezifischen Konfiguration variieren.\\n\\n</robo-wiki-note>\\n\\n## Backup-Schaltflächen\\n\\nZusätzlich zur Verwendung von Diensten zur Arbeit mit Backups können Sie den Vorgang vereinfachen, indem Sie die `button.create_backup` und  `button.restore_from_backup` Schaltflächen aus der Robonomics-Integration verwenden. Diese Schaltflächen rufen die entsprechenden Dienste mit den Standardparametern auf (die Backup-Schaltfläche erstellt ein Backup ohne Verlauf).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nUm Schaltflächen zu Ihrem Dashboard hinzuzufügen, befolgen Sie diese Schritte:\\n\\n1. Klicken Sie auf die drei Punkte in der oberen rechten Ecke des Dashboards.\\n2. Wählen Sie `Edit Dashboard`.\\n3. Klicken Sie auf die `Add Card` Schaltfläche in der unteren rechten Ecke.\\n4. Wählen Sie die `Entities` \\n5. Im Feld `Entities` suchen Sie nach den Entitäten button.create_backup und button.restore_from_backup.\\n6. Drücken Sie `Save`um die Entitäten zur Karte hinzuzufügen. \\n7. Beenden Sie die Bearbeitung, indem Sie auf die Schaltfläche in der oberen rechten Ecke klicken `Done` Schaltfläche in der oberen rechten Ecke.\"}},{\"node\":{\"id\":\"08e3823e98b73c00ff3870c0fb2bcab1\",\"title\":\"Guthaben auf Ihr Konto im Robonomics-Portal einzahlen\",\"path\":\"/docs/de/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**Nachdem Sie erfolgreich Ihre Konten im Robonomics-Portal erstellt haben, ist es an der Zeit, Geld auf diese Konten einzuzahlen, damit Sie Transaktionen initiieren können.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nBitte beachten Sie, dass diese und die folgenden Tutorials auf einer lokalen Instanz des Robonomics-Knotens demonstriert werden. Richten Sie Ihren eigenen mit [diesen Anweisungen](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navigieren Sie zum Abschnitt Konten im Robonomics-Portal. \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Wählen Sie das Konto aus, von dem aus Sie Geld überweisen möchten.\\n\\nIm Entwicklungsmodus gibt es mehrere Konten mit jeweils 10000 Einheiten Guthaben, die verwendet werden können, um Geld auf sind. Diese Pfade können jedoch je nach Ihrer spezifischen Konfiguration variieren.ere Konten im Entwicklungsnetzwerk zu überweisen. Diese Konten sind durch Schraubenschlüssel-Symbole <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> neben ihnen gekennzeichnet.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Klicken Sie auf die Schaltfläche \\\"Senden\\\" des Kontos, von dem aus Sie Geld überweisen möchten, zum Beispiel BOB.\\n\\n## 3. Wählen Sie das Konto aus, auf das Sie Geld überweisen möchten.\\nNach dem Klicken auf die Schaltfläche \\\"Senden\\\" werden Sie mit dem Fenster \\\"Geld senden\\\" aufgefordert. In dem angezeigten Fenster:\\n\\n- Wählen Sie aus der Liste der verfügbaren Konten das Konto aus, auf das Sie Geld überweisen möchten.\\n- Geben Sie die Anzahl der Einheiten ein, die Sie senden möchten.\\n- Drücken Sie \\\"Überweisung tätigen\\\".\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Autorisieren Sie die Transaktion.\\n\\nNach dem Drücken von \\\"Überweisung tätigen\\\" in der vorherigen Phase werden Sie mit dem Fenster \\\"Transaktion autorisieren\\\" aufgefordert.<br/>\\nÜberprüfen Sie die Details der Transaktion und klicken Sie schließlich auf die Schaltfläche \\\"Unterzeichnen und absenden\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nIn diesem Beispiel haben wir 500 Einheiten Guthaben von \\\"BOB\\\" nach \\\"EMPLOYER\\\" überwiesen. Sie können sehen, dass das Konto von EMPLOYER, das anfangs kein Guthaben hatte, jetzt 500 Einheiten Guthaben hat.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Stellen Sie sicher, dass Sie genügend Guthaben auf den Konten haben, die Sie im Playground verwenden möchten.**\"}},{\"node\":{\"id\":\"f43f82ffd5cba19d99cfab71b67b16c9\",\"title\":\"محول Zigbee مع Zigbee2MQTT لصورة مثبتة مسبقًا\",\"path\":\"/docs/ar/zigbee-to-mqtt-image/\",\"content\":\"\\n**في هذه المقالة ستقوم بإقران الأجهزة الذكية.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nافتح متصفح الويب وانتقل إلى `http://%RASPBERRY_IP_ADDRESS%:8099`. يمكنك العثور على عنوان IP لجهاز Raspberry Pi باستخدا [تطبيق Fing المحمول](https://www.fing.com/products) أو [أداة سطر الأوامر nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nسترى واجهة الويب لـ Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nحان الوقت لربط جهازك الذكي. \\nأولاً ، اضغط على زر `Permit join (All)` في أعلى واجهة الويب لـ Zigbee2MQTT. \\n\\nثم ، ابدأ في إقران الأجهزة. أكثر طريقة شائعة لتبديل جهاز إلى وضع الاتصال هو الاستمرار في الضغط على زر الطاقة أو تشغيلها / إيقاف تشغيلها 5 مرات. تأكد من تشغيل Zigbee2MQTT.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nعندما يتصل الجهاز ، ستراه في واجهة الويب:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nالآن يجب أن ترى هذا الاستشعار في واجهة Home Assistant WebUI الخاصة بك. انتقل إلى `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nبعد إضافة جميع الاستشعارات ، يمكنك إغلاق واجهة الويب لـ Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"2e3aea5ce7941120a677e21a85e4c5a6\",\"title\":\"مجموعة اختبارات Substrate Cumulus Parachain للرسائل بين السلاسل الجانبية\",\"path\":\"/docs/ar/xcm-robobank/\",\"content\":\"\\n\\nالهدف الرئيسي لهذا المشروع هو تبسيط تطوير وقت التشغيل الخاص بالسلاسل الجانبية عند استخدام الرسائل بين السلاسل الجانبية. \\nيتيح تطوير رمز التشغيل مع اختبارات الدمج ذات درجة عالية من التكرارية وسهولة الاستخدام.\\nيقوم بتلقائي بناء وإعداد تكوين الشبكة المحددة مسبقًا (أي سلسلة واحدة للتوجيه + سلسلتان جانبيتان) ، وإعداد قنوات الإرسال بين السلاسل الجانبية وتشغيل اختبارات الرسائل ، وإرسال الرسائل ، باستخدام استدعاء لوقت التشغيل ، كل ذلك مُنشأ ومُركب بلغة Python.\\n\\nيتم استخدام XCM Testsuite لاختبار دورة الإنتاج لـ Robobank - مجموعة من الوحدات الفرعية ، التي تسمح للروبوتات بالتسجيل في سلاسل جانبية خارجية ، واستلام الطلبات المدفوعة مسبقًا ، وتنفيذها واستلام المدفوعات باستخدام الرموز الخارجية. يتيح ذلك للروبوتات العمل داخل شبكة Robonomics مع كل البنية التحتية المطلوبة ، ولكن في الوقت نفسه ، تقدم خدماتها على أي سلسلة جانبية أخرى.\\n\\nمتوفر مقطع فيديو توضيحي على [YouTube](https://www.youtube.com/watch؟v=S_bZgsxngiM)\\n\\nالخطوات الرئيسية في سيناريو العرض التوضيحي هي:\\n- تشغيل سلسلة توجيه وسلسلتين جانبيتين في حزمة من 6 عمليات\\n- إعداد قنوات الرسائل XCM بين السلاسل الجانبية\\n- تسجيل روبوت في كلتا السلاسل الجانبية\\n- إنشاء طلب لهذا الروبوت في سلسلة العميل (احتياطي الدفع لإكمال الطلب)\\n- إرسال رسالة XCM إلى سلسلة Robonomics\\n- إنشاء سجل الطلب \\\"المعكوس\\\" على سلسلة Robonomics\\n- يقبل الروبوت الطلب على سلسلة Robonomics\\n- إرسال رسالة XCM حول قبول الطلب إلى سلسلة العميل\\n- قبول الطلب على سلسلة العميل (احتياطي رسوم الجزاء عن عدم إكمال الطلب حتى الموعد النهائي للطلب)\\n- يكمل الروبوت الطلب على سلسلة Robonomics\\n- إرسال رسالة XCM حول إكمال الطلب إلى سلسلة العميل\\n- تسوية جميع المدفوعات (يتم نقل دفعة العميل إلى الروبوت ، بالإضافة إلى رسوم الجزاء غير المستخدمة)\\n- إغلاق الطلب1\\n\\n\\n## المصدر\\nهذا المشروع هو نسخة مشتقة من\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nيحتوي على رمز الوقت التشغيل الذي يتم اختباره.\\nكما في رمز العقدة الأصلي للسلاسل الجانبية في الدليل \\\"./pallets\\\" ، \\\"./runtime\\\" ، \\\"./node\\\".\\n\\nالاختلافات مع \\\"substrate-node-template\\\" الأصلي:\\n- هذا الوقت التشغيل للمجمع لديه وحدة معالجة HRMP ويمكنه التعامل مع الرسائل من السلاسل الجانبية الشقيقة\\n- وحدة اختبار الوقت التشغيل الوهمية جاهزة للاختبارات الداخلية لـ XCM\\n\\n## بناء وتشغيل\\nالإعداد الموصى به (بشدة): \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[ملاحظة] يمكن أن يستغرق البناء الأول الكثير من الوقت ، حتى عدة ساعات على الأجهزة غير المثلى.\\n\\n[ملاحظة] يعمل البرنامج النصي مع الإصدارات الثابتة (تجزئة الهاشات) من Polkadot (Rococo) في سلسلة التوجيه والسلاسل الجانبية.\\n\\n[ملاحظة] بشكل افتراضي ، يقوم البرنامج النصي بإعادة إنشاء نفس البيئة في كل مرة يتم فيها تشغيله ، عن طريق إزالة جميع الحالات السابقة. يمكن تغيير هذا السلوك في \\\"config.sh\\\" باستخدام \\\"PERSISTENT\\\" param.\\n\\n\\nتشغيل بناء وبرنامج الإعداد.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nالإجراءات الأساسية لبرنامج \\\"init.sh\\\":\\n - قراءة التكوين (ملف \\\"config.sh\\\" مع رقم التنقيح ، ومفاتيح العقدة الأولية والمعرفات ، ومعلمة استمرارية بيانات السلسلة ، إلخ.)\\n - إعداد حزم النظام الأساسية و Rust و Python\\n - بناء برامج ثنائية منفصلة لسلسلة التوجيه وأيضًا لكل من السلاسل الجانبية\\n    - سيتم إنشاء البرامج الثنائية في الدليل ./bin. \\n - (اختياري) إزالة جميع بيانات السلسلة السابقة لجميع السلاسل\\n    - معطل إذا تم تعيين \\\"PERSISTENT=1\\\" في \\\"config.sh\\\"\\n - يعمل كعمليات منفصلة (بأرقام معرفات العمليات وأنابيب الإدخال / الإخراج المنفصلة):\\n    - المحققون في سلسلة التوجيه (أي 4 محققين لتشغيل تنقيح Rococo المستقر)\\n    - مجمعو السلاسل الجانبية للسلسلة 100 (أي مجمع واحد لللسلة الجانبية الأولى التي تقوم بتطويرها)\\n    - مجمعو السلاسل الجانبية للسلسلة 200 (أي مجمع واحد للسلسلة الجانبية الثانية التي تقوم بتطويرها)\\n - يطبع جميع نقاط النهاية والمنافذ إلى وحدة التحكم ، مما يتيح لك دراسة أي سلسلة باستخدام تطبيقات الواجهة الأمامية (مستكشف ، DApp)\\n - استمر في طباعة جميع بيانات الإخراج لجميع السلاسل إلى وحدة التحكم\\n\\n[تحذير] بعد التشغيل ، انتظر حتى يتم تشغيل الشبكة ، وتأكد من بدء تنفيذ الكتلة ، وأن السلاسل الجانبية مسجلة. يجب أن تستغرق هذه العمليات حوالي 5 دقائق (50 كتلة × 6 ثوانٍ).\\n\\n## التحقق من أن الإعداد الأولي يعمل \\n\\nاستخدم واجهة المستخدم الأمامية القياسية لـ Polkdot ونقاط النهاية المولدة \\\"--ws-port\\\" للاتصال بكل عقدة.\\nافتح [تطبيق Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) لمراقبة السلاسل. \\n\\n### مثال:\\nLocalhost ، 4 محققين لسلسلة التوجيه ، مجمع واحد للسلسلة الجانبية 100 ، مجمع واحد للسلسلة الجانبية 200:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nإذا عمل كل شيء، وبدأ التوافق، يمكننا المضي قدمًا في تشغيل حالات الاختبار الخاصة بنا (في نافذة الأوامر الجديدة).\\n\\n### اختبار تمرير الرسائل UMP\\n```bash\\n./scripts/init.sh ump\\n```\\nيقوم بإنشاء رسالة `Balance.transfer` في `parachain-100` ويمرها إلى سلسلة الوساطة.\\nعندما تستلم سلسلة الوساطة الرسالة، ستقوم بتحويل 15 رمزًا من حساب `para 100` إلى حساب Charlie.\\n\\n\\n### اختبار تمرير الرسائل HRMP\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nيقوم بإنشاء رسالة `Balance.transfer` في `parachain-100` ويمررها إلى `sibling 200`.\\nقبل ذلك، يمنح حساب `subl 100` 1000 رمز وينشئ قناة اتصال بين الباراشينات.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nيمكن إرسال رسائل أخرى عن طريق تشغيل الأمر الفرعي `hrmpm`. لا يقوم بإنشاء قناة وبالتالي يعمل بشكل أسرع.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### المزيد من الخيارات\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## شبكة اختبار محلية\\n\\n### إنشاء مواصفات سلسلة مخصصة\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nتحرير rococo_local.json، واستبدال معلمات الأرصدة والسلطات بالخاصة بك.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nعنوان Polkadot لـ //Alice//stash (تشفير sr25519).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nمفتاح جلسة Polkadot grandpa لـ //Alice (تشفير ed25519).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nعنوان Polkadot لـ //Alice (تشفير sr25519).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nتحويل rococo_local.json إلى التنسيق الخام.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nلاستخدام مواصفات سلسلة جديدة، استبدل ملف rococo.json في مجلد ./config/ بهذا الجديد وأعد تشغيل السلسلة.\\n```bash\\n./scripts/init.sh run\\n```\\nيمكنك تحرير الشفرة بحرية. سيقوم الأمر أعلاه بإعادة بناء المشروع وتحديث عقدة المجمع قبل البدء.\\nCumulus هو برنامج قبل الإصدار لا يزال قيد التطوير الشاق.\\nنحن نستخدم التزامًا محددًا من polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15 18 مارس 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nيمكنك استخدام إصدارات أحدث من البرنامج. للقيام بذلك، قم بتغيير POLKADOT_COMMIT في ./scipt/config.sh\\nإلى أحدث التزام في فرع `rococo-v1`، احذف ./bin/polkadot، وقم بتشغيل \\n```bash\\n./scripts/init.sh run\\n```\\n\\nتحديث تبعيات مشروع المجمع \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nقد تتطلب بعض التبعيات ميزات جديدة لأداة البرمجة Rust. يستند هذا المشروع إلى Rust `nightly-2021-01-26`\\nقم بتحديث إصدار أداة برمجة Rust في ./scripts/config.sh قبل البناء.\\n\\n## اختراق الباراشين\\n[إضافة لوحة خارجية](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - يجب أن تكون في \\\"تعلم المزيد\\\" ربما؟\\n## Learn More\\n\\nراجع [قالب العقدة في Substrate Developer Hub Node](https://github.com/substrate-developer-hub/substrate-node-template) لمعرفة المزيد عن هيكل هذا المشروع والقدرات التي يحتوي عليها والطريقة التي يتم بها تنفيذ تلك القدرات. يمكنك معرفة المزيد عن [مسار كتلة الباراشين](https://polkadot.network/the-path-of-a-parachain-block/) في مدونة Polkadot الرسمية. [ورشة عمل Parity Cumulus](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"df2d0f8e0e7970ef2c05567c443ff744\",\"title\":\"كيفية استخدام النماذج الأولية\",\"path\":\"/docs/ar/use-blueprints/\",\"content\":\"\\nفي هذه المقالة ستتعرف على كيفية إضافة النماذج الأولية لمساعد المنزل الخاص بك وتكوينها.\\n\\n## النماذج الأولية للتشغيل التلقائي\\n\\nتم تثبيت بعض النماذج الأولية بالفعل. تحتاج فقط إلى تكوين التشغيل التلقائي بناءً على هذه النماذج الأولية. يمكنك العثور على النماذج الأولية المثبتة مسبقًا في واجهة الويب في `Settings/Automations & Scenes`. افتح `Blueprints` وابحث عن النموذج الأولي الذي ترغب في استخدامه. في هذا المثال سيتم استخدام `Motion-activated Light`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nانقر على `Create Automation` لفتح محرر التشغيل التلقائي. قم بتعيين اسم واختيار نموذج أولي للاستخدام (`Motion-activated Light` في حالتنا). بعد ذلك ، يجب عليك اختيار مستشعر الحركة والمصباح. عند الانتهاء من التكوين ، انقر على `Save.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation التكوين\\\" />\\n\\nإذا كنت ترغب في إجراء تغييرات ، يمكنك العثور عليها عن طريق الانتقال إلى `Settings/Automations & Scenes` ثم `Automations`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## استيراد النماذج الأولية\\n\\nيمكن لمساعد المنزل استيراد النماذج الأولية من منتديات مساعد المنزل ومستودع GitHub ومستودعات GitHub Gists. يتم تحديد قائمة جميع النماذج الأولية في [تبادل النماذج الأولية](https://community.home-assistant.io/c/blueprints-exchange/53). بعد اختيارك ، انتقل إلى `Settings/Automations & Scenes` وافتح `Blueprints`. انقر على `Import Blueprint` وأدخل عنوان URL للنموذج الأولي المختار. ثم انقر على `PREVIEW BLUEPRINT`. في هذه الحالة ، سنستخدم [كشف مستوى البطارية المنخفض والإشعار لجميع مستشعرات البطارية](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nسيتم تحميل النموذج الأولي وعرض معاينة في مربع الاستيراد. يمكنك تغيير الاسم وإكمال الاستيراد. انقر على `Create Automation` لفتح محرر التشغيل التلقائي. هنا يمكنك تكوين معلمات التشغيل التلقائي وإضافة إجراءات للحصول على الإشعارات.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"a332ad5b935a531cfdef7ef2dfbed283\",\"title\":\"كيفية إرسال إطلاق مع الاشتراك\",\"path\":\"/docs/ar/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  تنبيه أن هذا البرنامج التعليمي يوضح استخدام الاشتراك في سلسلة Robonomics Kusama. يمكنك أيضًا تنفيذ جميع الخطوات نفسها على [العقد المحلي](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nإذا كان ديك عنوان يحتوي على اشتراك نشط ، فيمكن لأي أجهزة تم إعدادها باستخدام سر تلك الحساب إرسال extrinsics بدون رسوم. \\nلنجرب إرسال الأمر `launch`.\\n\\nانتقل إلى صفحة `Developer/Extrinsics` ، ثم اختر حسابك (الحساب من قائمة الأجهزة) وحدد `rws -> call (subscriptionId ، call)`. \\nثم في حقل `subscriptionId` ، الصق عنوان مالك الاشتراك (الشخص الذي قدم عرض المزاد) وفي الحقل التالي اختر `launch -> launch (robot ، param)`. في حقل `robot` ، اكتب العنوان الذي تريد إرسال معاملة `launch` إليه وأدخل الأمر (للحصول على وصف الأمر الخاص بالإطلاق ، راجع [هنا](/docs/launch)). ثم أرسل المعاملة:\\n\\n![launch](../images/rws/launch.png)\\n\\n\\nالآن انتقل إلى صفحة `Network/Explorer` ، وفي منطقة `Recent Events` سترى حدثين قمت بإنشائهما ؛ `rws.NewCall` و `launch.NewLaunch`:\\n\\n![events](../images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"10c613be2a02fd90eacbc59c1ba16cc5\",\"title\":\"تفعيل الاشتراك\",\"path\":\"/docs/ar/sub-activate/\",\"content\":\"\\nفي هذه المقالة ستقوم بإنشاء حسابات Robonomics parachain وشراء اشتراك IoT. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nللتحكم في Home Assistant باستخدام Robonomics ، تحتاج إلى حسابين على Robonomics parachain. بالنسبة لأحد الحسابات (`sub_owner`) ، تشتري اشتراكًا Robonomics. سيتحكم الحساب الثاني (`sub_controller`) في جميع عمليات Home Assistant (مثل التلميتريا) وسيمنح الوصول للمستخدمين الآخرين. ستوفر هذه الحسابات الأمان لـ Home Assistant الخاص بك. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nيجب إنشاء كلا الحسابين بتشفير **ed25519**. ولهذا السبب، تحتاج إلى إنشاء حساب باستخدام واجهة مستخدم Polkadot-JS وتحديد التشفير المطلوب. \\n\\nتم تعطيل هذه الميزة بشكل افتراضي على واجهة المستخدم Polkadot-JS. لتمكينها ، انتقل إلى `Settings` -> `General` -> `account options` وحدد `Allow local in-browser account storage` في قائمة السقوط `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## إنشاء حسابات المالك والمراقب\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. انتقل إلى [تطبيق Robonomics Parachain](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) على بوابة Polkadot / Substrate. **تحقق من الزاوية اليسرى العلوية للتأكد من أنك متصل بـ Robonomics Parachain.**\\n\\n2. انتقل إلى `Accounts` -> `Accounts` واضغط على زر `Add account`. سترى قائمة منبثقة تحتوي على بذرة الحساب. لديها نموذجين: *Mnemonic* (قابل للقراءة من قبل الإنسان) و *Raw* (سلسلة من الأرقام والحروف). \\n\\n3. افتح `Advanced creation options` ، غير نوع التشفير لإنشاء الحساب إلى `Edwards - ed25519` واضغط على `Next`.\\n\\n\\n4. احفظ عبارة البذرة الذاكرة النصية بأمان واضغط على `التالي`.\\n\\n5. في القائمة التالية ، يجب عليك تعيين اسم الحساب وكلمة المرور. اعطه اسم `sub_owner` للراحة. اضغط على `Next`.\\n\\n6. في النافذة الأخيرة ، انقر فوق `Save` لإنهاء إنشاء الحساب. سيتم أيضًا إنشاء ملفات JSON احتياطية يجب عليك تخزينها بأمان. يمكنك استخدام هذا الملف لاحقًا لاستعادة حسابك إذا تذكرت كلمة المرور.\\n\\n7. كرر هذه الخطوات لحساب بالاسم `sub_controller`.\\n\\n\\n## إضافة الحسابات إلى Polkadot.js\\n\\nللراحة ، يجب عليك استخدام [امتداد Polkadot.js](https://polkadot.js.org/extension/) وإضافة هذه الحسابات الجديدة إليه. بالنسبة لحساب ed25519 ، يمكنك فعل ذلك فقط باستخدام ملف JSON احتياطي. يمكنك استخدام الملفات المحفوظة عند إنشاء الحسابات.\\n\\nيمكنك الحصول على هذه الملفات مرة أخرى عن طريق إنشاء ملف احتياطي للحساب. انقر على النقاط الثلاث في حسابك ، اختر Create a backup file for this account`  واكتب كلمة المرور الخاصة بك.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. افتح الامتداد واضغط على زر `+` في الزاوية اليمنى العلوية ، ثم اختر `Restore account from backup JSON file`.\\n\\n2. في النافذة المفتوحة ، قم بتحميل ملف JSON ، أدخل كلمة المرور واضغط على `Restore`.\\n\\n3. تأكد من تحديد شبكة Robonomics للحسابات في امتداد Polkadot.js. على بوابة Polkadot / Substrate ، انتقل إلى `Setting` -> `Metadata` وانقر على زر `Update metadata`. \\n\\n4. قم بتأكيد تحديث البيانات الوصفية في النافذة المنبثقة. الآن سيعرض الامتداد تسمية الشبكة التي يتم استخدام العنوان لها.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## تفعيل اشتراك Robonomics \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nلهذه الخطوة ، يجب أن يكون لديك كمية كافية من رموز XRT (2-3 XRTs كحد أدنى) في حساب `sub_owner` الخاص بك.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. انتقل إلى تطبيق Robonomics dapp إلى [صفحة الاشتراك](https://dapp.robonomics.network/#/subscription) واضغط على توصيل الحساب في الشريط الجانبي الأيمن.\\n\\n2. في القائمة المنبثقة التالية ، قم بتوصيل امتداد Polkadot.js. سترى عنوان حسابك مع الرصيد.\\n\\n3. قبل الشراء ، تحقق من اختيار حساب `sub_owner`. اضغط على أيقونة ملف التعريف الخاصة بالعنوان ، يجب أن ترى حساب `sub_owner` تحت حقل `تحقق من حساب المالك`.\\n\\n4. أخيرًا ، اضغط على زر `SUBMIT` وأدخل كلمة المرور الخاصة بحسابك. بعد ذلك ، انتظر حتى يتم الانتهاء من عملية التفعيل. سترى حالة اشتراكك بعد فترة من الزمن.\\n\\n\\n## إضافة الحسابات إلى الاشتراك\\n\\nأنت الآن بحاجة إلى إضافة حساب \\\"وحدة تحكم فرعية\\\" إلى **قائمة الوصول**.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. افتح الامتداد وانقر على الرمز بجوار اسم الحساب. سيتم نسخ عنوان الحساب.\\n\\n\\n2. الصق هذا العنوان في حقل `Robonomics parachain address` في جزء **إدارة الوصول**. أعطه اسمًا واضغط على زر `+`. \\n\\n3. كرر الخطوات 1 و 2 لحساب `sub_owner`.\\n\\n4. اضغط على `Save`. أدخل كلمة مرور `sub_owner` الخاصة بك في نافذة النقاط المنبثقة وانتظر حتى يتم الانتهاء من عملية التفعيل.\\n\"}},{\"node\":{\"id\":\"eac9f3d52acd75ed3a004f8e34ef846e\",\"title\":\"احصل على بيانات تلميتري المنزل الذكي\",\"path\":\"/docs/ar/smart-home-telemetry/\",\"content\":\"\\n**في هذه المقالة، ستستخدم خدمة Robonomics التي تستعلم عن بيانات تلميتري الأجهزة المنزلية الذكية.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. اذهب إلى التطبيق واختر خدمة [بيانات تلميتري المنزل الذكي](https://dapp.robonomics.network/#/smarthome-telemetry).\\n\\n2. في حقل المراقب، أدخل عنوان `SUB_CONTROLLER`. أدخل عبارة البذرة لتشفير البيانات.\\n\\n3. في كتلة `Get telemetry`، اختر الطابع الزمني من القائمة المنسدلة واضغط على زر `DOWNLOAD TELEMETRY`.\\n\\n4. قد يستغرق تنزيل البيانات التلميترية بعض الوقت. بعد الانتهاء، سترى معلومات من أجهزتك ومستشعراتك.\\n\\n\\n<!---\\n## إطلاق devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"إطلاق\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list tهنا.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"5a0920eab6f547563dbb7728c35a467e\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/ar/sls-gateway/\",\"content\":\"\\n**في هذه المقالة ستقوم بإعداد بوابة Robonomics SLS. ستقوم بتثبيت البرامج المطلوبة للبوابة وتكوينها وربطها بـ Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## البرامج الثابتة\\n\\nأولاً ، تحتاج إلى تثبيت برامج البرمجة الثابتة للبوابة. قم بتجهيز البوابة عن طريق ضبط المفاتيح `1` و `3` في الجزء السفلي من بوابة SLS على `ON` ، ويجب أن تكون الأخرى على `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nقم بتوصيل البوابة بجهاز Raspberry Pi الخاص بك عبر منفذ USB type-C على البوابة.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nاستنسخ المستودع مع البرامج الثابتة على جهاز Raspberry Pi الخاص بك:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nانتقل إلى `robonomics-hass-utils/esp_firmware/linux`. لتفليش بوابة SLS ، تحتاج إلى تشغيل البرامج النصية `Clear` و `Flash_16mb`.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### حل المشاكل\\n\\nإذا كنت تواجه مشاكل في تحديث برامج البرمجة الثابتة للبوابة ، فيجب عليك اتخاذ خطوات إضافية:\\n\\n1. تأكد من تثبيت وحدة pySerial:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. قم بمنح المستخدم الخاص بك حقوق الوصول إلى منفذ USB وأعد تشغيل الكمبيوتر:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. في بعض الحالات ، من الضروري تغيير إعداد النطاق الترددي في البرنامج النصي لتحديث البرامج الثابتة. افتح البرنامج النصي `Flash_16mb.sh` باستخدام محرر `nano` وقم بتغيير معلة الباود من `921600` إلى قيمة أصغر (على سبيل المثال ، `115200`).\\n\\n## التكوين\\n\\n1. قم بفصل بوابة SLS عن الكمبيوتر. ضبط المفاتيح على ظهر البوابة في الموضع الصحيح. يجب أن تكون المفاتيح `5` (RX Zigbee to ESP) و `6` (TX Zigbee to ESP) في الموضع `ON` ، ويجب أن تكون الأخرى على `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. قم بتوصيل كابل الطاقة من النوع C. يجب أن يتحول الضوء المؤشر في الوسط إلى اللون الأخضر.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. عند بدء التشغيل الأول ، ستبدأ البوابة في مشاركة Wi-Fi مع SSID `zgw****`. قم بالاتصال بشبكة الاتصال هذه. تذكر أن الإشارة قد تكون ضعيفة إلى حد ما ، لذا من الأفضل أن تبقى بوابة SLS أقرب إلى جهاز الكمبيوتر الخاص بك. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. إذا تمت الاتصال بنجاح ، فسيتم فتح واجهة الويب (أو يمكنك العثور عليها على عنوان 192.168.1.1). \\n\\n5. سترى صفحة `Wi-Fi Settings` . حدد شبكة Wi-Fi الخاصة بك وأدخل كلمة المرور. اضغط على زر `Apply`. ستعيد البوابة التشغيل وتتصل بشبكة Wi-Fi الخاصة بك. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. ابحث عن عنوان IP المحلي لبوابة SLS للوصول إلى واجهة الويب. يمكنك استخدام تطبيق [Fing mobile app](https://www.fing.com/products) أو أداة [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) للعثور على ذلك. يجب أن يكون اسم البوابة كما يلي: `zgw****`. افتح واجهة الويب للبوابة عن طريق لصق عنوان IP البوابة في المتصفح.\\n\\n7. انتقل إلى `Setting` -> `Hardware` وتأكد من أن الإعدادات تبدو كما هو موضح في الصورة. قم بتصحيح الإعدادات إذا لزم الأمر وانقر على زر `Save`:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nالجدول مع القيم المطلوبة:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. ثم أعد تشغيل البوابة. اختر  `Actions` -> `Reboot system` في الزاوية العلوية اليمنى.\\n\\n9. تأكد من أن البوابة تعمل بشكل صحيح في نافذة معلومات Zigbee. يجب أن يكون حالة الجهاز `OK`.\\n\\n10. قم بتكوين إضافة الأجهزة تلقائيًا إلى Home Assistant. انتقل إلى `Zigbee` -> `Config` ثم اختر `Home Assistant MQTT Discovery` و `Clear States`. قم بحفظ التغييرات ومرة أخرى **أعد تشغيل** بوابة SLS.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nإذا كان لديك بالفعل بوابة SLS نشطة في منزلك ، وتقوم الآن بتكوين بوابة أخرى ، فسيتعارضون مع بعضهم البعض. لحل هذه المشكلة ، تحتاج إلى تغيير القناة على الجهاز الجديد. للقيام بذلك ، انتقل إلى `Zigbee` -> `Config` وقم بتغيير القناة إلى قناة أخرى (على سبيل المثال ، القناة 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## ربط SLS بـ MQTT\\n\\nبعد تكوين بوابة SLS ، تحتاج إلى ربط بوابة SLS بـ Home Assistant. افتح واجهة الويب لبوابة SLS وانتقل إلى `Settings/Link` -> `MQTT Setup`:\\n\\n\\nأضف عنوان وسيطك (عنوان جهاز Raspberry Pi مع Home Assistant في الشبكة المحلية ، يمكنك العثور عليه باستخدام تطبيق [Fing mobile app](https://www.fing.com/products) أو أداة [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)) ، والمنفذ (الافتراضي هو `1883`) واسم مستخدم وكلمة مرور وسيطك (التي قمت بإنشائها سابقًا) واسم الموضوع (يمكنك اختيار أي اسم). كما يجب أن يكون عنوان IP لجهاز Raspberry Pi ثابتًا. انقر على `Enable` و `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nاحفظ التغييرات. الآن ستظهر الأجهزة تلقائيًا في Home Assistant.\\n\\n## ربط الأجهزة\\n\\nقم بتوصيل أجهزتك عن طريق الانتقال إلى `Zigbee` -> `Join`. ضع حساساتك في وضع الاقتران ، وأكثر الطرق الشائعة لتبديل الجهاز إلى وضع الاتصال هي الاستمرار في الضغط على زر الطاقة أو تشغيلها / إيقاف تغيلها 5 مرات. اضغط على زر `Enable Join` لبدء البحث عن أجهزة Zigbee. سترى حساسات نشطة.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nالآن يمكنك الانتقال إلى قسم [**اشتراك IoT**](/docs/sub-activate) وبدء تفعيل اشتراك Robonomics.\\n\"}},{\"node\":{\"id\":\"4a5deef7248c238856f40d806aae092d\",\"title\":\"شبكة الاستشعار المركزية\",\"path\":\"/docs/ar/sensors-network-introduction/\",\"content\":\"\\nتم نقل المقالات حول شبكة الاستشعار المركزية إلى أكاديمية روبونوميكس: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"135e656858905ad4bcaaae657d6efa67\",\"title\":\"توصيل الذكاء الاصطناعي السحابي بأمان إلى أرض المصنع\",\"path\":\"/docs/ar/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nتستطيع تقنيات Robonomics حل التحديات التي تواجه الصناعة 4.0 وتطبيقها بالفعل في سيناريوهات العالم الحقيقي في البيئة الصناعية.\\n\\nيقوم عدد كبير من شركات الذكاء الاصطناعي ببناء حلول لتحسين العمليات على أرض المصنع، مما يتيح للمصانع إنتاج المزيد بتكلفة أقل. ومع ذلك، فإن معظم المصانع تتردد في توصيل بنيتها التحتية بالسحابة مباشرة نظرًا لأن ذلك يؤدي إلى مخاطر أمنية محتملة، والتي يمكن أن تؤدي إلى خسائر تصل إلى الملايين وحتى فقدان الأرواح البشرية.\\n\\nاستخدمت [MerkleBot](https://merklebot.com) [شبكة Robonomics](https://robonomics.network) لبناء حل لعملاء الصناعة لتوصيل مصنعهم بالذكاء الاصطناعي القائم على السحابة بطريقة آمنة.\\n\\nتم كتابة هذه المقالة عقب تجربة أجريناها باستخدام [بروتوكول Veracity](https://www.veracityprotocol.org/) الذي يستخدم خوارزميات لإنشاء حماية غير غازية لأي عنصر مادي بناءً على الصور من جهاز محمول.\\n\\nيوضح هذا الحالة استخدام عملية مسح الأجزاء الصناعية باستخدام ذراع روبوتية.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## عملية خطوة بخطوة\\n\\n### DApp كواجهة المستخدم\\n\\n<!-- ![](../images/google-play-store.gif) -->\\n<!-- <img src=\\\"../images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nيعمل DApp كواجهة المستخدم للمشغل. يتم استخدامه لطلب إطلاق الروبوت لجمع الصور وغرضه هو السماح بالاتصال الآمن بين بيئة المصنع والذكاء الاصطناعي القائم على السحابة.\\n\\n### إطلاق الروبوت\\n\\n<!-- ![](../images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nيقوم المشغل بإطلاق المسح الروبوتي عن طريق توقيع المعاملة في DApp. تضمن هذه الخطوة أن العملية على أرض المصنع يمكن أن تبدأ فقط استنادًا إلى المعاملة في سلسلة الكتل العامة.\\n\\nيتلقى الروبوت أمرًا من سلسلة الكتل من خلال شبكة Robonomics ويبدأ المسح. تتيح لنا تقنيات شبكة Robonomics سد الفجوة بين الهدف التجاري وعملية الروبوتيات.\\n\\n### جمع البيانات وإرسالها إلى الذكاء الاصطناعي القائم على السحابة\\n\\nفي DApp، يرى المشغل التأكيد ويبدأ الروبوت في مسح العناصر الموضوعة على الطاولة، مثل هذه الحالة، أو على خط المصنع مباشرة إذا دعت الحاجة.\\n\\n<!-- ![](../images/Veracity_Protocol_إطلاق.gif) -->\\n<!-- <img src=\\\"../images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nعندما يجمع الروبوت البيانات، يخزنها محليًا ويجعلها متاحة للذكاء الاصطناعي القائم على السحابة من خلال بروتوكول IPFS. من خلال تشفير البيانات وتنظيم تبادل البيانات من خلال معاملة سلسلة الكتل أيضًا، يمكننا تفويض الوصول إلى الذكاء الاصطناعي القائم على السحابة مع ضمان بقاء البيانات آمنة وفي مكانها.\\n\\nيسمح الآلية الأمنية المدمجة في Robonomics بالاستفادة من مستوى الأمان الذي يكلف الكثير من المصانع تنظيمه بأنفسهم.\\n\\n### إنشاء جواز سفر رقمي\\n\\nعندما يحلل الذكاء الاصطناعي القائم على السحابة البيانات، يتم تسجيل ملف السجل والتوصيات كـ [جواز سفر رقمي](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/) تلقائيًا. يمكن تتبع كل عملية ومسح لأن سجل سلسلة الكتل يحتوي على الهاش لكل هذه الملفات من خلال بروتوكول IPFS.\\n\\n## تعليقات حول الحالة الاستخدامية\\n\\nفي هذه الحالة الاستخدامية، تم استخدام ذراع Universal Robot UR3 الصناعية. ولكن بفضل دعم Robonomics لـ ROS، يمك استخدام معظم المنظمات الصناعية الرئيسية وتوصيلها بالذكاء الاصطناعي القائم على السحابة بأمان، بما في ذلك KUKA و Fanuc و Yaskawa.\\n\\nإذا كنت مهتمًا بمعرفة المزيد حول نشر وتكامل أدوات الذكاء الاصطناعي القائمة على السحابة بأمان، يرجى [التواصل](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"01ad62adec4ac29c9390b1738503f0e8\",\"title\":\"كيفية إضافة مستشعر SDS011 إلى Home Assistant\",\"path\":\"/docs/ar/sds-sensor-hass/\",\"content\":\"\\nيشرح هذا المقال كيفية توصيل مستشعر جودة الهواء SDS مع البرامج الثابتة [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) و [Robonomics](https://github.com/airalab/sensors-software) إلى Home Assistant.\\n\\n## التثبيت \\nهناك خياران للتثبيت المتاحان:\\n\\n### الخيار 1: HACS\\n\\nأسهل طريقة لإضافة مستشعر Luftdaten المحلي هي من خلال HACS. يمكنك [هنا](https://hacs.xyz/docs/setup/download/) العثور على شرح موجز حول كيفية إعداد HACS.\\n\\nبمجرد تثبيت HACS، انتقل إلى HACS -> التكاملات وابحث عن التكامل `Local Luftdaten Sensor`. انقر على زر التنزيل وأعد تشغيل Home Assistant بمجرد تنزيل التكامل.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### الخيار 2: التثبيت اليدوي\\n\\nتحت مستخدم homeassistant، استنسخ مستودع المشروع:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nإذا كان لديك بالفعل أي تكاملات مخصصة، قم بنسخ `custom_components/local_luftdaten/` إلى دليل `custom_components` الخاص بك، على سبيل المثال:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nإذا لم يكن لديك أي تكاملات مخصصة، قم بنسخ دليل `custom_components` بأكمله إلى دليل تكوين Home Assistant الخاص بك. على سبيل المثال:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## التكوين\\n\\nأنشئ إدخال مستشعر جديد في `configuration.yaml` الخاص بك وقم بضبط اسم المضيف أو عنوان IP. يمكنك استخدام [تطبيق Fing المحمول](https://www.fing.com/products) أو [أداة سطر الأوامر nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) للعثور على عنوان IP المحلي للمستشعر الخاص بك. يمكن أن يكون الاسم أي.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> يمكن العثور على قائمة جميع المستشعرات المدعومة في [المستودع](https://github.com/lichtteil/local_luftdaten).\\n\\nأعد تشغيل Home Assistant الخاص بك.\\nبعد ذلك يمكنك إضافة المستشعر إلى لوحة التحكم الخاصة بك. سيكون اسم الكيان هو الاسم الذي أضفته إلى `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"00122f9863c73177e8df52153952dbf0\",\"title\":\"كيفية توصيل جهاز الاستشعار SDS011\",\"path\":\"/docs/ar/sds-sensor-connect/\",\"content\":\"\\n** فيما يلي دليل خطوة بخطوة حول كيفية توصيل المستشعر الخاص بك بشبكة أجهزة استشعار Robonomics. تستخدم أجهزة الاستشعار لدينا البرنامج الثابت Robonomics، وهو إصدار محسّن من البرنامج الثابت الخاص بـ Sensor.community. يتضمن أجهزة استشعار إضافية ولديه آلية إرسال بيانات معدلة. **\\n\\n1. قم بتوصيل المستشعر بالمقبس لتشغيله.\\n2. ستقوم اللوحة بإنشاء شبكة Wi-Fi باسم \\\"RobonomicsSensor-xxxxxxxxx\\\". اتصل به من هاتفك أو جهاز الكمبيوتر الخاص بك: سترى نافذة التفويض (إذا لم يكن الأمر كذلك، افتح المتصفح وانتقل إلى `192.168.4.1`).\\n3. حدد شبكة Wi-Fi الخاصة بك من القائمة (أو اكتبها بنفسك إذا لم تكن موجودة في القائمة) واملأ حقل كلمة المرور.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nلا يمكن توصيل المستشعر إلا بشبكة Wi-Fi بتردد 2.4 جيجا هرتز.\\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. اكتب إحداثيات المكان الذي سيتم تركيب الحساس فيه. يمكنك الحصول عليها من أي خرائط أو الحصول عليها من العنوان باستخدام [هذا الرابط.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nسيتم بعد ذلك عرض إحداثيات المستشعر على خريطة متاحة للجمهور. إذا كنت لا تريد إظهار معلوماتك الخاصة، فاكتب إحداثيات قريبة، ولكن ليس دقيقة.\\n</robo-wiki-note> \\n5. انقر فوق `Save configuration وrestart`. سيتم إعادة تشغيل اللوحة والاتصال بشبكة Wi-Fi المحددة.\\n6. افتح [خريطة مستشعرات Robonomics](https://sensors.robonomics.network/#/) وابحث عن المكان الذي قمت بتثبيت المستشعر فيه. في بضع دقائق، ستتمكن من رؤية المستشعر الخاص بك مع البيانات الموجودة على الخريطة.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"dade166ce38fac5aceec05c52f1eae09\",\"title\":\"كيفية تشغيل نقطة تطوير Robonomics\",\"path\":\"/docs/ar/run-dev-node/\",\"content\":\"\\n**لاختبار تطبيقاتك على Robonomics قد ترغب في تشغيلها في وضع التطوير. يوضح هذا المقال خطوة بخطوة\\nتعليمات حول كيفية الحصول على نسخة اختبار محلية خاصة بك من Robonomics.**\\n\\n\\n## احصل على ملف تنفيذي للنقطة\\n\\n1. أولاً ، تحتاج إلى ملف تنفيذي ، قم بتنزيل الأرشيف الخاص به من أحدث [إصدار](https://github.com/airalab/robonomics/releases).\\n\\n2. انتقل إلى مجلد الأرشيف ، قم بفك الضغط عن الملف التنفيذي وقم بتغيير الأذونات:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## تشغيل\\n\\nقم بتشغيل النقطة باستخدام:\\n\\n```bash\\n./robonomics --dev\\n```\\nسترى الناتج التالي:\\n\\n![robonomics](../images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  إذا كنت ترغب في حذف الكتل الموجودة بالفعل ، فيمكنك القيام بذلك عن طريق إزالة RocksDB في `/tmp/substrate******/chains/dev/db/full`.\\n  استبدل `******` بمعرف مقابل يتم عرضه في السجلات عند الإطلاق.\\n\\n  إذا كنت ترغب في بدء تشغيل النقطة من البداية في كل مرة ، استخدم علامة `--tmp`.\\n\\n</robo-wiki-note>\\n\\n## الاتصال\\n\\nالآن يمكنك الاتصال بالنقطة المحلية الخاصة بك من خلال [بوابة Polkadot](https://polkadot.js.org/apps/#/explorer).\\n\\nقم بتغيير الشبكة إلى `Local Node` في الزاوية اليسرى العلوية واضغط على `Switch`.\\n\\n![switch](../images/dev-node/portal.png)\\n\\nمرحبًا بك في النسخة المحلية لـ Robonomics!\\n\\n![local_node](../images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"8eaf3e0eedc0d689a52c4be48d438338\",\"title\":\"خدمة فيديو روبونوميكس\",\"path\":\"/docs/ar/robonomics-video/\",\"content\":\"\\nيوضح هذا المقال كيفية إضافة كاميرا IP إلى Home Assistant وإرسال مقاطع الفيديو إلى خدمة Robonomics على الويب.\\n\\nلتوصيل الكاميرا بـ Home Assistant ، تحتاج إلى معرفة عنوان IP الخاص با وإنشاء حساب كاميرا محلي للاتصال بتيار RTSP.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nنظرًا لأن هذا يتم بطرق مختلفة لكل كاميرا ، فإن هذه العملية لا تعتبر في هذا المقال.\\n</robo-wiki-note>\\n\\nالمتطلبات:\\n- كاميرا IP\\n- حساب كاميرا محلي مكون\\n- عنوان IP للكاميرا\\n- Home Assistant المكونة\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nيفترض هذا المقال أن لديك كاميرا IP عامة بدون خيارات RTZ (تدوير ، ميل ، تكبير). \\n\\\"إذا كان لديك كاميرا RTZ ، فتحقق من [مقال \\\\\\\"كاميرا RTZ\\\\\\\"](/docs/ptz-camera). ثم عد إلى الخطوة الثانية هنا.\\\",\\n\\n</robo-wiki-note>\\n\\n## قم بتوصيل الكاميرا\\n\\nأولاً، تحتاج إلى معرفة عنوان URL الخاص ببث RTSP الخاص بالكاميرا.\\nللقيام بذلك ، حاول إدخال الاستعلام التالي على الإنترنت: \\\"<CAMERA_NAME> تيار RTSP\\\".\\nيجب أن يبدأ عنوان URL بـ `rtsp://<IP_Address>...`. \\n\\nيستخدم هذا المقال كاميرا \\\"Tapo\\\" ومسار التيار هو `rtsp://<IP_Address>/stream1`.\\n\\nافتح Home Assistant وانتقل إلى \\\"Settings\\\"-> \\\"Devices & Services\\\". اضغط على زر \\\"ADD INTEGRATION\\\" و\\nابدأ الكتابة \\\"Generic Camera\\\"  اختره.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nفي نافذة التكوين ، قم المعلومات التالية:\\n- Stream Source URL - عنوان URL لتيار RTSP الكاميرا\\n- Username - اكتب اسم مستخدم حساب الكاميرا المحلي الخاص بك\\n- Password - اكتب كلمة مرور لحساب الكاميرا المحلي الخاص بك\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nانتقل إلى أسفل الإعدادات واضغط على زر \\\"إرسال\\\".\\n\\nفي نافذة المعاينة ، قم بتفعيل خانة الاختيار \\\"This image looks good.\\\" واضغط على زر \\\"إرسال\\\". ثم - \\\"إنهاء\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### أضف إلى لوحة المعلومات\\n\\nبالإضافة إلى ذلك ، يمكنك إضافة التيار إلى لوحة المعلومات الخاصة بك. للقيام بذلك ، انتقل إلى لوحة المعلومات وأنشئ بطاقة جديدة \\n\\\"صورة سريعة\\\". الخطوات الإضافية:\\n- أدخل \\\"العنوان\\\" الذي تريده\\n- احذف البيانات من \\\"مسار الصورة\\\"\\n- حدد الكاميرا في \\\"كيان الكاميرا\\\"\\n- في \\\"عرض الكاميرا\\\" ، حدد \\\"مباشر\\\" حتى يكون هناك تأخير أقل\\n\\nواحفظها.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## تحقق من مجلد الوسائط\\n\\nقبل إرساله إلى Robonomics Video Service، يجب حفظ الفيديو في مجلد، ويجب أن يكون لدى Home Assistant حق الوصول إلى هذا المجلد.\\nأسهل خيار في هذه الحالة هو استخدام حزمة وسائط ، حيث يقم Home Assistant بتخزين جميع الوسائط.\\n\\n- إذا كنت تستخدم HAOS أو Pre-installed Image ، فلديك بالفعل مجلد وسائط في Home Assistant الخاص بك.\\n- إذا كنت تستخدم Home Assistant Core ، فيجب عليك الانتقال إلى مجلد `.homeassistant` وإنشاء مجلد `media` فيه.\\n- إذا كنت تستخدم Home Assistant Docker ، فأضف سطر ` -v /PATH_TO_YOUR_MEDIA:/media \\\\` إلى أمر Docker.\\n\\nللتحقق من أن كل شيء تم تعيينه بشكل صحيح ، انتقل إلى علامة التبويب “Media” -> “local media” في Home Assistant الخاص بك. \\nيجب أن ترى مجلدًا فارغًا (بدون أخطاء):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## استدعاء الخدمة\\n\\nلإرسال فيديو إلى Robonomics ، يجب عليك استدعاء خدمة مخصصة في Home Assistant. \\nفي هذا المقال يتم ذلك يدويًا ، ولكن يمكنك إنشاء تلقائي لذلك.\\n\\nللقيام بذلك ، انتقل إلى  \\\"Developer tools\\\" -> \\\"Services\\\"وابحث عن \\\"Robonomics: حفظ التسجيل في Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nفي \\\"الأهداف\\\" اختر كيان الكاميرا الخاص بك.\\nفي \\\"مسار حفظ التسجيل\\\" يجب أن قدم مسارًا مطلقًا إلى المجلد،\\nحيث يمكن لـ Home Assistant حفظ الفيديو:\\n- للصورة المثبتة مسبقًا - `/home/homeassistant/.homeassistant/media`;\\n- لـ HA OS أو Home Assistant Docker- `/media`;\\n- لـ Home Assistant Core - مسار إلى المجلد الذي تم إنشاؤه مسبقًا للوسائط.\\n\\nبالإضافة إلى ذلك ، يمكنك اختيار مدة التسجيل. \\n\\nاملأ البيانات واستدعِ الخدمة باستخدام زر \\\"استدعاء الخدمة\\\".\\n\\n## DAPP\\n\\nلعرض الفيديو الناتج ، انتقل إلى [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nالصق عنوان حساب جهاز التحكم الخاص بك وانقر على الزر أدناه. انتظر عملية \\\"البحث عن التوائم\\\". \\nكنتيجة ، ستحصل على CID IPFS مع جميع مقاطع الفيديو المسجلة.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nبعد ذلك ، حدد حساب جهاز التحكم (أو أي حساب آخر) من القائمة المنسدلة وقم بتوقيع رسالة للتفويض في\\nبوابة Web3 IPFS لتنزيل جميع مقاطع الفيديو. كنتيجة ، ستحصل على جميع مقاطع الفيديو المسجلة بواسطة منزلك الذكي.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nنظرًا لأن جميع مقاطع الفيديو في المجلد مشرة بمفتاح جهاز التحكم ، فإنه يجب عليك إدخاله لفك تشفير مقاطع الفيديو.\\nبعد ذلك ، يتم تنشيط زر تشغيل الفيديو. انقر عليه لتنزيل الفيديو.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"653474ad4d23e7fbd888cb4abda04be2\",\"title\":\"روبونوميكس سمارت هوم Overview\",\"path\":\"/docs/ar/robonomics-smart-home-overview/\",\"content\":\"\\n## الحماية الآمنة للأجهزة الإنترنت المتصلة بالبلوكشين \\n\\nبالنسبة لمنزلك الذكي، يوفر سوق الإنترنت المتصل بالأشياء الحديثة مجموعة واسعة من الحلول. ولكنك عادة ما تكون مرتبطًا بمزودي السحابة المركزية أو بوابات الملكية المكلفة. ونتيجة لذلك، فأنت كمستخدم تعتمد دائمًا على الأجهزة ومزود البنية التحتية لتشغيل نظامك الذكي. في الوقت نفسه، لا يمكن أن يكون منزلك الذكي حقًا ذكيًا بدون إحصاءات وتحليلات السحابة.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**نرى مشكلتين رئيسيتين في المنازل الذكية الحالية:**\\n\\n1. ليس لديك السيطرة على البيانات التي تشاركها مع البائع أو الطرف الثالث.\\n2. منزلك الذكي عرضة لإغلاق خوادم السحابة المركزية. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nلحل كلا المشكلتين، نقترح عليك تجربة روبونوميكس، سحابة آمنة وغير مركزية ومستقبلية.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## خطوات للحصول على سحابة خالية من الشركات\\n\\nفيما يلي بعض الخطوات البسيطة لإنشاء منزل ذكي بأسعار معقولة باستخدام Home Assistant كتطبيق للتواصل مع الأجهزة و Robonomics كمنصة سحابية غير مرتبطة بالشركات. يستفيد روبونوميكس من تقنيات الويب3 الحديثة الآمنة، مما يضمن تعزيز الأمان طوال العملية..\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Start هنا your smart home\\n\\nلقد أعددنا أدلة مفصلة حول إعداد منزل ذكي على روبونوميكس. قد تختلف الخطوات اعتمادًا على الحالة الخاصة بك: سواء كان لديك بالفعل Home Assistant تعمل مع الأجهزة المقترنة، أو إذا كنت تبدأ من الصفر لإنشاء منزلك الذكي.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ar/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/ar/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"0ed2183d90b77b92e81dc23a8a731c6e\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/ar/robonomics-prometheus-grafana/\",\"content\":\"\\n**تم توفير التعليمات التالية بواسطة [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**المقال الأصلي موجود [هنا](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## مقدمة\\nلمراقبة وصيانة أفضل للعقد الوبونوميكس ، من الجيد إعداد مراقبة استنادًا إلى خادم بروميثيوس وجرافانا. ستوضح هذه الوثيقة كيفية تكوين كل منهما لمراقبة العقد الخاص بك بشكل كامل.\\n\\n##  الشروط المسبقة\\n* [إعداد الخادم باستخدام Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [تم تثبيت مجمع Robonomics parachain](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* تأكد من أن robonomics.service يعمل على جهازك ويمكن الوصول إلى المنفذ 9615 \\n\\n## الخطوة 1 - إنشاء حسابات المستخدمين\\n\\nلأغراض الأمان ، سنبدأ بإنشاء حسابين جديدين للمستخدمين ، prometheus و node_exporter. قم بإنشاء هاتين الحسابين ، واستخدم الخيارات _--no-create-home_ و _--shell /bin/false_ حتى لا يتمكن هؤلاء المستخدمين من تسجيل الدخول إلى الخادم.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nقبل تنزيل برامج Prometheus ، قم بإنشاء الدلائل اللازمة لتخزين ملفات وبيانات Prometheus. وفقًا لتقاليد Linux القياسية ، سنقوم بإنشاء دليل في _/etc_ لملفات تكوين Prometheus ودليل في _/var/lib_ لبياناته.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nالآن ، قم بتعيين مالكية المستخدم والمجموعة على الدلائل الجديدة للمستخدم prometheus.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## الخطوة 2 - تنزيل برنامج Prometheus\\n\\nأولاً ، قم بتنزيل وفك حزمة الإصدار الثابت الحالي من Prometheus في دليل المستخدم الخاص بك. يمكنك العثور على أحدث البرامج الثنائية على [صفحة تنزيل Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nالآن ، قم بفك الأرشيف المحمل.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nسيتم إنشاء دليل يسمى prometheus-2.21.0.linux-amd64 يحتوي على ملفين ثنائيين (prometheus و promtool) ، ودلائل _consoles_ و _console_libraries_ التي تحتوي على ملفات واجهة الويب ، وترخيصًا ، وإشعارًا ، وعدة ملفات مثالية.\\n\\nانسخ الملفين الثنائيين إلى الدليل _/usr/local/bin_.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nقم بتعيين مالكية المستخدم والمجموعة على الملفين الثنائيين للمستخدم prometheus الذي تم إنشاؤه في الخطوة 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nانسخ الدلائل consoles و _console_libraries_ إلى _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nق بتعيين مالكية المستخدم والمجموعة على الدلائل للمستخدم prometheus. باستخدام العلامة -R سيضمن أن يتم تعيين المالكية على الملفات داخل الدليل أيضًا.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nالآن بعد تثبيت Prometheus ، سنقوم بإنشاء ملفات التكوين والخدمة الخاصة به في استعداد لتشغيله للمرة الأولى.\\n\\n## الخطوة 3 - تكوين Prometheus\\n\\nفي الدليل _/etc/prometheus_ ، استخدم nano أو محرر النص المفضل لديك لإنشاء ملف تكوين يسمى _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nفي الإعدادات العامة ، قم بتعريف الفاصل الزمني الافتراضي لجمع المقاييس. يجب أن يعمل Prometheus بهذه الإعدادات على كل مصدر بيانات ما لم تكون إعدادات المصدر الفردي تلغي الإعدادات العامة.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nقيمة الفاصل الزمني للجمع هذه تخبر Prometheus بجمع المقاييس من المصدر بيانات كل 15 ثانية ، وهو وقت كافٍ لمعظم المصدرين.\\nالآن ، أضف Prometheus نفسه إلى قائمة المصدرين للجمع من خلال التوجيهة التالية لـ scrape_configs:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nيستخدم Prometheus _job_name_ لوصف المصدرين في الاستعلامات وعلى الرسوم البيانية ، لذا تأكد من اختيار شيء وصفي هنا.\\n\\nوبما أن Prometheus يصدر بيانات مهمة عن نفسه يمكنك استخدامها لمراقبة الأداء وتصحيح الأخطاء ، فقد قمنا بتجاوز التوجيهة العامة للفاصل الزمني للجمع من 15 ثانية إلى 5 ثوانٍ للحصول على تحديثات أكثر تواترًا.\\n\\nأخيرًا ، يستخدم Prometheus التوجيهات _static_configs_ و _targets_ لتحديد مواقع تشغيل المصدرين. نظرًا لأن هذا المصدر يعمل على نفس الخادم الذي يعمل عليه Prometheus نفسه ، يمكننا استخدام localhost بدلاً من عنوان IP مع المنفذ الافتراضي 9090.\\n\\nيجب أن يبدو ملف التكوين الخاص بك الآن على هذا النحو:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nاحفظ الملف وأغلق محرر النص الخاص بك.\\n\\nالآن ، قم بتعيين مالكية المستخدم والمجموعة على ملف التكوين للمستخدم prometheus الذي تم إنشاؤه في الخطوة 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nمع الانتهاء من التكوين ، نحن جاهزون لاختبار Prometheus عن طريق تشغيله للمرة الأولى.\\n\\n## الخطوة 4 - تشغيل Prometheus\\n\\nقم بتشغيل Prometheus كمستخدم _prometheus_ ، وقدم المسار إلى كل من ملف التكوين ودليل البيانات.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nيحتوي الإخراج على معلومات حول تقدم تحميل Prometheus وملف التكوين والخدمات ذات الصلة. كما يؤكد أن Prometheus يستمع على المنفذ _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nإذا حصلت على رسالة خطأ، تحقق مرتين من استخدامك لصيغة YAML في ملف التكوين الخاص بك ثم اتبع التعليمات المعروضة على الشاشة لحل المشكلة.\\n\\nالآن، أوقف Prometheus عن طريق الضغط على _CTRL+C_، ثم افتح ملف خدمة _systemd_ جديد.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nيخبر ملف الخدمة _systemd_ بتشغيل Prometheus كمستخدم prometheus، مع ملف التكوين الموجود في الدليل _/etc/prometheus/prometheus.yml_ وتخزين البيانات في الدليل _/var/lib/prometheus_. قم بنسخ المحتوى التالي إلى الملف:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nأخيرًا، احفظ الملف وأغلق محرر النص الخاص بك. لاستخدام الخدمة الجديدة التي تم إنشاؤها، قم بإعادة تحميل systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nيمكنك الآن تشغيل Prometheus باستخدام الأمر التالي:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nللتأكد من تشغيل Prometheus، تحقق من حالة الخدمة.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nيخبرك الإخراج بحالة Prometheus ومعرف العملية الرئيسية (PID) واستخدام الذاكرة والمزيد.\\n\\nإذا لم تكن حالة الخدمة نشطة، اتبع التعليمات المعروضة على الشاشة وأعد تتبع الخطوات السابقة لحل المشكلة قبل متابعة البرنامج التعليمي.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nعندما تكون جاهزًا للمتابعة، اضغط على _Q_ لإنهاء الأمر الحالي. أخيرًا، قم بتمكين الخدمة للبدء عند التمهيد.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nالآن بعد أن تم تشغيل Prometheus ويعمل، يمكننا تثبيت مصدر بيانات إضافي لإنشاء مقاييس حول موارد الخادم الخاص بنا.\\n\\n## الخطوة 5 - تنزيل Node Exporter\\n\\nلتوسيع Prometheus ليشمل مقاييس حول نفسه فقط، سنقوم بتثبيت مصدر بيانات إضافي يسمى Node Exporter. يوفر Node Exporter معلومات مفصلة حول النظام، بما في ذلك استخدام وحدة المعالجة المركزية والقرص والذاكرة. قم بتنزيل الإصدار الثابت الحالي من Node Exporter إلى دليل المستخدم الخاص بك. يمكنك العثور على أحدث الثنائيات على [صفحة تنزيل Prometheus.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nالآن قم بفك ضغط الأرشيف الذي تم تنزيله.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nسيتم إنشاء دليل يسمى _node_exporter-1.0.1.linux-amd64_ يحتوي على ملف ثنائي يسمى _node_exporter_، وترخيص، وإشعار.\\n\\nانسخ الملف الثنائي إلى الدليل _/usr/local/bin_ وقم بتعيين مالكية المستخدم والمجموعة للمستخدم node_exporter الذي قمت بإنشائه في الخطوة 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nالآن بعد تثبيت Node Exporter، دعنا نقم بتجربته عن طريق تشغيله قبل إنشاء ملف خدمة له حتى يبدأ عند التمهيد.\\n\\n## الخطوة 6 - تشغيل Node Exporter\\n\\nإجراءات تشغيل Node Exporter مشابهة لتلك المتبعة لتشغيل Prometheus نفسه. ابدأ بإنشاء ملف خدمة Systemd لـ Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nانسخ المحتوى التالي إلى ملف الخدمة:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nاحفظ الملف وأغلق محرر النص الخاص بك. أخيرًا، قم بإعادة تحميل systemd لاستخدام الخدمة الجديدة التي تم إنشاؤها.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nيمكنك الآن تشغيل Node Exporter باستخدام الأمر التالي:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nتحقق من تشغيل Node Exporter بشكل صحيح باستخدام الأمر status.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nمثلما كان الحال من قبل، يخبرك هذا الإخراج بحالة Node Exporter ومعرف العملية الرئيسية (PID) واستخدام الذاكرة والمزيد. إذا لم تكن حالة الخدمة نشطة، اتبع التعليمات المعروضة على الشاشة وأعد تتبع الخطوات السابقة لحل المشكلة قبل المتابعة.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nأخيرًا، قم بتمكين Node Exporter للبدء عند التمهيد.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nبعد تكوين Node Exporter بالكامل وتشغيله كما هو متوقع، سنخبر Prometheus ببدء جمع المقاييس الجديدة.\\n\\n## الخطوة 7 - تكوين Prometheus لجمع مقاييس Node Exporter\\n\\nنظرًا لأن Prometheus يجمع فقط المصدرين التي تم تعريفها في جزء scrape_configs من ملف التكوين الخاص به، سنحتاج إلى إضافة إدخال جديد لـ Node Exporter، تمامًا كما فعلنا لـ Prometheus نفسه. افتح ملف التكوين.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nفي نهاية كتلة scrape_configs، أضف إدخالًا جديدًا يسمى node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nنظرًا لأن هذا المصدر يعمل أيضًا على نفس الخادم الذي يعمل عليه Prometheus نفسه، يمكننا استخدام localhost بدلاً من عنوان IP مرة أخرى مع منفذ Node Exporter الافتراضي، 9100. يجب أن يبدو ملف التكوين الخاص بك كالتالي:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nاحفظ الملف وأغلق محرر النص الخاص بك عندما تكون جاهزًا للمتابعة. أخيرًا، أعد تشغيل Prometheus لتطبيق التغييرات.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nمرة أخرى، تحقق من أن كل شيء يعمل بشكل صحيح باستخدام الأمر status.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nإذا لم يتم تعيين حالة الخدمة على نشطة، اتبع التعليمات المعروضة على الشاشة وأعد تتبع الخطوات السابقة قبل المتابعة.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nالآن لدينا Prometheus و Node Exporter مثبتان ومكونان ويعملان.\\n\\n## الخطوة 8 - إضافة Robonomic build في node_exporter\\n\\nبعد تثبيت Prometheus و node_exporter بنجاح، سيتعين علينا استخدام مصدر بيانات Prometheus المضمن في كل مشروع substrate. لتحقيق ذلك، يجب علينا إضافة إدخال إضافي إلى _/etc/prometheus/prometheus.yml_. \\nافتح ملف التكوين.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nفي نهاية كتلة scrape_configs، أضف إدخالًا جديدًا يسمى robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nاحفظ الملف وأغلق محرر النص. يجب أن يبدو ملف التكوين الخاص بك كما يلي:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nأخيرًا ، قم بإعادة تشغيل بروميثيوس لتطبيق التغييرات.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nمرة أخرى، تحقق من أن كل شيء يعمل بشكل صحيح باستخدام أمر الحالة.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nالآن لدينا بروميثيوس ومصدر العقدة ومصدر Robonomic مثبتة ومونة وجارية. الآن انتقل إلى Grafana\\n\\n## الخطوة 9 - إعداد Grafana\\n\\nآخر خطوة هي ربط بروميثيوس كمصدر بيانات في Grafana. لأغراض هذا البرنامج التعليمي ، سنستخدم Grafana المستندة إلى السحابة المجانية التي تسمح بوجود ما يصل إلى 5 لوحات تحكم بالإضافة إلى لوحة Robonomics المخصصة. انتقل ببساطة إلى grafana.com ، قم بإنشاء حساب جديد وقم بتسجيل الدخول إلى حالة Grafana الجديدة الخاصة بك.\\n\\nفي البداية ، يجب علينا إضافة مصدر بيانات جديد إلى Grafana والذي سيكون في حالتنا خادم Prometheus.\\nانتقل إلى مصدر البيانات:\\n\\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nثم انقر على إضافة مصدر بيانات\\n\\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nحدد بروميثيوس\\n\\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nفي الشاشة الجديدة ، ضع عنوان IP الخاص بخادم Prometheus مع منفذ 9090\\n\\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nبعد ذلك ، احفظ واختبر إذا قمت بجميع الخطوات يجب أن تكون النتيجة خضراء وجاهزة للاستيراد. في الموقع الرئيسي ، انقر على + ثم استيراد كما هو موضح في الصورة أدناه:\\n\\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nثم يجب أن ترى صفحة الاستيراد:\\n\\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nفي عنوان URL أو معرف لوحة القيادة في Grafana.com ، اكتب 13015 (حيث يعد هذا هو معرف لوحة Robonomic)\\n\\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nبعد تحميل لوحة القيادة الخارجية ، ستحصل على هذه الشاشة:\\n\\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nآخر خطوة هي اختيار مصدر البيانات الذي تم إنشاؤه مسبقًا والنقر فوق استيراد\\n\\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nهذا كل شيء! في هذه النقطة ، يجب أن ترى لوحة القيادة المستوردة. \\n\\n\\n## المراجع\\n\\n* [كيفية تثبيت بروميثيوس على أوبونتو 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [إنشاء لوحة مراقبة بواسطة بروميثيوس + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [دعم Grafana لـ Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [رصد مقاييس مضيف Linux باستخدام مصدر العقدة](https://prometheus.io/docs/guides/node-exporter/)\\n* [استعلام بروميثيوس](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [تصور مقاييس العقدة](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [مصدر بروميثيوس للعقدة](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [لوحة القيادة polkadot](https://github.com/w3f/polkadot-dashboard)\\n* [مقياس العقدة Polkadot](https://grafana.com/grafana/dashboards/12425)\\n* [لوحة القيادة Node Exporter لـ Prometheus](https://grafana.com/grafana/dashboards/11074)\\n* [مقاييس Grafana ROBONOMICS (XRT)](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"f0957a1d4e9f91442bceecd34467981b\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/ar/robonomics-opengov/\",\"content\":\"\\n## مقدمة\\n\\nتحول Robonomics نموذج حكم الباراشين إلى آلية OpenGov المتطورة في Polkadot التي تسمح للشبكة بالتطور مع مرور الوقت، بناءً على رغبة حاملي الرموز.\\nانتقال Robonomics إلى OpenGov يضمن أن يتمكن حالو رموز DAO، الذين يسيطرون على غالبية الحصة، من أن يأمروا دائمًا باتجاه باراشين Robonomics، وتنفيذ أي تغيير في الشبكة يرونه مناسبًا.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  ينطبق OpenGov فقط على Robonomics Parachain وهي سلسلة قائمة على الركيزة متصلة بسلسلة Kusama Relay Chain. لا ينطبق OpenGov على تطبيق Robonomics Ethereum، حيث أن شبكة Ethereum الرئيسية لا تدعم حاليًا أنظمة الحوكمة المتطورة مثل OpenGov\\n</robo-wiki-note>\\n\\nيغير OpenGov كيفية تنفيذ العمليات اليومية واتخاذ القرارات على الباراشين. يوفر وضوحًا أكبر بشأن نطاق الاستفتاءات ولديه القدرة على زيادة إلى حد كبير عدد القرارات التي يتم اتخاذها على الباراشين.\\n\\nتم تشغيل OpenGov على سلسلة Kusama Relay لبضعة أشهر في وقت كتابة هذا النص، وقد أثبت أنه يزيد بشكل كبير من عدد القرارات (الاستفتاءات الفردية والمنفصلة) التي يمكن لحاملي رموز DAO أن يقترحوها ويصوتوا عليها، ومن خلال التصويت - يتحكمون في نهاية المطاف في اتجاه البرووكول.\\n\\n**المحتوى الوارد في هذا القسم من الويكي سيتناول المبادئ الأساسية لـ OpenGov على باراشين Robonomics ويهدف إلى مساعدتك في فهم المفاهيم الكامنة وراء OpenGov.**\\n\\n*من المهم أن نلاحظ أن الحوكمة هي آلية متطورة باستمرار في البروتوكول، خاصة في مراحل التنفيذ المبكرة.*\\n\\nبالنسبة لأولئك الذين مهتمون بمعلمات مسار Robonomics OpenGov، انظر [هنا](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## حول الاستفتاءات\\n\\nالاستفتاءات هي طرق تصويت بسيطة وشاملة ومبنية على الحصة. يتم تعيين اقتراح محدد لكل استفتاء يأخذ شكل استدعاء وظيفة مميزة في وقت التشغيل للسلاسل. يمكن أن يشمل ذلك أيضًا الاستدعاء الأقوى `set_code``، الذي يتمتع بالقدرة على تبديل التعليمات البرمجية الكاملة لوقت تشغيل السلاسل - وهذا فريد بالنسبة للسلاسل القائمة على الركيزة، ويزيل متطلبات \\\"الشوكة الصلبة\\\" للسلسلة عند تحديث منطق أعمال السلاسل ( مدة العرض).\\n\\nالاستفتاءات هي أحداث منفصلة لها فترة تصويت محددة (سنتحدث في وقت لاحق عن الفترات المختلفة خلال دورة حياة الاستفتاء). يمكن لحاملي الرموز الفرديين التصويت بثلاث طرق على الاستفتاءات - AYE (موافقة/نعم)، NAY (اعتراض/لا)، أو ABSTAIN (عدم التصويت تمامًا).\\n\\nجميع الاستفتاءات لها فترة تنفيذ مؤجلة مرتبطة بها. هذه هي الفترة بين انتهاء الاستفتاء و، بفرض أن تمت الموافقة على الاستفتاء، تنفيذ التغييرات على الشبكة. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  هناك فترة تنفيذ **الحد الأدنى** محددة بشكل خاص لكل نوع مختلف من Origin، ولكن صاحب الاقتراح الخاص بالاستفتاء يمكنه تعيين مهام تلك الاستفتاءات المحددة لتنفيذ العديد من الكتل في المستقبل\\n\\n</robo-wiki-note>\\n\\nتعتبر الاستفتاءات \\\"مخبوزة\\\" إذا تم إغلاقها وتم تجميع الأصوات. بفرض أن تمت الموافقة على الاستفتاء، سيتم جدولته للتنفيذ (في جدولة السلاسل). تعتبر الاستفتاءات \\\"غير مخبوزة\\\" إذا كانت النتيجة قيد الانتظار - مثل إذا كان الاستفتاء لا يزال قيد التصويت حاليًا.\\n\\nمع إضافة OpenGov، يمكن لأي شخص أن يبدأ استفتاء في أي وقت، ويمكنه أن يفعل ذلك مرارًا وتكررًا. يزيل OpenGov القيود المتعلقة بإمكانية معالجة استفتاء واحد فقط في وقت واحد (يرجى ملاحظة أنه في Gov v1، يمكن التصويت على استفتاء واحد فقط في وقت واحد. باستثناء استفتاء الطوارئ الإضافي من قبل اللجنة الفنية المسرعة التي يمكن أيضًا التصويت عليها في نفس الوقت من قبل المجتمع).\\n\\nيقدم OpenGov العديد من الميزات / المفاهيم الجديدة المعروفة بـ Origins و Tracks، وتم تقديمها للمساعدة في تدفق ومعالجة الاستفتاءات في البروتوكول.\\n\\nيتم ربط كل Origin بفئة استفتاء واحدة، ويتم ربط كل فئة بمسار. يحدد المسار دورة حياة الاستفتاء وهو محدد لهذا الأصل المحدد الذي ينبعث منه الاستفتاء. يسمح وجود مسارات بمعلماتها الخاصة بتعديل دورة حياة الاستفتاءات بناءً على مستوى الامتياز الخاص بها (يمكنك أن تعتبر مستوى الامتياز كونه مدى قوة الاستفتاء وأنواع التغييرات التي يمكن أن يجريها على البروتوكل).\\n\\n*فكر في Origins كالسلطة المرتبطة بالاستفتاء، وفكر في Tracks كمعلمات التصويت المرتبطة بالاستفتاء، مثل طول فتراته ومعايير الموافقة والدعم.*\\n\\nعلى سبيل المثال، الترقية الزمنية للتشغيل ليست لها نفس الآثار على البروتوكول مثل تلميح الخزينة الصغير، وبالتالي يلزم وجود أصول مختلفة يتم تحديدها فيها معدلات تصويت مختلفة وموافقات وودائع وفترات تنفيذ (Tracks) محددة مسبقًا في الباليت الخاص بالسلاسل.\\n\\n## تقديم استفتاء ودورة حياة الاستفتاء \\n\\n### فترة التحضير\\n\\nفي OpenGov، عند إنشاء استفتاء بداية، يمكن التصويت عليه فوراً من قبل مجتمع حاملي الرموز. ومع ذلك، فإنه ليس في حالة يمكنه فيها الانتهء، أو إجراء فرز الأصوات، أو الموافقة عليه وتنفيذه فوراً. بدلاً من ذلك، يجب على الاستفتاءات أن تستوفي عددًا من المعايير قبل أن يتم نقلها إلى فترة القرار. حتى يدخل الاستفتاء فترة القرار، سيظل غير محدد - وفي النهاية سينتهي بعد فترة العمر الكلية كما هو محدد في المسار الفردي.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nالمعايير التي يجب توفرها لدخول الاستفتاء فترة القرار هي كما يلي:\\n1. فترة التحضير التي تحدد المدة التي يجب أن تمر قبل بدء فترة القرار. تساعد فترة التحضير على التخفيف من إمكانية \\\"التصويت السريع\\\" حيث يمكن للمهاجم الذي يسيطر على حصة كبيرة من القوة التصويتية أن يحاول استخدام حصته الكبيرة لتمرير استفتاء فورًا بعد الاقتراح، مما يتجاوز إمكانية أعضاء الجمعية الديمقراطية لحاملي الرموز الآخرين للحصول على وقت كافٍ للنظر في الاستفتاء والمشاركة في التصويت. ولهذا السبب تتمتع المنشآت ذات المستويات الأعلى من الامتياز بفترات تحضير أطول بشكل كبير.\\n\\n2. يجب أن يكون هناك مساحة لاتخاذ القرار. كل مسار لديه حدوده الخاصة لعدد الاستفتاءات التي يمكن اتخاذ قرار بشأنها في وقت واحد (max_deciding). المسارات التي تتمتع بمستويات امتياز أكثر قوة ستكون لها حدود أقل. على سبيل المثال، سيكون لدى المنشأة على مستوى الجذر عدد أقل بكثير من الاستفتاءات التي يمكن اتخاذ قرار بشأنها في وقت واحد مقارنة بالمنشآت ذات مستويات امتياز أقل مثل منشأة Small Tipper.\\n\\n3. يجب تقديم الوديعة القرارية. في البداية، إن إنشاء استفتاء رخيص نسبياً، وقيمة الوديعة المقدمة (التي تحجز عند إنشاء الاستفتاء بداية) منخفضة نسبياً، وتتألف بشكل رئيسي من القيمة التي يكلفها التخزين على السلسلة المتصلة بالاستفتاء. تكون الودائع القرارية أعلى بكثير، وهو ما يلزم لمكافحة البريد المزعج، ويلعب دورًا ي اللعبة الاقتصادية التي يقدمها OpenGov، والتي سنتناولها لاحقًا.\\n\\nبمجرد توفر كل هذه المعايير الثلاثة أعلاه، سينتقل الاستفتاء إلى فترة القرار. سيتم ثم فرز الأصوات على الاستفتاء نحو النتيجة.\\n\\n### فترة القرار\\n\\n*لمشاهدة فيديو توضيحي سريع لفترة القرار، انظر [هذا الفيديو](https://www.youtube.com/watch؟v=wk58C-2CqPI)*.\\n\\nبمجرد أن يستوفي الاستفتاء جميع المعايير كما هو موضح في القسم أعلاه، سيدخل فترة القرار.\\n\\nتدور فترة القرار حول مفهومين رئيسيين، وهما معايير الموافقة والدعم. \\n\\nتعرف الموافقة على أنها حصة وزن التصويت المؤيد (AYEs مقابل NAYs) مقارنة بإجمالي وزن التصويت (جميع التصويتات المؤيدة والمعارضة مجتمعة). يساهم اقتناع كل تصويت في الوزن الإجمالي للتصويتات المؤيدة/المعارضة (المزيد عن التصويت بالاقتناع / القفل الطوعي في الأقسام لاحقًا).\\n\\nالدعم هو إجمالي عدد الأصوات (الموز) التي شاركت في الاستفتاء (ولا يتم تعديلها بناءً على الاقتناع) مقارنة بإجمالي الأصوات الممكنة التي يمكن أن تتم في النظام (فكر في هذا على أنه إجمالي إصدار XRT على الباراشين - ولاحظ أن الإمداد الدوري الكلي لـ XRT ليس العامل الرئيسي هنا، بسبب حقيقة أن جزءًا من تلك الأرقام موجود على Ethereum كرموز ERC-20).\\n\\n**الأصوات التي تكون في اتجاه الامتناع لا تساهم في معايير الموافقة، ولكنها مدرجة / تحتسب في معايير الدعم**\\n\\nيجب أن يستوفي الاستفتاء معايير الدعم والموافقة خلال فترة القرار من أجل التقدم إلى فترة التأكيد.\\n\\nلمزيد من التفاصيل حول معايير الدعم والموافقة الفردية لكل مسار، انظر إلى [جدول البيانات](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit؟usp=sharing).\\n\\n### فترة التأكيد\\n\\nكل مسار له مدة محددة لفترة التأكيد. المسارات التي تتمتع بمستويات امتياز أعلى (مثل الجذر) لديها فترات تأكيد أطول بشكل كبير من تلك ذات المستويات الأقل (مثل Small Tipper).\\n\\nيجب أن تستمر الاستفتاءات في تلبية معايير الدعم والموافقة طوال مدة فترة التأكيد، وإلا فإنها ستعود مرة أخرى إلى فترة القرار (ملاحظة: لا يتم إيقاف فترة القرار خلال فترة التأكيد، لذلك فمن الممكن تمامًا أن تنتهي فترة القرار خلال فترة التأكيد، مما يعني أنه إذا تم طرد استفتاء من فترة التأكيد بسبب عدم استيفاء معايير الدعم والموافقة، فسيتم اعتباره استفتاء فاشل ولن يتم تنفيذه).\\n\\n**من الممكن ضبط معايير الموافقة والدعم للمسارات الفردية من خلال استفتاء بامتيازات الأصل الجذري.**\\n\\nالأصول ذات المستويات الأدنى من الامتياز لديها معايير الموافقة والدعم أسهل بكثير (تحددها المسار) لتلبية تلك ذات المستويات الأعلى من الامتياز. بالمثل، الأصول ذات المستويات الأعلى من الامتياز لديها منحنيات أقل حدة من تلك ذات المزيد من الامتيازات (كما هو محدد في المسار)، من أجل ضمان موافقة حامل رمز DAO على الاستفتاء، وتجنب الاستفتاء على الأصول ذات الامتياز العالي.\\n\\nفي OpenGov، يُعتبر الاستفتاءات التي لم يتم الموافقة عليها بعد انتهاء فترة القرار مرفوضة بشكل افتراضي، ويتم استرداد الودائع المقدمة والقرار إلى أصحابها (ملاحظة: يمكن أن يتم نشر القرار بواسطة شخص آخر غير مقدم الاستفتاء).\\n\\nإذا تمكن الاستفتاء من تلبية معايير الموافقة والدعم بشكل مستمر لفترة التأكيد بأكملها، فإنه يعتبر موافق عليه، وسيتم جدولته للتنفيذ من الأصل المقترح، ولكن الاستفتاء سيتم تنفيذه فقط بعد انقضاء الفترة الدنيا للتنفيذ.\\n\\n### فترة التنفيذ\\n\\nتحدد فترة التنفيذ من قبل المقدم عند اقتراح الاستفتاء، ولكنها تخضع للفترة الدنيا للتنفيذ التي يتم تحديدها في كل مسار. تمتلك الأصول الأقوى فترة تنفيذ دنيا أطول بكثير من تلك ذات الامتيازات الأقل. يضمن ذلك أن الشبكة لديها وقت كافٍ للتحضير لأي تغييرات قد يفرضها الاستفتاء القوي.\\n\\n## القفل الطوعي / الإدانة\\n\\nيستخدم Robonomics مفهوم القفل الطوعي أو التصويت بالإدانة. يسمح هذا لحاملي الرموز بزيادة قوة التصويت الخاصة بهم عن طريق تحديد مدة قفل الرموز التي يرغبون في قفلها للاستفتاء الخاص. يؤثر هذا الآلية فقط على معايير الموافقة لكل استفتاء، ولا يؤثر التصويت بالإدانة على معايير الدعم.\\n\\nيمكن حساب التصويت بالإدانة باستخدام هذه الصيغة:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nتوضح هذه الجدول كيف يتضاعف صوتك لمعايير الموافقة مع زيادة فترة القفل:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nأقصى قدر من الإدانة الذي يمكن لحامل الرمز استخدامه هو 6 مرات الإدانة. يمكنك فقط تعيين الإدانة وفقًا للجدول أعلاه، ولا يمكنك، على سبيل المثال، استخدام 5.5 مرات الإدانة.\\n\\nعندما يتم قفل الرمز بسبب التصويت، يمكن استخدامه للتصويت في استفتاءات أخرى، ومع ذلك، لن يكون جزءًا من رصيدك القابل للتحويل (لا يمكنك إرساله إلى حساب آخر) - وسيصبح الرصيد قابلًا للتحويل مرة أخرى بعد انتهاء فترة القفل بأكملها.\\n\\n## تفويض التصويت\\n\\nفي OpenGov، تمت إضافة آلية تسمح لحاملي الرموز الذين ليس لديهم بالضرورة الوقت الكافي لمراجعة كل استفتاء بأن تسخدم رموزهم كجزء من نظام الحوكمة، وهذا معروف باسم تفويض التصويت.\\n\\nيمكن لحاملي الرموز اختيار تفويض قوة التصويت الخاصة بهم إلى ناخب آخر في النظام (حساب آخر). يمكن للناخبين تحديد تفويض قوة التصويت الخاصة بهم بطريقة متجددة، مما يتيح لهم تعيين قوة التصويت الخاصة بهم لحساب مختلف لكل Origin فردي. يمكن للناخبين أيضًا تعيين كمية مختلفة من قوة التصويت لكل Origin (عدد الرموز ومستوى الإدانة).\\n\\nتهدف هذه الميزة إلى زيادة نسبة المشاركة في التصويت، وضمان تحقيق معايير الموافقة والدعم المطلوبة.\\n\\nلتفويض قوة التصويت الخاصة بك، يمكنك استخدام وظيفة \\\"التفويض\\\" التي يمكنك العثور عليها في قسم الحوكمة -> الاستفتاء في [بوابة Robonomics](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). بدلاً من ذلك، يمكن للمستخدمين تقديم استخراج convictionVoting(Delegate) باستخدام قسم المطور -> الاستخراج في بوابة Robonomics، ومع ذلك، استخدام وظيفة \\\"التفويض\\\" في قسم الاستفتاء في البوابة أسهل بكثير.\\n\\n## إلغاء / إنهاء الاستفتاء ولعبة الاقتصادية للحوكمة\\n\\nفي OpenGov، هناك Origins مخصصة لرفض الاستفتاءات الجارية، بغض النظر عن حالتها. يُعرف هذه بمسارات إلغاء الحوكمة وقاتل الحوكمة.\\n\\nتتدخل هذه المنشآت في استفتاء تم التصويت عليه بالفعل. إذا تمت الموافقة على الاستفتاء الناتج عن هذه المنشأة، فسيتم رفض الاستفتاء الجاري على الفور بغض النظر عن حالته. \\n\\nالإلغاء نفسه هو نوع من الاستفتاء يجب أن يتم التصويت عليه من قبل حاملي الرموز ليتم تنفيذه. يأتي الإلغاء مع منشأه ومساره الخاصين الذين لديهما وقت قيادة أقل (فترة القرار، إلخ)، ولهما منحنيات الموافقة والدعم بمنحنيات أكثر حدة (مما يعني أن معاييرهما أسهل بكثير لتحقيقها مع مرور الوقت) من المنشآت الأخرى. يرجع ذلك إلى حقيقة أن إلغاء الاستفتاء عادة ما يأتي مع شعور بالعاجلية.\\n\\nيهدف قاتل الحوكمة إلى رفض الاستفتاء الجاري على الفور. عندما يتم إلغاء الاستفتاء بواسطة هذا المنشأ، يتم استرداد الوديعة المقدمة ووديعة القرار إلى أصحابها. مثال على الوقت الذي يمكن اعتباره إلغاء الاستفتاء هو إذا قام المنشئ بارتكاب بعض الأخطاء البشرية في محتوى استفتاءه، ولم يحاول بالضرورة فعل أي شيء خبيث.\\n\\nيهدف قاتل الحوكمة إلى رفض الاستفتاء الجاري على الفور. هنا يدخل لعبة الاقتصادية للحوكمة. المنشآت ذات مستويات امتياز عالية، مثل الجذر، لديها وديعة قرار تتطلب كمية عالية من رأس المال (رموز XRT) ليتم نشر الاستفتاء في فترة القرار. \\n\\nإذا قام مهاجم خبيث بتقديم استفتاء، مثل استفتاء بأصول جذرية يهدف إلى `set_code` لتشغيل سلسلة لإيقاف إنتاج الكتل، فيمكن لجمعية حاملي الرموز أن تثير استفتاء قاتل الحوكمة لمعاقبة هذ العمل. إذا تم رفض الاستفتاء الخبيث عن طريق منشأ قاتل الحوكمة، فإن كل من الوديعة المقدمة ووديعة القرار يتم خصمها، مما يعني أن المنشئ (الحسابات التي قدمت هذه الودائع) ستفقد تلك الأموال. \\n\\nوهذا يعني أن هناك عواقب اقتصادية خطيرة للمهاجمين الخبيثين الذين يحاولون رفع استفتاء قد يكون له تأثيرات سلبية خطيرة على السلسلة، والتي في النظرية ستمنع أي مهاجم خبيث من محاولة القيام بذلك.\\n\\nإيداع القرار لمسار قاتل الحوكمة نفسه عالي جدًا، وذلك لمنع المشاركين الخبيثين من محاولة تخفيض الودائع للاستفتاء الجيد. يمكن قتل استفتاء قاتل الحوكمة الحالي بواسطة استفتاء قاتل لاحق.\\n\\n## لجنة التقنية لروبونوميكس والأصل المسموح به\\n\\nهذه المجموعة هي هيئة خبيرة ذاتية الحكم تهدف في المقام الأول إلى تمثيل البشر الذين يتمتعون بالمعرفة التقنية لبروتوكول شبكة روبونوميكس. \\n\\nهذه المجموعة (وفقط هذه المجموعة) قادرة على إطلاق استفتاءات من لوحة الأصول المسموح بها. تقوم هذه اللوحة بشيء واحد فقط، وهو السماح لأصل واحد بتصعيد مستوى امتياز آخر لعملية معينة. \\n\\nيمكن لهذه المجموعة أن تأذن بإجراء استفتاء من أصل يعرف باسم الجذر المسموح به، ويمكن تنفيذ هذه الاستفتاءات بامتيازات المستوى الجذري، ولكن هذه الاستفتاءات ستعمل بنجاح فقط مع بعض الأوامر المحددة التي تمت الموافقة عليها من قبل المجموعة. تتحقق لوحة الأصول المسموح بها من شيئين:\\n1. الأصل هو حقًا الجذر المسموح به (أي أن الاستفتاء قد مر عبر مسار هذا الأصل).\\n2. تمت الموافقة على الاقتراح من قبل المجموعة.\\n\\nإذا كانت كلا الشروط صحيحة، فسيتم تنفيذ العملية بامتيازات المستوى الجذري.\\n\\nيتيح هذا النظام القدرة على وجود مسار مواز جديد (أصل الجذر المسموح به)، حيث تسمح معلماته بفترة تصويت أقصر (معايير الموافقة والدعم أسهل قليلاً من المستوى الجذري). يسمح هذا العملية المفتوحة والشفافة لهذه المجموعة من الخبراء في بروتوكول شبكة روبونوميكس بتقديم استفتاءات يعتبرونها آمنة وحاسمة.\\n\\nيجب ملاحظة أن معايير الدعم للاستفتاء الذي يبدأ بأصل الجذر المسموح به لا تتجه نحو الصفر مثل العديد من الأصول/المسارات الأخرى. يضمن ذلك أن هذه المجموعة ليست لديها السيطرة الفعلية على بروتوكول شبكة روبونوميكس بأكمله، ويتطلب مستوى دعم (مشاركة الناخبين) الحد الأدنى من حاملي الرمز الكلي.\\n\\n\\n## مدة الاستفتاء \\n\\nمن المهم أن نفهم أن مدة كل استفتاء فردي ليست شيئًا ثابتًا، فهي ليست محددة بشكل قاطع. بعض الفترات داخل دورة حياة الاستفتاء، مثل فترة التنفيذ الدنيا، لها فعلاً مدة محددة، ومع ذلك - الفترة القرارية وغيرها ليست كذلك. على سبيل المثال، ليس من دقة أن نجمع أقصى مدة لفترات التحضير والقرار والتأكيد والتنفيذ الدني ونقول \\\"كل استفتاء سيستغرق X عدد الأيام\\\"، فهو أكثر سلاسة من ذلك بكثير.\\n\\nلنلقِ نظرة على ذلك من خلال عدد قليل من الاستفتاءات المنفصلة، التي تنبع جميعها من نفس الأصل، في هذه الحالة، الأصل الجذري. \\n\\nالأصل الجذري له مساره الخاص، حيث يتم تعيين مدة كل فترة، وكذلك منحنيات الموافقة والدعم.\\n\\nمن المهم أن نتذكر أن الاستفتاءات ستتقدم إلى المرحلة التالية في دورتها الحياتية إذا تم تلبية شروط معينة. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nيجب أن تفترض في الصور التالية أنه، من أجل أن يتقدم الاستفتاء إلى المرحلة التالية في دورته الحياتية، يجب أن تكون قد تم تلبية الشروط كما هو موضح في الصورة أعلاه (ما لم يُذكر خلاف ذلك).\\n\\n\\n### المدة القصوى الممكنة مع قليل جدًا من مشاركة الناخبين\\n\\nالصورة أدناه هي تمثيل للجدول الزمني الأقصى الممكن للاستفتاء، فكر في ذلك كاستفتاء يحتوي على:\\n1. تم نشر إيداع القرار، وبالتالي دخل فترة القرار.\\n2. صوت واحد فقط، على سبيل المثال، 1 XRT، في اتجاه الإيجابية - وهذا يعني أنه سيتم تلبية الدعم المطلوب (مشاركة الناخبين) في نهاية فترة القرار (نظرًا لأن الدعم العام منخفض جدًا)، ولكنه يحظى بموافقة 100%، لذا سيتم تلبية متطلبات دخول فترة التأكيد.\\n3. يستمر في تلبية المعايير المذكورة أعلاه خلال فترة التأكيد.\\n4. سيتم تنفيذ الاقتراح الذي أثير بواسطة الاستفتاء بالضبط في نفس الكتلة التي تنتهي فيها فترة التنفيذ الدنيا - من الناحية التقنية، يمكن لمبتكر الاستفتاء تعيين تغييرات الشبكة كما هو موضح في الاستفتاء لتنفيذ العديد من الكتل في المستقبل، لذا يمكن أن تستمر دورة حياة الاستفتاء الفردي الفعلية على مدى عدة أيام أو أسابيع أو أشهر أو سنوات.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nيمكننا أن نرى في هذا المثال أن دورة حياة الاستفتاء ستكون (تقريبًا) 17 يومًا.\\n\\n\\n### المدة مع الكثير من مشاركة الناخبين (مع عدد عال من الأصوات الإيجابية)\\n\\nالآن دعونا نلقي نظرة على الاستفتاء الذي أبدى فيه حامل الرمز المميز XRT DAO الكثير من الاهتمام. في هذا المثال، سنفترض أن ما يقرب من 248,771 XRT في إجمالي إقبال الناخبين قد حدث، وأن جميع الناخبين يصوتون في اتجاه AYE (ملاحظة: من الناحية الفنية في هذه المرحلة من الاستفتاء الجذري، وفقًا للمسار، يجب أن يكون 60% فقط من الأصوات يكون في اتجاه AYE لإجراء استفتاء للوفاء بمعايير الموافقة).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n قم دائمًا بمراجعة أحدث معلومات المسار للحصول على معلومات دقيقة فيما يتعلق بكل مسار، ويمكن العثور على مزيد من المعلومات في هذا [جدول البيانات](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nفي هذا المثال:\\n1. تم نشر إيداع القرار خلال فترة الإعداد، وبالتالي كان قادرًا على الانتقال إلى فترة اتخاذ القرار في نهاية فترة الإعداد.\\n2. صوت العديد من الناخبين على هذا الاستفتاء - حيث حصلوا على نسبة إقبال للناخبين تصل إلى 248,771 XRT تقريبًا في فترة زمنية قصيرة نسبيًا.\\n3. كانت الأصوات أغلبية في اتجاه AYE (أي شيء أعلى من 60% AYE).\\n4. يفي الاستفتاء باستمرار بمعايير فترة التأكيد طوال فترة التأكيد الخاصة به (ملاحظة: إذا توقف الاستفتاء عن تلبية معايير فترة التأكيد، فسيتم إعادته مرة أخرى إلى فترة القرار الخاصة به).\\n5. سيتم سن الاقتراح الذي طرحه الاستفتاء بالضبط على نفس الكتلة التي تنتهي فيها فترة التشريع الدنيا.\\n\\nنظرًا لوجود ما يقرب من 248,771 مشاركة في XRT، فإن الاستفتاء سوف يلبي معايير الدخول في فترة التأكيد الخاصة به بعد حوالي 168 ساعة (7 أيام).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nيمكننا أن نرى أنه في هذا المثال الثاني، نظرًا لوجود قدر كبير من إقبال الناخبين، انتهت فترة اتخاذ القرار فعليًا في منتصف الوقت الأقصى المخصص لها. مما يؤدي إلى استفتاء يمكن تفعيله خلال 10 أيام تقريبًا.\\n\\n\\n### المدة التي لا يتم فيها نشر إيداع القرار مطلقًا\\n\\nالآن، دعونا نلقي نظرة على الاستفتاء الذي تم إنشاؤه، ولكن لم يتم نشر إيداع القرار الخاص به مطلقًا. تكون مثل هذه الاستفتاءات في حالة من \\\"حالة النسيان\\\"، حيث تنتهي فترة الإعداد لها، ولكن نظرًا لعدم نشر إيداع القرار، يظل الاستفتاء في \\\"حالة الإعداد\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\n\\nيمكننا أن نرى أنه في هذا المثال الثالث، نظرًا لحقيقة أن إيداع القرار لم يتم نشره مطلقًا، فإن الاستفتاء لن يدخل أبدًا في فترة اتخاذ القرار، وبدلاً من ذلك يبقى في \\\"حالة الإعداد\\\". وهذا يعني أنه في النهاية، إذا لم يتم نشر أي إيداع للقرار، فسوف تنتهي مهلة الاستفتاء بعد انقضاء المدة المحددة في ثابت المهلة الخاص بمنصة التحميل.\\n\\nلقد حدث هذا في Kusama سابقًا، حيث تم نشر الاستفتاء بأصول الجذر، ولكن نظرًا لمتطلبات رأس المال العالية لنشر إيداع القرار، لم يدخل الاستفتاء أبدًا المراحل الأخيرة من دورة حياته. ويختتم هذا الاستفتاء بعلم \\\"انتهت المهلة\\\".\\n\\n\\n### المدة التي يتم فيها نشر إيداع القرار في وقت متأخر\\n\\nأخيرًا، دعونا نلقي نظرة على مثال حيث لم يتم نشر إيداع القرار لفترة طويلة بعد بدء الاستفتاء. لقد حدث هذا سابقًا في Kusama حيث تم نشر استفتاء باستخدام الأصل الجذري، ولكن كان على المنشئ قضاء بعض الوقت للعثور على شخص لديه قدر كبير من رأس المال لنشر إيداع القرار نيابة عنه.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nفي هذا المثال الأخير، نظرًا لأنه تم نشر إيداع القرار بعد انتهاء فترة الإعداد، ولكن قبل انتهاء مهلة الاستفتاء - فإن دورة حياة الاستفتاء هي في الواقع أطول بكثير من المعتاد، حيث يدخل فترة القرار بعد كمية أطول من الوقت.\\n\\nمن المهم ملاحظة أن حامل الرمز المميز DAO قادر على التصويت بـ AYE/NAY في الاستفتاءات الموجودة في فترة الإعداد، أو العالقة في \\\"حالة الإعداد\\\".\\n\"}},{\"node\":{\"id\":\"47fd9137cce4dd4d1a9d2a4223edb232\",\"title\":\"إعداد تكامل Robonomics\",\"path\":\"/docs/ar/robonomics-hass-integration/\",\"content\":\"\\n**في هذه المقالة، ستضيف Robonomics إلى Home Assistant. يتيح ذلك لـ Home Assistant تسجيل سجلات البيانات ببيانات مشفرة إلى Robonomics Parachain والاستماع إلى أوامر الإطلاق من الباراشين للتحكم في الأجهزة الذكية. يستخدم التكامل IPFS لتخزين البيانات وإرسال تجزئات IPFS إلى وظائف السجلات أو الإطلاق.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. في واجهة الويب لـ Home Assistant، انتقل إلى `Settings` -> `Device & Services` واضغط على `ADD INTEGRATION`. ابحث عن `Robonomics`.\\n\\n2. انقر على Robonomics واملأ التكوين: \\n\\n- أضف البذرة من حساب `SUB_CONTROLLER` إلى بذرة حساب المراقب.\\n- أضف عنوان الحساب العام لحساب `SUB_OWNER` إلى عنوان مالك الاشتراك.\\n- قم بتعيين فترة إرسال البيانات (بشكل افتراضي هو 10 دقائق).\\n- (اختياري) يمكنك إضافة بيانات اعتماد لخدمة التثبيت Pinata أو بوابة مخصصة أخرى لنشر بياناتك على نطاق أوسع في شبكة IPFS.\\n\\n3. اضغط على `SUBMIT` بعد الانتهاء من التكوين. إذا قمت بملء كل شيء بشكل صحيح، سترى نافذة النجاح.\\n\\nهذا كل شيء! لقد قمت بإعداد تكامل Robonomics بالكامل في Home Assistant. الآن يمكنك استخدام جميع \\nخدمات Robonomics عبر الويب. لمعرفة المزيد عنها، انتقل إلى [\\\"قسم الاستخدام\\\"](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"c3e978f3aa6e973ef2d992692d285360\",\"title\":\"واجهة Python و Robonomics IO\",\"path\":\"/docs/ar/rinterface/\",\"content\":\"\\n**بعض العمليات الخارجية المنفذة في حزم Robonomics من الصعب تقديمها من تطبيق Polkadot. بالإضافة إلى ذلك، هناك \\nحاجة للتفاعل مع هذه الوظائف باستخدام لغات البرمجة. لهذا الغرض تم تطوير أداة Python بسيطة\\ncalled [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface). إنه غلاف فوق صيانة polkascan\\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). فيما يلي وصف موجز لهذه الحزمة\\nوبعض الروابط والأمثلة المفيدة. أيضًا، يتم مناقشة أدوات CLI.**\\n\\n## robonomics-interface\\n\\nمتاح على [PyPi](https://pypi.org/project/robonomics-interface/) حزمة جاهزة للتنزيل والإعداد.\\nهناك وثائق مفصلة تم إنشاؤها بواسطة docstring [documentation](https://multi-agent-io.github.io/robonomics-interface/) متاحة أيضًا.\\n\\nفي النهاية، هذه أداة للمطورين الذين يرغبون في التفاعل مع سلسلة كتل Robonomics عبر أدوات البرمجة. تقريبًا \\nجميع مشاريع Python لفريق Robonomics التي تتفاعل مع الباراشين تستخدم هذه الواجهة.\\n\\n### التثبيت\\n\\nتتطلب عملية التثبيت من المستخدم تثبيت Python 3.8 على الأقل. لا يوجد `x86` أو `arm7` أو `arm8`.\\nعملية تجميع. يتم بناء ونشر جميع العجلات من قبل مسؤولي الاعتماديات.\\n\\nيتم استخدام `pip` كأداة تثبيت:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### استخدام عينة\\n\\nالفكرة لرئيسية هي إنشاء مثيل `Account` ثم استخدامه لإنشاء مثيلات مخصصة للحزم.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  من الممكن أيضًا استخدام نقاط النهاية المخصصة (على سبيل المثال، العقد المحلي للاختبار):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nمن الممكن أيضًا تقديم العمليات الخارجية:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  كما تم ذكره، تتوفر المزيد من الأمثلة على صفحة [documentation](https://multi-agent-io.github.io/robonomics-interface/) .\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` يحتوي أيضًا على أدوات CLI لـ Python `click` للاستخدام في أغراض النمذجة الأولية والاختبارات السريعة. يتم تثبيتها\\nمع الحزمة ومتاحة في الطرفية:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nيمكنك محاولة استخدامها مع العقد المحلي. تم اعتماد فلسفة الأنابيب:\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"98779c77c73681e3312df9034d839897\",\"title\":\"روبونوميكس على إيثريوم\",\"path\":\"/docs/ar/robonomics-ethereum/\",\"content\":\"\\nجميع المعلومات حول روبونوميكس على إيثريوم تم نقلها إلى مستودع GitHub. يمكن العثور على جميع المعلومات اللازمة [هنا.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"1290a72cd4b1a8d6ae20579326814927\",\"title\":\"روبونوميكس سمارت هوم\",\"path\":\"/docs/ar/notifications/\",\"content\":\"\\nيمكنك تلقي إشعارات على هاتفك الذكي باستخدام [notify](https://notify.events/). أولاً قم بالتسجيل هناك وفي `لوحة التحكم` قم بإنشاء قناة جديدة:\\n\\n![control_panel](../images/home-assistant/not_control_panel.png)\\n\\nأضف العنوان واضغط على `حفظ`:\\n\\n![channel](../images/home-assistant/not_create_chanell.png)\\n\\nثم ضغط على `Add Source`واختر `Home Assistant` في علامة التبويب `IoT and Smart Home`:\\n\\n![source](../images/home-assistant/not_add_source.png)\\n\\nاكتب العنوان واضغط على `Next`:\\n\\n![source_next](../images/home-assistant/not_add_source_next.png)\\n\\nسترى هناك الرمز الذي تحتاج إلى إضافته إلى ملف التكوين الخاص بك لـ Home Assistant. احفظه في مكان ما واضغط على `Done`:\\n\\n![token](../images/home-assistant/not_token.png)\\n\\nثم اضغط على `Subscribe` لإضافة المشتركين:\\n\\n![subscribe](../images/home-assistant/not_subscribe.png)\\n\\nاختر أي مشترك تريده واتبع التعليمات.\\n\\nالآن تحتاج إلى تحرير التكوين على جهاز الكمبيوتر الخاص بك باستخدام Home Assistant. تحت مستخدم `homeassistant` افتح ملف `configuration.yaml`:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nوأضف هذه الأسطر:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nأضف أيضًا تلقائي جديد بعد سطر `automation:`:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nسيقوم هذا التلقائي بإرسال رسالة `Door was changed to on/off` بعد تغيير حالة الاستشعار برقم الكيان `binary_sensor.contact_sensor_contact` من `off` إلى `on`.\\n\\nوأعد تشغيل Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"36721abb21f49454ce511f24d990772f\",\"title\":\"تحكم في كاميرا PTZ في Home Assistant\",\"path\":\"/docs/ar/ptz-camera/\",\"content\":\"\\nتغطي هذه المقالة عملية إعداد كاميرا PTZ في Home Assistant. \\nسيتم استخدام بروتوكول ONVIF. هذا يتطلب حساب كاميرا محلي.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nعملية إعداد حساب الكاميرا المحلية غير مشمولة في هذه المقالة.\\n</robo-wiki-note>\\n\\nالمتطلبات:\\n- كاميرا PTZ\\n- حساب كامرا محلي\\n- عنوان IP للكاميرا\\n- Home Assistant المكونة\\n\\n## التكامل مع ONVIF\\n\\nلنبدأ بتثبيت **تكامل ONVIF**. \\n\\nانتقل إلى \\\"Devices & Services\\\" في \\\"Settings\\\" واضغط على الزر \\\"ADD INTEGRATION\\\".\\nاكتب \\\"ONVIF\\\" واختر التكامل. ستظهر النافذة التالية.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nاضغط على زر \\\"Submit\\\". سيحاول البحث تلقائيًا عن الكاميرا الخاصة بك. إذا نجح، \\nاختر كاميراك من القائمة واملأ الحقول الفارغة. \\nإلا أنه يجب عليك ملء جميع الحقول يدويًا إذا لم ينجح البحث التلقائي. ستظهر النافذة التالية.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nاملأ الفجوات:\\n- Name - قم بإعطاء اسم لكاميراك\\n- Host - قدم عنوان IP لكاميراك\\n- Port - عادة ما يكون 2020 هو الأكثر شيوعًا، ولكن مزود الكاميرا الخاص بك قد يغيره\\n- Username - اكتب اسم مستخدم حساب الكاميرا المحلي\\n  - Password - اكتب كلمة مرور لحساب الكاميرا المحلي\\n\\nواضغط على \\\"Submit\\\". اختر منطقة للكاميرا الخاصة بك وانقر على \\\"Finish\\\".\\n\\n## أضف تحكم الكاميرا إلى لوحة القيادة\\n\\nالآن بعد أن قمت بإعداد الكاميرا بالكامل، يمكنك إضافة تدفقها وأزرار التحكم إلى لوحة القيادة.\\n\\nانتقل إلى لوحة القيادة وابدأ بإنشاء بطاقة جديدة. اختر \\\"Picture Glance\\\".\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nاملأ البيانات:\\n- Title - اختر عنوان صورة الكاميرا\\n- Camera Entity - اختر كيان الكاميرا من القائمة المنسدلة\\n- Camera View - اختر \\\"live\\\" للحصول على تأخير أقل\\n\\nبعد ذلك، انتقل إلى وضع \\\"Code Editor\\\" عن طريق الضغط على الزر في الجانب الأيسر السفلي. سترى الكود التالي:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nاستبدل محتوى `entities: []` وفقًا للمثال التالي (`<YOUR_CAMERA_ENTITY>` هو نفس المعلمة `camera_image`):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nهذا كل شيء. الآن يجب أن ترى بطاقة الكاميرا PTZ على لوحة القيادة مع أزرار التحكم.\\n\\n## حل المشاكل\\nإذا كنت تستخدم Home Assistant Core ولا ترى تيارًا من الكاميرا ، يجب عليك تثبيت تكاملات \\\"stream\\\" و \\\"FFMPEG\\\". \\nللقيام بذلك، يجب عليك إضافة السلاسل `stream: ` و `ffmpeg: ` في نهاية configuration.yaml.\"}},{\"node\":{\"id\":\"77ec5a4ab0cbdbb33e777f8c57a4fb0c\",\"title\":\"المسؤولية\",\"path\":\"/docs/ar/liability/\",\"content\":\"\\n**لتحويل الروبوتات إلى عوامل اقتصادية، يحتاج المرء إلى أداة تعاقدية للقيام بذلك. الوفاء بالمسؤولية - منصة Robonomics التي تنفذ العقود بين حسابات Parachain!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  يرجى الانتباه إلى أن هذا البرنامج التعليمي معروض على مثيل محلي لـ Robonomics Node. قم بإعداده باستخدام [هذه التعليمات](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## نظرة عامة على النظرية\\n\\nبالعودة إلى إثناوم، كان هناك هيكل معقد جدًا لتفاعل المسؤولية. يمكنك التعرف عليه [هنا](/docs/robonomics-how-it-works). في هذه الأيام أصبحت الأمور أسهل قليلاً مع كوساما!\\n\\n### المفاوضات\\n\\nلتوقيع العقد، يحتاج الجانبان إلى التفاوض أولاً. يمكن إجراء ذلك بعدة طرق، بما في ذلك [IPFS PubSub](https://blog.ipfs.tech/25-pubsub/) أو Robonomics PubSub. عينة من كود Python باستخدام Robonomics PubSub هي\\nمعروض [هنا](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub). \\n\\nالعرض والطلب عبارة عن رسائل تحتوي على خاصيتين رئيسيتين للعقد: **الوصف الوظيفي** و **السعر**. يجب أن يصمم المستخدم تنسيق الرسالة لكل تطبيق محدد. ليس من المهم في عملية المفاوضات اتباع قاعدة صارمة بشأن الشكل. يتم عرض التدفق المحتمل في الصورة أدناه.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  يرجى ملاحظة أن PubSub هو بروتوكول مفتوح ، لذا يجب عدم نقل أي بيانات حساسة. لهذا يجب عليك استخدام بروتوكولات أخرى.\\n\\n</robo-wiki-note>\\n\\n\\n### التوقيعات\\n\\nعندما تنتهي المفاوضات بنجاح، يحتاج كل جانب إلى التوقيع على ما يسمى باتفاقه المسمى بالتوقيع. هذه رسالة تحتوي على الوصف الوظيفي والسعر **بصيغة محددة** موقعة بمفتاح خاص للحساب. توجد [أداة Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.المسؤولية.sign_liability) لذلك أيضًا.\\n - يُطلق على وصف الوظيفة اسم **التقنيات**. هذا هو سلسلة طويلة بطول 32 بايتًا يمكن أن تكون CID مشفرة.\\n - يُطلق على السعر اسم **الاقتصاد**. هذا هو عشري XRT - واينر. 1 واينر = 10 ** -9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  يمكن للشخص الحصول على [IPFS](https://ipfs.tech/) CID بتنسيق مناسب باستخدام [مكتبة Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  عند استخدام وظيفة `sign_liability` ، لا حاجة لتحويل الهاش ، سيتم ذلك تلقائيًا.\\n\\n</robo-wiki-note>\\n\\nبعد المثال على القهوة:\\n\\n1. المهمة هي JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. تكون CID الخاص بها هو `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. لذا فإن **التقنيات** (CID المحول) هو `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **الاقتصاد** هو `1.5 XRT`.\\n\\nعند التوقيع، حان الوقت لإنشاء مسؤولية! يمكن أن يتم ذلك عن طريق أحد الطرفين (إما الوعد أو الوعد) أو عن طريق حساب طرف ثالث لما يسمى بالمزود.\\n\\n## إنشاء المسؤولية\\n\\n### التحضيرات\\n\\nوكما ذكرنا سابقًا، يشارك جانبان على الأقل في هذه العملية. في هذا المثال، دعونا نستخدم ثلاثة وننشئ موفرًا منفصلاً لهذا الغرض. لنفترض أن المفاوضات جرت بطريقة أو بأخرى بالفعل.\\n\\n### 1. انتقل إلى Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nهنا قمنا بتزويد المزود بـ 100 XRT للتوقيع على المسؤوليات الخارجية، وتم منح الوعد 2 XRT لدفع ثمن العمل.\\nلم يتم منح المتعهد أي أموال (باستثناء الوديعة القائمة على الوجود بمقدار 1 mXRT على الأقل).\\n\\n### 1. انتقل إلى Developer -> Extrinsics الخارجية\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. اختر المسؤولية -> إنشاء من قائمة الاستخراجات الممكنة\\n\\nاختر أيضًا الحساب الذي ترغب في تقديم الاستخراج معه. قم بملء جميع المعلمات.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"التوقيعات\\\">\\n\\n  نظرًا لأن المزود يستخدم هنا ، لا حاجة لمعرفة بذور المشاركين. فقط توقيعاته المطلوبة.\\n\\n</robo-wiki-note>\\n\\n### 3. قم بإرسال العملية\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. استعراض المسؤولية الخاصة بك في الأحداث\\n\\nللقيام بذلك، انتقل إلى \\\"Network -> Explorer\\\" وابحث عن قائمة الأحداث على اليمين. انقر على أيقونة المثلث للتوسيع.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  يمكن تحويل التجزئة إلى IPFS CID باستخدام نفس [أداة Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. استكشاف التخزين\\n\\nيمكنك أيضًا استكشاف بعض الخصائص للمسؤوليات في وحدة التخزين `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  تظهر وظيفة التخزين `Next Index` أحدث فهرس للمسؤولية +1 ، لذلك على الرغم من أنها `1` ، يتم استكشاف المسؤولية `0`.\\n\\n</robo-wiki-note>\\n\\n## التقارير\\n\\nتخيل أن القهوة تم إعدادها والآن يحتاج جهاز صنع القهوة إلى الإبلاغ عنها بطريقة ما. هنا تأتي تقارير المسؤولية إلى الساحة. كدليل على العمل ، يضيف الحساب CID آخر كمحتوى تقرير عند إنهاء المسؤولية الحالية. هذا مرة أخرى يتطلب توقيع المتعهد.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  تحتوي الرسالة الموقعة على مؤشر المسؤولية الحالي ومعرف IPFS CID للتقرير المشفر بتمثيل 32 بايت. مرة أخرى ، يمكن أن يساعد [أداة Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) في توقيع التقرير.\\n\\n</robo-wiki-note>\\n\\nمع مثال آلة القهوة:\\n\\n1. التقرير هو JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. معرف IPFS CID الخاص به هو `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. لذا فإن **الحمولة** (CID المحولة) هي `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2`\\n4. **المؤشر** هو `0` وهو المؤشر الحالي للمسؤولية.\\n\\n### 1. انتقل إلى extrinsics ، liability -> finalize(report)\\n\\nاملأ المعلمات وأرسلها خارجيًا. مرة أخرى، قد يتم ذلك عن طريق حساب جهة خارجية.\\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  تنبيه: يجب أن يكون حساب المتعهد غير \\\"ميت\\\" - يجب أن يكون لديه الإيداع الحيوي بحد أدنى 1 mXRT.\\n\\n</robo-wiki-note>\\n\\nقم بتوقيع وإرسال التقرير. عند الانتهاء ، يمكنك استكشافه في الأحداث.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. استكشاف reports\\n\\nيمكنك أيضًا ملاحظة التقرير في المخزن. انتقل إلى `Developer -> Storage` واختر `المسؤولية` من القائمة المنسدلة.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. التحقق من الأرصدة\\n\\nفي الصورة يتم عرض أن المتعهد حصل على \\\"salary\\\"\\\". حدثت علاقة اقتصادية!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  في الوقت الحالي ، ليس هناك طريقة للتحقق مما إذا تم الانتهاء من العمل ، لذلك بمجرد أن يقوم المتعهد بالإبلاغ ، يتم تحويل الرموز إلى حسابه.\\n  سيتم إضافة ميزة التحقق في المستقبل.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"51f1882a77f1ba7bc42729b51fabb1d5\",\"title\":\"إطلاق\",\"path\":\"/docs/ar/launch/\",\"content\":\"\\n**الميزة الأساسية الأخرى لسلسلة Robonomics هي البليت الجاهز. يسمح لك بإرسال الأوامر إلى الحسابات/أي كيانات تقف خلفها. تتضمن هذه الأوامر معلمة لتحديد المهمة المطلوب تنفيذها.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  يرجى الانتباه إلى أن هذه الدروس والدروس التالية تُعرض على نسخة محلية من Robonomics Node. قم بإعداد الخاص بك باستخدام [هذه التعليمات](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. انتقل إلى Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. اختر launch -> launch من القائمة المنسدلة للعناصر الخارجية المحتملة\\n\\nاختر أيضًا الحساب الذي ترغب في إرسال الـ extrinsic به. قم بملء حقل العنوان المستهدف وحقل المعلمة.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  يدعم التشغيل سلاسل طويلة بطول 32 بايت كأوامر ([المصدر](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)))،\\n  لذلك هناك مجال للارتجال هنا:\\n  - بالنسبة للأوامر الأساسية مثل التبديل، يمكنك استخدام \\\"0x0000000000000000000000000000000000000000001\\\" أو\\n  \\\"0x00000000000000000000000000000000000000000000000000\\\".\\n  - بالنسبة للأوامر المتقدمة بما في ذلك أوامر json، يمكنك استخدام [IPFS](https://ipfs.tech/) CID بتنسيق\\n  [الطريقة الصحيحة](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. قم بإرسال العملية\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. قم بمراجعة إطلاقك في الأحداث\\n\\nللقيام بذلك، انتقل إلى *Network -> Explorer* وابحث عن قائمة الأحداث على اليمين. انقر على أيقونة المثلث للتوسيع.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"3b1dbe92acfaf34dc627758b84cad240\",\"title\":\"كيفية تحديث إصدار نود روبونوميكس كولاتور\",\"path\":\"/docs/ar/how-to-update-collator-node-version/\",\"content\":\"\\nمن المستحسن قراءة المقالات التالية قبل قراءة هذا المنشور: [\\\"كيفية بناء نود كولاتور\\\"](/docs/how-to-build-collator-node) و [\\\"كيفية تشغيل روبونوميكس كولاور\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nيحتوي هذا المقال على الأوامر المطلوبة لتحديث نود روبونوميكس كولاتور (العامل على نظام أوبونتو)، ويعطي أيضًا مثالًا بعد ذلك.\\n\\n## **الأوامر المطلوبة**\\n\\n0. قبل أن تبدأ، من المستحسن أن تكون مسجل الدخول كـ `root`، إذا لم يكن الأمر كذلك، فأوصيك بأن تستخدم:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. قم بإيقاف خدمة روبونوميكس:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. قم بإزالة الإصدار السابق من روبونوميكس (تأكد من أنك في المجلد الصحيح):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. احصل على [أحدث إصدار](https://github.com/airalab/robonomics/releases) من روبونوميكس:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. قم بفك الضغط عن الملف:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. قم بنقل الملف:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nيجب عليك نقل هذا الملف إلى المجلد الصحيح الذي قمت بتثبيت نود روبونوميكس فيه)\\n\\n</robo-wiki-note>\\n\\n6. قم بتشغيل روبونوميكس:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nمثال لترقية نود الكولاتور إلى روبونوميكس v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **تغيير قاعدة بيانات سلسلة ريلي كوساما بدون تعيين مسار أساسي**\\n\\nفي بعض الأحيان، تتسبب بعض اللقطات الفورية لسلسلة ريلي كوساما في حدوث أخطاء في نودك. وهذا غالبًا ما يتسبب في توقف عمل النود. مثال على الخطأ الناجم عن قاعدة بيانات سلسلة ريلي معطوبة:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nلحل هذا الخطأ، يجب عليك إزالة قاعدة بيانات سلسلة ريلي كوساما الحالية (على الأرجح RocksDb) واستبدالها بقاعدة بيانات أخرى مثل ParityDb. قم بتنفيذ الأوامر التالية:\\n\\n1. ابحث عن مجلد نود روبونوميكس وتحقق من الملفات:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. تأكد من رؤية مجلد polkadot، ثم انتقل إلى مجلد chains:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. احذف الدليل \\\"ksmcc3\\\":\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. قم بإنشاء مجلد جديد بالاسم `ksmcc3`.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. الآن تحتاج إلى تنزيل لقطة فورية جديدة. يستخدم هذا المثال لقطة فورية لسلسلة ريلي مقطوعة بشكل كبير، ولكن يمكنك استبدالها بأي لقطة فورية تفضلها.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. أثناء تنزيل اللقطة الفورية، افتح جلسة جديدة وقم بتحرير ملف الخدمة الخاص بك:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nقم بتعديل الأسطر داخل ملف الخدمة التي تتعلق بقاعدة البيانات والتقليم:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nاستخدم `Ctrl + S` ثم `Ctrl + X` لحفظ والخروج من ملف الخدمة.\\n\\n7. الآن تحتاج إلى إعادة تحميل الخدمة الخاصة بك.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. في هذا الوقت، في الجلسة الأخرى، نأمل أن يكون قد تم تنزيل قاعدة البيانات الجديدة، لذا قم بفك الضغط عن الملف:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. بعد اكتمال عملية فك الضغط، قم بتنفيذ الأمر التالي:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. الآن يمكنك بدء الخدمة، ومراقبتها للتحقق من عدم وجود أخطاء، والتحقق من أنها تتصل بكل من سلسلة ريلي وباراتشين.\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"8e16fe9332fa9703ca59864eab67c70a\",\"title\":\"كيفية إطلاق مجمع Robonomics\",\"path\":\"/docs/ar/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  في الفيديو التعليمي ولقطات الشاشة لهذه المقالة، استخدمنا الإصدار 1.4.0 من Robonomics. تحتاج إلى استخدام نفس الأوامر، ولكن استبدل إصدار Robonomics بالإصدار الحلي.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nحاليًا، يتم الحفاظ على شبكة Robonomics بشكل أساسي من قبل المطورين الأصليين، ولكن يمكن لأي شخص دعم المشروع. كل عقدة كاملة إضافية في سلسلة الكتل تساعد في جعلها أكثر ستدامة ومقاومة للأخطاء. تتوفر برامج تشغيل عقدة Robonomics في [الإصدارات](https://github.com/airalab/robonomics/releases) أو يمكن [بناؤها من المصدر](/docs/how-to-build-collator-node/).\\n\\n## ما هو المجمع\\n\\nCollator هو جزء من Robonomics parachain. هذا النوع من العقدة ينشئ كتل جديدة لسلسلة Robonomics.\\n\\n>يقوم المجمعون بالحفاظ على سلاسل الجانب عن طريق جمع معاملات سلاسل الجانب من المستخدمين وإنتاج دلائل انتقال الحالة لمحققي سلسلة الإرسال. بعبارة أخرى، يقوم المجمعون بالحفاظ على سلاسل الجانب عن طريق تجميع معاملات سلاسل الجانب في مرشحات كتل سلاسل الجانب وإنتاج دلائل انتقال الحالة للمحققين بناءً على تلك الكتل.\\n\\nيمكنك معرفة المزيد عن collators على صفحة الويكي المتعلقة [Polkadot](https://wiki.polkadot.network/docs/learn-collator)\\n\\nفي سلسلة Robonomics المظلية، يحصل كل مُجمِّع على مكافآت قدرها (**0.001598184 XRT**) لكل كتلة يبنيها المُجمِّع (تحدث المكافآت عندما يتم إغلاق الكتل بالسلسلة).\\nأيضًا، يحصل المجمع الذي يبني الكتلة على **50% من رسوم المعاملات** الموجودة في الكتلة التي ينشئها.\\n\\n## المتطلبات\\n\\nيُوصَى بأن تطلق مجمعًا باستخدام **متطلبات الأجهزة القياسية** لـ [مُصَادِقِيَّةِ Polkadot](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ متوافق مع x86-64.\\n+ Intel Ice Lake، أو أحدث (Xeon أو سلسلة Core)؛ AMD Zen3، أو أحدث (EPYC أو Ryzen).\\n+ 4 أنوية فيزيائية بتردد 3.4 جيجاهرتز.\\n+ تعطيل التعدد المتزامن للمواضيع (Hyper-Threading على Intel، SMT على AMD).\\n+ التخزين - قرص NVMe SSD بسعة 1 تيرابايت (حيث يجب أن يكون بحجم مناسب للتعامل مع نمو سلسلة الكتل).\\n+ الذاكرة - 32 جيجابايت DDR4 ECC\\n\\n\\nفي هذه المقالة نستخدم المواصفات التالية:\\n+ 4 vCPU\\n+ 700 جيجابايت من مساحة NVMe لقواعد بيانات المجمع. يتطلب القدرة على توسيع مساحة القرص هذه.\\n+ 8 جيجابايت من ذاكرة الوصول العشوائي\\n\\n\\n## معلومات هامة\\n1. نستخدم بعض المتغيرات في هذه التعليمات، وسيتعين عليك استبدال القيم بقيمك الخاصة في جميع الأوامر:\\n    + **%NODE_NAME%** هو اسم العقدة. مثال: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** هو المسار إلى الحجم المركب. مثال: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** هو عنوان الحساب في نظام Polkadot في تنسيق SS58. مثال: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. لاحظ أنه يجب عليك تضمين *--state-cache-size=0* في إطلاق خدمة المجمع. هذا المعلمة مهمة لاستقرار المجمع.\\nيمكنك رؤية مزيد من المعلومات في [المشكلة ذات الصلة](https://github.com/airalab/robonomics/issues/234) على github.\\n\\n## أطلق مجمع Robonomics بسهولة للمرة الأولى\\n\\nيمكنك بسهولة إطلاق مجمع مباشرة في سطر الأوامر للتحقق من الأخطاء.\\nبعد القيام بذلك، يُوصَى بشدة بإطلاق مجمع Robonomics كخدمة (انظر الخطوة التالية).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## قم بتشغيل أداة تجميع Robonomics كخدمة\\n\\n1. قم بإنشاء المستخدم للخدمة مع دليل المستخدم الرئيسي\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. قم بتنزيل واستخراج ونقل البرنامج الثنائي لـ Robonomics إلى الدليل */usr/local/bin/*. يجب عليك استبدال *$ROBONOMICS_VERSION* بالإصدار الحالي لـ Robonomics في الأوامر في هذا القسم. يمكنك العثور على الإصدار الحالي على [صفحة الإصدارات في مستودع Robonomics على github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](../images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. قم بإنشاء ملف الخدمة systemd بالاسم *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    وأضف الأسطر التالية في ملف الخدمة:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](../images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. احفظ هذا الملف، ثم قم بتمكين وبدء الخدمة:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nعنوان الرصد: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nيمكن مراقبة سجلات المُجمعين باستخدام: `journalctl -u robonomics.service -f`\\n\\nبمجرد إطلاق أداة تجميع Robonomics، ستبدأ في المزامنة مع سلسلة Kusama Relay Chain، وقد يستغرق ذلك وقتًا طويلاً، اعتمادًا على سرعة الشبكة لديك ومواصفات النظام، لذلك نوصي بتنزيل لقطة Kusama. \\n\\n\\n## تسريع عملية المزامنة باستخدام لقطة Kusama\\n\\nنوصي بالقيام بذلك فور إنشاء الخدمة وبدء تشغيلها. يمكنك العثور على مزيد من المعلومات حول اللقطات وتعليمات الاستخدام على الصفحة التالية: https://ksm-rocksdb.polkashots.io/\\n\\nالتعليمات:\\n\\n1. قم بإيقاف خدمة Robonomics وإزالة دليل قاعدة بيانات Kusama الحالي:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. قم بتنزيل اللقطة الفعلية واستخراجها:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](../images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    يمكنك إزالة الأرشيف الذي تم تنزيله بعد التفريغ الناجح:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. تعيين الملكية الصحيحة لمجلد قاعدة البيانات:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. قم بتشغيل خدمة Robonomics مرة أخرى:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. تحقق من سجلات الخدمة:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](../images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## حل المشاكل\\n### خطأ: \\\"State Database error: Too many sibling blocks inserted\\\"\\nلإصلاح هذا الخطأ، يمكنك فقط تشغيل أداة التجميع في وضع الأرشيف:\\n\\n1) أولاً، يجب أن تقوم بإيقاف خدمة Robonomics: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) ثم أضف المعلمة `--state-pruning=archive` إلى جزء الباراشين في ملف الخدمة. مثال على ملف الخدمة المحرر:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) أعد تحميل تكوين مدير systemd:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) قم بإزالة قاعدة بيانات الباراشين الموجودة:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) قم بتشغي خدمة الروبونوميكس:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    بعد ذلك يجب الانتظار لمزامنة قاعدة بيانات الباراشين.\\n\\n### خطأ: \\\"cannot create module: compilation settings are not compatible with the native host\\\" \\nهذا الخطأ متعلق بمعلمات الافتراضية. يجب استخدام نوع \\\"host-model\\\" للمعالج المحاكى. يمكنك ضبط ذلك على مضيف الافتراضية.\\n\\nولكن إذا واجهت هذا الخطأ على أي استضافة، فيجب عليك طلب الدعم الفني حول هذه المشكلة فقط.\\n\"}},{\"node\":{\"id\":\"f5048a448931dab62b960b2e70536ab9\",\"title\":\"كيفية بناء عقدة المجمع من المصدر\",\"path\":\"/docs/ar/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  في الفيديو التعليمي ولقطات الشاشة لهذه المقالة، استخدمنا الإصدار 1.4.0 من Robonomics. تحتاج إلى استخدام نفس الأوامر، ولكن استبدل إصدار Robonomics بالإصدار الحلي.\\n</robo-wiki-note>\\n\\n## ما هو المجمع\\n\\nالمجمع هو جزء من سلسلة Robonomics. يقوم هذا النوع من العقدات بإنشاء كتل جديدة للسلسلة..\\n\\n>يقوم المجمعون بالحفاظ على سلاسل الجانب عن طريق جمع معاملات سلاسل الجانب من المستخدمين وإنتاج دلائل انتقال الحالة لمحققي سلسلة الإرسال. بعبارة أخرى، يقوم المجمعون بالحفاظ على سلاسل الجانب عن طريق تجميع معاملات سلاسل الجانب في مرشحات كتل سلاسل الجانب وإنتاج دلائل انتقال الحالة للمحققين بناءً على تلك الكتل.\\n\\nيمكنك معرفة المزيد عن المجمع على صفحة الويكي المتعلقة [بولكادوت](https://wiki.polkadot.network/docs/learn-collator)\\n\\nفي سلسلة Robonomics المظلية، يحصل كل مُجمِّع على مكافآت (**0.000380520 XRT**) مقابل كل كتلة قام بإنشائها، إذا كانت هذه الكتلة مغلقة بالسلسلة.\\nيحصل المجمّع أيضًا على **رسوم معاملات بنسبة 50%** من هذه الكتلة.\\n\\n## عملية البناء\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\n\\\"تأكد من تثبيت Rust والبرامج الداعمة. سيطلب منك برنامج التثبيت الخاص بـ Rust حول خيارات التثبيت الحالية، يجب عليك اختيار الخيار `1) المتابعة مع التثبيت (الافتراضي)`.\\\",\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![تثبيت Rust](../images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nقم بتثبيت سلسلة الأدوات الليلية المطلوبة والهدف wasm.\\nالأوامر التالية صالحة لـ Robonomics v2.6.0 أيضًا:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](../images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nسيتعين عليك أيضًا تثبيت الحزم التالية:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nالآن يمكنك تثبيت عقدة robonomics من مصدر git.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](../images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](../images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nبعد هذا الأمر، سيكون الملف الثنائي المترجم لـ robonomics في دليل `~/.cargo/bin`.\\n\\nالخطوة التالية هي كيفية تشغيل عقدة المجمع. يمكنك قراءة المزيد عن ذلك في مقالة [\\\"كيفية تشغيل عقدة المجمع Robonomics\\\"](/docs/how-to-launch-the-robonomics-collator).\"}},{\"node\":{\"id\":\"264bbb95dafcc0ab6d080ef7861d9e4b\",\"title\":\"قم بترقية نظام التشغيل المساعد المنزلي الخاص بك\",\"path\":\"/docs/ar/hass-os-upgrade/\",\"content\":\"\\n**يحتوي هذا المقال على تعليمات لترقية نظام التشغيل المساعد المنزلي الحالي الخاص بك مع دمج Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## تثبيت IPFS Add-on\\n\\n\\nيقوم دمج Robonomics بتخزين البيانات باستخدام خادم IPFS المحلي ، لذا يجب عليك تثبيته أولاً. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. هناك [إضافة IPFS لمساعد المنزل](https://github.com/airalab/ipfs-addon). لتثبيتها ، انتقل إلى `Settings` -> `Add-ons` واضغط على زر `ADD-ON STORE` في الزاوية السفلى اليمنى.\\n\\n2. اضغط على النقاط الثلاث في الزاوية اليمنى العلوية واختر `Repositories`. أضف هنا الرابط التالي:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. اضغط على زر `ADD`.\\n\\n4. أغلق مدير المستودع وقم بتحديث الصفحة. الآن في نهاية الصفحة يمكنك رؤية إضافة IPFS Daemon.\\n\\n5. افتح الإضافة واضغط على `INSTALL`. بعد التثبيت ، اضغط على `START`.\\n\\n## قم بتثبيت HACS\\n\\n[متجر مجتمع مساعد المنزل (HACS)](https://hacs.xyz/) يتيح لك تثبيت التكاملات المخصصة.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. قبل البدء ، تحتاج إلى تثبيت إضافة للاتصال بجهاز مساعد المنزل باستخدام SSH. في متجر الإضافات ، ابحث عن `ssh`. نوصي بتثبيت إضافة `SSH & Web Terminal`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  إذا لم يتم العثور على إضافة SSH ، جرب تمكين وضع المتقدم في إعدادات ملف المستخدم الخاص بك. للقيام بذلك ، انقر على أيقونة الملف الشخصي في الزاوية السفلى اليسرى ، وابحث عن خيار وضع المتقدم.\\n\\n</robo-wiki-note>\\n\\n2. اختر الإضافة واضغط على `INSTALL`. بعد الانتهاء من التثبيت ، انتقل إلى علامة التبويب `التكوين` وأضف `password` أو `authorized_keys`. لا تنسى حفظ هذا الجزء من التكوين.\\n\\n3. في علامة التبويب `Info` ، اضغط على `START`. إذا كنت ترغب في رؤية الإضافة في الشريط الجانبي ، لا تنسى تمكين `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. افتح إضافة SSH وقم بتشغيل الأمر التالي:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. أعد تشغيل Home Assistant (يمكنك القيام بذلك في `Settings`->`System`).\\n\\n6. الآن ستكون تكاملات HACS متاحة للإضافة في قائمة `Integrations`. انتقل إلى ``Settings`->`Devices & Services` ، واضغط على `Add Integration` وابحث عن HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  لاستخدام HACS ، تحتاج إلى حساب Github.\\n\\n</robo-wiki-note>\\n\\n7. انقر عليه واتبع تعليمات التثبيت. \\n\\n## قم بتثبيت دمج Robonomics\\n\\nالآن يمكنك تثبيت دمج Robonomics باستخدام HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nافتح HACS من قائمة الشريط الجانبي وانتقل إلى `Integra1tions`. انقر فوق `Explore & Download Repositories`، ثم ابحث عن `Robonomics` وانقر فوق الزر `Download` الموجود في الزاوية اليمنى السفلية. بمجرد اكتمال التنزيل، قم بإعادة تشغيل Home Assistant.\"}},{\"node\":{\"id\":\"5e86ea515e42e3d59a9b05d4dc2042fb\",\"title\":\"صورة مثبتة مسبقًا لجهاز Raspberry Pi\",\"path\":\"/docs/ar/hass-image-install/\",\"content\":\"\\n**مرحبًا بك في الدليل على تثبيت Home Assistant مع دمج Robonomics على جهاز Raspberry Pi. Home Assistant هو نظام منزلي ذكي مفتوح المصدر يوفر محورًا مركزيًا للتحكم في الأجهزة الذكية في شبكة منزلك. من خلال الدمج مع Robonomics ، يمكنك تعزيز وظائف وأمان منزلك الذكي باستخدام خدمة سحابية لامركزية. في هذه المقالة ، سنقدم تعليمات خطوة بخطوة حول كيفية تثبيت Home Assistant مع Robonomics على جهاز Raspberry Pi ، مما يمنحك القدرة على أتمتة والتحكم في جوانب مختلفة من منزلك باستخدام حل آمن ولامركزي. لنبدأ!**\\n\\n## الأجهزة التي تحتاجها للتثبيت\\n\\nإذا لم تقم بدمج Home Assistant بالفعل في إعداد منزلك الذكي ، فمن المهم أن تكون على علم بالمعدات التي ستحتاجها لإنشاء نظام منزل ذكي كامل من البداية.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. قم بتنزيل صورة Robonomics المثبتة مسبقًا\\n\\nتحتوي صورة Robonomics المثبتة مسبقًا على:\\n- Home Assistant Core\\n- IPFS\\n- وسيط MQTT والتكامل\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nيمكنك التحقق من الشفرة المصدرية وتنزيل أحدث إصدار للصورة على [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. قم بتكوين الصورة\\n\\nقم بتثبيت [Raspberry Pi Imager](https://www.raspberrypi.com/software/) على جهاز الكمبيوتر الخاص بك. ثم قم بإدخال بطاقة SD.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nقم بتشغيل برنامج Raspberry Pi Imager. اختر الصورة المطلوبة كنظام التشغيل وتأكد من تحديد بطاقة SD الخاصة بك من قائمة التخزين المنسدلة.\\nفي الإعدادات:\\n- قم بتعيين اسم المستخدم وكلمة المرور (احفظ اسم المستخدم الافتراضي \\\"pi\\\" ليكون سهل الحفظ),  \\n- قدم اسم وكلمة مرور Wi-Fi الخاصة بك, \\n- اختر بلدك من قائمة الانسحاب\\nثم `اكتب` الصورة. \\n                   \\n<robo-wiki-note type=\\\"note\\\">احفظ اسم المستخدم وكلمة المرور بعناية ، لأنه سيتعين استخدام هذه البيانات لحل المشكلات في حالة الحاجة </robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nيمكنك العثور على رموز البلدان [هنا](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. الإقلاع الأول\\n\\n**أخرج بطاقة SD بأمان** ، ثم قم بإدخالها في Raspberry Pi. ثم **أدخل محول Zigbee** في Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">من المهم إدخال محول Zigbee قبل بدء تشغيل Raspberry Pi للمرة الأولى! \\nمطلوب لتكوين تلقائي لشبكة zigbee.</robo-wiki-note>\\n\\n**إذا كان لديك [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (الذي يحتوي على البرامج الثابتة اللازمة بالكامل) ، فيمكنك ببساطة المتابعة مع هذه التعليمات. ومع ذلك ، إذا كان لدك محول آخر ، فأول شيء يجب عليك القيام به هو تفليشه ببرنامج Zigbee2MQTT. يمكنك العثور على تعليمات لجهازك [هنا](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nبعد ذلك ، قم بتوصيل كابل الطاقة بجهازك. يجب أن يتصل بشبكة Wi-Fi الخاصة بك. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nبمجرد توصيل جهاز Raspberry Pi، سيضيء مؤشر LED الأحمر وسيومض مؤشر LED الأخضر لبعض الوقت. انتظر ما يصل إلى 5 دقائق حتى يتم تشغيل Raspberry Pi والتسجيل على الشبكة. \\n\\nالآن ابحث عن عنوان IP لـ Raspberry Pi. يمكنك استخدام تطبيق الجوال [Fing](https://www.fing.com/products) أو \\n[أداة سطر الأوامر nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/) للعثور على `robots-home` (يمكن أن يكون الاسم الاختياري `Home(homeassistant)`) \\nاسم الجهاز المضيف في قائمة العناوين IP. \\n\\nفي هذا المثال ، العنوان هو `192.168.43.56`. \\n\\nللتحقق من أن كل شيء يعمل ، افتح متصفح الويب وانتقل إلى صفحة الويب `http://%RASPBERRY_IP_ADDRESS%:8123`. في هذا المثال ، سيكون `192.168.43.56:8123`.\\nإذا كان كل شيء على ما يرام ، سترى واجهة Home Assistant على الويب. إذا لم يتم فتح صفحة الويب ، انتظر حتى 5 دقائق ليتم تشغيل Raspberry Pi وحاول مرة أخى. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## حل المشاكل\\n\\n1. لتغيير إعدادات Wi-Fi لاحقًا ، يجب عليك تسجيل الدخول إلى Raspberry Pi الخاص بك عبر الأمر `ssh`. للقيام بذلك ، افتح الطرفية على جهاز الكمبيوتر الخاص بك\\nواكتب الأمر `ssh` مع اسم المستخدم الخاص بك ، الذي قمت بإنشائه في خطوة \\\"تكوين الصورة\\\" (الافتراضي هو \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\nثم استخدم الأمر `sudo raspi-config`. ابحث عن مزيد من المعلومات حول هذا الأمر على [الموقع الرسمي.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"6de24c8c0c3585ec8e71494e96aa7bbc\",\"title\":\"تهيئة مساعد المنزل\",\"path\":\"/docs/ar/hass-init/\",\"content\":\"\\n**بعد تثبيت مساعد المنزل، يجب تهيئته.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nأنت تبدأ بإنشاء حساب المالك لمساعد المنزل. هذا الحساب هو مسؤول ويمكنه إجراء أي تغييرات. افتح متصفح الويب وانتقل إلى `http://%RASPBERRY_IP_ADDRESS%:8123`. يمكنك العثور على عنوان IP لجهاز Raspberry Pi باستخدام [تطبيق Fing المحمول](https://www.fing.com/products) أو [أداة سطر الأوامر nmap](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">قد يتغير عنوان Raspberry Pi مع مرور الوقت، بسبب إعدادات الموجه.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. في الصفحة الأولى، أدخل اسمًا واسم مستخدم وكلمة مرور وانقر على زر `CREATE ACCOUNT`.\\n\\n2. في الشاشة التالية، أدخل اسمًا لمنزلك وقم بتعيين موقعك ونظام الوحدات الخاص بك. انقر على `DETECT` للعثور على موقعك وتعيين المنطقة الزمنية ونظام الوحدات الخاص بك بناءً على ذلك الموقع. إذا كنت لا ترغب في إرسال موقعك، يمكنك ضبط هذه القيم يدويًا.\\n\\n3. بعد ذلك، سيعرض مساعد المنزل أي أجهزة تم اكتشافها على شبكتك. لا تقلق إذا رأيت عددًا أقل من العناصر المعروضة أدناه؛ يمكنك دائمًا إضافة الأجهزة يدويًا لاحقًا. في الوقت الحالي، فقط انقر على `FINISH` وستكون في الشاشة الرئيسية لمساعد المنزل.\\n\\n4. في النهاية، سترى واجهة مساعد المنزل على الويب، والتي ستعرض جميع أجهزتك. \\n\\n\\n## حل المشاكل\\n\\n1. إذا نسيت اسم المستخدم أو كلمة المرور الخاصة بك للمستخدم المحلي، [تحقق من هذه المقالة](https://www.home-assistant.io/docs/locked_out/) لاستعادة بيانات الاعتماد الخاصة بك.\\n\"}},{\"node\":{\"id\":\"29c10462aa890e0ecddb23ba5144df4d\",\"title\":\"ترقية Home Assistant Docker الخاص بك لنظام التشغيل شبيه بيونكس\",\"path\":\"/docs/ar/hass-docker-upgrade/\",\"content\":\"\\n**يحتوي هذا المقال على تعليمات لترقية Home Assistant Docker الحالي (على نظام تشغيل شبيه بيونكس) مع تكامل Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. يفترض أن تستخدم صور وحوية Docker الافتراضية لـ Home Assistant بالاسم <u>homeassistant</u>.\\n  2. سيتم تثبيت IPFS وتشغيله كخدمة <u>systemd</u> على جهاز المضيف.\\n  3. يفترض أن لديك [Python3.9](https://www.python.org/downloads/) أو أحدث مثبت.\\n\\n</robo-wiki-note>\\n\\n## تثبيت\\n\\nقم بتنزيل نص التثبيت وتشغيله في الطرفية:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nسترى الناتج التالي:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  قد ترى خطأ مثل `mkdir: can't create directory 'custom_components': File exists`. هذا يعني أن لديك بالفعل هذا المجلد مع بعض المكونات المخصصة المثبتة. تجاهل هذه الرسالة فقط.\\n\\n</robo-wiki-note>\\n\\nإعادة تشغيل الحاوية:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## التحقق\\n\\nتحقق من أن خدمة IPFS قيد التشغيل والعمل:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nسترى الناتج التالي:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"d6c8ba25fb67bc79061ccba625ce1051\",\"title\":\"ترقية Home Assistant Core الخاص بك\",\"path\":\"/docs/ar/hass-core-upgrade/\",\"content\":\"\\n**يحتوي هذا المقال على تعليمات لترقية Home Assistant Core الحالي الخاص بك مع تكامل Robonomics.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. يفترض أن تكون تثبيت Home Assistant Core الخاص بك قد تم وفقًا للتعليمات الرسمية أن هناك مستخدم <u>homeassistant</u> وبيئة `venv`. إذا لم يكن الأمر كذلك ، فاتبع التعليمات أدناه ، **ولكن قم بتحرير النص وفقًا لذلك**.\\n  2. سيتم تثبيت IPFS وتشغيله كخدمة <u>systemd</u> على جهاز المضيف.\\n  3. يفترض أن يكون لديك [Python3.10](https://www.python.org/downloads/) أو أحدث مثبت.,\\n\\n</robo-wiki-note>\\n\\n## ثَبَّتَ\\n\\nقم بتنزيل نص التثبيت وتشغيله في الطرفية:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nسترى الناتج التالي:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nخلال العملية ، سيُطلب منك تأكيد إعادة تشغيل العديد من الخدمات. باستخدام `tab` ، حدد الخيار `yes`.\\\",\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  قد ترى خطأ مثل `mkdir: can't create directory 'custom_components': File exists`. هذا يعني أن لديك بالفعل هذا المجلد مع بعض المكونات المخصصة المثبتة. تجاهل هذه الرسالة فقط.\\n\\n</robo-wiki-note>\\n  \\nبعد الانتهاء ، قم بإعادة تشغيل Home Assistant الخاص بك.\\n\\n## يؤكد\\n\\nتحقق من أن خدمة IPFS قيد التشغيل والعمل:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nسترى الناتج التالي:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"6b7904ce660132010c01aedf284874bd\",\"title\":\"Glossary\",\"path\":\"/docs/ar/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\nتوازن بين مفتاح عام ومفتاح خاص، حيث يكون الجزء العام هو عنوان المستخدم العام، والجزء الخاص هو المفتاح السري للوصول إلى التحكم في هذا العنوان.\\n\\n\\n### Auction (of Parachains)\\nآلية تأجير فتحات للباراشين في نظامي بولكادوت وكوساما؛ حيث يجب على الباراشين الفوز في مزاد الشموع للحصول على فتحة.\\n\\n### Autonomous Agent\\nنظام حسابي يستقبل بيانات حسية من بيئته ويقرر كيفية الاستجابة للمحفزات الخارجية من أجل تحقيق أهدافه.\\n\\n### AIRA\\nوكيل روبوت ذكي مستقل - برنامج تم تطويره من قبل فريق روبونوميكس في عام 2015، ينفذ معيار التفاعل الاقتصادي بين الإنسان والآلة وبين الآلات من خلال عقد مسؤولية فكرية.\\n\\n\\n## B\\n\\n### Blockchain\\nبمعنى عام، شبكة موزعة تستخدم التشفير للسماح لمجموعة من المشاركين بالتوصل إلى اتفاق بدون الثقة فيما يتعلق بالحالة المتغيرة للنظام.\\n\\n### Blockchain استكشافr\\nتطبيق يسمح باستكشاف الكتل والمعاملات والعناوين المختلفة على سلسلة الكتل (مثل إيثرسكان، سبسكان).\\n\\n### Blueprint (Hass)\\nمنطق تلقائي مُعد مسبقًا يمكن إضافته بسهولة إلى نسخة من مساعد المنزل.\\n\\n### Bridge\\nتكنولوجيا وأساليب تسمح لسلسلتين مستقلتين اقتصاديًا وتكنولوجيًا بالتواصل مع بعضهما البعض. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nأو Cs - حصة المليون من رمز XRT واحد، 1 XRT = 1,000,000 Cs؛ سمي على اسم رونالد كوز، اقتصادي بريطاني، أحد مؤسسي الاقتصاد المؤسسي، الحائز على جائزة نوبل التذكارية في العلوم الاقتصادية.\\n\\n### Collator\\nعقد تحافظ على باراشين من خلال جمع المعاملات الخاصة بالباراشين وإنتاج إثباتات انتقال الحالة للمحققين.\\n\\n### Consensus\\nعملية تتوصل فيها عقد شبكة blockchain إلى اتفاق حول الحالة الحالية للبيانات في الشبكة (على سبيل المثال، إثبات العمل، وإثبات الحصة).\\n\\n### Crowdloan\\nحملة جمع رموز للمزايدة على فتحات في مزاد بولكادوت / كوساما.\\n\\n### Cybernetics\\nدراسة التحكم والاتصال في الحيوان والآلة، وفقًا لتعريف ن. وينر.\\n\\n### Cyber-Physical System\\nأو نظام الكمبيوتر والشبكات والعمليات الفيزيائية المتعددة المتكاملة والمتبادلة.\\n\\n\\n## D\\n\\n### DAO\\nمنظمة مملوكة جماعيًا وتحكمها سلسلة كتل، حيث يتم إدارة الموارد وفقًا لمجموعة محددة مسبقًا من القواعد ويتم تنفيذ إنفاذها تلقائيًا.\\n\\n### سجل البيانات (Function)\\nوظيفة باراشين روبونوميكس، تخزن بيانات الجهاز على سلسلة الكتل.\\n\\n### Dapp\\nأو التطبيق المركزي — تطبيق يعمل كجزء من شبكة موزعة ويوفر وصولًا إلى وظائفه بطريقة سهلة للمستخدم.\\n\\n### Decentralized Cloud\\nخدمة حوسبة سحابية تعتمد على شبكة ند لند اللامركزية التي يمكن للمستخدمين الانضمام إليها إما لاستخدام الخدمات أو توفير مواردهم مثل الحوسبة والشبكات والتخزين، إلخ.\\n\\n### Digital Twin\\nنسخة رقمية من معدات حقيقية تنسخ خصائصها التقنية والبيانات التاريخية.\\n\\n\\n## E\\n\\n### Edge-system\\nجهاز إنترنت الأشياء يعمل كوصلة بين أنظمة الجهات المضمنة المتاحة محليًا والشبكة العالمية، ويدعم عادة بروتوكولات الاتصال وينقل بيانات الاستشعار وإشارات التحكم.\\n\\n### Embedded System\\nجهاز إنترنت الأشياء ذو موارد حوسبة واتصال محدودة يوفر وظائف أساسية (مستشعرات، محركات، أزرار) على أدنى مستوى، عادةً بدون واجهات المستخدم.\\n\\n### Etهناum\\nنظام سلسلة كتل مفتوح المصدر وله وظيفة كمنصة للعديد من العملات المشفرة الأخرى، فضلاً عن تنفيذ العقود الذكية اللامركزية.\\n\\n### Ethereum Upgrade\\nالمعروف سابقًا باسم إثيريوم 2.0 أو إيث2 - ترقيات لبروتوكول إثيريوم التي يجب أن تجعل الشبكة أكثر قابلية للتوسع وأانًا واستدامة؛ لهذه الأغراض، يقترح تغيير التوافق إلى إثبات الحصة وإضافة آلية تجزئة لزيادة سعة الشبكة.\\n\\n### Exodus\\nعملية نقل رموز XRT من شبكة إثيريوم إلى باراشين روبونوميكس.\\n\\n### Extrinsic\\nوظيفة في شبكة بولكادوت وكوساما، يمكن أن تؤدي تحولات حالة الشبكة من خارج الحالة.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nأو جيك — جزء من ألف من رمز XRT، 1 XRT = 1 000 جيك؛ يحمل اسم فيكتور غلوشكوف، عالم رياضيات سوفيتي، واحد من مؤسسي تكنولوجيا المعلومات والسيبرنيات في الاتحاد السوفيتي.\\n\\n\\n## H\\n\\n### Home Assistant\\nأو هاس – برنامج نظام تحكم مفتوح المصدر، مصمم ليكون مركزًا مركزيًا للأجهزة الذكية. \\n\\n### HRMP\\nأو تمرير الرسائل الموجهة عبر الترحيل الأفقي — وهي رسالة آمنة تمر بين سلاسل المظلات، وتقوم بتخزين جميع الرسائل في مخزن سلسلة الترحيل قبل إرسالها إلى سلاسل المظلات.\\n\\n### HMI\\nأو واجهة الإنسان والآلة — واجهة المستخدم أو لوحة القيادة التي تربط المستخدم بجهاز أو نظام أو جهاز.\\n\\n\\n## I\\n\\n### Industry 4.0\\nأو الثورة الصناعية الرابعة — التأتأة المستمرة للتصنيع التقليدي والممارسات الصناعية باستخدام التكنولوجيا الذكية الحديثة.\\n\\n### IPFS\\nأو نظام الملفات بين الكواكب — برنامج ند لند لتخزين ومشاركة البيانات في نظام ملفات موزع.\\n\\n### IoT\\nأو إنترنت الأشياء — اصال بشبكة عالمية من المليارات من الأجهزة، قادرة على جمع البيانات ودمجها في البيئة.\\n\\n### IoT Gateway\\nنظام حافة يجمع وينقل البيانات من أجهزة إنترنت الأشياء إلى الشبكة والعكس؛ غالبًا ما تكون هذه الأجهزة نسخة أكثر تعقيدًا من جهاز توجيه الواي فاي.\\n\\n### IoT Provider\\nخدمة خارجية توفر لمستخدمي إنترنت الأشياء الوصول عن بُعد إلى البيانات والتحليلات، وكذلك التحكم في الأجهزة الذكية عبر الإنترنت.\\n\\n### IoT Subscription\\nميزة باراشين روبونوميكس، تسمح باستخدام جميع وظائف الباراشين لفترة معينة بدون رسوم.\\n\\n\\n## K\\n\\n### KSM\\nرمز أصلي لشبكة كوساما.\\n\\n### Kusama\\nشبكة \\\"الكناري\\\" لبولكادوت تتكون من نسخة مبكرة غير مدققة من برنامج بولكادوت.\\n\\n\\n## L\\n\\n### إطلاق (Function)\\nوظيفة باراشين روبونوميكس تبدأ أو تتوقف عن طريق إرسال أمر عبر سلسلة الكتل.\\n\\n### Lease Period\\nمدة زمنية يمكن للباراشين الاتصال بسلسلة الإرسال.\\n\\n### Libp2p\\nمكتبة مفتوحة المصدر لإنشاء شبكات ند لند المشفرة بين الأقران.\\n\\n### Lights-out Factory\\nمصنع ذكي - مصنع متكامل تمامًا ولا يتطلب وجود بشري في الموقع.\\n\\n### Lighthouse\\nعقد ذكي، في مفهوم اقتصاد الروبوت، يقوم بإجراء صفقة عندما يقوم المزود بإقامة تطابق سوقي بين الواعد والموعود.\\n\\n### المسؤولية\\nعقد ذكي، يتم إنشاؤه بواسطة أنظمة السيبر-الفيزيائية مع بعضها البعض أو مع البشر، لتنفيذ مهمة مقابل الدفع.\\n\\n### المسؤولية Market\\nمنصة، في مفهوم اقتصاد الروبوت، مسؤولة عن تطابق العروض والطلبات بين عقداء النظام.\\n\\n\\n## M\\n\\n### MQTT\\nأو نقل الرسائل عبر الانترنت — بروتوكول يعمل على نشر واشتراك الرسائل وتم تصميمه للشبكات ذات النطاق الترددي المنخفض والتأخير العالي وعدم الموثوقية لتشغيل حجم كبير من رسائل أجهزة الإنترنت من الأشياء.\\n\\n### MQTT Broker\\nخدمة تستقبل جميع الرسائل من عملاء MQTT ثم توجه الرسائل إلى العملاء المشتركين المناسبين.\\n\\n\\n## N\\n\\n### NFT\\nأو رمز غير قابل للتبادل — رمز لا يمكن استبداله ولا يمكن تمييزه عن الرموز الأخرى التي تسمح بتجزئة العناصر الفريدة وتوفير الملكية الحصرية لهذه الرموز.\\n\\n### Node (of Robonomics)\\nوحدة قائمة على Substrate أو Ethereum مع امتدادات Robonomics للاتصال بشبكة Robonomics.\\n\\n\\n## O\\n\\n### On-chain Governance\\nعملية تحديد التغييرات المسموح بها في الشبكة، مثل تعديلات الشفرة أو نقل الأموال، التي توجد في الشبكة نفسها ويمكن أن تغيرها مباشرة.\\n\\n\\n## P\\n\\n### Pallet\\nوحدة الركيزة المكتوبة بلغة Rust والتي تجمع منطقًا أو خوارزمية محددة لوقت تشغيل blockchain القائم على الركيزة. \\n\\n### Parachain\\nهيكل بيانات مخصص ومحدد للتطبيق (عادةً، سلسلة كتل) متكامل في سلسلة الريلي ويمكن التحقق منه بواسطة المحققين.\\n\\n### Parathread\\nباراشين بدون فتحة يمكنه المشاركة مؤقتًا (على أساس كتلة بكتلة مع رسوم) في أمان سلسلة الريلي.\\n\\n### Polkadot\\nشبكة متعددة السلاسل ومتنوعة تسمح بالاتصال المشترك بين سلاسل الكتل ذات الخصائص المختلفة.\\n\\n### Polkadot/Substrate Portal\\nواجهة مستخدم Substrate الأساسية للتفاعل مع شبكة Polkadot و Kusama وغيرها من شبكات Substrate.\\n\\n### Proposal (on Polkadot / Kusama)\\nدعوة وظيفية محتملة للتصويت عليها في استفتاء بولكادوت أو كوساما أو باراتشينز. \\n\\n### Proof-of-Work\\nآلية توافقية يتعين على المشاركين في الشبكة أداء عملية حسابية للتوصل إلى اتفاق.\\n\\n### Proof-of-Stake\\nآلية توافقية يتعين على المشاركين في الشبكة رهن رأس المال المرتبط بالعملة المشفرة المرتبطة بها للوصول إلى اتفاق.\\n\\n### Promisee\\nعقدة تقوم بطلب تنفيذ مهمة في مفهوم اقتصاد الروبوت.\\n\\n### Promisor\\nعقدة توافق على تنفيذ مهمة مقابل الدفع في مفهوم اقتصاد الروبوت.\\n\\n### Provider (Robonomics)\\nعقدة، في مفهوم اقتصاد الروبوت، تراقب رسائل سوق المسؤولية وتطابق العرض والطلب مقابل رسوم رمزية. \\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\nكجزء من الحوكمة على السلسلة، قم بالتصويت على ما إذا كان يجب قبول الاقتراح من قبل مستخدمي الشبكة أم لا.\\n\\n### Relay Chain\\nالسلسلة الرئيسية التي تنسق توافق Polkadot / Kusama والاتصال بين الباراشين.\\n\\n### Robofirm\\nمنظمة يتم فيها تشغيل دورة العمل الكاملة تلقائيًا ولا تحتاج إلى مشاركة بشرية.\\n\\n### Rococo\\nشبكة الاختبار لاختبار الباراشين على Kusama\\n\\n### robonomics-interface\\nمكتبة Python متخصصة في التفاعل مع Robonomics للبرمجة المريحة.\\n\\n### روبونوميكس على إيثريوم\\nإصدار من شبكة Robonomics يعمل فوق Ethereum، تم إصداره في عام 2018.\\n\\n### Robot Economy\\nنظام اقتصادي يعمل فيه الأجهزة كوكلاء مستقلين قادرين على أداء الأنشطة الاقتصادية الرئيسية التي كانت في السابق فريدة للبشر.\\n\\n### Robot-as-a-Service\\nأو RaaS — نموذج عمل تأجير الشركات لمعدات الروبوتات للعملاء والعملاء للاستخدام على المدى القصير أو الطويل.\\n\\n### ROS\\nأو نظام التشغيل للروبوتات — إطار عمل لتطوير برامج الروبوت، يوفر خدمات مصممة لعنقود الحوسبة المتنوعة مثل التجريد عن الأجهزة، والتحكم في الأجهزة على مستوى منخفض، وتنفيذ الوظائف المستخدمة بشكل شائع، وتمرير الرسائل بين العمليات، وإدارة الحزم.\\n\\n### ROS 2\\nإصدار محدث ومعاد بناؤه من نظام التشغيل للروبوتات مع ميزات جديدة، مثل دعم الروبوتات المتعددة والأنظمة المضمنة الصغيرة، والتكامل مع الوقت الحقيقي.\\n\\n### ROS 2 Middleware\\nأو RMW — بروتوكول يوفر ميزات ROS 2 القياسية مثل الاكتشاف والتسلسل والنقل؛ يدعم ROS 2 تنفيذات وسيط متعددة يمكن اختيارها لتناسب متطلبات المشروع بشكل أفضل.\\n\\n### RWS\\nأو خدات الويب Robonomics — خدمات البنية التحتية اللامركزية للروبوتات والإنترنت من الأشياء التي تتيح الاتصال بالأجهزة بسهولة والتفاعل مع تطبيقات المستخدم وخدمات السحابة والأجهزة الأخرى بأمان؛ لديها رمزها الخاص أيضًا يسمى RWS، والذي يوفر اشتراكًا مدى الحياة في الإنترنت من الأشياء في باراشين Robonomics.\\n\\n### تشغيلtime\\nوظيفة انتقال الحالة لسلسلة الكتل تحدد خوارزمية صالحة لتحديد حالة الكتلة التالية بناءً على الحالة السابقة.\\n\\n\\n## S\\n\\n### Seed Phrase\\nمفتاح خاص قابل للقراءة بواسطة الإنسان يتم إنشاؤه كسلسلة من الكلمات العشوائية ومطلوب للوصول إلى عنوان سلسلة الكتل ورموزها.\\n\\n### Shared Security\\nنموذج الأمان لـ Polkadot / Kusama حيث تكون جميع السلاسل مؤمنة بنفس القدر من خلال وضع براهين على صحة كتل الباراشين في سلسلة الريلي بحيث يحتاج المهاجم المحتمل إلى مهاجمة النظام بأكمله.\\n\\n### SLS Gateway\\nبوابة IoT مفتوحة المصدر لأجهزة Zigbee تعتمد على تحكم ESP32 المطورة بواسطة Smart Logic System.\\n\\n### Slot (of Parachain)\\nمورد نادر في بيئة Polkadot / Kusama يسمح للباراشين بالاتصال بسلسلة الريلي دون رسوم لكل كتلة.\\n\\n### Smart Leasing\\nنموذج لنموذج الروبوت كخدمة، حيث يتم دفع الإيجار ليس بالوقت، ولكن للعمليات المحددة وعددها.\\n\\n### Smart Contract\\nبرنامج أو خوارزمية مخزنة على سلسلة الكتل تعمل تلقائيًا عند تحقيق الشروط المحددة مسبقًا.\\n\\n### SSH\\nأو Secure Shell — بروتوكول شبكة لتشغيل خدمات الشبكة بشكل آمن عبر شبكة غير آمنة، يستخدم تشفير المفتاح العام لمصادقة الكمبيوتر البعيد.\\n\\n### Staking\\nجزء من واجب الدليل على الحصة، وهو عملية ربط الرموز عن طريق إيداعها كضمان لفرصة إنتاج كتلة صالحة والحصول على مكافأة.\\n\\n### Substrate\\nإطار عمل قابل للتعديل لبناء سلاسل الكتل مثل Polkadot و Kusama.\\n\\n\\n## T\\n\\n### Treasury\\nصندوق يتم جمع الأموال من خلال جزء من مكافآت إنتاج الكتل، ورسوم المعاملات، والرهان، إلخ، ويمكن إنفاقها من خلال عرض مقترح للإنفاق؛ إذا انتهت الخزينة من فترة الإنفاق دون إنفاق جميع أموالها، فإنها تتعرض لحرق نسبة من الأموال.\\n\\n### Transaction Costs\\nتكلفة جمع ومعالجة المعلومات بسبب العقانية المحدودة للوكلاء الاقتصاديين وتعقيد العمليات.\\n\\n\\n## V\\n\\n### Validator\\nعقدة تؤمن سلسلة الريلي عن طريق رهن رموزها، والتحقق من البراهين من المجمعين على الباراشين، والتصويت على التوافق مع المحققين الآخرين.\\n\\n\\n## W\\n\\n### Web3\\nفكرة لتحسين جديدة للويب تدمج مفاهيم مثل اللامركية وتقنيات البلوكشين والاقتصاد القائم على الرموز.\\n\\n### Wiener (XRT)\\nأو Wn - جزء بليوني من رمز XRT واحد، 1 XRT = 1 000 000 000 Wn؛ مسمى على اسم نوربرت وينر، عالم رياضيات أمريكي، أحد مؤسسي السيبرنياتيك ونظرية الذكاء الاصطناعي.\\n\\n\\n## X\\n\\n### XCM\\nأو تنسيق رسالة التوافق المشترك - تنسيق للرسائل بين أنظمة البلوكشين المختلفة في بولكادوت / كوساما.\\n\\n\\n### XRT\\nرمز أصلي لشبكة روبونوميكس، يوجد بشكل مستقل على شبكتي إيثريوم وكوساما.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nتنفيذ شبكة تراكبية لنظام توجيه مشفر بالكامل من النهاية إلى النهاية لشبكات الشبكة.\\n\\n\\n## Z\\n\\n### Zigbee\\nبروتوكول اتصال لاسلكي يستخدم بشكل شائع جدًا لتوصيل الأجهزة الذكية بسبب استهلاك الطاقة المنخفض وسهولة التكوين ومرونة التكوين ودعم توبولوجيا الشبكة الذاتية التنظيم والاسترداد الذاتي.\\n\\n### Zigbee Adapter\\nجهاز ينقل البيانات بين شبكة زيجبي وشبكة أخرى (مثل Wi-Fi) للتحكم في أجهزة زيجبي.\\n\\n### Zigbee2MQTT\\nبرنامج يسمح بربط Zigbee بشبكات MQTT عن طريق ترجمة الرسائل من شبكة إلى أخرى.\"}},{\"node\":{\"id\":\"2b12849e7a29815926ec3de3fe4d29a8\",\"title\":\"الإدارة العالمية\",\"path\":\"/docs/ar/global-administration/\",\"content\":\"\\n**سيوضح لك هذا المقال كيفية إعداد مستخدم جديد لـ Home Assistant الخاص بك.**\\n\\n## إضافة المستخدمين إلى الاشتراك\\n\\nلا يمكنك استخدام حسابات تم إنشاؤها مسبقًا لأن `SUB_OWNER` و `SUB_CONTROLLER` يوفران الأمان، وأول مستخدم قمت بإنشائه عند بدء استخدام Home Assistant ليس لديه حساب Robonomics Parachain.\\n\\n1. قم بإنشاء حساب على Robonomics parachain، كما فعلت في [المقال السابق](/docs/sub-activate/).\\n\\n2. باستخدام حساب `SUB_OWNER`، أضف حساب مستخدم جديد إلى الاشتراك في [التطبيق](https://dapp.robonomics.network/#/subscription/devices). الآن يجب أن يكون هناك ثلاثة عناوين في قائمة الوصول: `SUB_OWNER` و `SUB_CONTROLLER` و `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## منح الوصول للمستخدم\\n\\n1. انتقل إلى خدمة التطبيق المسماة [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). اختر الحساب الذي قمت بإنشائه للتو في الشريط الجانبي الأيمن (تحقق من أنك قمت باختيار الحساب المقصود عن طريق الضغط على أيقونة الملف الشخصي).\\n\\n2. أدخل بذرة `USER` في الحقل المطلوب. أضف عناوين `SUB_OWNER` و `SUB_CONTROLLER` في حقول اعتمادات المسؤول. إذا كان كل شيء صحيحًا، سترى حالة التحقق `VERIFIED`.\\n\\n3. قم بإنشاء كلمة مرور لمستخدم جديد قمت للتو بتسجيله ثم قم بتأكيد العملية، والتي ستكون الآن بدون رسوم بسبب الاشتراك. في وقت لاحق يمكنك استعادة كلمة المرور في علامة التبويب \\\"استعادة\\\".\\n\\n4. بعد عملية التسجيل، قم بتسجيل الدخول إلى Home Assistant باستخدام عنوان المستخدم الخاص بك كاسم مستخدم وكلمة مرور جديدة.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nالآن يمكنك استخدام التطبيق للتحكم في منزلك من خلال Robonomics، تحقق من المقالة [**\\\"الحصول على بيانات تلميحات المنزل الذكي\\\"**](/docs/smart-home-telemetry/).\\n\\n## حل المشاكل\\n\\n1. إذا نسيت كلمة مرور Home Assistant من حساب Robonomics الخاص بك، [تحقق من Dapp.](https://dapp.robonomics.network/#/home-assistant)\\nانتقل إلى جزء \\\"كلمة مرور Home Assistant الخاصة بك\\\" واختر علامة التبويب \\\"Restore\\\".\\n\"}},{\"node\":{\"id\":\"7fd5e5b04e3910dc1d050cc135134c0c\",\"title\":\"البدء\",\"path\":\"/docs/ar/getting-started/\",\"content\":\"\\n## ما هو روبونوميكس\\n\\nتوفر منصة روبونوميكس أدوات للعمل مع شبكة الاقتصاد الروبوتي. تسمح روبونوميكس لمصممي المدن الذكية ومناطق صناعة 4.0 ببناء الثقة بين [خدمات الروبوتات الذاتية](/docs/glossary#cyber-physical-system)، وتوفير [وصول المستخدم المباشر عبر تطبيق الويب اللامركزي](/docs/glossary#dapp) لطلب المنتجات من المصانع الذاتية وخدمات شبكات الاستشعار الحضرية. وهذا بدوره سيسمح لنا بوضع نظام لامركزي يراقب نشاطات الأنظمة الفيزيائية السيبرانية على مستوى عالمي.\\n\\nالرسم البياني التالي يصف المكان الذي يحتله روبونوميكس في السيناريو:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nاعثر على المزيد في [بناء تطبيقات الويب اللامركزية على منصة روبونوميكس](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## دليل بدء سريع لشبكة روبونوميكس\\n**لراحة المبتدئين، ابتكر مطورو روبونوميكس الأساسيون منهجًا تعليميًا يتكون من [6 دروس تعلمية](/docs/wschool2021-intro/)!**\\n\\nستستكشف هنا الهندسة المعمارية للإنترنت الأشيائية بدون خادم! خدمات الويب لروبونوميكس (RWS) هي الخدمة الأساسية للبنية التحتية للروبوتات والإنترت الأشيائية على منصة بولكادوت وآي بي إف إس.\\n\\nيمكن لخريجي الدورة أن يطلقوا سلسلة توصيل محلية ويتحكموا في جهاز متوافق مع ROS من خلال عملية تبادل عبر السلاسل.\\n\\n**[انضم إلى Discord لمطوري روبونوميكس](https://discord.gg/jTxqGeF5Qy) للتواصل مع المجتمع والحصول على الدعم الفني.**\\n\\n### فوائد لخريجي أكاديمية روبونوميكس\\n- تدريب لأفضل الطلاب   كن عضوًا في فريق روبونوميكس وساهم في تطوير المنتج المختار.\\n- مجتمع نشط وفعال وأحداث منتظمة   كن جزءًا من مجتمع المتعلمين، وناقش حالات الاستخدام الخاصة بك مع خبراء الصناعة. انضم وشارك في المسابقات!\\n- شهادة إتمام   أضف شهادة إتمام الدورة في بناء تطبيقات الويب اللامركزية للإنترنت الأشيائية إلى سيرتك الذاتية.\\n- مساعدة في القبول في جامعة ITMO. سواء كنت بكالوريوس أو ماجستير، ستحصل على مساعدة في قبولك في الجامعة.\\n- فرص التمويل والتسريع: 1)قدم طلب للحصول على منحة تدعيم أكاديمية تصل إلى 50.000 دولار؛ 2)شارك في برنامج تسريع بنائي روبونوميكس بدعم من مؤسسة Web3؛ 3)نشر تطبيق DAPP مستقل على منصة روبونوميكس؛ 4)تحقيق الربح منه والحصول على دعم تسويقي من فريق روبونوميكس.\\n\\n\\n## ما يحتويه الوثائق\\n\\n### أنا مطور تطبيقات الويب اللامركزية\\n\\n- [روبونوميكس-js على GitHub](https://github.com/airalab/robonomics-js) - مجموعة أدوات بسيطة لتطوير تطبيقات الويب اللامركزية على شبكة روبونوميكس.\\n- [قالب التطبيق](https://github.com/airalab/vue-dapp-robonomics-template) - يستخدم Vue.js\\n- [وثائق الويكي](/docs/robonomics-js/)\\n\\n### أنا مهندس روبوتي\\n\\nتحقق من قسم [الحالات](/docs/iot-sensors-connectivity/) وابدأ في التطوير من خلال [الأمثلة](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"b5a2206cd4da1dc190131a90342a17b2\",\"title\":\"كيفية شراء اشتراك\",\"path\":\"/docs/ar/get-subscription/\",\"content\":\"\\n**دفع عمولات للمعاملات في سلسلة الكتل مزعج. تخيل جهاز IoT يرسل بيانات الاستشعار كل 5-10 دقائق. هذا سيجعلك تدفع الكثير خلال الشهر. أحد الميزات الرئيسية لشبكة Robonomics هو RWS - اشتراك خدمة الويب Robonomics. ادفع شهريًا وانسى تكلفة المعاملة! للحصول على الخلفية النظرية ، راجع [هذا](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) المقال.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  تنبيه أن هذا البرنامج التعليمي يوضح شراء اشتراك في Robonomics Kusama parachain. يمكنك أيضًا تنفيذ جميع الخطوات نفسها على [العقد المحلي](/docs/run-dev-node).\\n\\n  شيء آخر قبل البدء. هذه هي طريقة \\\"صعبة\\\" لشراء اشتراك. هناك طريقة تقليدية للقيام بذلك من خلال [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## تقديم عرض في مزاد\\n\\nتُباع الاشتراكات في Robonomics بنموذج المزاد. للحصول على واحدة ، تحتاج إلى تقديم عرض في المزاد والفوز به (لا تقلق ، إنها سريعة).\\n\\nفي `Developer/Chain state` يمكنك رؤية المزادات المتاحة. \\nاختر `rws` و `auctionQueue` واضغط على زر `+` ، سترى معرفات المزادات المتاحة:\\n\\n![queue](../images/rws/queue.png)\\n\\nيمكنك رؤية معلومات حول أي اشتراك باستخدام `rws` `auction` ومعرف المزاد (معرف المزاد في الصورة هو 79):\\n\\n![auction](../images/rws/auction.png)\\n\\nفي معلومات المزاد يمكنك رؤية حقل `winner` ، في الوقت الحالي هو `null` لذا ليس لدي أحد هذا الاشتراك ويمكنك الحصول عليه. لذلك انتقل إلى `Developer/Extrinsic` ، اختر حسابك و `rws -> bid`. قم أيضًا بتعيين معرف المزاد (79) ومبلغ الوحدات المطلوبة (أكثر من 1000000000 Wn):\\n\\n![bid](../images/rws/bid.png)\\n\\nقدم المعاملة وتحقق من معلومات المزاد بالمعرف 79 (في `حالة السلسلة`Chain state`rws -> auction` والمعرف 79):\\n\\n![win](../images/rws/auc_win.png)\\n\\nالآن في حقل `winner` سترى عنوان حسابك ، وهذا يعني أن هذا الحساب لديه الاشتراك 79. يبدأ المزاد بأول عرض ويستمر لعدة كتل ، لذا إذا قام شخص ما بعرض مزيد من الرموز المميزة منك في الكتل القليلة التالية ، فسيكون هذا هو الفائز وسيحصل على الاشتراك.\\n\\nالآن يمكنك إضافة الأجهزة. الأجهزة هي حسابات قادرة على استخدام هذا الاشتراك وتقديم الخارجيات بدون رسوم.\\nلاختباره، أنشئ حسابًا جديدًا بدون رموز مميزة وأضفه إلى الأجهزة.\\n\\nلإضافة الأجهزة ، اختر `rws -> setDevices` في `Developer/Extrinsic`. ثم اضغط على زر `Add Item` واختر الحساب الذي تم إنشاؤه مؤخرًا بدون رموز:\\n\\n![set_devices](../images/rws/set_devices.png)\\n\\nقدم المعاملة. الآن يمكنك التحقق من قائمة الأجهزة في  `Chain state` باستخدام `rws -> devices`. سترى هنا عنوان حسابك بدون رموز. اختر الحساب الذي قام بشراء الاشتراك واضغط على `+`:\\n\\n![devices](../images/rws/devices.png)\\n\\nالآن يمكنك محاولة [إرسال الإطلاق](/docs/subscription-launch) الخارجي باستخدام الاشتراك.\"}},{\"node\":{\"id\":\"bafaad095926e0754f53180a8867d92c\",\"title\":\"إعداد Gaka-Chu وتثبيت البرامج\",\"path\":\"/docs/ar/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n** في هذه المقالة سنقوم بشرح بعض خطوات التثبيت والتشغيل لإعداد روبوت الرسام. المتطلبات:**\\n- KUKA KR6 R900 sixx مع KRC4 و SmartPad؛\\n- Intel NUC مع [ROS melodic](http://wiki.ros.org/melodic/تثبيتation/Ubuntu) مثبت؛\\n- طاولة ودهان وفرشاة وماء.\\n\\n## تثبيت البرامج على KRC4\\nمطلوب واجهة EKI على كل من KRC4 و NUC. يتم تقديم معلومات مفصلة حول كيفية إعدادها على KRC4 [هنا](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). قم بتشغيلها على تحكم الروبوت.\\n\\n## تثبيت البرامج على NUC\\nإنشاء مساحة عمل catkin:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nتنزيل حزم ROS. يتم تخزين جميع النصوص [هنا](https://github.com/airalab/robot_painter/tree/test_branch). استنساخ المستودع:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nقد تحتاج إلى بعض ملفات الرأس والمكتبات لجعل كل شيء يعمل بشكل صحيح. قم بتنزيلها:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nأضف أمر المصدر إلى ملف `.bashrc`:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nحتى الآن. يجب أن تكون قادرًا على تشغيل النصوص. إذا حدث خطأ ما ، جرب بعض [إجراءات الاستكشاف والإصلاح](https://github.com/airalab/robot_painter/issues)\\n\\n## ملء الثوابت\\nأولاً وقبل كل شيء ، يحتاج الروبوت إلى معرفة موقع واتجاه القماش وكذلك موقع علبة الدهان. يتم تحديد كل ذلك في `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. دعنا نلقي نظرة عليه.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nهذه هي ثوابت معادلة السطح التي تحدد موقع القماش في الفضاء ثلاثي الأبعاد. يتم الحصول عليها خلال عملية معايرة موضحة أدناه. يأتي بعدها الدهان.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nهذه هي إحداثيات علبة الدهان. يمكن أيضًا تحديدها أثناء عملية المعايرة. يتم تحديد حجم القماش في\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nتخزين الثوابت المهمة الأخرى في `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nأسماؤهم تقول كل شيء ، لذا قم بملئها وفقًا للحالة.\\n\\n## معايرة Gaka-Chu\\nعملية المعايرة نفسها بسيطة جدًا.\\n\\n1) قم بتشغيل واجهة EKI على KRC4:\\n\\nقم بتسجيل الدخول في وضع 'AUT' ، وقم بتشغيل السائقين وتشغيل النص `eki_hw_interface`\\n\\n2) قم بتشغيل واجهة EKI على NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nيجب أن يظهر سجلات لا نهائية.\\n\\n3) قم بتشغيل RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nيجب أن ترى ما يلي:\\n\\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nحاول تحريك نهاية المؤثر والنقر على 'Plan and Execute'. يجب أن يتحرك الروبوت. انتقل إلى SmartPad وانتقل إلى **Display -> Actual position** وقم بمرقبة إحداثيات نهاية المؤثر. ضع قماشًا أفقيًا على قاعدة الروبوت. قم بتوصيل فرشاة في حامل الفرشاة وقم بتحريكها بعناية حتى تلامس القماش بالكاد. في هذا الموضع ، قم بحفظ إحداثيات نهاية المؤثر. كرر ذلك 12-15 مرة. قم أيضًا بحفظ إحداثيات مركز القماش وعلبة الدهان.\\nعندما تحصل على مجموعة من الإحداثيات ، استخدم [هذه](https://github.com/nakata5321/Matlab_scripts_gaka-chu) نصوص Matlab لحل الثوابت المفقودة والرباعي. الصقهم. قم بإعادة بناء مساحة العمل الخاصة بك باستخدام\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## اختبار معايرة Gaka-Chu\\nعندما يتم المعايرة ، يجب اختبار Gaka-Chu عن طريق رسم حدود القماش. لجعله يفعل ذلك ، قم بتنفيذ كل منها في نافذة الطرفية الجديدة:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nبعد ذلك ، يجب أن ترى حدود القماش في RViz:\\n\\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nفي الطرفية ، اضغط على \\\"S\\\" لأداء الاختبار. يجب أن يتحرك نهاية المؤثر للروبوت فوق حدود القماش ويجب أن تلامس الفرشاة القماش بلطف خلال الحركة بأكملها. إذا لم يحدث ذلك ، جرب إعادة المعايرة. إذا كانت نموذج القماش مدارًا بشكل خاطئ ، يمكنك تدويره عن طريق تغيير الرباعي في Matlab.\\n\\n## صنع فن\\nتحتاج إلى 6 وحدات أساسية لجعل كل شيء يعمل:\\n- واجهة EKI؛\\n- MOVEit + RViz;\\n- بث إطارات البيئة؛\\n- خدمة تحويل الصورة؛\\n- وحدة رسم المسارات؛\\n- بدء المؤشر.\\n\\nلنشغلهم واحدًا تلو الآخر.\\n\\n### واجهة Eki\\nعلى KRC4 ، قم بتشغيل `eki_hw_interface` ، على NUC في نافذة الطرفية الجديدة قم بالتالي:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz و MOVEit\\nتحتاج إلى مخطط ومحاكاة. قم بتشغيلهما باستخدام\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### البيئة\\nأخبر الروبوت بموقع علبة الدهان والقماش. لاحظ أنه ليس من الضروري تشغيل `draw workspace` node ، حيث يشترك `tf_broadcaster` في حجم القماش. فقط لا يظهر ذلك في RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### معالج الصور\\nيجب معالجة جميع الصور الواردة. قم بتشغيل الخدمة.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nعندما يتلقى الاتصال ، يقوم بمعالجة صورة بفلتر HP وإنشاء ملف rosbag مع المسارات.\\n\\n### رسام المسارات\\nالبرنامج النصي الأكثر أهمية هنا هو رسام المسارات نفسه. ينتظر الصورة ، ويستدعي خدمة TextConverter ويقوم برسم اللوحة.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## أرسل للروبوت صورة للرسم\\nيستمع الروبوت إلى موضوع ROS محدد حيث تحتاج إلى تمرير مسار لصورة مرغوبة. يجب أن تكون الصورة مربعة (العرض يساوي الارتفاع) ومصنوعة من خطوط. أرسل المسار:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nبعد ذلك. يظهر نافذتان تعرضان الحدود والمسارات. أغلقهما وانظر إلى رسم Gaka-Chu. كن حذرًا وكن دائمًا على استعداد للضغط على زر الإيقاف الطارئ.\\nعندما ينتهي Gaka-Chu من فنه ، يمكنك إرسال مسار آخر للصورة ويكرر الرسام العملية بأكملها.\\n\"}},{\"node\":{\"id\":\"ea3078de5824457a152af204d46f9a82\",\"title\":\"توصيل جهاز Amazon FreeRTOS بـ Robonomics عبر MQTT\",\"path\":\"/docs/ar/freertos-mqtt/\",\"content\":\"\\nإليك العرض التوضيحي لكيفية توصيل الميكروكنترولر الذي يعمل بنظام [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) بشبكة Robonomics عبر MQTT. يرجى التحقق من [هذا المستودع](http://github.com/khssnv/freertos_mqtt_robonomics_example) للحصول على مصدر المشروع.\\n\\nنحن نستخدم [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) مع توزيعة FreeRTOS وتنفيذ MQTT المقدمة من [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) حيث تعد Espressif بائعًا للميكروكنترولر المستخدم.\\n\\nهناك أيضًا مستشعر [PMS-3003](http://www.plantower.com/en/content/?107.html) لأغراض التوضيح. يقيس المستشعر وجود المواد الجسيمية في الهواء ويمكن للشخص استخدامه لتقدير جودة الهواء.\\n\\nجودة الهواء ليست موضوع المقالة، يمكنك العثور على المزيد حولها على موقع منظمة الصحة العالمية: [تلوث الهواء البيئي (في الهواء الطلق)](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). هدف النظام هو نشر قياسات المستشعر إلى شبكة Robonomics التابعة لـ Airalab.\\n\\n## إعداد الأجهزة\\n\\nنقوم بتوصيل PMS3003 TXD PIN5 بـ ESP32 DevKitC IO17 لنقل القياسات عبر UART.\\nكما يتطلب كلا الجهازين طاقة وأرضية مشتركة.\\n\\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\\n\\n## تدفق البيانات\\n\\nمن أجل تسليم قياسات المستشعر إلى شبكة Robonomics، هدفنا على مستوى البرامج الثابتة هو الحصول على البيانات من المستشعر عن طريق بروتوكول الاتصال المضمن الذي يدعمه (UART في حالتنا) وتمريرها إلى مثيل AIRA عن طريق MQTT / TCP.\\n\\n![Sending](../images/freertos-mqtt/send.svg)\\n\\nفي مثالنا، نستخدم نسخة AIRA المستضافة في السحابة والتي تتوفر عن طريق عنوان IP العام واسم النطاق المعين.\\nفي مثيل AIRA، نقوم بإعداد وسيط MQTT `mosquitto` والاشتراك في موضوع `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` للحصول على رسائل من MQTT.\\n\\nثم نمرر الرسائل إلى كاتب `robonomics io` عن طريق الأنبوب.\\n\\n![Receiving](../images/freertos-mqtt/recv.svg)\\n\\nالآن البيانات متاحة في شبكة Robonomics ويمكننا قراءتها مرة أخرى باستخدام `robonomics io`.\\n\\n## البرامج الثابتة\\n\\nنستخدم [تطبيق عينة ESP-MQTT مع نقل TCP](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) كأساس.\\n\\nنقوم فقط بتعديل `main/app_main.c` للاتصال بالمستشعر عبر UART، ومزامنة الوقت باستخدام SNTP وروتين الناشر المنتظم لبروتوكول MQTT.\\n\\nإذا كنت تحاول تكرار المشروع، وهو أول مشروع قائم على ESP IDF، يرجى اتباع [دليل برمجة ESP-IDF من Espressif](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) في البداية للتعرف على عمليات البرامج الثابتة مثل التكوين والبناء والتحميل باستخدام أداة `idf.py`.\\n\\n### Wi-Fi التكوين\\n\\nمن أجل التواصل مع مثيل AIRA المنتشر في السحابة، يحتاج الميكروكنترولر الخاص بنا إلى اتصال بالإنترنت.\\nنستخدم Wi-Fi ESP32 لذلك.\\nتوفر Espressif أدوات لتكوين Wi-Fi المدمجة.\\nفي مثالنا، نستخدم بيئة التطوير مع نظام التشغيل Ubuntu 20.04 GNU/Linux.\\nلتكوين Wi-Fi، نذهب إلى مجلد المشروع ونقوم بتشغيل أداة تكوين SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nثم نقوم بتعيين SSID وكلمة مرور نقطة الوصول لشبكة Wi-Fi في قسم `Example الاتصالion التكوين`.\\n\\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### تكوين نقطة النهاية MQTT\\n\\nهناك شيئين يجب تكوينهما لبروتوكول MQTT.\\nالأول هو عنوان وسيط MQTT.\\nيمكن تكوينه باستخدام أداة تكوين SDK.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nقم بتعيين `عنوان الوسيط` في قسم `Example التكوين`.\\n\\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nالشيء الثاني هو موضوع MQTT.\\nنقوم بتعيينه في البرامج الثابتة مع بادئة اسم المشروع تليها عنوان MAC لـ ESP32 الخاص بنا.\\nيعطينا `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` للشريحة الدقيقة الخاصة بنا.\\n\\n## من MQTT إلى Robonomics\\n\\nفي البداية، دعنا نتحقق مما إذا كنا نستلم البيانات عبر MQTT.\\nيمكننا الاشتراك في موضوع وسيط MQTT Mosquitto الخاص بنا لجهاز النشر.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nهنا نقوم بجلب حزمة `mosquitto` إلى بيئتنا لاستخدام أداة `mosquitto_sub`.\\nثم نشترك في الموضوع المحدد في البرمجيات الثابتة.\\nحصلنا على قياساتنا مما يعني أن AIRA يستلم البيانات عبر MQTT بشكل صحيح.\\nالآن دعونا نوجه هذه الرسائل إلى شبكة Robonomics.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nهنا نستخدم أداة `robonomics` لنشر الرسائل في قناة النشر والاشتراك `/freertos_mqtt_robonomics_example`.\\nنحدد `bootnodes` لضمان إنشاء اتصال واحد على الأقل.\\n\\nالآن نحن نقرأ هذه الرسائل من نفس قناة النشر والاشتراك.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## الموارد الأصلية المستخدمة\\n\\n* توصيلات ESP32 DevKitC من مدونة GoJimmy https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* هيكل البيانات وفك التشفير PSM3003 من مشروع OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**شكراً لكم جميعاً!**\\n\"}},{\"node\":{\"id\":\"7fdf3375174f1f7e08b1ca8759f5632a\",\"title\":\"How to Edit Wiki\",\"path\":\"/docs/ar/edit-wiki/\",\"content\":\"\\n**روبونوميكس ويكي هو مصدر مفتوح. أي تصحيحات مرحب بها: إصلاح الأخطاء والأخطاء الطباعية وبعض المعلومات غير الواضحة أو التي لم تعد صالحة ، والترجمة إلى أي لغة. سوف تحتاج إلى [GitHub](https://github.com/) حساب.**\\n\\n\\n## كيية التحرير\\n\\nإذا كنت بحاجة إلى تحرير وثائق روبونوميكس ويكي ، يرجى اتباع هذه الخطوات\\n\\nتأكد من أن لديك [Node.js](https://nodejs.org/en/download/package-manager/) و [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) مثبتة.\\n\\n### 1. استنساخ المستودع\\n\\nفي البداية ، تحتاج إلى استنساخ مستودع الويكي:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nانتقل إلى دليل المستودع وقم بتشغيل الأوامر التالية:\\n\\n`باستخدام npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`باستخدام yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. تقديم محليًا  (develop, develop-m1)\\n\\nثم نشر المشروع محليًا: \\n\\n```\\ngridsome develop\\n```\\n\\n> إذا كان لديك خطأ `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS` ، قم بتشغيل الأمر التالي:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. إجراء PR\\n\\n[إجراء طلب سحب](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) إلى [مستودع الويكي](https://github.com/airalab/robonomics-wiki)\\n\\n## مكونات\\n\\n### Asciinema\\nروبونوميكس ويكي لديها دعم لـ Asciinema. لإدراج Asciinema ، يرجى اتباع هذه التعليمات:\\n* استيراد المكون بعد كتلة frontmatter `import Asciinema from '~/components/Asciinema.vue'`\\n* إدراج كفقرة منفصلة `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>` ، حيث يكون vid هو معرف asciicast المحدد\\n\\n> يمكنك الحصول على نص الويدجت لـ asciicast محدد عن طريق النقر على رابط \\\"تضمين\\\" في صفحة asciicast.\\n> يبدو هذا على النحو التالي:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[وثائق Asciinema](https://asciinema.org/docs/embedding)\\n\\nفي المثال أعلاه ، يكون vid هو 14.\\n\\n### شفرة\\n\\nيمكنك إضافة إضافات مفيدة إلى التعليمات البرمجية الخاصة بك:\\n\\n`شفرة مع زر النسخ`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nأو \\\"رمز مع سطر إضافي\\\".\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**خصائص code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nتحتوي وثائق في روبونوميكس ويكي على كتلة frontmatter. يجب أن تكون في الجزء العلوي من ملف Markdown ، ويجب أن تأخذ شكل YAML صالح محاط بخطوط متعددة. بين الخطوط المتعددة ، يمكنك تعيين أو تحرير الخيارات التالية:\\n\\n```YAML\\n---\\ntitle: How to contribute # عنوان الصفحة ، لا حاجة لتكراره في النص\\ncontributors: [positivecrash] # المساهمون الرئيسيون (الذين يديرون هذه الصفحة بنشاط). مطلوب اسم المستخدم في GitHub ، بدون أي رموز إضافية\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/تثبيتation\\n    # الأدوات التي تم استخدامها لاختبار التكنولوجيا\\n---\\n```\\n\\n### Grid \\nيساعد في إضافة تخطيط الشبكة إلى العناصر:\\n\\n- استخدم مكون تغليف الشبكة أولاً: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- ثم استخدم قدر الاحتياج مكونات عناصر الشبكة داخل العناصر المغلفة:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**خصائص robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### الصور\\n\\n#### كيفية تحميل \\nتحميل اصورة في المجلد `/docs/images/url-of-your-doc`\\n* إذا كانت الصورة بحاجة إلى توطين ، فأدخلها جميعًا في مجلد واحد\\n* استخدم ملحق اللغة في اسم الصور إذا كانت مترجمة ، على سبيل المثال `image_en.jpg`\\n* تأكد من أن الصورة الخاصة بك محسنة للويب وفي نفس الوقت تبدو جيدة\\n\\n#### كيفية إدراج \\n\\nهناك طريقتان لإدراج الصور في وثائقك:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nمن المستحسن إدراج الصور باستخدام العلامة المدمجة `<robo-wiki-picture>` ، ومع ذلك يمكنك أيضًا استخدام الطريقة القياسية لملفات Markdown.\\n\\n</robo-wiki-note>\\n\\n`مع تسمية`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`أو بدون تسمية` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`أو صورة بسيطة` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`أو صورة بسيطة مع تسمية`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`صورة مع alt`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**خصائص robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### ملاحظات وتحذيرات\\nيمكنك إضافة ملاحظات وإعطائها أنواعًا محددة:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`ملاحظة بعنوان`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`ملاحظة بمحتوى`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`ملاحظة بعنوان ومحتوى`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**خصائص robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nيمكنك إضافة علامات تبويب إلى الوثيقة:\\n\\n- استخدم مكون تغليف علامات التبويب: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- ثم استخد قدر الاحتياج مكونات عناصر التبويب داخل العناصر المغلفة:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`علامات تبويب أفقية`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`علامات تبويب عمودية`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`عنصر تبويب بحدود`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**خصائص robo-wiki-tabs (المغلف)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**خصائص robo-wiki-tab (العنصر)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### عنوان مع الأشارات\\nيمكنك إنشاء عناوين مخصصة مع الأشارات وإعطائها قيمة معينة\\n\\n`عنوان مع الأشارة`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nor\\n\\n`title without anchor`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**خصائص robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### مقاطع الفيديو\\n\\nهناك طريقتان لإدراج مقاطع الفيديو في وثائقك:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nمن المستحسن إدراج مقاطع الفيديو باستخدام العلامة المدمجة `<robo-wiki-video>` ، ومع ذلك يمكنك أيضًا استخدام الطريقة القياسية لملفات Markdown.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nتحتاج إلى تحديد تنسيق الفيديو\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### خصائص\\n\\n- إذا كنت تضيف ملفًا بحجم أكبر من <span style=\\\"color:#af1c1c\\\">10MB</span>, من فضلك قم برفعه على السيرفر وليس على الريبو.\\n\\n- يمكنك استخدام أي خصائص لـ [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- التنسيقات المقبولة - mp4 و webm و ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nيمكنك تضمين أي فيديو YouTube في الوثيقة عن طريق إدراج رابط المشاركة كفقرة منفصلة بدون أي علامات أو علامات إضافية ، على سبيل المثال: `https://youtu.be/kQaSwNYHJQ8`\\n\\nومع ذلك، إذا كنت بحاجة إلى التشغيل التلقائي، فيجب عليك استخدام مكون خاص:\\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**خصائص robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## كيفية تحرير تنقل الشريط الجانبي\\n\\nإذا كنت بحاجة إلى تحرير تنقل الشريط الجانبي لروبونوميكس ويكي ، يرجى اتباع هذه الخطوات:\\n\\n* تحرير الملف `/data/sidebar_docs.yaml`.\\n\\n* قرر أين تضع الوثيقة الخاصة بك\\n\\n* استخدم YAML صالح لـ `/data/sidebar_docs.yaml` واعتمد على هيكل الملف الحالي\\n\\n* **ملاحظة مهمة:** إذا كنت تستخدم نفس الوثيقة في أقسام / فرع فرعي مختلفة مثل: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: صورة مثبتة مسبقًا لجهاز Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nتأكد من إضافة معلمة `topic` مثل هذا: \\n\\n(for navigation to work properly) \\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## كيفية إضافة التنقل المخصص للمستندات\\n\\n* تعديل الملف `/data/sidebar_docs.yaml`.\\n\\n* ابحث عن المستند الصحيح وأضف المعلمات \\\"next\\\" و\\\"prev\\\" مثل هذا:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* إذا كنت ترغب في إزالة التنقل بالكامل ، فأضف معلمة `withoutNav`:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* إذا كنت ترغب في إزالة التنقل فقط لـ `الصفحة السابقة` أو `الصفحة التالية` ، فأضف معلمة `withoutPrev` أو `withoutNext`:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nor\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"84e83a888fe98a22d362ecb22400741a\",\"title\":\"احصل على إشعار عند فتح الباب\",\"path\":\"/docs/ar/door-notification/\",\"content\":\"\\nفي هذه المقالة، ستقوم بتثبيت تكامل مُنبه الروبوت في تيليجرام وتكوين أتمتة، ستُرسل إشعارًا إلى حساب تيليجرام الخاص بك عند فتح الباب.\\n\\n## إشعارات روبوت تيليجرام\\n\\nأولاً، تحتاج إلى إنشاء روبوت تيليجرام شخصي. لهذا، انتقل إلى [روبوت تيليجرام الخاص @BotFather](https://t.me/botfather) واتبع التعليمات. \\nاحفظ الرمز الخاص بك للوصول إلى واجهة برمجة التطبيقات HTTP.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nاحتفظ برمزك **بأمان** وقم بتخزينه **بشكل آمن**، يمكن لأي شخص استخدامه للتحكم في روبوتك \\n\\n</robo-wiki-note>\\n\\nالخطوة التالية هي العثور على ***User Chat ID***. لهذا استخدم الخطوة التالية [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nالآن دعنا نقوم بتثبيت تكامل \\\"Telegram broadcast\\\". سيقوم هذا التكامل بإرسال رسائل إلى تيليجرام الخاص بك.\\n\\nبالنسبة لصورة Robonomics المثبتة مسبقًا، أو Docker Home Assistant أو Home Assistant Core، يجب عليك تحرير `configuration.yaml`. قم بالاتصال بجهاز Raspberry Pi الخاص بك عبر `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nقم بلصق الأسطر التالية في نهاية الملف. أدخل **bot API key** و **your User Chat ID**. أيضًا قم بإنشاء اسم لخدمة الإشعار الخاصة بك:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**احفظ التكوين وأعد تحميل Home Assistant.**\\n\\n\\nكنتيجة، سيتم إنشاء خدمة في Home Assistant، ستُرسل أي رسالة إلى محادثة تيليجرام معك. \\nيمكنك التحقق من ذلك في قائمة أدوات المطور في واجهة Home Assistant على الويب. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  إشعار فتح الباب\\n\\nالآن حان الوقت لإنشاء أتمتة. أولاً، قم بإستيراد النموذج إلى Home Assistant الخاص بك من هذا الرابط:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nثم قم بإنشاء أتمتة:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nالآن ستتلقى رسالة من روبوت تيليجرام في كل مرة يتم فيها فتح الباب.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nيمكنك استخدام هذه الأتمتة مع أي أبواب / نوافذ في منزلك.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"4874843642bd301317f036789552c0e8\",\"title\":\"التوائم الرقمية\",\"path\":\"/docs/ar/digital-twins/\",\"content\":\"  \\n**تخيل أن لديك جهاز معقد أو نظام يحتوي على عدة وحدات للصيانة ويتطلب عدة حسابات للاستخدام. للحفاظ على جميعها في مكان واحد أو لتشفير بعض الوظائف بحسابات منفصلة أو، على سبيل المثال، لتعيين مصادر بيانات مختلفة لتدفقات المعلومات المختلفة، يجب استخدام وحدة التوأم الرقمي.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  يرجى الانتباه إلى أن هذه الدروس والتعليمات التالية تتم على نسخة محلية من نود روبونوميكس. قم بإعداد النسخة الخاصة بك باستخدام [هذه التعليمات](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## نظرة عامة على النظرية\\nيمكن لأي حساب إنشاء وإدارة توأم رقمي. يمكن تخيل التوأم على أنه نوع من الجدول يحتوي على المحتويات التالية:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nحيث:\\n* **DT id** هو فهرس فريد للتوأم الرقمي غير الموقع.\\n* **Topic name** هو بيانات `H256` بتنسيق ست عشري أو ASCII بطول 32 بايتًا، نفس طول [`إطلاق`](/docs/launch) المعلمة الخارجية. \\nعلى سبيل المثال: `0x1234....FF` أو `hello.parachain.robonomics.world`.\\n* **Source** - هو عنوان حساب ما.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  كما تم مناقشته سابقًا في نظرة عامة على المعلمة الخارجية للإطلاق، يمكن تمثيل `H256` على أنه معرف IPFS مشفر (انظر\\n  [أداة Python](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) لذلك).\\n  بالتالي، يمكن استخدام المواضيع كتخزين بيانات أيضًا، على سبيل المثال، وصف وحدة التوأم.\\n\\n</robo-wiki-note>\\n\\n\\n## إنشاء توأم رقمي\\n\\n### 1. انتقل إلى المطور -> العمليات الخارجية\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. اختر digitalTwin -> create من القائمة المنسدلة للمعلمات الخارجية الممكنة\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nقدم المعامل. هنا، لا توجد معلمات مطلوبة لإنشاء توأم. سيتم منحه فهرس وسيكون فقط مالك التوأم الرقمي قادرًا على إضافة/تعديل مواضيع التوأم من الآن فصاعدًا.\\n\\nيمكن العثور على معرف التوأم في صفحة نظرة عامة على المستكشف.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## إضافة موضوع\\n\\n### اختر digitalTwin -> setSource من القائمة المنسدلة للمعلمات الخارجية الممكنة\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - معرف التوأم الرقمي، الذي تم الحصول عليه من صفحة استكشافr.\\n* `topic` - اسم الموضوع `H256` المناقش سابقًا. في هذه الصورة، إنه سلسلة مكونة من 32 رمزًا.\\n* `source` - عنوان الحساب المرتبط بالموضوع.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  توجه انتباهك إلى أنه يمكن استبدال الموضوع بعنوان مصدر آخر إذا لزم الأمر.\\n\\n</robo-wiki-note>\\n\\nقم بتوقيع وتقديم المعلمة الخارجية.\\n\\n## Explore\\n\\nيمكنك العثور على جميع المعلومات حول التوائم الرقمية الموجودة في وحدة تخزين `Developer -> Chain state` `digitalTwin`.\\n\\n- إجمالي عدد التوائم - `total()`;\\n- مالك التوأم الرقمي - `owner(u32)`;\\n- معلومات حول مواضيع التوأم الرقمي - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"930559d2fe8213c498977f160f478012\",\"title\":\"سجل البيانات\",\"path\":\"/docs/ar/datalog/\",\"content\":\"\\n**الآن بعد أن لديك بعض الأموال في حسابك يمكنك تقديم extrinsics. أول شيء لتجربته هو Datalog. يتيح لك تخزين البيانات في سلسلة الكتل بشكل دائم. تخيل تخزين موزع ومحمي بالتشفير لبياناتك وهذا هو!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nيرجى الانتباه إلى أن هذه الدروس والتعليمات التالية تتم على نسخة محلية من نود روبونوميكس. قم بإعداد النسخة الخاصة بك باستخدام [هذه التعليمات](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. انتقل إلى المطور -> العمليات الخارجية\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. اختر سجل البيانات -> تسجيل من القائمة المنسدلة للعمليات الخارجية الممكنة\\n\\nاختر أيضًا الحساب الذي ترغب في إرسال العملية الخارجية به. قم بملء حقل التسجيل.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  يدعم سجل البيانات سلسلة نصية بحد أقصى 512 بايت. يمكن استخدامه لتخزين كمية كبيرة من البيانات [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. قم بإرسال العملية\\n\\nقم بتوقيع وإرسال العملية باستخدام الحساب الذي تم إنشاؤه مسبقًا باستخدام الامتداد أو التطبيق اللامركزي.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  يمكنك أيضًا مسح **جميع** سجلاتك باستخدام *datalog -> erase* الاستدعاء.\\n\\n</robo-wiki-note>\\n\\n## 4. قم بمراجعة سجل البيانات الخاص بك في التخزين\\n\\nللقيام بذلك، انتقل إلى *Developer -> Chain state*, حدد *datalog -> datalogIndex*, حدد حسابك واضغط على زر \\n\\\"+\\\" للحصول على فهرس سجلات حسابك ثم استكشف السجل الذي تحتاجه باستخدام *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"استكشافr\\\">\\n\\n  يمكن رؤية جميع الأحداث بما في ذلك سجل البيانات في تدفق الأحداث في *المستكشف*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"615cda48b2888901c0d8ceda6be7156f\",\"title\":\"إنشاء هوية رقمية تعمل بواسطة إيثريوم\",\"path\":\"/docs/ar/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nأحد خدمات روبونوميكس هو [تسجيل جواز السفر الرقمي](https://dapp.robonomics.network/#/passport/) للبيانات التي لا علاقة لها. تتيح الخدمة لك إنشاء هوية رقمية تحفظ هاشات البيانات في سلسلة الكتل العامة وتعيين عنوان فريد.\\n\\nيمكنك العثور على خدمة \\\"تسجيل جواز السفر الرقمي\\\" في [Robonomics DApp](https://dapp.robonomics.network/) في قسم \\\"الخدمات\\\" أو مجرد اتباع هذا [رابط مباشر](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## شرح الفيديو\\n\\nيظهر الفيديو التالي تقدم تسجيل ورقة العمل البيضاء لروبونوميكس:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## خطوة بخطوة في الصور\\n\\n### 1. افتح الخدمة\\n\\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. أضف المعلومات والملفات اللازمة\\n\\nيرجى ملاحظة أنه يمكن إضافة صور متعددة.\\n\\n![Filled Form](../images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. قم بتوقيع الطلب\\n\\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. وافق على الرموز\\n\\nتفرض الخدمة رسومًا صغيرة. ولكن يجب عليك أولاً الموافقة على الكمية المطلوبة من الرموز التي ستنفق من حسابك.\\n\\n![Approve Tokens](../images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. قبول العرض وتوقيع الرسالة مرة أخرى\\n\\n![Send Order](../images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. ألق نظرة على جواز السفر الذي تم إنشاؤه\\n\\n![The Digital Identity](../images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nيستغرق عملية التسجيل بعض الوقت. في النهاية ، سترى رابطًا للهوية التي تم إنشاؤها.\\n\"}},{\"node\":{\"id\":\"fb7a44b19698f14da33d39cb166c10d6\",\"title\":\"إنشاء حساب لـ Robonomics Parachain\",\"path\":\"/docs/ar/create-account-in-dapp/\",\"content\":\"\\n**للتفاعل والتشغيل مع Robonomics Parachain ، يحتاج المطورون والمستخدمون إلى إنشاء حساب على بوابة Polkadot / Substrate. يقوم الحساب بأداء وظائف أساسية للشبكة: عنوان الشبكة العامة (المفتاح العام) ، والتحكم في الوصول إلى العنوان والأموال (المفتاح الخاص) ، وإرسال المعاملات إلى الشبكة ، وعرض الرموز الخاصة بك وكميتها ، وما إلى ذلك. فيما يلي طريقتان رئيسيتان لإنشاء حساب لـ Robonomics Parachain.**\\n\\n## 1. باستخدام امتداد المتصفح Polkadot{.js}\\n\\nيوفر امتداد Polkadot آلية لإنشاء الحساب والتفاعل مع جميع مشاريع Polkadot / Kusama بما في ذلك Robonomics Parachain. هذه ليست أكثر الطرق أمانًا لإدارة حسابك ، ولكنها الأكثر ملاءمة من حيث التوازن بين الأمان والاستخدام.\\n\\n## 1.1. تثبيت امتداد المتصفح\\n\\nيتوفر امتداد المتصفح لـ [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) و [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (بالإضافة إلى المتصفحات القائمة على Chromium).\\n\\n![Browser Extension](../images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. فتح تطبيق Robonomics Parachain\\n\\nانتقل إلى [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) on Polkadot / Substrate Portal. If this is the first time you entered the portal, it will request access to the browser extension, so allow access. \\n\\nOnce you've opened the app, take a look at the top left corner. The name of the network, its icon and the number of the last block are displayed tهنا. Clicking on this area will open a list of all Polkadot / Kusama networks, including test networks and local nodes. You can switch between networks by حددing the required one and pressing the `Switch` button. **Make sure you are connected to Robonomics Parachain now**. \\n\\n![Robonomics Parachain app](../images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. تحديث بيانات التمديد\\n\\nمن المرجح جدًا أن يطلب منك التطبيق تحديث بيانات التمديد لعرض المعلومات الصحيحة حول السلسلة التي تتصل بها. انتقل إلى **الإعدادات -> البيانات الوصفية** ، اضغط على زر `تحديث البيانات الوصفية` ، ثم في النافذة المنبثقة ، اسمح للامتداد بالقيام بذلك. \\n\\n![Updating metadata](../images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. إنشاء حساب في التمديد\\n\\nافتح امتداد المتصفح Polkadot{.js}. انقر فوق الزر الكبير زائد أو حدد `إنشاء حساب جديد` من الرمز الزائد الصغير في الزاوية العلوية اليمنى. يجب أن ترى القائمة التالية ، مع بذرة منجنيك المولدة على شكل اثني عشر كلمة والعنوان. \\n\\n![Account creation, step one](../images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nالبذرة هي مفتاحك للحساب. معرفة البذرة تسمح لك (أو لأي شخص آخر يعرف البذرة) بالسيطرة على هذا الحساب وإعادة إنشائه ، إذا نسيت كلمة المرور. **من المهم جدًا تخزينها في مكان آمن** ، يفضل على الورق أو جهاز غير رقمي ، وليس في التخزين الرقمي أو على الكمبيوتر. \\n\\nاحفظ البذرة واضغط على `الخطوة التالية`. يجب أن ترى القائمة التالية.\\n\\n![Account creation, step two](../images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* يسمح لك بتحديد الشبكات التي سيتم استخدام هذا الحساب حصريًا لها. يمكنك استخدام نفس العنوان على عدة شبكات ، ومع ذلك ، لأسباب الخصوصية ، يُوصَى بإنشاء عنوان جديد لكل شبكة تستخدمها. \\nحدد شبكة Robonomics من قائمة السحب. إذا لم تتمكن من العثور على شبكة Robonomics ، فمن المحتمل أنك لم تقم بتحديث البيانات الوصفية ، فعد وافعل ذلك.\\n\\n    - ستلاحظ أن تنسيق العنوان ورمز الحساب سيتغير - هذا أمر طبيعي. تمثل تنسيقات الشبكة المختلفة مجرد تمثيلات أخرى لنفس المفتاح العام. \\n\\n- *Name* تُستخدم فقط كاسم للحساب لاستخدامك الشخصي فقط. لا يتم تخزينها على سلسلة الكتل ولن يراها المستخدمون الآخرون. \\n\\n- *Password* تُستخدم لتشفير معلومات حسابك. ستحتاج إلى إعادة إدخالها عند توقيع المعاملات على البوابة. أنشئ واحدة وتذكرها.\\n\\nنتيجة لذلك ، بعد إنشاء حساب ، ستراه في قائمة الحسابات في امتداد Polkadot{.js}. يمكنك بالنقر على النقاط الثلاث ، إعادة تسمية الحساب ، تصديره ، إزالته من الامتداد وتغيير الشبكة المستخدمة للحساب. \\n\\nأيضًا ، سيظهر الحساب في قائمة **الحسابات -> الحسابات** على البوابة ، حيث سيتم التأكيد على أنه تم حقنه باستخدام الامتداد.\\n\\n![Successful account creation](../images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. مباشرة على تطبيق Robonomics Parachain\\n\\nYou can use the user interface on the Polkadot / Substrate Portal to create an حساب. It could be used for development and tests. \\n\\n## 2.1. فتح تطبيق Robonomics Parachain\\n\\nGo to [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) على بوابة Polkadot / Substrate. **تحقق في الزاوية اليسرى العلوية من أنك متصل بـ Robonomics Parachain**.  \\n\\nانتقل إلى **الحسابات -> الحسابات** واضغط على زر `إضافة حساب`. \\n\\n![Robonomics Parachain App](../images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. إنشاء حساب\\n\\nيجب أن ترى قائمة البوب ​​التالية مع بذرة الحساب. \\n\\n![Generating account seed](../images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nلديها نموذجين: *Mnemonic* (قابل للقرءة من الإنسان) و *Raw* (سلسلة من الأرقام والحروف). احفظ عبارة البذرة بأمان واضغط على `التالي`.\\n\\n> يمكنك أيضًا تغيير نوع التشفير لإنشاء الحساب ، لذلك افتح `خيارات الإنشاء المتقدمة` واختر النوع (`ed25519` في الصورة).\\n\\n![ed25519 crypto type account](../images/creating-an-account/ed-account.jpg)\\n\\nفي القائمة التالية ، يجب عليك تعيين اسم الحساب وكلمة المرور ، على غرار تعليمات التمديد الموضحة أعلاه.\\n\\n![Generating account name and password](../images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nالنقر على زر 'التالي' سيأخذك إلى النافذة الأخيرة. انقر على 'حفظ' لإنهاء إنشاء الحساب. سيتم أيضًا إنشاء ملفات JSON احتياطية يجب عليك تخزينها بأمان. يمكنك استخدام هذا الملف لاحقًا لاستعادة حسابك إذا تذكرت كلمة المرور.\\n\\n![Successful account creation](../images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 إضافة حساب ed25519 إلى امتداد Polkadot\\n\\nقد تحتاج إلى إضافة الحساب الذي تم إنشاؤه إلى امتداد Polkadot.js (بالنسبة لحساب ed25519 ، يمكنك فعل ذلك فقط باستخدام ملف JSON الاحتياطي). لذلك ، تحتاج إلى إنشاء ملف احتياطي للحساب. اضغط على النقاط الثلاث في حسابك واختر 'إنشاء ملف احتياطي لهذا الحساب' واكتب كلمة المرور الخاصة بك.\\n\\n![Backup file](../images/creating-an-account/backup-file.jpg)\\n\\nثم افتح امتدادًا واضغط على زر '+' في الزاوية العلوية اليمنى ، ثم اختر 'استعادة الحساب من ملف JSON الاحتياطي'.\\n\\n![Restore backup in extension](../images/creating-an-account/extention-add-backup.jpg)\\n\\nفي النافذة المفتوحة ، اسحب الملف المحفوظ ، أدخل كلمة المرور واضغط على 'استعادة'.\\n\\n![Restore backup in extension 2](../images/creating-an-account/file-backup.jpg)\\n\\n## 3. تم إنشاء الحساب بنجاح \\n\\nالآن يمكنك التعامل بشكل كامل مع حسابك الجديد. أرسل واستلم الرموز والرسائل واكتب datalog وأكثر من ذلك. لا تتردد في استكشاف جميع ميزات التطبيق. لنسخ عنوان حسابك ببساطة ، انقر فوق رمزه ، وسيتم نسخ العنوان إى الحافظة. \\n\\nإذا كنت ترغب في معرفة المزيد عن حسابات Polkadot / Kusama وطرق إنشائها الإضافية ، يمكن العثور على مزيد من المعلومات [هنا](https://wiki.polkadot.network/docs/learn-accounts) و [هنا](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"5abcee69898d7e197f2bc8a696cafc91\",\"title\":\"كيفية المساهمة في موارد روبونوميكس\",\"path\":\"/docs/ar/contributing/\",\"content\":\"\\nشبكة روبونوميكس هي مشروع مفتوح المصدر ونرغب في تسهيل المساهمة لأي شخص. يمكنك إنشاء مقالات، واقتراح التغييرات، وتحسين الوثائق أو تشغيل الاختبارات. إذا كنت ترغب في المساهمة، يرجى فتح مشكلة جديدة أو إنشاء طلب سحب في نفس المستودع.\\n\\n## المستودعات الرئيسية لروبونوميكس \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — مشروع الويكي الرئيسي\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  الموقع الرسمي الرئيسي لشبكة روبونوميكس \\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — الصفحة الرئيسية لخدمات روبونوميكس عبر الويب\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — تطبيق الويب الرسمي\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — الموقع الرسمي لأكاديمية روبونوميكس\\n\\n### قواعد التقارير\\n\\nعند فتح مشكلة جديدة، لا تنسى بعض القواعد الأساسية للتقارير:\\n\\n1. اختر المستودع الدقيق الذي ترغب في تقديم مشكلة له.\\n\\n2. إذا كنت تقوم بالإبلاغ عن خطأ، تأكد من أن الخطأ لم يتم الإبلاغ عنه بالفعل.\\n\\n3. تأكد من تضمين العنوان والوصف الواضح، وأكبر قدر ممكن من المعلومات ذات الصلة.\\n\\n4. يرجى إضافة بادئة لمشكلتك من بين البادئات التالية: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## طلبات السحب\\n\\nقد يخضع أي مستودع لـRobonomics لطلبات السحب أو التغييرات من قبل المساهمين، حيث تعتقد أن لديك شيئًا قيمًا لإضافته أو تغييره. من فضلك، لا تنسى القواعد الأساسية للمساهمين.\\n\\n### قواعد المساهمة\\n\\n1. يفضل طلبات السحب على المشكلات، إذا كان لديك بعض التصحيحات، خاصة للتغييرات الصغيرة مثل الأخطاء الإملائية.\\n\\n2. تأكد من أن وصف طلب السحب يصف بوضوح المشكلة والحل. قم بتضمين رقم المشكلة ذات الصلة إذا كانت مطبقة.\\n\\n3. يرجى عدم إصلاح المسافات البيضاء، أو تنسيق الشفرة، أو إجراء تصحيحات مجردة للمظهر.\\n\\n4. يرجى المحاولة للالتزام بأسلوب Markdown واللغة والتخطيط السائد.\\n\\n\\n\"}},{\"node\":{\"id\":\"fd7ce0be32055bac2fb202570d4438ee\",\"title\":\"خدمة التعويض\",\"path\":\"/docs/ar/carbon-footprint-service/\",\"content\":\"\\nمثال على العمل موجود في الفيديو:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nخدمة لتعويض بصمة ثاني أكسيد الكربون عن طريق حرق الرموز المميزة في شبكة Statemine.\\nيتم حساب ثاني أكسيد الكربون الناتج على النحو التالي: البيانات الواردة من الجهاز بالواط مضروبة في المعاملات تعتمد على المنطقة. يتم تغطية 1 طن من ثاني أكسيد الكربون عن طريق استهلاك رمز واحد. [هنا](/docs/carbon-footprint-sensor) هي التعليمات لتوصيل الجهاز.\\n\\n## سيناريو\\n\\n1. سجل جهازًا جديدًا في التوأم الرقمي في شبكة Robonomics \\n2. بمجرد انتهاء الفاصل الزمني ، احصل على آخر البيانات من جميع الأجهزة واضربها بالمعامل اعتمادًا على المنطقة\\n3. جمع البيانات وتحويلها إلى أطنان ثاني أكسيد الكربون\\n4. طرح إجمالي عدد الرموز المحترقة من البيانات الحالية \\n5. حرق عدد صحيح من الرموز في شبكة Statemine \\n6. حفظ إجمالي عدد الرموز المحترقة في قاعدة البيانات المحلية و سجل البيانات \\n\\n\\n## التثبيت\\n\\nاستنسخ المستودع وعدل ملف التكوين.\\n\\n```\\ngit clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## وصف التكوين\\n\\nلا تقم بتعديل `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network wهنا Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nتم أخذ معاملات الطاقة غير المتجددة من [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) وتخزينها في `utils/coefficients.py`. \\n\\n## إطلاق\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"4b8c5fd321a9b97974185f9869659df0\",\"title\":\"توصيل الاستشعار\",\"path\":\"/docs/ar/carbon-footprint-sensor/\",\"content\":\"\\nمثال على العمل موجود في الفيديو:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## المتطلبات\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (أو واحدة من [مدعومة](https://www.zigbee2mqtt.io/information/supported_adapters.html))\\n\\nالخدمة تعمل على Raspberry Pi وتتصل بالمقبس الذكي عبر بروتوكول zigbee.\\n\\n## عصا Zigbee\\n\\nIf you have JetHome USB JetStick Z2 it already has necessary firmware so you don't need to flash it. But if you have another adapter firstly you need to flash it with zigbee2MQTT software. You can find instructions for you device [هنا](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nقم بتوصيل المحول وتحقق من عنوان المحول (قد يكون أيضًا `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nقد تحتاج إلى الوصول إلى منفذ USB أولاً. أضف مستخدمك إلى مجموعة `dialout` (يعمل في أوبونتو، ولكن اسم المجموعة قد يكون مختلفًا في نظام التشغيل الآخر).\\nبالنسبة لأوبونتو:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nبالنسبة لـ arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nثم قم بتسجيل الخروج وتسجيل الدخول أو إعادة تشغيل الكمبيوتر.\\n\\n## التثبيت\\n\\nاستنسخ المستودع:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## التكوين\\n\\nانتقل إلى `data/configuration.yaml` وقم بتعيين `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nقد ترغب أيضًا في ملء الحقلين \\\"الخادم\\\" و\\\"المنفذ\\\" بالمعلومات المقابلة. في حقل \\\"الخادم\\\"، استخدم عنوان IP الخاص بجسر \\\"docker0\\\" لتأسيس الاتصال:\\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nهنا عنوانك هو `172.17.0.1`.\\n\\nثم قم بإنشاء ملف config/config.yaml بالمعلومات التالية وقم بتعيين موقعك (يمكنك الاطلاع على https://countrycode.org/ للحصول على رمز ISO المكون من 3 أحرف):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## توصيل المقبس\\n\\nالتشغيل الأول:\\n\\n```\\ndocker-compose up     \\n```\\n\\nللتبديل إلى وضع الزوجية على المقبس، اضغط على زر الطاقة لبضع ثوان حتى يبدأ الضوء في الوميض باللون الأزرق بسرعة. \\n\\nفي السجلات يجب أن ترى الآن أن المقبس الخاص بك بدأ بنشر إلى mqtt. \\n\\n\\n## بعد الزوية\\n\\nإذا كنت لا تسمح للأجهزة الأخرى بالاقتران بجهازك، فيجب عليك الآن الانتقال إلى \\\"data/configuration.yaml\\\" وتعيين \\\"permit_join: false\\\". أعد تشغيل الخدمة (استخدم `Ctrl+C` و\\n\\n```bash\\ndocker-compose up     \\n```\\nمرة أخرى لتقديم التغييرات).\\n\\n## التشغيل\\nعند بدء التشغيل الأول سيتم إنشاء حساب للمقبس. \\n> إذا كان لديك بالفعل حساب يجب عليك إضافة بذرته إلى ملف `config.config.yaml` في قسم `device_seed`:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nبعد إنشاء الحساب سترى العنوان في السجلات (سيتم إضافة البذرة إلى `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nتحتاج إلى نقل بعض الرموز إلى هذا الحساب لرسوم المعاملات، يمكنك القيام بذلك على [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nسيعرف الخدمة أن لديك رموز كافية، في السجلات سترى:\\n```\\nplug               | Balance is OK\\n```\\nسيعرف الخدمة رسائل mqtt من المقبس واستخدام الطاقة بأمان. كل ساعة (يمكنك تغيير الوقت المحدد في `config/config.yaml` في قسم `sending_timeout`، الوقت المحدد بالثواني) ستقوم بإنشاء سجل بيانات يحتوي على المعلومات التالية:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"dc4cf2104cb499b9d8d26d826cfe0b2c\",\"title\":\"خدمات النسخ الاحتياطي\",\"path\":\"/docs/ar/backup-services/\",\"content\":\"\\n**في هذه المقالة، ستتعلم كيفية إنشاء نسخ احتياطية لتكوين Home Assistant الخاص بك واستعادته عند الحاجة. لإنشاء النسخ الاحتياطية، يتم استدعاء خدمة تقوم بإنشاء أرشيف آمن يحتوي على ملفات التكوين. تقوم الخدمة أيضًا بإضافة تكوين Mosquitto brocker و Zigbee2MQTT إلى النسخة الاحتياطية إذا كانت موجودة. ثم تقوم هذه الخدمة بإضافة الأرشيف إلى IPFS وتخزين معرف النتيجة في Robonomics Digital Twin.**\\n## إنشاء نسخة احتياطية لتكوين Home Assistant\\n\\nيتيح لك إنشاء نسخة احتياطية استعادة تكوين Home Assistant الخاص بك بسهولة في حالة حدوث خطأ.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nلكي تتمكن من إجراء نسخ احتياطية واستعادة التكوين الخاص بك، من الضروري استخدام **بوابة IPFS مخصصة** مثل Pinata. بدون ذلك، ستتم تخزين نسخة الاحتياطية الخاصة بك فقط على عقدة IPFS المحلية الخاصة بك، مما قد يمنعك من استعادة تكوين Home Assistant الخاص بك في حالة فشل العقدة المحلية.\\n\\n</robo-wiki-note>\\n\\n1. في واجهة الويب لـ Home Assistant، انتقل إلى `أدوات المطور` -> `الخدمات`. ابحث عن `Robonomics: حفظ النسخة الاحتياطية في Robonomics` واضغط على `استدعاء الخدمة`.\\n\\n2. انتظر حتى تظهر إشعار `تم تحديث النسخة الاحتياطية في Robonomics` في `الإشعارات`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nلا تحاول إنشاء نسخة احتياطية أو استعادة التكوين فور تحميل Home Assistant و Robonomics Integration. يرجى **الانتظار لمدة تقريبية 5 دقائق** لإتمام الإعداد الأولي.\\n\\n</robo-wiki-note>\\n\\nوسيطات الخدمة:\\n- **نسخة احتياطية كاملة** (الافتراضي: خاطئ) - إضافة قاعدة البيانات إلى النسخة الاحتياطية، بحيث يتم تخزين تاريخ حالات الكيان أيضًا.\\n- **مسار ملف كلمة مرور mosquitto** (الافتراضي: `/etc/mosquitto`) - إذا كنت تستخدم طرق تثبيت Home Assistant Core أو Docker وليس لديك مسار افتراضي لـ Mosquitto brocker، يجب عليك تغيير هذا المعلم. *لا يلزم ذلك لـ Home Assistant OS أو Superviser*.\\n\\n## استعادة تكوين Home Assistant من النسخة الاحتياطية\\n\\nلكي تتمكن من استعادة التكوين الخاص بك، ستحتاج إلى Home Assistant و Robonomics Integration مثبتين. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nلضمان استعادة التكوين الناجحة في طرق تثبيت Home Assistant Core و Docker، تحتاج إلى أداء خطوات الإعداد الإضافية كما هو موضح في نهاية الصفحة.\\n\\n</robo-wiki-note>\\n\\n1. قم بتثبيت Home Assistant مع Robonomics Integration (إذا لم يتم تثبيته بعد)، باتباع الخطوات الواردة في المقالة الخاصة بـ [طريقة التثبيت المطلوبة](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-هنا-your-smart-home).\\n\\n2.  [قم بإعداد Robonomics Integration](https://wiki.robonomics.network/docs/robonomics-hass-integration) باستخدام **نفس البذور** التي استخدمتها في تكوين Robonomics السابق. إذا انتهت اشتراكك، [أعد تنشيطه](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. في واجهة الويب لـ Home Assistant، انتقل إلى `أدوات المطور` -> `الخدمات`. ابحث عن `Robonomics: استعادة من النسخة الاحتياطية في Robonomics` واضغط على `استدعاء الخدمة`. انتقل إلى صفحة `نظرة عامة` للتحقق من حالة النسخة الاحتياطية الخاصة بك.\\n\\n4. بعد الاستعادة، سيتم إعادة تشغيل Home Assistant تلقائيًا. إذا لم يتم إعادة تشغيل Home Assistant لأي سبب، يمكنك التحقق من حالة الاستعادة عن طريق مراقبة حالة الكيان `robonomics.backup`. إذا كانت الحالة هي `تمت الاستعادة`، فسيتعين عليك إعادة تشغيل Home Assistant يدويًا عن طريق الانتقال إلى `الإعدادات` > `النظام` والنقر على زر `إعادة التشغيل` الموجود في الزاوية العلوية اليمنى.\\n\\n5. إذا كان النسخة الاحتياطية الخاصة بك تتضمن تكوين Zigbee2MQTT أو Mosquitto، فيجب عليك إعادة تشغيل هذه الخدمات لتمكين التكوين الجديد. يمكنك القيام بذلك يدويًا عن طريق إعادة تشغيل الخدمات بشكل فردي، أو يمكنك ببساطة إعادة تشغيل جهاز Home Assistant لضمان إعادة تشغيل جميع الخدمات.\\n\\nوسيطات الخدمة:\\n- **مسار ملف كلمة مرور mosquitto** (الافتراضي: `/etc/mosquitto`) - إذا كنت تستخدم طرق تثبيت Home Assistant Core أو Docker وليس لديك مسار افتراضي لـ Mosquitto brocker، يجب عليك تغيير هذا المعلم. *لا يلزم ذلك لـ Home Assistant OS أو Superviser*.\\n- **مسار تكوين Zigbee2MQTT** (الافتراضي: `/opt/zigbee2mqtt`) - إذا كنت تستخدم طرق تثبيت Home Assistant Core أو Docker وليس لديك مسار افتراضي لـ Zigbee2MQTT، يجب عليك تغيير هذا المعلم. *لا يلزم ذلك لـ Home Assistant OS أو Superviser*.\\n\\n## استعادة تكوين Mosquitto و Zigbee2MQTT لطريقة تثبيت Home Assistant Core\\n\\nإذا كانت النسخة الاحتياطية تتضمن تكوين Mosquitto أو Zigbee2MQTT، خلال عملية الاستعادة، سيتم وضعهما في المسار الافتراضي أو في المسار المحدد في المعلمات. ومع ذلك، إذا قمت بتثبيت تكامل Robonomics في Home Assistant Core الموجود *(ليس من صورة Robonomics المثبتة مسبقًا)*، فقد لا يكون لدى المستخدم `homeassistant` صلاحية الوصول إلى هذا المسار.\\n\\nلذا لاستعادة تكوين Mosquitto و Zigbee2MQTT، يجب منح أذونات القراءة اللازمة للمستخدم `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## نسخ احتياطي لتكوين Mosquitto و Zigbee2MQTT لطريقة تثبيت Home Assistant بواسطة Docker\\n\\nلنقل نسخ احتياطية لتكوينات Mosquitto و Zigbee2MQTT من حاوية Docker ، تحتاج إلى إنشاء أحجام لتكويناتهما المعنية. يمكن تحقيق ذلك عن طريق تشغيل حاوية Home Assistant الخاصة بك بوسائط إضافية:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nأو إجراء تغييرات في ملف `compose.yaml` الخاص بك:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nيرجى ملاحظة أن المسارات الافتراضية لتكوينات Mosquitto و Zigbee2MQTT هي `/etc/mosquitto` و `/opt/zigbee2mqtt` على التوالي. ومع ذلك ، قد تختلف هذه المسارات اعتمادًا على إعدادك المحدد.\\n\\n</robo-wiki-note>\\n\\n## أزرار النسخ الاحتياطي\\n\\nبالإضافة إلى استخدام الخدمات للعمل مع النسخ الاحتياطية ، يمكنك تبسيط العملية باستخدام أزرار `button.create_backup` و `button.restore_from_backup` من تكامل Robonomics. تُطلق هذه الأزرار الخدمات المعنية بالمعلمات الافتراضية (تنشئ زر النسخ الاحتياطي نسخة احتياطية بدون تاريخ).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nلإضافة أزرار إلى لوحة التحكم الخاصة بك ، اتبع هذه الخطوات:\\n\\n1. انقر على النقاط الثلاث في الزاوية اليمنى العلوية من لوحة التحكم.\\n2. حدد `تحرير لوحة التحكم`.\\n3. انقر على زر `إضافة بطاقة` في الزاوية اليمنى السفلية.\\n4. اختر بطاقة `الكيانات`.\\n5. في حقل `الكيانات` ، ابحث عن كيانات button.create_backup و button.restore_from_backup.\\n6. اضغط على `حفظ` لإضافة الكيانات إلى البطاقة.\\n7. انتهِ من التحرير بالنقر على زر `تم` في الزاوية اليمنى العلوية.\"}},{\"node\":{\"id\":\"7798211576aad3ea46b32c84757f9abb\",\"title\":\"إضافة الأموال إلى حسابك على بوابة روبونوميكس\",\"path\":\"/docs/ar/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**بعد إنشاء حساباتك بنجاح على بوابة روبونوميكس، حان الوقت لإضافة الأموال إليها حتى تتمكن من إجراء المعاملات.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\nيرجى الانتباه إلى أن هذه الدروس والتعليمات التالية تُعرض على نسخة محلية من نود روبونوميكس. قم بإعداد النسخة الخاصة بك باستخدام [هذه التعليمات](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. انتقل إلى قسم الحسابات على بوابة روبونوميكس \\n\\n![Accounts](../images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. اختر الحساب الذي ترغب في تحويل الأموال منه\\n\\nفي وضع التطوير، هناك عدة حسابات، تحتوي كل منها على 10000 وحدة من الأموال، يمكن استخدامها لتحويل الأموال إلى حسابات أخرى تم إنشاؤها في الشبكة التطويرية. يتم تمييز هذه الحسابات بوجود علامات العزم بجانبها. <img alt=\\\"wrench sign\\\" src=\\\"../images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> بجانبهم.\\n\\n![Accounts-for-sending](../images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- انقر على زر \\\"إرسال\\\" للحساب الذي ترغب في تحويل الأموال منه، على سبيل المثال BOB\\n\\n## 3. اختر الحساب الذي ترغب في تحويل الأموال إليه\\nبعد النقر على زر \\\"إرسال\\\"، ستظهر لك نافذة \\\"إرسال الأموال\\\". في النافذة المطلوبة:\\n\\n- من قائمة الحسابات المتاحة، اختر الحساب الذي ترغب في إرسال الأموال إليه.\\n- أدخل عدد الوحدات التي ترغب في إرسالها.\\n- اضغط على \\\"إجراء التحويل\\\"\\n\\n![Transfer-Funds](../images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. قم بتأكيد العملية\\n\\nبعد الضغط على \\\"إجراء التحويل\\\" في المرحلة السابقة، ستظهر لك نافذة \\\"تأكيد العملية\\\".<br/>\\nقم بمراجعة تفاصيل العملية وأخيرًا انقر على زر \\\"توقيع وإرسال\\\".\\n\\n![sign-transaction](../images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nفي هذا المثال، قمنا بتحويل 500 وحدة من الأموال من \\\"BOB\\\" إلى \\\"EMPLOYER\\\". يمكنك أن ترى أن حساب EMPLOYER، الذي لم يكن لديه أي أموال في البداية، يحتوي الآن على 500 وحدة من الأموال.\\n\\n![funds-added](../images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**تأكد من وجود أموال كافية في الحسابات التي ترغب في استخدامها في الملعب.**\"}},{\"node\":{\"id\":\"d10b7cc796b237f6c864989173c83e99\",\"title\":\"Zigbee Adapter with Zigbee2MQTT for Pre-installed Image\",\"path\":\"/docs/zigbee-to-mqtt-image/\",\"content\":\"\\n**In this article you will pair smart devices.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/zigbee2mqtt.png\\\" />\\n\\n## Pairing Device\\n\\nOpen a web browser and go to `http://%RASPBERRY_IP_ADDRESS%:8099`. You can find the IP address of Raspberry Pi \\nusing [Fing mobile app](https://www.fing.com/products) or [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\nYou will see web-interface of Zigbee2MQTT:\\n\\n<robo-wiki-picture src=\\\"home-assistant/z2m-webinterface.jpg\\\" />\\n\\n\\n\\n\\nIt's time to connect your smart device. \\nFirst, press `Permit join (All)` button at the top of web-interface of Zigbee2MQTT. \\n\\nThen, start to pair devices. The most common way to switch a device to connect mode is to hold its power button or switch them on/off 5 times. Make sure Zigbee2MQTT is running.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\nWhen the device connects, you will see them in web-interface:\\n\\n<robo-wiki-picture src=\\\"home-assistant/device_connected.jpg\\\" />\\n\\nNow you should see this sensor in your Home Assistant WebUI. Go to `Settings` -> `Devices & Services` -> `Devices`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/mqtt-devices.jpg\\\" />\\n\\nAfter adding all the sensors, you can close web-interface of Zigbee2MQTT.\\n\"}},{\"node\":{\"id\":\"54f1b0e2741eed380c3c65400dc18416\",\"title\":\"Substrate Cumulus Parachain Testsuite for cross-chain messaging\",\"path\":\"/docs/xcm-robobank/\",\"content\":\"\\n\\nThe main goal of this project is the simplification of parachain runtime development, when cross-chain messages are used. \\nIt allows the development of runtime code with integration tests with high degree of repeatability and simple usage.\\nIt automates building, construction of pre-set network configuration (i.e. 1 relay chain + 2 parachains), setup message-passing channels between parachains and run messaging tests, sending messages, using call to runtime, all constructed and composed in Python.\\n\\nXCM Testsuite is used for testing the production cycle of Robobank - the set of Substrate pallets, which allow robots to register on external parachains, receive pre-paid orders, execute them and receive payments using external tokens. This allows robots to operate inside the Robonomics network with all required infrastructure, but at the same time, offer their services on any other parachain.\\n\\nAn example video is available on [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)\\n\\nThe main steps in the demo scenario are:\\n- launch relay chain and two parachains in a pack of 6 processes\\n- setup XCM message channels between parachains\\n- register a robot in both parachains\\n- create an order for this robot in the client parachain (reserving payment for the completion of order)\\n- send XCM message to the Robonomics parachain\\n- creating the \\\"mirrored\\\" order record on the Robonomics parachain\\n- robot accepts the order on the Robonomics parachain\\n- send XCM message about the order acceptance back to the client parachain\\n- accept the order on the client parachain (reserving a penalty fee for lack-of-order-completion until the order deadline)\\n- robot completes the order on the Robonomics parachain\\n- send XCM message about the order completion to the client parachain\\n- settle all payments (client payment is transfered to the robot, as well as the unutilized penalty fee)\\n- close the order1\\n\\n\\n## Upstream\\nThis project is a fork of the\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template).\\nIt contains code of the runtime pallets being tested.\\nAs in original node code of the parachains is in \\\"./pallets\\\", \\\"./runtime\\\", \\\"./node\\\" catalogs.\\n\\nDifferences with original \\\"substrate-node-template\\\":\\n- this collator runtime has HRMP handler module and can handle messages from siblings parachains\\n- mock test runtime ready-made for internal XCM tests\\n\\n## Build & Run\\nRecommended(highly) setup: \\n```\\nUbuntu 20, 16 Gb RAM, 8 CPU, 120 Gb SSD\\n```\\n[NOTE] The first build can take a lot of time, up to several hours on suboptimal machines.\\n\\n[NOTE] The script works with the FIXED versions (commit hashes) of Polkadot(Rococo) in relay chain and parachains.\\n\\n[NOTE] By default the script re-creates the same environment every launch, by removing all previous states. This behaviour can be changed in \\\"config.sh\\\" using \\\"PERSISTENT\\\" param.\\n\\n\\nRun build and setup script.  \\n```bash\\ngit clone https://github.com/airalab/xcm-robobank-prototype.git\\ncd xcm-robobank-prototype\\n./scripts/init.sh\\n```\\n\\nBasic actions of \\\"init.sh\\\" script:\\n - read config (file \\\"config.sh\\\" with revision number, initial node keys and identifiers, chaindata persistence param, etc.)\\n - setup OS packets, Rust and Python\\n - bulds separate binaries for the relay chain and also for both parachains\\n    - binaries will be generated in ./bin subdirectory. \\n - (optional) removes all previous chain data for all chains\\n    - disabled if \\\"PERSISTENT=1\\\" is set in \\\"config.sh\\\"\\n - runs as separate processes (with separate PIDs and I/O pipes):\\n    - validators of relay chain (i.e. 4 validators of running a stable Rococo revision)\\n    - collators for parachain-100 (i.e. single collator for first parachain, that you're developing)\\n    - collators for parachain-200 (i.e. single collator for second parachain, that you're developing)\\n - prints all endpoints, ports to console, allowing you to study any chain using frontend apps (explorer, DApp)\\n - keep printing all the output data of all chains to console\\n\\n[WARNING] After launching, wait until the network is up, make sure that block finalization has started, and that the parachains are registered. These processes should require approximately 5 min (50 blocks x 6 sec).\\n\\n## Checking that initial setup works \\n\\nUse the standard Polkdot frontend and generated \\\"--ws-port\\\" endpoints to connect with each node.\\nOpen [Polkadot application](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) to monitor the chains. \\n\\n### Example:\\nLocalhost, 4 relay chain validators, one parachain-100 collator, one parachain-200 collator:\\n- [Relay validator 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)\\n- [Relay validator 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)\\n- [Relay validator 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)\\n- [Relay validator 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)\\n- [Parachain-100 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)\\n- [Parachain-200 collator](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)\\n\\n\\nIf everything works, and consensus started off, we can proceed to run our test cases (in a new terminal).\\n\\n### UMP message passing test\\n```bash\\n./scripts/init.sh ump\\n```\\nIt creates a `Balance.transfer` message in `parachain-100` and passes it to the relay chain.\\nWhen the relay chain receives the message it will transfer 15 tokens from `para 100` account to the Charlie acount.\\n\\n\\n### HRMP message passing test\\n```bash\\n./scripts/init.sh ump\\n```\\n\\nIt creates a `Balance.transfer` message in `parachain-100` and passes it to the `sibling 200` one.\\nBefore that, it endows the`subl 100` account with 1000 tokens and  establish a communication channel between the parachains.\\n```bash\\n./scripts/init.sh hrmp\\n```\\nNext messages can be sent by running the `hrmpm` subcommand. It doesn't create a channel and so it runs faster.\\n```bash\\n./scripts/init.sh hrmpm\\n```\\n\\n### More options\\n```bash\\n./scripts/init.sh help\\n```\\n\\n## Local Testnet\\n\\n### Create customized chain spec\\n```\\n./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json\\n```\\n\\nEdit rococo_local.json, replace the balances and authorities parameters with yours.\\n```json\\n  \\\"keys\\\": [\\n    [\\n      \\\"\\\",\\n      \\\"\\\",\\n      {\\n        \\\"grandpa\\\": \\\"\\\",\\n        \\\"babe\\\": \\\"\\\",\\n        \\\"im_online\\\": \\\"\\\",\\n        \\\"para_validator\\\": \\\"\\\",\\n        \\\"para_assignment\\\": \\\"\\\",\\n        \\\"authority_discovery\\\": \\\"\\\"\\n      }\\n    ]\\n```\\n\\nPolkadot address for //Alice//stash (sr25519 cryptography).\\n```bash\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash\\n```\\n\\n```text\\nSecret Key URI `//Alice//stash` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nPolkadot grandpa session key for //Alice (ed25519 cryptography).\\n```bash\\n$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nPolkadot address for //Alice (sr25519 cryptography).\\n```\\n$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice\\n```\\n```text\\nSecret Key URI `//Alice` is account:\\nSecret seed:      \\n\\nPublic key (hex): \\n\\nAccount ID:       \\n\\nSS58 Address:     \\n```\\n\\nConvert rococo_local.json to the raw format.\\n```\\n./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json\\n```\\nTo use new chain spec replace rococo.json file in ./config/ directory this new one and rerun chain.\\n```bash\\n./scripts/init.sh run\\n```\\nYou can freely edit the code. The above command will rebuild the project and update the collator node before starting.\\nCumulus is pre-release software that is still under heavy development.\\nWe are using a specific commit of polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 mar 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)\\n\\nYou can use more recent versions of the software. To do this, change  POLKADOT_COMMIT  in ./scipt/config.sh\\nto the latest commit of `rococo-v1` branch, delete ./bin/polkadot, and run \\n```bash\\n./scripts/init.sh run\\n```\\n\\nUpdate collator project dependencies \\n```bash\\ncargo update\\n./scripts/init.sh build\\n```\\nSome dependencies probably require new rust toolchain features. This project is based on rust `nightly-2021-01-26`\\nUpdate rust toolchain version in ./scripts/config.sh before build.\\n\\n## Hack parachain\\n[Add external pallet](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - should it probably be in \\\"learn more\\\"?\\n## Learn More\\n\\nRefer to the upstream\\n[Substrate Developer Hub Node Template](https://github.com/substrate-developer-hub/substrate-node-template)\\nto learn more about the structure of this project, the capabilities it encapsulates and the way in\\nwhich those capabilities are implemented. You can learn more about\\n[The Path of Parachain Block](https://polkadot.network/the-path-of-a-parachain-block/) on the\\nofficial Polkadot Blog.\\n[Parity Cumulus Workshop](https://substrate.dev/cumulus-workshop/#/)\\n\"}},{\"node\":{\"id\":\"5cdb6b93b647d5c775d185a65b49fddc\",\"title\":\"How To Use Blueprints\",\"path\":\"/docs/use-blueprints/\",\"content\":\"\\nIn this article you will know how to add automation blueprints to your Home Assistant and configure it.\\n\\n## Blueprint Automations\\n\\nSome blueprints are already installed. Automations based on such blueprints only need to be configured. In web interface you can find pre-installed blueprints in `Settings/Automations & Scenes`. Open `Blueprints` and find the blueprint you want to use. In this example `Motion-activated Light` will be used. \\n\\n<robo-wiki-picture src=\\\"home-assistant/blueprint-settings.jpg\\\" alt=\\\"Blueprint Settings\\\" />\\n\\nClick on `Create Automation` to open the automation editor. Give a name, choose a blueprint to use (`Motion-activated Light` in our case). After that you need to choose motion sensor and lamp. When configuration is finished, click `Save`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/automation-configure.jpg\\\" alt=\\\"Automation Configuration\\\" />\\n\\nIf you want to make changes, you can find it by going to `Settings/Automations & Scenes` and then `Automations`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/automations-all.jpg\\\" alt=\\\"Automations List\\\" />\\n\\n## Importing Blueprints\\n\\nHome Assistant can import blueprints from the Home Assistant forums, GitHub and GitHub gists. List of all Blueprints are located on [Blueprints Exchange](https://community.home-assistant.io/c/blueprints-exchange/53). After you chose, go to `Settings/Automations & Scenes` and open `Blueprints`. Click on `Import Blueprint` and insert URL of the chosen blueprint. Then click on `PREVIEW BLUEPRINT`. In this case we will use [Low battery level detection & notification for all battery sensors](https://community.home-assistant.io/t/low-battery-level-detection-notification-for-all-battery-sensors/258664). \\n\\n<robo-wiki-picture src=\\\"home-assistant/importing-blueprint.jpg\\\" alt=\\\"Importing Blueprint\\\" /> \\n\\nThis will load the blueprint and show a preview in the import dialog. You can change the name and finish the import. Click on `Create Automation` to open the automation editor. Here you can configure automation's parameters and add actions to get notifications.\\n\\n<robo-wiki-picture src=\\\"home-assistant/configure-battery-blueprint.jpg\\\" alt=\\\"Configure Battery Blueprint\\\" /> \"}},{\"node\":{\"id\":\"913698afe42043885b786cf78193aa9a\",\"title\":\"How to Send Launch with Subscription\",\"path\":\"/docs/subscription-launch/\",\"content\":\"\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Pay attention that this tutorial demonstrates using a subscription on Robonomics Kusama parachain. You can also perform\\n  all the same steps on your [local node](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\nIf your address has an active subscription, then any devices set up with that account's secret can send extrinsics with no fee. \\nLet's try to send the `launch` command.\\n\\nGo to the `Developer/Extrinsics` page, then choose your account (the one from device list) and select `rws -> call(subscriptionId, call)`. \\nThen in `subscriptionId` field paste the subscription's owner address (the one who bid the auction) and in the next field\\nchoose `launch -> launch(robot, param)`. In the `robot` field type the address you want to send `launch` transaction \\nto and insert the command (for launch command description refer [here](/docs/launch)). Then submit transaction:\\n\\n![launch](./images/rws/launch.png)\\n\\n\\nNow go to the `Network/Explorer` page, and in the `Recent Events` area you will see two events that you created; `rws.NewCall` and `launch.NewLaunch`:\\n\\n![events](./images/rws/events.png)\\n\"}},{\"node\":{\"id\":\"e12edf7195df63e5a7c77ee7f4827afa\",\"title\":\"Subscription Activate\",\"path\":\"/docs/sub-activate/\",\"content\":\"\\nIn this article you will create Robonomics parachain accounts and buy IoT subscription. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sub_activate.png\\\" />\\n\\n\\nTo control Home Assistant with Robonomics, you need 2 accounts on the Robonomics parachain. For one of the accounts (`sub_owner`), you will buy a Robonomics subscription. Second account (`sub_controller`) will control all Home Assistant processes (such as telemetry) and will give access to other users. These accounts will provide security for your Home Assistant. \\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nBoth accounts must be created with **ed25519** encryption. Because of this, you need to create an account using the Polkadot-JS UI and select the required encryption. \\n\\nThis feature is disabled by default on the Polkadot-JS UI. To enable it, navigate to `Settings` -> `General` -> `account options` and select `Allow local in-browser account storage` in the drop-down menu `in-browser account creation`.\\n\\n</robo-wiki-note>\\n\\n## Create Owner and Controller Accounts\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQiJYPYajUJXENX2PzSJMSKGSshyWyPNqugSYxP5eCNvm', type:'mp4'}]\\\" />\\n\\n1. Go to [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) on Polkadot / Substrate Portal. **Check the top left corner to ensure that you are connected to Robonomics Parachain.**\\n\\n2. Go to `Accounts` -> `Accounts` and press `Add account` button. You will see the popup menu with account seed. It has two forms: *Mnemonic* (human-readable) and *Raw* (a sequence of digits and letters). \\n\\n3. Open `Advanced creation options`, change the crypto type of creating account to `Edwards - ed25519` and press `Next`.\\n\\n\\n4. Save the mnemonic seed phrase securely and press `Next`.\\n\\n5. In the next menu, you need to set the account name and password. Give it a name `sub_owner` for convenience. Press `Next`.\\n\\n6. On the last window click `Save` to finish account creation. It will also generate a backup JSON-files that you should safely store. You can later use this file to recover your account if you remember the password.\\n\\n7. Repeat these steps for an account with the name `sub_controller`.\\n\\n\\n## Add Accounts to Polkadot.js\\n\\nFor convenience, you should use the [Polkadot.js extension](https://polkadot.js.org/extension/) and add these newly created accounts to it. For an ed25519 account you can do that only with a backup JSON file. You can use the files saved when you created the accounts.\\n\\nYou can get these files again by creating a backup file of the account. Press on three dots on your account, choose `Create a backup file for this account` and type in your password.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmRd7gztUjWkLF4W2XuJwy5aXBwzNV2aPCU6CQQLvUpSNj', type:'mp4'}]\\\" />\\n\\n1. Open an extension and press `+` button on the top right, then choose `Restore account from backup JSON file`.\\n\\n2. In an opened window upload the JSON file, enter the password and press `Restore`.\\n\\n3. Make sure the Robonomics network is selected for accounts in the Polkadot.js extension. On on Polkadot / Substrate Portal go to `Setting` -> `Metadata` and click on the `Update metadata` button. \\n\\n4. Confirm the metadata update in the popup. Now the extension will show the label of the network for which the address is used.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmT5sTNP9t8gpbD4RJJw6ETwG4wiziiChAh2uHHBk9Zsyd', type:'mp4'}]\\\" />\\n\\n## Activate Robonomics Subscription \\n\\n<robo-wiki-note type=\\\"okay\\\">\\n\\nFor this step, you must have a sufficient amount of XRT tokens (minimum 2-3 XRTs) in your `sub_owner` account.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmXrFCajmJgkRDSbshGD3QehjnoyS6jafEPSjHdYkoBHum', type:'mp4'}]\\\" />\\n\\n1. Go to Robonomics dapp to the [subscription page](https://dapp.robonomics.network/#/subscription) and press connect account on the right sidebar.\\n\\n2. In the following popup menu connect Polkadot.js extension. You will see your account address with balance.\\n\\n3. Before purchasing, check that you chose the `sub_owner` account. Press the address profile icon, you should see the `sub_owner` account under the `Check owner account` field.\\n\\n4. Finally, press the `SUBMIT` button and enter the password for your account. After that wait until the activation process is completed. You will see the state of your subscription after a while.\\n\\n\\n## Add Accounts to Subscription\\n\\nNow you need to add a `sub_controller` account to the **access list**. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmV1gkwtcXsWv54ov9tuXfcHg7nqs1foM8cRwts4sqnqtX', type:'mp4'}]\\\" />\\n\\n1. Open extension and click on the icon near the account name. It will copy the account address.\\n\\n\\n2. Paste this address to the `Robonomics parachain address` field in the **Manage access** part. Give it a name and press the `+` button. \\n\\n3. Repeat steps 1 and 2 for `sub_owner` account.\\n\\n4. Press `Save`. Enter your `sub_owner` password in the popup window and wait until the activation process is completed.\\n\"}},{\"node\":{\"id\":\"a652f42d33dee5a1791a1924f14ed797\",\"title\":\"Get Smart Home Telemetry\",\"path\":\"/docs/smart-home-telemetry/\",\"content\":\"\\n**In this article, you will use the Robonomics service, which queries the telemetry of smart home devices.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmao9RoWcKo2qs4PAGtm5gqHzyAHJcpDqNLgciU35FJeVm', type:'mp4'}]\\\" />\\n\\n1. Go to dapp and choose [SmartHome Telemetry](https://dapp.robonomics.network/#/smarthome-telemetry) service.\\n\\n2. In the controller field enter the `SUB_CONTROLLER` address. Insert the seed phrase to encrypt data.\\n\\n3. In the `Get telemetry` block choose a timestamp from the drop-down list and press the `DOWNLOAD TELEMETRY` button.\\n\\n4. Telemetry downloading could take some time. After finishing, you will see the information from your devices and sensors.\\n\\n\\n<!---\\n## Launch devices\\n\\nGo back and  choose service [\\\"SmartHome Telemetry\\\"](https://dapp.robonomics.network/#/services). You will forward to DApp website. In first login give permission to website to use polkadot{.js} extension. You will see next:\\n\\n<robo-wiki-picture src=\\\"home-assistant/telemetry-start.jpg\\\" />\\n\\nFind address of your `user` account and press blue button:\\n\\n<robo-wiki-picture src=\\\"home-assistant/datalog-start.jpg\\\" />\\n\\nAnd you will see popup \\\"Launch\\\" window:\\n\\n<robo-wiki-picture src=\\\"home-assistant/launch-window.jpg\\\" />\\n\\nLaunch command calls HomeAssistant service, first two fields are **service name** - \\\"Platform\\\" and **service function** - \\\"Name\\\". Let's find them.\\n\\nFor this go to your Home Assistant interface in browser -> `Developer tools` -> `SERVICES` and turn on `YAML mode`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-services.jpg\\\" />\\n\\nFind a service you need using a search field or choose from a drop-down list there.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light.jpg\\\" />\\n\\nLet's find a `light` service. You will see available functions(`turn_on`, `turn_off`, `toggle`). Choose `turn_on` function.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-light-on.jpg\\\" />\\n\\nOn the picture you see **service name** - `light` and **service function** - `turn_on`. Write these statements to popup window of DApp.\\n\\n<robo-wiki-picture src=\\\"home-assistant/light-window.jpg\\\" />\\n\\nNext you need to find the sensor ID. For this go to `Overview` on the HA page. Find sensor, which you want to turn on(in this example it is the light) and press on it. \\n\\n<robo-wiki-picture src=\\\"home-assistant/light-name.jpg\\\" />\\n\\nYou will see a popup window and with a \\\"settings\\\" button on it the top-right corner. Press on it. The popup window will change. In the new window you will find required `entity_id`:\\n\\n<robo-wiki-picture src=\\\"home-assistant/entity-ha.jpg\\\" />\\n\\nCopy it and paste to field in our dapp:\\n\\n<robo-wiki-picture src=\\\"home-assistant/dapp-entity.jpg\\\" />\\n\\nFinally, press `SEND` button and sign transaction with your password. Wait until transaction is in block and check your light. It should be turned on (sometimes it takes a bit more time).\\n\\nCongratulations, You have fully installed and set up Your Home Assistant with Robonomics!\\n-->\\n\"}},{\"node\":{\"id\":\"c4a05afab713f91f79eaaa2e497d4553\",\"title\":\"Robonomics SLS Gateway\",\"path\":\"/docs/sls-gateway/\",\"content\":\"\\n**In this article you will set up Robonomics SLS Gateway. You will install the required software for the gateway, configure it and connect it to Home Assistant.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls_gateway.png\\\" />\\n\\n## Firmware\\n\\nFirst you need to install microcontroller firmware of the gateway. Prepare the gateway by setting switches `1` and `3` at the bottom part of SLS Gateway to `ON`, others must be `OFF`.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-13.gif\\\" />\\n\\nConnect gateway to your Raspberry Pi via USB type-C port on the gateway.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-rpi.gif\\\" />\\n\\nClone the repository with firmware to your Raspberry Pi:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ngit clone https://github.com/airalab/robonomics-hass-utils.git\\n```\\n\\n</code-helper>\\n\\nGo to `robonomics-hass-utils/esp_firmware/linux`. To flash the SLS gateway you need to run `Clear` and `Flash_16mb` scripts.\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\ncd robonomics-hass-utils/esp_firmware/linux\\nsudo chmod +x Clear.sh\\nsudo chmod +x Flash_16mb.sh\\n./Clear.sh\\n./Flash_16mb.sh\\n```\\n\\n</code-helper>\\n\\n### Troubleshooting\\n\\nIf you are experiencing problems updating the gateway firmware, you need to take additional steps:\\n\\n1. Make sure you have the pySerial module installed:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\npip install pyserial\\n```\\n</code-helper>\\n\\n2. Give your user access rights to the USB port and reboot computer:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsudo usermod -a -G dialout $USER\\nsudo reboot\\n```\\n</code-helper>\\n\\n3. In some cases, it is necessary to change the bandwidth setting in the script to update the firmware. Open the `Flash_16mb.sh` script with the `nano` editor and change the baud parameter from `921600` to a smaller value (for example, `115200`).\\n\\n## Configuration\\n\\n1. Disconnect SLS Gateway from rhe computer. Set the switches on the back of the gateway to the proper position. Switches `5` (RX Zigbee to ESP) and `6` (TX Zigbee to ESP) must be in the `ON` position, the others must be `OFF`. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-56.gif\\\" />\\n\\n2. Connect the type-C power cable. The indicator light in the center should turn green.\\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-connect.gif\\\" />\\n\\n3. On the first startup, the gateway will start sharing Wi-Fi with the SSID `zgw****`. Connect to this network. Keep in mind that the signal may be quite weak, so it is better to keep the SLS gateway closer to your computer. \\n\\n<robo-wiki-picture src=\\\"home-assistant/sls-gateway-wifi.gif\\\" />\\n\\n4. If the connection is successful, the web interface will open (or you can find it on 192.168.1.1 address). \\n\\n5. You will see `Wi-Fi Settings` page. Select your Wi-Fi and enter the password. Press `Apply` button. The gateway will restart and connect to your Wi-Fi network. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSht6roENzrV6oqsQ1a5gp6GVCz54EDZdPAP8XVh9SCwH', type:'mp4'}]\\\" />\\n\\n6. Find the local IP of the SLS gateway to access the web interface. To find it you can use [Fing mobile app](https://www.fing.com/products) or [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). The gateway name should look like this: `zgw****`. Open the web interface of the gateway by pasting the gateway IP into a browser.\\n\\n7. Go to `Setting` -> `Hardware` and make sure that the settings look like on the image. Correct the settings if necessary and click `Save` button:\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmeSksMxU9xkvvK7f81WDAYULiMFokK7P7KDVYEjv2MHjn', type:'mp4'}]\\\" />\\n\\nThe table with required values:\\n\\n| Field                    | Value              |\\n|--------------------------|:-------------------|\\n| Zigbee module            | TI                 |\\n| Zigbee UART RX           | 22                 |\\n| Zigbee UART TX           | 23                 |\\n| Zigbee RST Pin           | 18                 |\\n| Zigbee BSL Pin           | 19                 |\\n| Service Button Pin       | 33 (pullUP - true) |\\n| Number addressable leds  | 0                  |\\n| Led Red (or addr)        | 21                 |\\n| Led Green                | 5                  |\\n| Led Blue                 | 27                 |\\n| I2C SDA                  | 255                |\\n| I2C SCL                  | 255                |\\n\\n8. Then reboot the gateway. Choose `Actions` -> `Reboot system` at the right top corner.\\n\\n9. Make sure that the gateway works properly in the Zigbee info window. DeviceState should be `OK`.\\n\\n10. Configure automatically adding devices to Home Assistant. Go to `Zigbee` -> `Config` then choose `Home Assistant MQTT Discovery` and `Clear States`. Save changes and again **reboot** SLS gateway.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nIf you already have an active SLS gateway in your home, and you are now configuring another one, then they will conflict with each other. To solve this problem you need to change the channel on the new device. To do this, go to `Zigbee` -> `Config` and change the channel to another one (e.g. channel 15).\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmVZMB1xQeB6ZLfSR6aUrN6cRSF296s8CMJt7E2jBJ5MjZ', type:'mp4'}]\\\" />\\n\\n## Pairing SLS to MQTT\\n\\nAfter configuring the SLS Gateway, you need to connect SLS Gateway to Home Assistant. Open SLS Gateway web interface and go to `Settings/Link` -> `MQTT Setup`:\\n\\n\\nAdd your broker address (address of the Raspberry Pi with Home Assistant in local network, you can find it with [Fing mobile app](https://www.fing.com/products) or [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/)), port (default is `1883`) your broker username and password (which you have created earlier) and the topic name (you can choose any). Also, the Raspberry Pi IP address must be static. Click on `Enable` and `Retain states`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdNKDqwwy87VQEDDVsX5kpaDQm9wKKPEJUNJnhnjx6e5y', type:'mp4'}]\\\" />\\n\\nSave changes. Now devices will be automatically shown in Home Assistant.\\n\\n## Connect Devices\\n\\nConnect your devices by going to `Zigbee` -> `Join`. Put your sensors in pairing mode, the most common way to switch a device to connect mode is to hold its power button or switch them on/off for 5 times. Press the `Enable Join` button to start searching Zigbee devices. You will see active sensors.\\n\\n<robo-wiki-picture src=\\\"home-assistant/switch-device.gif\\\" />\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmdq3PBNY88QbYYqakwSLG2vn3mVUom3w3wsSWfTd1pzJA', type:'mp4'}]\\\" />\\n\\n\\nNow you can go to the [**IoT Subscription**](/docs/sub-activate) section and start activating the Robonomics subscription.\\n\"}},{\"node\":{\"id\":\"4862ab749c8f7064a610e983e34b8ee1\",\"title\":\"Decentralized Sensors Network\",\"path\":\"/docs/sensors-network-introduction/\",\"content\":\"\\nThe articles about Decentralized Sensors Network was transferred to Robonomics Academy: https://robonomics.academy/en/online-courses/sensors-connectivity-course/\"}},{\"node\":{\"id\":\"6b4a1d174b284fa9ef26fded1023fc79\",\"title\":\"Securely connect cloud AI to the factory floor\",\"path\":\"/docs/securely-connect-cloud-ai-to-the-factory-floor/\",\"content\":\"\\nRobonomics technologies can already solve the challenges that Industry 4.0 faces and they are already applied to real-world scenarios in the industrial environment.\\n\\nA large number of AI companies are building solutions to optimize the processes on the factory floor, allowing plants to produce more with less cost. However, most plants are hesitant to connect their infrastructure to the cloud directly since this results in potential cybersecurity risks, which could lead to million-dollar losses and even the loss of human life.\\n\\n[MerkleBot](https://merklebot.com) has used [Robonomics Network](https://robonomics.network) to build a solution for industrial clients to connect their factory to the cloud-based AI in a secure way.\\n\\nThis article is written in the wake of an experiment we conducted with [Veracity Protocol](https://www.veracityprotocol.org/) that uses algorithms to create non-invasive protection of any physical item based on the photographs from a mobile device.\\n\\nThis use case shows the process of scanning the industrial parts using a robotic arm.\\n\\n[Demo video](https://youtu.be/8AL70LFVX5w)\\n\\n## Step-by-step process\\n\\n### DApp as user interface\\n\\n<!-- ![](./images/google-play-store.gif) -->\\n<!-- <img src=\\\"./images/google-play-store.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"google-play-store.gif\\\" />\\n\\nDApp acts as a user interface for the operator. It is used to request the launch of the robot to collect the photographs and its purpose is to allow secure communication between the factory environment and cloud-based AI.\\n\\n### Launching the robot\\n\\n<!-- ![](./images/Veracity_Protocol_Transaction.gif) -->\\n<!-- <img src=\\\"./images/Veracity_Protocol_Transaction.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Transaction.gif\\\" />\\n\\nThe operator launches the robotic scan by signing the transaction in the DApp. This step guarantees that the process on the factory floor can only start based on the transaction in the public blockchain.\\n\\nThe robot receives a command from the blockchain through the Robonomics Network and begins the scan. Robonomics Network technologies allow us to close the gap between the business objective and robotics operation.\\n\\n### Data collection and sending to cloud-based AI\\n\\nIn the DApp the operator sees the confirmation and the robot begins to scan the items placed on the table, such as in this use case, or on the factory line directly if the need arises.\\n\\n<!-- ![](./images/Veracity_Protocol_Launch.gif) -->\\n<!-- <img src=\\\"./images/Veracity_Protocol_Launch.gif\\\" /> -->\\n<robo-wiki-picture src=\\\"Veracity_Protocol_Launch.gif\\\" />\\n\\n\\nWhen the robot collects the data, it stores it locally and makes it available to cloud-based AI through IPFS protocol. By encrypting the data and organizing the data exchange through a blockchain transaction as well, we can authorize access to cloud-based AI while making sure that the data remains secure and in place.\\n\\nThe security mechanism built into Robonomics based on the shared security of public blockchains allows gaining the level of security that is prohibitively expensive for most factories to organize on their own.\\n\\n### Digital passport creation\\n\\nWhen the cloud-based AI analyses the data, the log file and recommendations are recorded as a [Digital Passport](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/) automatically. Every operation and scan can be traced back since the blockchain record has the hash to all these files through IPFS protocol.\\n\\n## Comments about the use case\\n\\nIn this use case, Universal Robot UR3 industrial arm was used. But thanks to Robonomics support for ROS, most major industrial manipulators can be used and connected to cloud-based AI securely, including KUKA, Fanuc, and Yaskawa.\\n\\nIf you are interested to learn more about the deployment and integration of cloud-based AI instruments securely please [reach out](mailto:v@merklebot.com)\\n\"}},{\"node\":{\"id\":\"796bced25879ea4f4347a89eb7299922\",\"title\":\"How to Add SDS011 Sensor to Home Assistant\",\"path\":\"/docs/sds-sensor-hass/\",\"content\":\"\\nThis arcticle explains, how to connect SDS Air Quality sensor with [Luftdaten](https://github.com/opendata-stuttgart/sensors-software) & [Robonomics](https://github.com/airalab/sensors-software) Firmware to Home Assistant.\\n\\n## Installation \\nThere are two installation options available:\\n\\n### Option 1: HACS\\n\\nThe easiest way to add a Local Luftdaten Sensor is through HACS. [Here](https://hacs.xyz/docs/setup/download/) you can find a brief explanation on how to set up HACS.\\n\\nOnce HACS is installed, navigate to HACS -> Integrations and search for the `Local Luftdaten Sensor` integration. Click on the download button and restart Home Assistant once the integration is downloaded.\\n<robo-wiki-picture src=\\\"sds-hacs.png\\\"/>\\n\\n### Option 2: Manual Installation\\n\\nUnder the homeassistant user, clone the project repository:\\n\\n<code-helper copy>\\n\\n  ```shell\\n  git clone https://github.com/lichtteil/local_luftdaten.git\\n  ```\\n</code-helper>\\n\\nIf you already have any custom integrations, copy the `custom_components/local_luftdaten/` to your `custom_components` directory, For example:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/local_luftdaten ~/.homeassistant/custom_components/\\n  ```\\n</code-helper>\\nIf you don't have any custom integrations, copy the whole `custom_components` directory to your Home Assistant configuration directory. For example:\\n\\n<code-helper copy>\\n\\n  ```\\n  cd local_luftdaten\\n  mv custom_components/ ~/.homeassistant/\\n  ```\\n</code-helper>\\n\\n## Configuration\\n\\nCreate a new sensor entry in your `configuration.yaml` and adjust the host name or the ip address. To find the local ip address of you sensor you can use [Fing mobile app](https://www.fing.com/products) or [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Name can be any.\\n\\n|Parameter              |Type    | Necessity    | Description\\n|:----------------------|:-------|:------------ |:------------\\n|`host`                 | string | required     | IP address of the sensor\\n|`scan_interval`        | number | default: 180 | Frequency (in seconds) between updates\\n|`name`                 | string | required     | Name of the sensor\\n|`monitored_conditions` | list   | required     | List of the monitored sensors\\n\\n<code-helper copy>\\n\\n  ```yaml\\n  sensor:\\n    - platform: local_luftdaten\\n      host: 192.168.0.100\\n      scan_interval: 150\\n      name: Air quality sensor\\n      monitored_conditions:\\n        - SDS_P1\\n        - SDS_P2\\n        - HTU21D_temperature\\n        - HTU21D_humidity\\n        - signal\\n  ```\\n</code-helper>\\n\\n> List of all supported sensors can be found in the [repository](https://github.com/lichtteil/local_luftdaten).\\n\\nRestart you Home Assistant.\\nAfter that you can add sensor to your dashboard. Name of the entity will be the name you added to `configuration.yaml`.\\n<robo-wiki-picture src=\\\"sds-configuration-card.png\\\"/>\"}},{\"node\":{\"id\":\"7b3d8a046117381fffe21ff8d882c42a\",\"title\":\"How to Connect SDS011 Sensor\",\"path\":\"/docs/sds-sensor-connect/\",\"content\":\"\\n** Here is a step-by-step guide on how to connect your sensor to the Robonomics Sensors Network. Our sensors utilize the Robonomics firmware, which is an enhanced version of the sensor.community firmware. It includes additional sensors and has a modified data sending mechanism. **\\n\\n1. Plug in the sensor into the socket to power it.\\n2. The board will create a Wi-Fi network named `RobonomicsSensor-xxxxxxxxx`. Connect to it from your phone or computer: you will see the authorization window (if not, open the browser and go to `192.168.4.1`).\\n3. Select your Wi-Fi network from the list (or write it yourself if it's not on the list) and fill in the password field.\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"INFO\\\">\\nThe sensor can only be connected to a 2.4GHz Wi-Fi network. \\n</robo-wiki-note> \\n<robo-wiki-picture src=\\\"sds-sensor-wifi.png\\\"/>\\n4. Write the coordinates of the place, where the sensor will be installed. You can obtain them from any maps or obtain it from the address using [this link.](https://www.latlong.net/convert-address-to-lat-long.html)\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\nThe sensor coordinates will then be displayed on a publicly available map. If you do not want to show your private information, write close, but not exact coordinates.\\n</robo-wiki-note> \\n5. Click on `Save configuration and restart`. The board will reboot and connect to the specified Wi-Fi network.\\n6. Open [Robonomics sensors map](https://sensors.robonomics.network/#/) and find your place where you installed the sensor. In a couple of minutes you will be able to see your sensor with data on map.\\n<robo-wiki-picture src=\\\"sds-sensor-map.png\\\"/>\\n\\n\"}},{\"node\":{\"id\":\"9d28d8429441488738c3be3032aebbb6\",\"title\":\"How to Run Robonomics Dev Node\",\"path\":\"/docs/run-dev-node/\",\"content\":\"\\n**For testing your applications on Robonomics you may want to run it in the dev mode. This article shows step-by-step\\ninstructions how to get your own local testing instance of Robonomics.**\\n\\n\\n## Get Node Binary\\n\\n1. First, you need a binary file, download the archive with it from the latest [release](https://github.com/airalab/robonomics/releases).\\n\\n2. Navigate to the archive folder, unpack the binary and change permissions:\\n\\n```bash\\ntar xf robonomics-2.4.0-x86_64-unknown-linux-gnu.tar.gz\\nchmod +x robonomics\\n```\\n\\n## Run\\n\\nRun the node with:\\n\\n```bash\\n./robonomics --dev\\n```\\nYou will see the following output:\\n\\n![robonomics](./images/dev-node/robonomics.png)\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"From Scratch\\\">\\n\\n  If you want to purge existing blocks you may do this with removing RocksDB at `/tmp/substrate******/chains/dev/db/full`.\\n  Replace `******` with a corresponding identifier displayed in logs on launch.\\n\\n  If you want to start the node from scratch every time use `--tmp` flag.\\n\\n</robo-wiki-note>\\n\\n## Connect\\n\\nNow you can connect to your local node through the [Polkadot Portal](https://polkadot.js.org/apps/#/explorer).\\n\\nChange the network to `Local Node` in the upper left corner and press `Switch`.\\n\\n![switch](./images/dev-node/portal.png)\\n\\nWelcome to the local instance of Robonomics!\\n\\n![local_node](./images/dev-node/dev-portal.png)\\n\\n\\n\"}},{\"node\":{\"id\":\"46280e4d2286257ec5abb05b7df995bf\",\"title\":\"Robonomics Video Service\",\"path\":\"/docs/robonomics-video/\",\"content\":\"\\nThis article shows how to add an IP camera to Home Assistant and send videos to Robonomics Web Service.\\n\\nTo connect a camera to Home Assistant, you need to know its IP address and create a local camera account to connect to the RTSP stream.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nSince this is done differently for each camera, this process is not considered in this article.\\n</robo-wiki-note>\\n\\nRequirements:\\n- IP camera\\n- Configured local camera account\\n- IP address of the camera\\n- Configured Home Assistant\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nThis article assumes that you have a general IP camera without RTZ (rotate, tilt, zoom) options. \\nIf you have an RTZ camera, check [\\\"RTZ camera\\\" article](/docs/ptz-camera). And then come back to a second step here.\\n\\n</robo-wiki-note>\\n\\n## Connect the Camera\\n\\nFirst, you need to find out the URL for the RTSP stream of the camera. \\nTo do so, try entering the following query on the Internet: \\\"<CAMERA_NAME> RTSP stream\\\".\\nStream URL must start with `rtsp://<IP_Address>...`. \\n\\nThis article uses a \\\"Tapo\\\" camera and the stream path is `rtsp://<IP_Address>/stream1`.\\n\\nOpen Home Assistant and go to \\\"Settings\\\"-> \\\"Devices & Services\\\". Press the \\\"ADD INTEGRATION\\\" button and\\nstart typing \\\"Generic Camera\\\" integration. Choose it.\\n\\n <robo-wiki-picture src=\\\"home-assistant/generic.jpg\\\" />\\n\\nIn the configuration window provide the following information:\\n- Stream Source URL - The URL of camera's RTSP stream\\n- Username - write a username of your local camera account\\n- Password - write a password for your local camera account\\n\\n<robo-wiki-picture src=\\\"home-assistant/genericconf.jpg\\\" />\\n\\nScroll down the settings and press the \\\"Submit\\\" button.\\n\\nIn Preview window activate the checkbox \\\"This image looks good.\\\" and press the \\\"Submit\\\" button. Then - \\\"Finish\\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/preview-camera.jpg\\\" />\\n\\n### Add to the Dashboard\\n\\nAdditionally, you can add the stream to your dashboard. To do this, navigate to the dashboard and create a new card \\n\\\"Picture Glance\\\". Further steps:\\n- enter the \\\"Title\\\" you want\\n- delete data from \\\"Image Path\\\"\\n- select the camera in \\\"Camera Entity\\\"\\n- in the \\\"Camera View\\\", select \\\"live\\\" so that there is less delay\\n\\nAnd save it.\\n<robo-wiki-picture src=\\\"home-assistant/camera_picture_glance.jpg\\\" />\\n\\n## Check media folder\\n\\nBefore being sent to the Robonomics Video Service, the video must be saved in a folder, and Home Assistant must have access to this folder. \\nThe easiest option in this case is to use a media pack, in which the Home Assistant stores all the media.\\n\\n- If you use HAOS or Pre-installed Image your Home Assistant **already has Media folder**.\\n- If you use Home Assistant Core, you should go to `.homeassistant` folder and create `media` folder in it.\\n- If you use Home Assistant Docker, add ` -v /PATH_TO_YOUR_MEDIA:/media \\\\` line to the Docker command.\\n\\nTo check that everything was set up correctly, go to the “Media” -> “local media” tab in your Home Assistant. \\nYou should see an empty folder (no errors):\\n\\n<robo-wiki-picture src=\\\"home-assistant/media-folder.jpg\\\" />\\n\\n## Service Call\\n\\nTo send a video to Robonomics, you should call a dedicated service in Home Assistant. \\nIn this article this is done manually, but you can create an automation for it.\\n\\nTo do this, go to \\\"Developer tools\\\" -> \\\"Services\\\" and find \\\"Robonomics: Save recording to Robonomics \\\".\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-service.jpg\\\" />\\n\\nIn \\\"Targets\\\" choose your camera entity.\\nIn \\\"Path to save the recording\\\" you should provide an absolute path to the folder,\\nwhere Home Assistant can save the video:\\n- For Pre-installed image - `/home/homeassistant/.homeassistant/media`;\\n- For HA OS or Home Assistant Docker- `/media`;\\n- For Home Assistant Core - Path to previously created media folder.\\n\\nAdditionally, you can choose the recording Duration. \\n\\nFill in the data and call the service with the \\\"CALL SERVICE\\\" button.\\n\\n## DAPP\\n\\nTo view the resulted video go to [Robonomics DAPP](https://vol4tim.github.io/videostream/).\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-dapp.jpg\\\" />\\n\\nPaste in your controller's account address and click the button below. Wait for the \\\"Search for Twins\\\" process. \\nAs a result, you will get an IPFS CID with all recorded videos.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-ipfs.jpg\\\" />\\n\\nNext, select the controller account (or any other) from the drop-down list and sign a message for authorization in\\nthe Web3 IPFS gateway to download all the videos. As a result, you will obtain all the videos recorded by your smart home.\\n\\n<robo-wiki-picture src=\\\"home-assistant/show-videos.jpg\\\" />\\n\\nSince all the videos in the folder are encrypted with the controller key, you need to insert it to decrypt videos.\\nAfter that, the video playback button is activated. Click on it to download the video.\\n\\n<robo-wiki-picture src=\\\"home-assistant/video-seed.jpg\\\" />\\n\\n\\n\\n\\n\\n\\n\"}},{\"node\":{\"id\":\"5f056fe68d5b80d90ffff0af2a2df91d\",\"title\":\"Robonomics OpenGov\",\"path\":\"/docs/robonomics-opengov/\",\"content\":\"\\n## Introduction \\n\\nRobonomics has shifted the parachain's governance model to Polkadot's sophisticated OpenGov mechanism that allows the chain to evolve over time, at the ultimate behest of the token holders.\\nRobonomics' transition to OpenGov ensures that the token holder DAO, which control the majority of the stake, can always command the direction of the Robonomics parachain, enacting any change to the network that they deem suitable.\\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n  OpenGov is only applicable to the Robonomics Parachain which is a Substrate based chain connected to the Kusama Relay Chain. OpenGov is not applicable for the Robonomics Ethereum implementation, as the Ethereum mainnet does not currently support sophisticated governance systems such as OpenGov\\n</robo-wiki-note>\\n\\nOpenGov changes how the day-to-day operations and decision making are carried out on the parachain. It provides greater clarity as to the scope of referendums and has the potential to dramatically increase the throughput of decisions that are made on the parachain.\\n\\nOpenGov has been live on the Kusama relay chain for a few months at the time of writing, and has proven that it dramatically increases the number of decisions (individual & discrete referenda) that the token holder DAO can propose, vote on, and through voting – ultimately control the direction of the protocol.\\n\\n**The following content contained within this section of the wiki will go over the core principles of OpenGov on the Robonomics parachain and aims to help you better understand the concepts behind OpenGov.**\\n\\n*It is important to note that governance is a constantly evolving mechanism in the protocol, especially at the early stages of implementation.*\\n\\nFor those purely interested in the Robonomics OpenGov Track parameters, see [here](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n## About Referenda\\n\\nReferenda are simple, inclusive, and stake-based voting schemes. Each referendum has a specific proposal associated with it that takes the form of a privileged function call in the chains' runtime. This can also include the most powerful call `set_code`, which has the ability to switch out the entire code of the chains' runtime – this is unique to Substrate based chains, and removes the requirement for a \\\"hard fork\\\" of the chain when updating the chains' business logic (runtime).\\n\\nReferenda are discrete events which have a fixed voting period (more about the different periods during the lifecycle of a referendum later). Individual token holders can vote in one-of-three ways on referenda – AYE (agree/yes), NAY (disagree/no), or ABSTAIN from voting entirely.\\n\\nAll referenda have an enactment delay associated with them. This is the period between the referendum ending and, assuming the referendum was approved, the changes being enacted on the network. \\n\\n<robo-wiki-note title='Note:' type=\\\"warning\\\">\\n\\n  There is a **Minimum** Enactment Period specifically set for each different type of Origin, but the originator of a particular referendum can set that specific referendums' tasks to execute many blocks into the future\\n\\n</robo-wiki-note>\\n\\nReferenda are considered \\\"baked\\\" if it is closed and the votes are tallied. Assuming that the referendum was approved, it will be scheduled for enactment (in the chains' scheduler). Referenda are considered \\\"unbaked\\\" if the outcome is pending – such as if the referendum is still currently being voted on.\\n\\nWith the addition of OpenGov, anyone is able to start a referendum at any time, and they can do so as many times as they wish. OpenGov removes the limitation of only 1 referendum being able to be processed at a time (note that, in Gov v1, only 1 referendum can be voted on at at time. The only exception being additional emergency referendum by fast tracked Technical Committee which can also be simultaneously voted on by the community).\\n\\nOpenGov introduces several new features / concepts known as Origins and Tracks, and these are introduced to help aid in the flow and processing of referenda in the protocol.\\n\\nEach Origin is associated with a single referendum class, and each class is associated with a track. The track outlines the lifecycle for the referendum and is specific for that particular Origin from which the referendum originates. Having tracks with their own specific parameters allows the network for dynamically modify the lifecycle of referenda based on their privilege level (you can think of privilege level as being how powerful a referenda can be / what types of changes it can make to the protocol).\\n\\n*Think of Origins as the power associated with a referendum, and think of Tracks as the voting parameters associated with a referendum, such as the lengths of it's periods, and the Approval and Support criteria.*\\n\\nFor example, a runtime upgrade does not have the same implications for the protocol as a small treasury tip, and therefore different origins are needed in which different turnouts, approvals, deposits, and enactment periods (Tracks) will be predetermined in the chains' pallet.\\n\\n## Proposing a Referendum & Referendum Lifecycle \\n\\n### Preparation Period\\n\\nIn OpenGov, when a referendum is initially created, it can be immediately voted on by the token holder community. However, it is not immediately in a state where it can end, or otherwise have its votes counted, be approved and summarily enacted. Instead, referenda must fulfil a number of criteria before they are moved into the Decision Period. Until referenda enter the Decision Period, they will remain undecided – and will eventually time-out after the overall lifecycle period as specified in the individual track.\\n\\n<robo-wiki-picture src='robonomics-opengov/1.jpeg' alt=\\\"picture\\\" />\\n\\nThe criteria for a referendum to enter the Decision Period is as follows:\\n1. A Preparation Period that outlines the amount of time that must elapse before the Decision Period can begin. This Preparation Period helps to mitigate against the possibility of \\\"decision sniping\\\" whereby an attacker controlling a substantial amount of voting power might seek to use their large stake to have a referendum be passed immediately after proposing, circumventing the possibility for the other members of the token holder DAO to have adequate time to consider the referendum and participate in the vote. Hence why Origins with higher privilege levels have significantly longer Preparation Periods.\\n\\n2. There must be room for the decision. Each track has it's own limits for the amount of referenda which can be decided upon simultaneously (max_deciding). Tracks that have more powerful privilege levels will have lower limits. For example, the Root level origin will have a significantly lower amount of referendums that can be decided upon simultaneously in comparison to lower privilege level origins such as the Small Tipper origin.\\n\\n3. The Decision Deposit must be submitted. Initially creating a referendum is fairly cheap, and the value of the Submission Deposit (reserved when the referendum is initially created) is fairly low, and is mainly made up of the value it costs for the on-chain storage associated with the referendum. Decision Deposits are significantly higher, which is required in order to combat spam, and plays into the economical game which OpenGov brings, which we will go through later.\\n\\nOnce all of these three criteria above have been met, the referendum will move into the Decision Period. The votes on the referendum will then be counted towards the outcome.\\n\\n### Decision Period\\n\\n*For a quick video demonstration of the Decision Period, see [this video](https://www.youtube.com/watch?v=wk58C-2CqPI)*.\\n\\nOnce a referendum has met all of the criteria as detailed in the section above, it will enter the Decision Period.\\n\\nThe Decision Period revolves around two main concepts, that being the Approval and Support criteria. \\n\\nApproval is defined as the share of the approval vote weight (AYEs vs NAYs) compared to the total vote weight (all AYE & NAY votes combined). Conviction of each vote counts towards the overall weight of the AYE/NAY votes (more about conviction voting / voluntary lock up in a later section).\\n\\nSupport is the total number of votes (tokens) that have participated in the referendum (and does not get adjusted for conviction) compared to the total possible votes that could be made in the system (think of this as the total issuance of XRT on the parachain – notably, the total circulating supply of XRT is not the main factor here, due to the fact that some portion of that number exists on Ethereum as ERC-20 tokens).\\n\\n**Votes which are in the ABSTAIN direction do NOT contribute to the Approval criteria, but are included / count towards the Support criteria**\\n\\nA referendum must meet the Support AND Approval criteria during the Decision Period in order to progress to the Confirmation Period.\\n\\nFor details of the individual Support and Approval criteria for each track see this [spreadsheet](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n### Confirmation Period\\n\\nEach track has it's own specific duration for it's Confirmation Period. Tracks which have greater privilege levels (such as Root) have significantly longer Confirmation Periods than    those with lower privilege levels (such as Small Tipper).\\n\\nReferenda must continue to meet the Approval and Support criteria for the entire duration of the Confirmation Period, otherwise they will once again go back into the Decision Period (note: the Decision Period is not paused during the Confirmation Period, so it is entirely possible that a Decision Period may expire during the Confirmation Period, meaning that if a referendum is bumped out of the Confirmation Period due to it no longer meeting the Approval and Support criteria, it will then be considered as a failed referendum and not enacted).\\n\\n**It is possible to adjust the Approval and Support criteria for individual tracks through a referendum with Root Origin privileges.**\\n\\nOrigins with lower privilege levels have significantly easier approval and support criteria (set by the track) to be met than those with higher privilege levels. Similarly, origins with higher privilege levels have less steep curves than those with less privileges (as defined in the track), in order to ensure that the token holder DAO does indeed approve of the referendum, and avoid referendum sniping for high privilege origin referenda.\\n\\nIn OpenGov, referenda that are not approved after the Decision Period expires are considered rejected by default, and both the submission and decision deposits are refunded to their originators (note: the decision deposit can be posted by someone other than the originator of the referendum).\\n\\nIf a referendum manages to continually meet the Approval and Support criteria for the entire Confirmation Period, then it is considered approved, and will be scheduled to execute from the proposed origin, but the referendum will only execute after the minimum enactment period has elapsed.\\n\\n### Enactment Period\\n\\nThe Enactment Period is specified by the originator when the referendum is proposed, but it is subject to the Minimum Enactment Period which is specified in each track. More powerful Origins have a much higher minimum enactment period than those with less privileges. This ensures that the network has ample time to prepare for any changes that powerful referendum may impose.\\n\\n## Voluntary Locking / Conviction\\n\\nRobonomics uses a concept known as voluntary locking, or conviction voting. This allows token holders to increase their voting power by deciding for how long they are willing to lock up their tokens for a particular referendum. This mechanism only affects the Approval criteria for each referendum, and conviction voting does not affect the Support criteria.\\n\\nConviction Voting can be calculated using this formula:\\n\\n$$\\\\text{Approval Votes} = \\\\text{Tokens} * \\\\text{Conviction\\\\_Multiplier}$$\\n\\n\\nThis table shows you how each increasing level of lock-up period multiplies your vote for the approval criteria:\\n\\n| Lock Periods | Vote Multiplier | Lock Up Days |\\n|--------------|-----------------|--------------|\\n| No Lock      | 0.1x            | 0          |\\n| 1            | 1x              | 7            |\\n| 2            | 2x              | 14           |\\n| 4            | 3x              | 28           |\\n| 8            | 4x              | 56           |\\n| 16           | 5x              | 112          |\\n| 32           | 6x              | 224          |\\n\\n\\nThe maximum amount of conviction that a token holder can use is 6x conviction. You can only set conviction as per the table above, and you cannot, for example, use 5.5x conviction.\\n\\nWhile a token is locked due to voting, they can still be used to vote in other referendums, however, they will not be part of your transferrable balance (you cannot send it to another account) – and the balance will only become transferrable again once the entire lock up period has expired.\\n\\n## Vote Delegation\\n\\nIn OpenGov, a mechanism was added in order to allow tokens holders who don't necessarily have enough time to review each referendum to still have their tokens be used as part of the governance system, this is known as vote delegation.\\n\\nToken holders can choose to delegate their voting power to another voter in the system (another account). Voters can specify to delegate their voting power in an agile way, allowing them to assign their voting power to a different account for each individual Origin. Voters can also set to assign a different amount of voting power for each Origin (number of tokens and conviction level).\\n\\nThis delegation feature has one goal, to increase voter turnout, and to help to ensure that the required turnouts to meet the Approval and Support criteria are met.\\n\\nTo delegate your voting power, you can use the \\\"Delegate\\\" function which you can find on the Governance -> Referendum section of the [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/explorer). Alternatively, users can submit the convictionVoting(Delegate) extrinsic using the Developer -> Extrinsics section of the Robonomics Portal, however using the \\\"Delegate\\\" function of the referendum section of the portal is far easier.\\n\\n## Cancelling / Killing Referendum and the Governance Economic Game\\n\\nIn OpenGov, there are Origins which are dedicated to rejecting ongoing referendums, regardless of it's status. These are known as the Governance Canceller and Governance Killer tracks.\\n\\nThese Origins intervene on a referendum that is already been voted on. These Origins, if the referendum originating from them is approved, will immediately reject an ongoing referendum regardless of it's status. \\n\\nCancellation itself is a type of referendum which must be voted on by the token holders in order to be executed. Cancellation comes with its own origin and track which have a lower lead time (Decision Period, etc.), and have Approval and Support curves with a steeper/sharper curve (meaning their criteria are much easier to meet over time) than other Origins. This is due to the fact that cancellation of a referendum usually will come with a sense of urgency.\\n\\nGovernance Canceller aims to instantly reject an already ongoing referendum. When a referendum is cancelled by this origin, both the Submission and Decision Deposit are refunded to their originators. An example of when a referendum might be considered to be cancelled is if the originator has made some human-error in their referendum's contents, and hasn't necessarily tried to do anything malicious.\\n\\nGovernance Killer aims to instantly reject an already ongoing referendum. This is where the governance economic game comes into play. Origins with high privilege levels, such as Root, have a Decision Deposit which requires a high amount of capital (XRT tokens) to be posted in order for the referendum to enter the Decision Period. \\n\\nIf a malicious actor submits a referendum, such as a referendum with Root origins which aims to `set_code` of the chains' runtime to something which will stop the chain producing blocks, then the token holder DAO can raise a counter Governance Killer referendum to punish this action. If the malicious referendum is rejected via the Governance Killer origin, then both the Submission and Decision deposits are slashed, meaning that the originator (the account(s) which posted these deposits) will lose those funds. \\n\\nThis means that their is a severe economic consequence for malicious actors to attempt to raise referendum which would have severe negative impacts for the chain, which in theory will stop any malicious actor from attempting to do this.\\n\\nThe Decision Deposit for the Governance Killer track itself is quite high, this is in order to stop equally malicious actors from attempting to slash deposits of otherwise good referendum. **An existing Governance Killer referendum can be killed by a subsequent Governance Killer referendum.**\\n\\n## Robonomics Technical Committee & Whitelisted Origin\\n\\nThis group is a self-governing expert body which has the primary goal of representing humans who embody and possess the technical knowledge of the Robonomics network protocol. \\n\\nThis group (and only this group) is able to originate referenda from the Whitelist pallet. This pallet does one thing, it allows one Origin to escalate the privilege level of another Origin for a certain operation. \\n\\nThis group can authorize referendum from a origin known as Whitelisted-Root, and these referendum can be executed with Root-level privileges, but these referendum will only successfully work with certain specified commands that have been authorized by the group. The Whitelist pallet verifies two things:\\n1. The Origin really is the Whitelisted-Root (i.e. that referendum passed through this Origin's track).\\n2. The proposal has indeed been whitelisted by the group.\\n\\nIf both conditions are true, then the operation will execute with Root-level privileges.\\n\\nThis system enables the ability to have a new parallel Track (Whitelisted-Root Origin), whose parameters allow for a shorter voting turnaround (Approval and Support criteria are slightly easier to meet than Root). This open and transparent process allows this body of experts for the Robonomics Network Protocol to propose referendums that they have determined are safe, and time-critical.\\n\\nIt should be noted that the Support Criteria for referendum initiated with the Whitelisted-Root origin does not trend towards 0 like a lot of other origins/tracks. This ensures that this group does not have defacto control over the entire Robonomics Network Protocol, and requires a minimum level of Support (voter turnout) from the overall token holder DAO.\\n\\n\\n## Referendum Durations \\n\\nIt is important to understand, that the duration of each individual referendum is not a concrete thing, it is not set in stone. Some periods within the referendum's lifecycle, such as the minimum enactment period, do indeed have a concrete duration, however – others, including the decision period do not. For example, it is not accurate to add up the maximum durations for the Preparation, Decision, Confirmation, and Min. Enactment Periods and state that \\\"each referendum will take X number of days\\\", it is a lot more fluid than that.\\n\\nLet's look at this through the lens of a few separate referendums, all of which originate from the same Origin, in this case, the Root origin. \\n\\nThe Root Origin has it's own track, where the durations for each period are set, as well as the Approval and Support curves.\\n\\nIt is important to remember that Referendums will only proceed to the next stage in their lifecycle if certain conditions are met. \\n\\n<robo-wiki-picture src='robonomics-opengov/2.jpeg' alt=\\\"picture\\\" />\\n\\nYou should assume in the following images that, in order for a referendum ascend into the next stage of it's lifecycle, the conditions as described in the above image would have to have been met (unless otherwise stated).\\n\\n\\n### Maximum possible duration with very little voter turnout\\n\\nThe below image is a representation of the maximum possible timeline for a referendum, think of this as a referendum that:\\n1. Has had it's Decision Deposit posted, and therefore has gone into the Decision Period.\\n2. Has a single vote, for example, 1 XRT, in the AYE direction – this will mean that it will only meet the required Support (voter turnout) at the very end of the Decision Period (since the overall Support is extremely low), but has 100% Approval, so eventually will meet the requirements of entering the Confirmation Period.\\n3. Continues to meet the aforementioned criteria during the Confirmation Period.\\n4. The proposal raised by the referendum will be enacted exactly on the same block as the Minimum Enactment Period ends – technically the originator of referendum can set the network changes as detailed in the referendum to enact many blocks into the future, so realistically the actual lifecycle of an individual referendum could span over many days, weeks, months, or years.\\n\\n<robo-wiki-picture src='robonomics-opengov/3.jpeg' alt=\\\"picture\\\" />\\n\\nWe can see that in this example, the lifecycle of the referendum would be (approximately) 17 days.\\n\\n\\n### Duration with a lot of voter turnout (with a high amount of AYE votes)\\n\\nNow let's take a look at a referendum where the XRT token holder DAO has expressed a lot of interest. In this example, we will assume that ~248,771 XRT in overall voter turnout has occurred, and all voters are voting in the AYE direction (note: technically at this stage of a Root referendum, as per the track, only 60% of votes must be in the AYE direction for a referendum to meet the Approval criteria).\\n\\n<robo-wiki-note title=\\\"Note:\\\" type=\\\"warning\\\">\\n\\n Always consult the most up-to-date track information for accurate information in regards to each Track, more info can be found on this [spreadsheet](https://docs.google.com/spreadsheets/d/1CzUKxl5bEhLQRLC223NB81RTH4X4HgAoS1HPng23mXE/edit?usp=sharing).\\n\\n</robo-wiki-note>\\n\\nIn this example:\\n1. The Decision Deposit was posted during the Preparation Period, and therefore it was able to transition to the Decision Period at the end of the Preparation Period.\\n2. Many voters voted on this referendum – obtaining a voter turnout of ~248,771 XRT in a relatively short amount of time.\\n3. Votes were majority in the AYE direction (anything above 60% AYE).\\n4. The referendum continually meets the Confirmation Period criteria for it's entire Confirmation Period (Note: If a referendum stops to meet the criteria of the Confirmation Period, then it is bumped back to it's Decision Period).\\n5. The proposal raised by the referendum will be enacted exactly on the same block that the Minimum Enactment Period ends.\\n\\nDue to the fact that there was ~248,771 XRT turnout, the referendum will meet the criteria to enter it's Confirmation Period after ~168 hours (7 days).\\n\\n<robo-wiki-picture src='robonomics-opengov/4.jpeg' alt=\\\"picture\\\" />\\n\\nWe can see that in this second example that due to the fact that there was a good amount of voter turnout, the Decision Period actually ended halfway through it's maximum alloted time. Resulting in a referendum that can be enacted in ~10 days.\\n\\n\\n### Duration when Decision Deposit is never posted\\n\\nNow, let's take a look at a referendum that was originated, but never has it's Decision Deposit posted. Such referendums are in a sort of \\\"limbo\\\" state, where their Preparation Period has ended, but since the Decision Deposit was not posted, the referendum stays in the \\\"Preparing State\\\".\\n\\n<robo-wiki-picture src='robonomics-opengov/5.jpeg' alt=\\\"picture\\\" />\\n\\nWe can see that in this third example, due to the fact that the Decision Deposit was never posted, the referendum will actually never enter the Decision Period, instead it stays in the \\\"Preparing State\\\". This means that eventually, if no Decision Deposit is ever posted, the referendum will time out after the duration as specified in the timeOut constant of the pallet has elapsed.\\n\\nThis has happened on Kusama previously, whereby a referendum was posted with Root origins, but due to the high capital requirements to post the Decision Deposit, the referendum never entered the latter stages of it's lifecycle. Such referendum conclude with the \\\"timed out\\\" flag.\\n\\n\\n### Duration when Decision Deposit is posted late\\n\\nFinally, let's take a look at an example where the Decision Deposit was not posted for quite a while after the referendum was originated. This has happened previously on Kusama where a referendum was posted with the Root origin, but the originator had to spend time to find someone with a high amount of capital to post the Decision Deposit on their behalf.\\n\\n<robo-wiki-picture src='robonomics-opengov/6.jpeg' alt=\\\"picture\\\" />\\n\\nIn this final example, due to the fact that the Decision Deposit was posted after the Preparation Period had ended, but before the referendum has timed out – the lifecycle of the referendum is actually a lot longer than normal, as it enters the Decision Period after a longer amount of time.\\n\\nIt is important to note that the token holder DAO is able to vote AYE/NAY on referendums that are in the Preparation Period, or stuck in the \\\"Preparing State\\\".\\n\"}},{\"node\":{\"id\":\"517fd4db2d5dacbe91f138fdd1ce214d\",\"title\":\"Robonomics + Prometheus + Grafana\",\"path\":\"/docs/robonomics-prometheus-grafana/\",\"content\":\"\\n**The following instruction is provided by [Hubo Bubo](https://github.com/hubobubo)**\\n\\n**The original article is located [here](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\\n\\n## Introduction\\nTo better monitor and maintain Robonomics node(s) it's good to setup a monitoring based on Prometheus Server and Grafana. This doc will show how to configure each one of it to fully monitor your node.\\n\\n##  Prerequisites\\n* [Server Setup with Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \\n* [Robonomics parachain collator installed](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\\n* Make sure you have robonomics.service working on your machine and port 9615 is reachable \\n\\n## Step 1 — Creating Service Users\\n\\nFor security purposes, we’ll begin by creating two new user accounts, prometheus and node_exporter. Create these two users, and use the _--no-create-home_ and _--shell /bin/false_ options so that these users can’t log into the server.\\n```\\nsudo useradd --no-create-home --shell /bin/false prometheus\\nsudo useradd --no-create-home --shell /bin/false node_exporter\\n```\\n\\nBefore we download the Prometheus binaries, create the necessary directories for storing Prometheus’ files and data. Following standard Linux conventions, we’ll create a directory in _/etc_ for Prometheus’ configuration files and a directory in _/var/lib_ for its data.\\n```\\nsudo mkdir /etc/prometheus\\nsudo mkdir /var/lib/prometheus\\n```\\nNow, set the user and group ownership on the new directories to the prometheus user.\\n```\\nsudo chown prometheus:prometheus /etc/prometheus\\nsudo chown prometheus:prometheus /var/lib/prometheus\\n```\\n## Step 2 — Downloading Prometheus\\n\\nFirst, download and unpack the current stable version of Prometheus into your home directory. You can find the latest binaries on the [Prometheus download page.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nNow, unpack the downloaded archive.\\n\\n```\\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\\n\\n```\\nThis will create a directory called prometheus-2.21.0.linux-amd64 containing two binary files (prometheus and promtool), _consoles_ and _console_libraries_ directories containing the web interface files, a license, a notice, and several example files.\\n\\nCopy the two binaries to the _/usr/local/bin_ directory.\\n\\n```\\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\\n\\n```\\nSet the user and group ownership on the binaries to the prometheus user created in Step 1.\\n\\n```\\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\\nsudo chown prometheus:prometheus /usr/local/bin/promtool\\n\\n```\\nCopy the consoles and _console_libraries_ directories to _/etc/prometheus_.\\n\\n```\\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\\n\\n```\\nSet the user and group ownership on the directories to the prometheus user. Using the -R flag will ensure that ownership is set on the files inside the directory as well.\\n\\n```\\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\\n\\n```\\nNow that Prometheus is installed, we’ll create its configuration and service files in preparation of its first run.\\n\\n## Step 3 — Configuring Prometheus\\n\\nIn the _/etc/prometheus_ directory, use nano or your favorite text editor to create a configuration file named _prometheus.yml_.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nIn the global settings, define the default interval for scraping metrics. Note that Prometheus will apply these settings to every exporter unless an individual exporter’s own settings override the globals.\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\n```\\nThis scrape_interval value tells Prometheus to collect metrics from its exporters every 15 seconds, which is long enough for most exporters.\\nNow, add Prometheus itself to the list of exporters to scrape from with the following scrape_configs directive:\\n\\n```\\n...\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nPrometheus uses the _job_name_ to label exporters in queries and on graphs, so be sure to pick something descriptive here.\\n\\nAnd, as Prometheus exports important data about itself that you can use for monitoring performance and debugging, we’ve overridden the global scrape_interval directive from 15 seconds to 5 seconds for more frequent updates.\\n\\nLastly, Prometheus uses the _static_configs_ and _targets_ directives to determine where exporters are running. Since this particular exporter is running on the same server as Prometheus itself, we can use localhost instead of an IP address along with the default port, 9090.\\n\\nYour configuration file should now look like this:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n```\\nSave the file and exit your text editor.\\n\\nNow, set the user and group ownership on the configuration file to the prometheus user created in Step 1.\\n\\n```\\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\\n\\n```\\nWith the configuration complete, we’re ready to test Prometheus by running it for the first time.\\n\\n## Step 4 — Running Prometheus\\n\\nStart up Prometheus as the _prometheus_ user, providing the path to both the configuration file and the data directory.\\n\\n```\\nsudo -u prometheus /usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nThe output contains information about Prometheus’ loading progress, configuration file, and related services. It also confirms that Prometheus is listening on port _9090_.\\n\\n```\\n_log output_\\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\\\"No time or size retention was set so using the default time retention\\\" duration=15d\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\\\"Starting Prometheus\\\" version=\\\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\\\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\\\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\\\"(soft=1024, hard=4096)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\\\"(soft=unlimited, hard=unlimited)\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\\\"Starting TSDB ...\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\\\"Replaying on-disk memory mappable chunks if any\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\\\"On-disk memory mappable chunks replay completed\\\" duration=12.659µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\\\"Replaying WAL, this may take a while\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=0 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\\\"WAL segment loaded\\\" segment=1 maxSegment=1\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\\\"WAL replay completed\\\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\\\"TSDB started\\\"\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\\\"Loading configuration file\\\" filename=/etc/prometheus/prometheus.yml\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\\\"Completed loading of configuration file\\\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\\\"Server is ready to receive web requests.\\\"\\n```\\nIf you get an error message, double-check that you’ve used YAML syntax in your configuration file and then follow the on-screen instructions to resolve the problem.\\n\\nNow, halt Prometheus by pressing _CTRL+C_, and then open a new _systemd_ service file.\\n\\n```\\nsudo nano /etc/systemd/system/prometheus.service\\n\\n```\\nThe service file tells _systemd_ to run Prometheus as the prometheus user, with the configuration file located in the _/etc/prometheus/prometheus.yml_ directory and to store its data in the _/var/lib/prometheus_ directory.Copy the following content into the file:\\n\\n```\\n[Unit]\\nDescription=Prometheus\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=prometheus\\nGroup=prometheus\\nType=simple\\nExecStart=/usr/local/bin/prometheus \\\\\\n    --config.file /etc/prometheus/prometheus.yml \\\\\\n    --storage.tsdb.path /var/lib/prometheus/ \\\\\\n    --web.console.templates=/etc/prometheus/consoles \\\\\\n    --web.console.libraries=/etc/prometheus/console_libraries\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nFinally, save the file and close your text editor. To use the newly created service, reload systemd.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nYou can now start Prometheus using the following command:\\n\\n```\\nsudo systemctl start prometheus\\n\\n```\\nTo make sure Prometheus is running, check the service’s status.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nThe output tells you Prometheus’ status, main process identifier (PID), memory use, and more.\\n\\nIf the service’s status isn’t active, follow the on-screen instructions and re-trace the preceding steps to resolve the problem before continuing the tutorial.\\n\\n```\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\\n Main PID: 29650 (prometheus)\\n    Tasks: 9 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nWhen you’re ready to move on, press _Q_ to quit the status command. Lastly, enable the service to start on boot.\\n\\n```\\nsudo systemctl enable prometheus\\n\\n```\\n\\nNow that Prometheus is up and running, we can install an additional exporter to generate metrics about our server’s resources.\\n\\n## Step 5 — Downloading Node Exporter\\n\\nTo expand Prometheus beyond metrics about itself only, we’ll install an additional exporter called Node Exporter. Node Exporter provides detailed information about the system, including CPU, disk, and memory usage. Download the current stable version of Node Exporter into your home directory. You can find the latest binaries on [Prometheus download page.](https://prometheus.io/download/)\\n\\n```\\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nNow, unpack the downloaded archive.\\n\\n```\\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\\n\\n```\\nThis will create a directory called _node_exporter-1.0.1.linux-amd64_ containing a binary file named _node_exporter_, a license, and a notice.\\n\\nCopy the binary to the _/usr/local/bin_ directory and set the user and group ownership to the node_exporter user that you created in Step 1.\\n\\n```\\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\\n\\n```\\nNow that you’ve installed Node Exporter, let’s test it out by running it before creating a service file for it so that it starts on boot.\\n\\n## Step 6 — Running Node Exporter\\n\\nThe steps for running Node Exporter are similar to those for running Prometheus itself. Start by creating the Systemd service file for Node Exporter.\\n\\n```\\nsudo nano /etc/systemd/system/node_exporter.service\\n\\n```\\nCopy the following content into the service file:\\n\\n```\\n[Unit]\\nDescription=Node Exporter\\nWants=network-online.target\\nAfter=network-online.target\\n\\n[Service]\\nUser=node_exporter\\nGroup=node_exporter\\nType=simple\\nExecStart=/usr/local/bin/node_exporter --collector.systemd\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nSave the file and close your text editor. Finally, reload systemd to use the newly created service.\\n\\n```\\nsudo systemctl daemon-reload\\n\\n```\\nYou can now run Node Exporter using the following command:\\n\\n```\\nsudo systemctl start node_exporter\\n\\n```\\nVerify that Node Exporter’s running correctly with the status command.\\n\\n```\\nsudo systemctl status node_exporter\\n\\n```\\nLike before, this output tells you Node Exporter’s status, main process identifier (PID), memory usage, and more. If the service’s status isn’t active, follow the on-screen messages and re-trace the preceding steps to resolve the problem before continuing.\\n\\n```\\n_Output_\\n* node_exporter.service - Node Exporter\\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\\n Main PID: 29612 (node_exporter)\\n    Tasks: 7 (limit: 4915)\\n   CGroup: /system.slice/node_exporter.service\\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\\n```\\nLastly, enable Node Exporter to start on boot.\\n\\n```\\nsudo systemctl enable node_exporter\\n\\n```\\nWith Node Exporter fully configured and running as expected, we’ll tell Prometheus to start scraping the new metrics.\\n\\n## Step 7 — Configuring Prometheus to Scrape Node Exporter\\n\\nBecause Prometheus only scrapes exporters which are defined in the scrape_configs portion of its configuration file, we’ll need to add an entry for Node Exporter, just like we did for Prometheus itself. Open the configuration file.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nAt the end of the scrape_configs block, add a new entry called node_exporter.\\n\\n```\\n...\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nBecause this exporter is also running on the same server as Prometheus itself, we can use localhost instead of an IP address again along with Node Exporter’s default port, 9100. Your whole configuration file should look like this:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n```\\nSave the file and exit your text editor when you’re ready to continue. Finally, restart Prometheus to put the changes into effect.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nOnce again, verify that everything is running correctly with the status command.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nIf the service’s status isn’t set to active, follow the on screen instructions and re-trace your previous steps before moving on.\\n\\n```\\nOutput\\n* prometheus.service - Prometheus\\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\\n Main PID: 19725 (prometheus)\\n    Tasks: 8 (limit: 4915)\\n   CGroup: /system.slice/prometheus.service\\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\\n```\\n\\nWe now have Prometheus and Node Exporter installed, configured, and running.\\n\\n## Step 8 - Adding Robonomic build in node_exporter\\n\\nAfter successfully installed Prometheus and node_exporter we will have to use build in prometheus exporter in every substrate project. To make this happen we have to add additional entry to _/etc/prometheus/prometheus.yml_. \\nOpen the configuration file.\\n\\n```\\nsudo nano /etc/prometheus/prometheus.yml\\n\\n```\\nAt the end of the scrape_configs block, add a new entry called robonomic_exporter.\\n\\n``` \\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\nSave the file and exit your text editor. Your whole configuration file should look like this:\\n\\n```\\nglobal:\\n  scrape_interval: 15s\\n\\nscrape_configs:\\n  - job_name: 'prometheus'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9090']\\n  - job_name: 'node_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9100']\\n  - job_name: 'robonomics_exporter'\\n    scrape_interval: 5s\\n    static_configs:\\n      - targets: ['localhost:9615']\\n```\\n\\nFinally, restart Prometheus to put the changes into effect.\\n\\n```\\nsudo systemctl restart prometheus\\n\\n```\\nOnce again, verify that everything is running correctly with the status command.\\n\\n```\\nsudo systemctl status prometheus\\n\\n```\\nWe now have _Prometheus_ and _Node Exporter_ as well as _Robonomic Exporter_ installed, configured, and running. Now move on to Grafana\\n\\n## Step 9 - Setting up Grafana\\n\\nThe last step is to connect Prometheus as a Data Source in Grafana. For purpose of this tutorial we will use free cloud-based grafana which allow to have up to 5 dashboards as well as dedicated [Robonomics dashboard](https://grafana.com/grafana/dashboards/13015). Simply go to [grafana.com](https://grafana.com/) create new account and login to your newly created grafana instance.\\n\\nAt the beginning we must add to Grafana new _**Data Source**_ which in our case will be Prometheus server.\\nGo to Data Source:\\n\\n>![DataSource](./images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\\n\\nThen click **_Add data source_**\\n\\n>![DataSource](./images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\\n\\nNext select _**Prometheus**_\\n\\n>![DataSource](./images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\\n\\nIn new screen put your **_Prometheus server IP adress with 9090 port_**\\n\\n> ![DataSource](./images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\\n\\nAfter that _**Save & Test**_ if you did all steps you should be green and ready to go for importing dashboard. On the main site click to **+** and then **Import** as shown on the pic below:\\n\\n> ![Import dashboard](./images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\\n\\nThen you should see Import page:\\n\\n> ![Import page](./images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\\n\\nIn the _Grafana.com dashboard url or id_ write _**13015**_ (as this is ID of the Robonomic dashboard)\\n\\n> ![Import Robonomic dashboard](./images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\\n\\nAfter loading external dashboard you will get this screen:\\n\\n> ![XRT 13015 dashboard import](./images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\\n\\nThe last step is to choose previously created **_Data Source_** and click _**Import**_\\n\\n> ![Prometheus as a DataSource](./images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\\n\\nTHAT'S IT ! At this point you should see imported dashboard. \\n\\n\\n## References\\n\\n* [How To Install Prometheus on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\\n* [Build A Monitoring Dashboard by Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\\n* [Grafana support for Prometheus](https://prometheus.io/docs/visualization/grafana/)\\n* [Monitoring Linux host metrics with the node exporter](https://prometheus.io/docs/guides/node-exporter/)\\n* [Querying Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\\n* [Visualizing Node Metrics](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\\n* [Polkadot node metric](https://grafana.com/grafana/dashboards/12425)\\n* [Node Exporter for Prometheus Dashboard](https://grafana.com/grafana/dashboards/11074)\\n* [Grafana ROBONOMICS (XRT) Metrics](https://grafana.com/grafana/dashboards/13015)\\n\\n\"}},{\"node\":{\"id\":\"30f4215c9d7d0ade3a7831b264a2abe3\",\"title\":\"Robonomics Smart Home Overview\",\"path\":\"/docs/robonomics-smart-home-overview/\",\"content\":\"\\n## Secure IoT with Blockchain \\n\\nFor your smart home, the modern IoT market provides a wide range of solutions. But you are usually tied to centralized cloud providers or expensive proprietary gateways. As a result, you as a user are always dependent on the hardware and infrastructure vendor to run your smart system. At the same time, your smart home cannot be truly smart without cloud statistics and analytics.\\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}, {src: 'https://crustipfs.info/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}]\\\"  cover=\\\"covers/cover-3.png\\\" />\\n\\n**We see two main problems with current smart homes:**\\n\\n1. You have no control over what data you share with the vendor or third party.\\n2. Your smart home is vulnerable to shutdowns of centralized cloud servers. \\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-problems.png\\\" />\\n\\nTo solve both problems, we suggest you to try Robonomics, our **secure**, **serverless** and **futuristic** decentralized cloud.\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha-robonomics.png\\\" />\\n\\n## Steps to corporate-free cloud\\n\\nHere are some simple steps to create an affordable smart home using Home Assistant as a device communication application and Robonomics as a corporate-free, decentralized cloud platform. Robonomics leverages modern and secure Web3 technologies, ensuring enhanced security throughout the process.\\n\\n<robo-wiki-picture src=\\\"home-assistant/robonomics-secure-blockchain-smart-home_3.png\\\" />\\n\\n## Start here your smart home\\n\\nWe have prepared detailed guides on setting up a smart home on Robonomics. The steps may vary depending on your specific situation: whether you already have an operational Home Assistant with paired devices, or if you are starting from scratch to establish your smart home.\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\" flexible>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/sub-activate/?topic=Upgrade Home Assistant OS\\\" label=\\\"For Home Assistant users\\\" block />\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-button link=\\\"/docs/hass-image-install\\\" label=\\\"For new users\\\" block />\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\"}},{\"node\":{\"id\":\"e12c829cdc7ea4bd0ca4b05f3cc6919a\",\"title\":\"Robonomics integration setup\",\"path\":\"/docs/robonomics-hass-integration/\",\"content\":\"\\n**In this article, you will add Robonomics to Home Assistant. This allows Home Assistant to record datalogs with encrypted data to Robonomics Parachain and listen to launch commands from the parachain to control smart devices. Integration uses IPFS to store data and send IPFS hashes to datalog or launch functions.**\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmQp66J943zbF6iFdkKQpBikSbm9jV9La25bivKd7cz6fD', type:'mp4'}]\\\" />\\n\\n1. In the web interface of Home Assistant go to `Settings` -> `Device & Services` and press `ADD INTEGRATION`. Search for `Robonomics`.\\n\\n2. Click on Robonomics and fill in the configuration: \\n\\n- Add seed from the `SUB_CONTROLLER` account to controller account seed.\\n- Add the public address of the `SUB_OWNER` account to the subscription owner address.\\n- Set the interval of data sending (by default it is 10 minutes).\\n- (Optional) You can add credentials for pinning service Pinata or other custom gateway to spread your data wider over the IPFS network.\\n\\n3. Press `SUBMIT` after finishing the configuration. If you filled in everything correctly, you will see the success window.\\n\\nThat's all! You have fully setup Robonomics Integration into Home Assistant. Now you can use all \\nRobonomics Web Services. To find out more about them, go to [\\\"Use\\\" section](/docs/global-administration).\\n\"}},{\"node\":{\"id\":\"a98df1be40f5c33942e2f0ab0a3482ce\",\"title\":\"Robonomics on Ethereum\",\"path\":\"/docs/robonomics-ethereum/\",\"content\":\"\\nAll information about robonomics on ethereum moved to GitHub repository. All necessary information could be [found here.](https://github.com/airalab/Robonomics_on_Ethereum_Wiki)\"}},{\"node\":{\"id\":\"6f9bac97e1e87005049e99935929e129\",\"title\":\"PTZ camera control in Home Assistant\",\"path\":\"/docs/ptz-camera/\",\"content\":\"\\nThis article covers a process of an PTZ camera set up in Home Assistant. \\nONVIF protocol will be used. This requires a local camera account.\\n\\n<robo-wiki-note type=\\\"warning\\\">\\nThe process of setting up the local camera account is not covered in this article.\\n</robo-wiki-note>\\n\\nRequirements:\\n- PTZ camera\\n- Local camera account\\n- Camera IP address\\n- Configured Home Assistant\\n\\n## ONVIF integration\\n\\nLet's start with the installation of **ONVIF integration**. \\n\\nGo to \\\"Devices & Services\\\" in \\\"Settings\\\" and press the \\\"ADD INTEGRATION\\\" button.\\nType \\\"ONVIF\\\" and choose the integration. You will see the next window.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifsetup.jpg\\\" />\\n\\nPress the \\\"Submit\\\" button. It will try to automatically search for your camera. If succeeded, \\nchoose your camera from the list and fill in empty fields. \\nOtherwise, you have to fill in all the fields manually. You will see the following window.\\n\\n <robo-wiki-picture src=\\\"home-assistant/onvifconfig.jpg\\\" />\\n\\nFill in the gaps:\\n- Name - give a name to your camera\\n- Host - provide The IP address of your camera\\n- Port - mostly common it's 2020, but your camera provider may change it\\n- Username - write a username of your camera local account\\n  - Password - write a password for your camera local account\\n\\nand press \\\"Submit\\\". Choose an Area for your camera and click on \\\"Finish\\\".\\n\\n## Add camera control to the dashboard\\n\\nNow that you have fully set up the camera, you may add its stream and control buttons to the dashboard.\\n\\nGo to the dashboard and start with creating a new card. Choose the \\\"Picture Glance\\\" one.\\n\\n <robo-wiki-picture src=\\\"home-assistant/glance.jpg\\\" />\\n\\nFill in the data:\\n- Title - choose camera image title\\n- Camera Entity - choose a camera entity from the drop-down list\\n- Camera View - choose \\\"live\\\" to get less delay\\n\\nNext, switch to \\\"Code Editor\\\" mode by pressing the button at the bottom left side. You will see the following code:\\n```shell\\ncamera_view: live\\ntype: picture-glance\\ntitle: Kitchen\\nimage: https://demo.home-assistant.io/stub_config/kitchen.png\\nentities: []\\ncamera_image: camera.tapo_mainstream\\n```\\n\\nReplace the content of `entities: []` according to the example below (`<YOUR_CAMERA_ENTITY>` is the same as the `camera_image` parameter):\\n\\n<code-helper copy>\\n\\n```\\nentities:\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: LEFT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Left\\n    show_state: false\\n    icon: 'mdi:arrow-left'\\n    show_icon: true\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: UP\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Up\\n    icon: 'mdi:arrow-up'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        tilt: DOWN\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Tilt Down\\n    icon: 'mdi:arrow-down'\\n  - entity: <YOUR_CAMERA_ENTITY>\\n    tap_action:\\n      action: call-service\\n      service: onvif.ptz\\n      service_data:\\n        entity_id: <YOUR_CAMERA_ENTITY>\\n        pan: RIGHT\\n        speed: 1\\n        distance: 0.3\\n        move_mode: ContinuousMove\\n    name: Pan Right\\n    icon: 'mdi:arrow-right'\\n    show_icon: true\\n```\\n\\n</code-helper>\\n\\nThat's all. Now you should see the PTZ camera card on the dashboard along with control buttons.\\n\\n## Troubleshooting\\nIf you are using Home Assistant Core and you don't see a stream from the camera, you should install \\\"stream\\\" and \\\"FFMPEG\\\" integrations. \\nTo do this, you should add `stream: `  and `ffmpeg: ` strings to the end of configuration.yaml.\"}},{\"node\":{\"id\":\"2a669f5338ceb2a3e5f8d74959d53372\",\"title\":\"Python interface and Robonomics IO\",\"path\":\"/docs/rinterface/\",\"content\":\"\\n**Some extrinsics implemented in Robonomics pallets are hard to be submitted from the Polkadot app. More that, there is \\na need to interact with this functionality using programming languages. For this purpose a simple Python tool was developed\\ncalled [robonomics-interface](https://github.com/Multi-Agent-io/robonomics-interface). It's a wrapper over polkascan-maintained \\n[py-substrate-interface](https://github.com/polkascan/py-substrate-interface). Below is a brief description of this package\\nand some useful links and examples. Also, CLI tools is discussed.**\\n\\n## robonomics-interface\\n\\nAvailable on [PyPi](https://pypi.org/project/robonomics-interface/) package is ready to download and set up.\\nThere is a detailed docstring-generated [documentation](https://multi-agent-io.github.io/robonomics-interface/) available as well.\\n\\nAll in all, this is a tool for developers who wish to interact with Robonomics blockchain via programming tools. Almost \\nall the Python projects of Robonomics team which interact with the parachain use this interface.\\n\\n### Installation\\n\\nThe installation process requires user to have at least Python 3.8 installed. Neither `x86`, nor `arm7`, nor `arm8`\\narchitectures require compilation process. All the wheels are built and published by dependencies maintainers.\\n\\n`pip` is used as an installation tool:\\n\\n```bash\\n$ pip3 install robonomics_interface\\n```\\n\\n### Sample use\\n\\nThe main idea is to create an `Account` instance and then use it to create pallet-dedicated instances.\\n\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account()\\ndatalog_ = Datalog(account)\\ndatalog_.get_item(addr=\\\"4G1V6yyvrkd3Z57H1giUky8RTRX3SZieRvuDpQzK4knNRy5R\\\",index=2)\\n\\n>>> (1657226418528, 'blah')\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Local node\\\">\\n\\n  It is also possible to use custom endpoints (e.g. local node for testing):\\n\\n  ```python\\n  account = Account(remote_ws=\\\"ws://127.0.0.1:9944\\\")\\n  ```\\n\\n</robo-wiki-note>\\n\\nExtrinsics are also possible to submit:\\n\\n```python\\nfrom robonomicsinterface import Account, Datalog\\naccount = Account(seed=\\\"one two three four five six seven eight nine ten eleven twelve\\\")\\ndatalog_ = Datalog(account)\\ndatalog_.record(\\\"Hello, Robonomics!\\\")\\n\\n>>> 0xb2f742b6164ffc14b75a21188b37287c2416e6617635805e0a77db12773f6068  # this is an extrinsic hash\\n```\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Docs\\\">\\n\\n  As have been said, more examples are available on the [documentation](https://multi-agent-io.github.io/robonomics-interface/) page.\\n\\n</robo-wiki-note>\\n\\n## CLI tool\\n\\n`robonomics-interface` also contains a Python `click` CLI tools to use for purposes of prototyping and quick tests. It is installed\\nwith the package and available in the Terminal:\\n\\n```bash\\n$ robomomics_interface --help\\n\\n#Usage: robonomics_interface [OPTIONS] COMMAND [ARGS]...\\n#\\n#Options:\\n#  --help  Show this message and exit.\\n#\\n#Commands:\\n#  read   Subscribe to datalog/launch events in the chain\\n#  write  Send various extrinsics (launch commands or record datalogs)\\n```\\n\\nYou may try to use it with local node. Pipeline philosophy is adopted:\\n\\n```bash\\n$ echo \\\"Hello, Robonomics!\\\" | robonomics_interface write datalog -s \\\"//Alice\\\" --remote_ws \\\"ws://127.0.0.1:9944\\\"\\n\\n#0x22dbac7d25d2ee67c7d985f074163f674c8c9b4c554e545ca4c7186307e9023c  # this is an extrinsic hash\\n```\"}},{\"node\":{\"id\":\"f60e2642a26264299ba111d9f49a07d5\",\"title\":\"Robonomics Smart Home\",\"path\":\"/docs/notifications/\",\"content\":\"\\nYou can receive notifications on your smartphone with [notify](https://notify.events/). Girstly register there and on `Control Panel` create new channel:\\n\\n![control_panel](./images/home-assistant/not_control_panel.png)\\n\\nAdd title and press `Save`:\\n\\n![channel](./images/home-assistant/not_create_chanell.png)\\n\\nThen press `Add Source` and choose `Home Assistant` in `IoT and Smart Home` tab:\\n\\n![source](./images/home-assistant/not_add_source.png)\\n\\nWrite title and press `Next`:\\n\\n![source_next](./images/home-assistant/not_add_source_next.png)\\n\\nThere you will see the token which you need to add to your configuration file for home Assistant. Save it somewhere and press `Done`:\\n\\n![token](./images/home-assistant/not_token.png)\\n\\nthen press `Subscribe` to add subscribers:\\n\\n![subscribe](./images/home-assistant/not_subscribe.png)\\n\\nChoose whatever subscriber you want and follow the instructions.\\n\\nNow you need to edit configuration on your computer with Home Assistant. Under `homeassistant` user open `configuration.yaml` file:\\n\\n```bash\\nsudo -u homeassistant -H -s\\nnano ~/.homeassistant/configuration.yaml\\n```\\n\\nAnd add theese lines:\\n\\n```yaml\\nnotify_events:\\n    token: <your token from notify>\\n```\\nAlso add new automation after `automation:` line:\\n```yaml\\n- alias: notifications\\n  trigger:\\n  - entity_id: binary_sensor.contact_sensor_contact\\n    platform: state\\n    from: 'off'\\n    to: 'on'\\n  action:\\n  - service: notify.notify\\n    data:\\n      message: Door was changed to {{ states(\\\"binary_sensor.contact_sensor_contact\\\") }}\\n```\\nThis automation will send message `Door was changed to on/off` after sensor with entity id `binary_sensor.contact_sensor_contact` change state from `off` to `on`.\\n\\nAnd restart Home Assistant:\\n```bash\\nsystemctl restart home-assistant@homeassistant.service\\n```\"}},{\"node\":{\"id\":\"f52ebfe9b47062f648d7a7f3cb033f45\",\"title\":\"Launch\",\"path\":\"/docs/launch/\",\"content\":\"\\n**Another basic feature of Robonomics parachain is the Launch pallet. It allows you to send commands to the accounts/any entities behind them. These commands include parameter to specify the task to be executed.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Please pay attention that this and following tutorials are demonstrated on a local instance of Robonomics Node. Set up yours with [these instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navigate to Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"launch/extrinsics.jpg\\\" />\\n\\n## 2. Choose launch -> launch from the dropdown list of possible extrinsics\\n\\nAlso choose an account you want to submit the extrinsic with. Fill in the target address and the parameter field.\\n\\n<robo-wiki-picture src=\\\"launch/launch.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  Launch supports 32 bytes long strings as commands ([source](https://polkascan.github.io/py-scale-codec/types.html#scalecodec.types.H256)),\\n  so there is a room to improvise here:\\n  - For basic commands like toggling you may use \\\"0x0000000000000000000000000000000000000000000000000000000000000001\\\" or\\n  \\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\".\\n  - For advanced commands including json-like you may use [IPFS](https://ipfs.tech/) CID formatted in a \\n  [proper way](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n\\n</robo-wiki-note>\\n\\n## 3. Submit transaction\\n\\n<robo-wiki-picture src=\\\"launch/submit.jpg\\\" />\\n\\n## 4. Review your launch in the events\\n\\nFor this, navigate to *Network -> Explorer* and find a list of events on the right. Click a triangle icon to expand.\\n\\n<robo-wiki-picture src=\\\"launch/event.jpg\\\" />\\n\"}},{\"node\":{\"id\":\"3cee4bdd78b62d9dbaf0d6715e60335c\",\"title\":\"Liability\",\"path\":\"/docs/liability/\",\"content\":\"\\n**To turn robots into economic agents one needs a contract tool for this. Meet Liability - Robonomics pallet implementing\\ncontracts between parachain accounts!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Please pay attention that this tutorial is demonstrated on a local instance of Robonomics Node. Set up yours with [these instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Theory Overview\\n\\nBack on the Ethereum there was quite a complicated structure of liability interaction. You can get acquainted with it \\n[here](/docs/robonomics-how-it-works). Nowadays things are a bit easier with Kusama!\\n\\n### Negotiations\\n\\nTo sign a contract the two sides need to negotiate first. This may be done several ways, including \\n[IPFS PubSub ](https://blog.ipfs.tech/25-pubsub/) or Robonomics PubSub. A sample of Python code using Robonomics PubSub is \\npresented [here](https://multi-agent-io.github.io/robonomics-interface/usage.html#pubsub). \\n\\nOffer and demand are messages containing two main characteristics of a contract: **job description** and **price**. Message\\nformat is to be designed by user for each specific application. It is not that important in the negotiations process to follow\\na strict format rule. The possible flow is presented in the picture below.\\n\\n<robo-wiki-picture src=\\\"liability/negotiations.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"PubSub\\\">\\n\\n  Note that PubSub is an open protocol, so no sensible data should be transferred. For this you should use other protocols.\\n\\n</robo-wiki-note>\\n\\n\\n### Signatures\\n\\nWhen negotiations are successfully over, each side needs to sign its so-called agreement named a signature. This is a \\nmessage containing job description and price **in a specific format** signed with a private key of the account. There is a \\n[Python tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_liability) for that as well.\\n - Job description is called **technics**. This is a launch-like 32 bytes long string which may be an encoded IPFS CID.\\n - Price is called **economics**. This is an XRT decimal - Weiner. 1 Weiner = 10**-9 XRT.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"32 bytes\\\">\\n\\n  One may obtain an [IPFS](https://ipfs.tech/) CID formatted in a proper way with the [Python library](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes).\\n  When using the `sign_liability` function, no need to transform the hash, it will be done automatically.\\n\\n</robo-wiki-note>\\n\\nFollowing the coffee example:\\n\\n1. The task is a JSON\\n```json\\n{\\\"task\\\": \\\"make_espresso\\\", \\\"description\\\": \\\"Make one cup of espresso\\\"}\\n```\\n2. Its IPFS CID is `QmP17mWKtQtq2Gq6qZAggPRrho3sVjQGBpXZ8KZiQ57FDi`\\n3. So the **technics** (transformed CID) is `0x09daaa8055722a6894951b1273e807f8a46628efeec46805f0228ace230bd5a9` \\n4. **Economics** is `1.5 XRT`.\\n\\nWhen signed, it's time to create a liability! This may be done by one of the sides (either promisee or promisor) or by a \\n3rd-party account of a so-called provider.\\n\\n## Create Liability\\n\\n### Preparations\\n\\nAs have been mentioned earlier, at least two sides are involved in the process. For this example, let's use three and make\\na separated provider for this. Assume that the negotiations took place somehow already.\\n\\n### 1. Create three accounts and add funds to them\\n\\n<robo-wiki-picture src=\\\"liability/balances.jpg\\\" />\\n\\nHere we have supplied the provider with 100 XRT to sign liability extrinsics, promisee was given 2 XRT to pay for the work.\\nPromisor wasn't granted any funds (except for an existential deposit of at least 1 mXRT).\\n\\n### 1. Navigate to Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"liability/extrinsics.jpg\\\" />\\n\\n### 2. Choose liability -> create from the dropdown list of possible extrinsics\\n\\nAlso choose an account you want to submit the extrinsic with. Fill in all the parameters.\\n\\n<robo-wiki-picture src=\\\"liability/create.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Signatures\\\">\\n\\n  Since provider is used here, no need to know seeds of the participants. Only their signatures needed.\\n\\n</robo-wiki-note>\\n\\n### 3. Submit transaction\\n\\n<robo-wiki-picture src=\\\"liability/submit.jpg\\\" />\\n\\n### 4. Review your liability in the events\\n\\nFor this, navigate to `Network -> Explorer` and find a list of events on the right. Click a triangle icon to expand.\\n\\n<robo-wiki-picture src=\\\"liability/new-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Hash\\\">\\n\\n  The hash may be transformed to an IPFS CID with the same \\n  [Python tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_32_bytes_to_qm_hash).\\n\\n</robo-wiki-note>\\n\\n### 5. Storage exploring\\n\\nYou may also explore some characteristics of the liabilities in storage module `liability`.\\n\\n<robo-wiki-picture src=\\\"liability/storage-liability.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Next Index\\\">\\n\\n  The `Next Index` storage function shows the latest liability index +1, so even though it's `1`, liability `0` is explored.\\n\\n</robo-wiki-note>\\n\\n## Reports\\n\\nImage that a coffee has been made and now the coffee machine needs to report it somehow. That's where liability reports\\ncome into scene. As a proof of labour the account adds another IPFS CID as a report content when finalizing the existing\\nliability. This again requires a signature of the promisor.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Report signature\\\">\\n\\n  Message signed contains of the existing liability index and the report IPFS CID encoded in 32 bytes representation. Once again,\\n  the [Python tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.Liability.sign_report) can help to sign the report.\\n\\n</robo-wiki-note>\\n\\nKeeping with the coffee machine example:\\n\\n1. Report is a JSON\\n```json\\n{\\\"report\\\": \\\"Coffee made! Time to execute - 80 seconds.\\\"}\\n```\\n2. Its IPFS CID is `QmeXCrBuv6cw825JJfSWqNVv28AyjJZW9KReN9wcLQjfCm`\\n3. So the **payload** (transformed CID) is `0xf06f2394f55537a5f37d63fd72bfbef50e9f60ea9e0e34224e455afae27a97a2` \\n4. **Index** is `0` it's the existing liability index.\\n\\n### 1. Navigate to extrinsics, liability -> finalize(report)\\n\\nFill in the parameters and submit extrinsic. Again, this may be done by a 3rd-party account. \\n\\n<robo-wiki-picture src=\\\"liability/report.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Existential deposit\\\">\\n\\n  Pay attention that the promisor account should not be \\\"dead\\\" - it should have the existential deposit of at least 1 mXRT.\\n\\n</robo-wiki-note>\\n\\nSign and submit the report. When done, you can explore it in the events.\\n\\n<robo-wiki-picture src=\\\"liability/new-report.jpg\\\" />\\n\\n### 2. Explore reports\\n\\nYou can also observe the report in the storage. Go to `Developer -> Storage` and choose `liability` from the dropdown list.\\n\\n<robo-wiki-picture src=\\\"liability/storage-report.jpg\\\" />\\n\\n### 3. Check balances\\n\\nOn the picture it's shown that now the promisor has got the \\\"salary\\\". Economical relationship happened!\\n\\n<robo-wiki-picture src=\\\"liability/balances-2.jpg\\\" />\\n\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Verifying\\\">\\n\\n  As for now there is no way to verify the job is done, so as soon as the promisor reports, the tokens are transferred to its account.\\n  The verify feature is to be added in the future.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"63a149194297b1a03eb2f1210b92a68e\",\"title\":\"How to Update Robonomics Collator Node Version\",\"path\":\"/docs/how-to-update-collator-node-version/\",\"content\":\"\\nIt is recommended to have read the following articles prior to reading this post: [\\\"How to Build Collator Node\\\"](/docs/how-to-build-collator-node) & [\\\"How to Launch the Robonomics Collator\\\"](/docs/how-to-launch-the-robonomics-collator).\\n\\nThis article contains the commands required to update a Robonomics collator node (running on Ubuntu), and also gives an example afterwards.\\n\\n## **Required Commands**\\n\\n0. Before you begin, it is recommended that you are logged in as `root`, if not, then I would recommend that you use:\\n\\n<code-helper copy>\\n\\n```shell\\nsudo su -\\n```\\n\\n</code-helper>\\n\\n1. Stop the Robonomics service:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl stop robonomics.service\\n```\\n\\n</code-helper>\\n\\n2. Remove previous version of Robonomics (make sure you are in the correct directory):\\n\\n<code-helper copy>\\n\\n```shell\\nrm -f robonomics.X.X.X-ubuntu-x86_64.tar.gz\\n```\\n\\n</code-helper>\\n\\n3. Get the [latest release](https://github.com/airalab/robonomics/releases) version of Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nwget https://github.com/airalab/robonomics/releases/vX.X.X/.....\\n```\\n</code-helper>\\n\\n\\n4. Extract the file:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xf robonomics-X.X.X-x86_64-unknown-linux.gnu.tar.gz\\n```\\n</code-helper>\\n\\n5. Move the file:\\n\\n<code-helper copy>\\n\\n```shell\\nmv robonomics /usr/local/bin/\\n```\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\">\\n\\nYou need to move this file to the correct directory which you installed the Robonomics node)\\n\\n</robo-wiki-note>\\n\\n6. Start Robonomics:\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl start robonomics.service\\n```\\n</code-helper>\\n\\nExample for upgrading collator node to Robonomics v1.8.4:\\n\\n<code-helper>\\n\\n```shell\\nsudo su -\\ncd /home/admin\\nsystemctl stop robonomics.service\\nrm -f robonomics-1.7.3-x86_64-unknown-linux-gnu.tar.gz\\nwget https://github.com/airalab/robonomics/releases/download/v1.8.4/robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\ntar -xf robonomics-1.8.4-x86_64-unknown-linux-gnu.tar.gz\\nmv robonomics /usr/local/bin/\\nsystemctl start robonomics.service\\n\\n```\\n</code-helper>\\n\\n## **Changing Kusama Relay Chain Database with No Base Path Set**\\n\\nThere are times where certain snapshots of the Kusama Relay Chain cause your node to have errors. This will often cause your node to stop working. Example error caused by a corrupt Relay Chain database:\\n\\n<code-helper>\\n\\n```shell\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] GRANDPA voter error: could not complete a round on disk: Database\\nDec 08 19:14:31 ns3159483 robonomics[1019836]: 2022-12-08 19:14:31 [Relaychain] Essential task `grandpa-voter` failed. Shutting down service.\\nDec 08 19:14:32 ns3159483 robonomics[1019836]: Error: Service(Other(\\\"Essential task failed.\\\"))\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:32 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\nec 08 19:14:33 ns3159483 robonomics[1022922]: Error: Service(Client(Backend(\\\"Invalid argument: Column families not opened: col12, col11, col10, col9, col8, col7, col6, col5, col4, col3, col2, col1, col0\\\")))\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Main process exited, code=exited, status=1/FAILURE\\nDec 08 19:14:33 ns3159483 systemd[1]: robonomics.service: Failed with result 'exit-code'.\\n```\\n</code-helper>\\n\\nIn order to fix this error, you should remove your existing Kusama Relay Chain database (likely RocksDb) and replace it with another Db such as ParityDb. Execute the following commands:\\n\\n1. Find the directory of Robonomics node and check the files:\\n\\n<code-helper>\\n\\n```shell\\ncd /home/robonomics/\\nls -a\\n```\\n</code-helper>\\n\\n2. Confirm that you see the polkadot directory, and then navigate to the chains directory:\\n\\n<code-helper>\\n\\n```shell\\ncd /polkadot/chains/\\nls -a\\n```\\n</code-helper>\\n\\n3. Delete the `ksmcc3` directory:\\n\\n<code-helper copy>\\n\\n```shell\\nrm -r ksmcc3\\n```\\n</code-helper>\\n\\n4. Make a new `ksmcc3` directory.\\n\\n<code-helper>\\n\\n```shell\\nmkdir ksmcc3\\nchown -R robonomics:robonomics ksmcc3\\ncd ksmcc3\\n```\\n\\n</code-helper>\\n\\n5. Now you need to download a new snapshot. This example uses a heavily pruned relay chain snapshot, but you can swap it for any snapshot you prefer.\\n\\n<code-helper copy>\\n\\n```shell\\nwget wget https://snaps.sik.rocks/ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n6. Whilst the snapshot is downloading, open a new session and edit your service file:\\n\\n\\n<code-helper copy>\\n\\n```shell\\nsudo nano /etc/systemd/system/robonomics.service\\n```\\n\\n</code-helper>\\n\\nModify lines within the service file which relate to the database and pruning:\\n\\n<code-helper copy>\\n\\n```shell\\n  --database=paritydb \\\\\\n  --state-pruning=100 \\\\\\n  --blocks-pruning=100 \\\\\\n  --execution=Wasm\\n```\\n\\n</code-helper>\\n\\n  \\nUse `Ctrl + S` and then `Ctrl + X` to save and exit the service file.\\n\\n7. Now you need to reload your daemon.\\n\\n<code-helper copy>\\n\\n```shell\\nsystemctl daemon-reload\\n```\\n</code-helper>\\n\\n\\n8. By this time, in your other session, hopefully the new Db has downloaded, so extract the file:\\n\\n<code-helper copy>\\n\\n```shell\\ntar -xvzf ksm_pruned.tar.gz\\n```\\n\\n</code-helper>\\n\\n9. After the unpacking is completed, execute the following:\\n\\n<code-helper copy>\\n\\n\\n```shell\\nchown -R robonomics:robonomics paritydb\\n```\\n\\n</code-helper>\\n\\n10. Now you can start the service, monitor it for any errors, and check that it is peering on both the relay chain and the parachain:\\n\\n\\n<code-helper copy>\\n\\n\\n```shell\\nsystemctl start robonomics && journalctl -fu robonomics\\n```\\n</code-helper>\"}},{\"node\":{\"id\":\"657264036c99df16b9de979bb6c7a850\",\"title\":\"How to build collator node from source\",\"path\":\"/docs/how-to-build-collator-node/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  In the screencast and screenshots of this article, we used version 1.4.0 of Robonomics. You need to use the same commands, but replace the version of Robonomics with the current one.\\n</robo-wiki-note>\\n\\n## What is a collator\\n\\nCollator is part of the Robonomics parachain. This nodes type creates new blocks for chain.\\n\\n>Collators maintain parachains by collecting parachain transactions from users and producing state transition proofs for Relay Chain validators. In other words, collators maintain parachains by aggregating parachain transactions into parachain block candidates and producing state transition proofs for validators based on those blocks.\\n\\nYou can learn more about collator on the related [Polkadot wiki page](https://wiki.polkadot.network/docs/learn-collator)\\n\\nIn the Robonomics parachain every collator get rewards (**0.000380520 XRT**) for every block it built, if this block was sealed to the chain. \\nAlso collator get **50% transactions fees** from this block.\\n\\n## Building process\\n\\nhttps://youtu.be/wnAtD7w0Pxk\\n\\nEnsure you have Rust and the support software installed. The Rust installer will ask you about current installation options, you should choose the `1) Proceed with installation (default)` option.\\n\\n\\n```\\n  curl https://sh.rustup.rs -sSf | sh\\n  # on Windows download and run rustup-init.exe\\n  # from https://rustup.rs instead\\n  source $HOME/.cargo/env\\n```\\n![Install Rust](./images/how-to-build-collator-node/install_rust.jpg)\\n\\n\\nInstall the required nightly toolchain and wasm target.\\nNext commands actual for Robonomics v2.6.0:\\n\\n```\\n  rustup install nightly-2022-08-05\\n```\\n![Install nightly](./images/how-to-build-collator-node/install_nightly.jpg)\\n\\n\\n```\\n  rustup default nightly-2022-08-05\\n  rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-05\\n```\\nYou will also need to install the following packages:\\n\\n  1. Linux:\\n\\n  ```\\n    sudo apt install cmake git clang libclang-dev\\n  ```\\n  2. Mac:\\n\\n  ```\\n    brew install cmake pkg-config git llvm\\n  ```\\n  3. Windows (PowerShell):\\n\\n  ```\\n    # Install git https://git-scm.com/download/win\\n    # Install LLVM\\n    # Download and install the Pre Build Windows binaries\\n    # of LLVM  from http://releases.llvm.org/download.html\\n  ```\\nNow you can install the robonomics node from git source.\\n\\n```\\n  cargo install --force --git https://github.com/airalab/robonomics --tag v2.6.0 robonomics-node\\n```\\n![Start build Robonomics](./images/how-to-build-collator-node/start_build_robonomics.jpg)\\n![End build Robonomics](./images/how-to-build-collator-node/end_build_robonomics.jpg)\\n\\n\\nAfter this command the compiled robonomics binary will be in `~/.cargo/bin` directory.\\n\\nThe next step is how to launch the collator node. You can read about it in the [\\\"How to launch the Robonomics collator\\\"](/docs/how-to-launch-the-robonomics-collator) article.\"}},{\"node\":{\"id\":\"716e3992e88ea98e13db8c7022696a41\",\"title\":\"How to launch the Robonomics collator\",\"path\":\"/docs/how-to-launch-the-robonomics-collator/\",\"content\":\"\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n  In the screencast and screenshots of this article, we used version 1.4.0 of Robonomics. You need to use the same commands, but replace the version of Robonomics with the current one.\\n</robo-wiki-note>\\n\\nhttps://youtu.be/wUTDDLDbzTg\\n\\nCurrently the Robonomics network is primarily maintained by the initial developers, but anyone can support the project. Every additional full node of the blockchain helps it to become more sustainable and fault tolerant. Robonomics node binaries are available in [release](https://github.com/airalab/robonomics/releases) assets or it can be [built from source](/docs/how-to-build-collator-node/).\\n\\n## What is a collator\\n\\nA Collator is part of the Robonomics parachain. This type of node creates new blocks for the Robonomics chain.\\n\\n>Collators maintain parachains by collecting parachain transactions from users and producing state transition proofs for Relay Chain validators. In other words, collators maintain parachains by aggregating parachain transactions into parachain block candidates and producing state transition proofs for validators based on those blocks.\\n\\nYou can learn more about collators on the related [Polkadot wiki page](https://wiki.polkadot.network/docs/learn-collator)\\n\\nIn the Robonomics parachain every collator gets rewards of (**0.001598184 XRT**) for every block that the collator builds (rewards occur when blocks are sealed to the chain). \\nAlso the collator that builds the block gets **50% of transactions fees** contained within the block they create.\\n\\n## Requirements\\n\\nIt is recommended that you launch a collator using the **standard hardware requirements** for [Polkadot validators](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-polkadot#standard-hardware):\\n+ x86-64 compatible.\\n+ Intel Ice Lake, or newer (Xeon or Core series); AMD Zen3, or newer (EPYC or Ryzen).\\n+ 4 physical cores @ 3.4GHz.\\n+ Simultaneous multithreading disabled (Hyper-Threading on Intel, SMT on AMD).\\n+ Storage - An NVMe SSD of 1 TB (As it should be reasonably sized to deal with blockchain growth).\\n+ Memory - 32 GB DDR4 ECC\\n\\n\\nIn this article we use next specifications:\\n+ 4 vCPU\\n+ 700 GB of NVMe space for collator's databases. The ability to expand this disk space is required.\\n+ 8GB RAM\\n\\n\\n## Important information\\n1. We use some variables in these instructions, and you'll need to replace the values for your own in all the commands:\\n    + **%NODE_NAME%** is the node name. Example: *my-robonomics-kusama-collator*\\n    + **%BASE_PATH%** is the path to mounted volume. Example: */mnt/HC_Volume_16056435/*\\n    + **%POLKADOT_ACCOUNT_ADDRESS%** is the account address in the Polkadot ecosystem in SS58 format. Example: *4Gp3QpacQhp4ZReGhJ47pzExQiwoNPgqTWYqEQca9XAvrYsu*\\n\\n2. Note that you need to include *--state-cache-size=0* in the collator's service launch. This parameter is important for the stability of the collator.\\nYou can see more info in the related [issue](https://github.com/airalab/robonomics/issues/234) on github.\\n\\n## First time easily launch a Robonomics collator\\n\\nYou can easily launch a collator directly in the command line to check for errors.\\nAfter doing this it is strongly recommended to launch the Robonomics collator as a service (watch next step).\\n\\n```\\nroot@robokusama-collator-screencast:~# robonomics \\\\\\n  --parachain-id=2048 \\\\\\n  --name=\\\"%NODE_NAME%\\\" \\\\\\n  --validator \\\\\\n  --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n  --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n  --base-path=\\\"%BASE_PATH%\\\" \\\\\\n  --state-cache-size=0 \\\\\\n  -- \\\\\\n  --database=RocksDb \\n```\\n\\n\\n## Launch the Robonomics collator as a service\\n\\n1. Create the user for the service with home directory\\n    ```\\n    root@robokusama-collator-screencast:~# useradd -m robonomics\\n    ```\\n\\n2. Download, extract and move the Robonomics binary to the */usr/local/bin/* directory. You need to replace *$ROBONOMICS_VERSION* with the current version of Robonomics in the commands in this section. You can find the current version on the [Releases page of the Robonomics repository on github](https://github.com/airalab/robonomics/releases).\\n   ```\\n   root@robokusama-collator-screencast:~# wget https://github.com/airalab/robonomics/releases/download/v$ROBONOMICS_VERSION/robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# tar -xf robonomics-$ROBONOMICS_VERSION-x86_64-unknown-linux-gnu.tar.gz\\n   root@robokusama-collator-screencast:~# mv robonomics /usr/local/bin/\\n   ```\\n   ![Download Robonomics 1.4.0 binary](./images/how-to-launch-the-robonomics-collator/wget_binary.png)\\n\\n\\n3. Create the systemd service file named *robonomics.service*:\\n    ```\\n    root@robokusama-collator-screencast:~# nano /etc/systemd/system/robonomics.service\\n    ```\\n\\n    And add the following lines in the service file:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n      --parachain-id=2048 \\\\\\n      --name=\\\"%NODE_NAME%\\\" \\\\\\n      --validator \\\\\\n      --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n      --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n      --base-path=\\\"%BASE_PATH%\\\" \\\\\\n      --state-cache-size=0 \\\\\\n      --execution=Wasm \\\\\\n      -- \\\\\\n      --database=RocksDb \\\\\\n      --execution=Wasm\\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n    ![Create Robonomics service file](./images/how-to-launch-the-robonomics-collator/nano_robonomics_service.png)\\n\\n\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%\\n    ```\\n\\n\\n4. Save this file, then enable and start the service:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl enable robonomics.service \\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\nTelemetry url: https://telemetry.parachain.robonomics.network/#/Robonomics\\n\\nCollators logs can be monitored with: `journalctl -u robonomics.service -f` \\n\\nOnce the Robonomics collator is launched it will begin to sync with the Kusama Relay Chain, this can take a considerable amount of time, depending on your network speed and system specifications, so we recommend to download a Kusama snapshot. \\n\\n\\n## Speeding up the sync process using a Kusama snapshot\\n\\nWe recommend to do this immediately after you've created and started the Robonomics service. You can find more info about snapshots and usage instructions on the following page: https://ksm-rocksdb.polkashots.io/\\n\\nInstructions:\\n\\n1. Stop the Robonomics service and remove the current Kusama database directory:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/polkadot/chains/ksmcc3/db/\\n    ```\\n2. Download the actual snapshot and extract it:\\n    ```\\n    root@robokusama-collator-screencast:~# wget https://ksm-rocksdb.polkashots.io/snapshot -O kusama.RocksDb.tar.lz4\\n    root@robokusama-collator-screencast:~# lz4 -c -d kusama.RocksDb.tar.lz4 | tar -x -C %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n    ![Download Kusama snapshot](./images/how-to-launch-the-robonomics-collator/wget_kusama_snapshot.png)\\n\\n    You can remove the downloaded archive after succesful unpacking:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -v kusama.RocksDb.tar.lz4\\n    ```\\n\\n3. Setting the right ownership for the database folder:\\n    ```\\n    root@robokusama-collator-screencast:~# chown -R robonomics:robonomics %BASE_PATH%/polkadot/chains/ksmcc3\\n    ```\\n4. Start the Robonomics service again:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n5. Check service logs:\\n    ```\\n    root@robokusama-collator-screencast:~# journalctl -u robonomics.service -f\\n    ```    \\n    ![Check service logs](./images/how-to-launch-the-robonomics-collator/finish_journalctl.png)\\n\\n## Troubleshooting\\n### Error: \\\"State Database error: Too many sibling blocks inserted\\\"\\nFor fix this error you can just launch your collator in archive mode: \\n\\n1) First, need to stop the Robonomics service: \\n    \\n    root@robokusama-collator-screencast:~# systemctl stop robonomics.service\\n    \\n\\n2) Then add the parameter `--state-pruning=archive` to the parachain part of the service file. Example of the edited service file:\\n    ```\\n    [Unit]\\n    Description=robonomics\\n    After=network.target\\n    \\n    [Service]\\n    User=robonomics\\n    Group=robonomics\\n    Type=simple\\n    Restart=on-failure\\n\\n    ExecStart=/usr/local/bin/robonomics \\\\\\n    --parachain-id=2048 \\\\\\n    --name=\\\"%NODE_NAME%\\\" \\\\\\n    --validator \\\\\\n    --lighthouse-account=\\\"%POLKADOT_ACCOUNT_ADDRESS%\\\" \\\\\\n    --telemetry-url=\\\"wss://telemetry.parachain.robonomics.network/submit/ 0\\\" \\\\\\n    --base-path=\\\"%BASE_PATH%\\\" \\\\\\n    --state-cache-size=0 \\\\\\n    --execution=Wasm \\\\\\n    --state-pruning=archive \\\\\\n    -- \\\\\\n    --database=RocksDb \\\\\\n    --execution=Wasm \\n\\n    [Install]\\n    WantedBy=multi-user.target\\n    ```\\n\\n3) Reload the systemd manager configuration:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl daemon-reload\\n    ```\\n\\n4) Remove the exists parachain database:\\n    ```\\n    root@robokusama-collator-screencast:~# rm -rf %BASE_PATH%/chains/robonomics/db/\\n    ```\\n\\n5) Start the robonomics service:\\n    ```\\n    root@robokusama-collator-screencast:~# systemctl start robonomics.service\\n    ```\\n\\n    After that need to wait for the synchronization of the parahain database.\\n\\n### Error: \\\"cannot create module: compilation settings are not compatible with the native host\\\"\\nThis error related to the virtualization parameters. Need to use \\\"host-model\\\" type of the emulated processor. You can set up this on the virtualisation host.\\n\\nBut, if you catch this error on any hosting, you need to ask the technical support about this problem only.\\n\"}},{\"node\":{\"id\":\"b6ca48a552d45fad1f2e74721af685f8\",\"title\":\"Upgrade Your Home Assistant OS\",\"path\":\"/docs/hass-os-upgrade/\",\"content\":\"\\n**This article contains instructions to upgrade your existing Home Assistant OS with Robonomics integration.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/homeassistant_os.png\\\" />\\n\\n## Install IPFS Add-on\\n\\n\\nRobonomics Integration stores the data using local IPFS daemon, so you need to install it first. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdAmUHW9bpTU6sUwBYu4ai4DVJ6nZ5xerjM9exvooGKGq', type:'mp4'}]\\\" />\\n\\n1. There is an [IPFS Add-on for Home Assistant](https://github.com/airalab/ipfs-addon). To install it go to `Settings` -> `Add-ons` and press the `ADD-ON STORE` button in the lower right corner.\\n\\n2. Press on three dots in the upper right corner and choose `Repositories`. Add there the following link:\\n\\n<code-helper copy>\\n\\n```\\nhttps://github.com/airalab/ipfs-addon\\n```\\n\\n</code-helper>\\n\\n3. Press `ADD` button.\\n\\n4. Close the repository manager and refresh the page. Now in the end of the page you can see IPFS Daemon Add-on.\\n\\n5. Open the addon and press `INSTALL`. After installation press `START`.\\n\\n## Install HACS\\n\\n[Home Assistant Community Store (HACS)](https://hacs.xyz/) allows you to install custom integrations.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYJFpxrww9PRvcAUhdgKufeDbyUFoBZTREZHPgV452kzs', type:'mp4'}]\\\" />\\n\\n1. Before start, you need to install add-on for connecting to the Home Assistant device with SSH. In Add-on Store search `ssh`. We recommend to install `SSH & Web Terminal` add-on.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  If the SSH addon is not found, try enabling Advanced Mode in your user profile settings. To do this, click on the profile icon in the lower left corner, and find the Advanced Mode option.\\n\\n</robo-wiki-note>\\n\\n2. Choose the add-on and press `INSTALL`. After installation is finished, go to `Configuration` tab and add `password` or `authorized_keys`. Don't forget to save this part of configuration.\\n\\n3. In the `Info` tab press `START`. If you want to see the addon in the sidebar, don't forget to enable `Show in sidebar`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmcijfJ45fmW9omB67xWyPKvHhZuwLMTTQ7DBqnyxHUXR1', type:'mp4'}]\\\" />\\n\\n4. Open SSH Add-on and run the following command:\\n\\n<code-helper copy additionalLine=\\\"Home Assistant Command Line\\\">\\n\\n```bash\\nwget -O - https://get.hacs.xyz | bash -\\n```\\n\\n</code-helper>\\n\\n5. Restart Home Assistant (you can do it in `Settings`->`System`). \\n\\n6. Now HACS Integration will be available to add in the `Integrations` menu. Go to `Settings`->`Devices & Services`, press `Add Integration` and find HACS.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Warning\\\">\\n\\n  To use HACS you need a Github Account.\\n\\n</robo-wiki-note>\\n\\n7. Click on it and follow the installation instructions. \\n\\n## Install Robonomics Integration\\n\\nNow you can install Robonomics Integration using HACS.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmUodGanHyTE8hCJdcCHzvdnmuyVVGvnfTuYvYTPVKhh5d', type:'mp4'}]\\\" />\\n\\nOpen HACS from the sidebar menu and navigate to `Integrations`. Click on `Explore & Download Repositories`, then search for `Robonomics` and click on the `Download` button located in the lower right corner. Once the download is complete, restart Home Assistant.\"}},{\"node\":{\"id\":\"2ec95dfc8a5c62f4f21381867d9f4e2b\",\"title\":\"Home Assistant Initialization\",\"path\":\"/docs/hass-init/\",\"content\":\"\\n**After installing Home Assistant, it needs to be initialized.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_init.png\\\" />\\n\\nYou are starting with the creation of the owner account of Home Assistant. This account is an administrator and can make any changes. Open web browser and go to `http://%RASPBERRY_IP_ADDRESS%:8123`. You can find the IP address of Raspberry Pi using [Fing mobile app](https://www.fing.com/products) or [nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/).\\n\\n<robo-wiki-note type=\\\"note\\\">Raspberry Pi address may change in time, due router settings.</robo-wiki-note>\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmYd1Mh2VHVyF3WgvFsN3NFkozXscnCVmEV2YG86UKtK3C', type:'mp4'}]\\\" />\\n\\n1. At the first page, enter a name, username, password and click on the `CREATE ACCOUNT` button.\\n\\n2. On the next screen, enter a name for your home and set your location and unit system. Click `DETECT` to find your location and set your time zone and unit system based on that location. If you don't want to send your location, you can set these values manually.\\n\\n3. After that, Home Assistant will show any devices that it has discovered on your network. Don’t worry if you see fewer items than what is shown below; you can always manually add devices later. For now, just click `FINISH` and you will be on the main Home Assistant screen.\\n\\n4. Finally, you will see the Home Assistant web interface, which will show all of your devices. \\n\\n\\n## Troubleshooting\\n\\n1. If you forget your login or password for local user, [check this article](https://www.home-assistant.io/docs/locked_out/) to restore your credentials.\\n\"}},{\"node\":{\"id\":\"db3dac72fca3d30e742c18c575345724\",\"title\":\"Pre-installed Image For Raspberry Pi\",\"path\":\"/docs/hass-image-install/\",\"content\":\"\\n**Welcome to the guide on installing Home Assistant with Robonomics integration on a Raspberry Pi. Home Assistant is an open-source home automation system that provides a centralized hub for controlling smart devices in your home network. By integrating with Robonomics, a decentralized cloud service, you can enhance the functionality and security of your smart home. In this article, we will provide step-by-step instructions on how to install Home Assistant with Robonomics on a Raspberry Pi, giving you the ability to automate and control various aspects of your home using a secure and decentralized solution. Let's get started!**\\n\\n## Hardware you need for installation\\n\\nIf you haven't already incorporated Home Assistant into your smart home setup, it's important to be aware of the equipment you'll need to establish a complete smart home system from the ground up.\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"3\\\" flexible>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n      <b>Raspberry Pi 4 (at least 2 GB RAM)</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n      <b>SD card 16Gb+</b>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_7.png\\\" /> \\n      <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\" target=\\\"_blank\\\"><b>Zigbee adapter</b></a>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n  <robo-wiki-grid-element-wrapper textAlign=\\\"center\\\" :columns=\\\"2\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <a href=\\\"https://www.zigbee2mqtt.io/supported-devices/\\\" target=\\\"_blank\\\"><b>Zigbee smart devices</b></a>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_9.png\\\" />\\n      <b>Desktop for setup</b>\\n    </robo-wiki-grid-element>\\n  </robo-wiki-grid-element-wrapper>\\n\\n\\n## 1. Download Robonomics pre-installed image\\n\\nRobonomics pre-installed image contains:\\n- Home Assistant Core\\n- IPFS\\n- MQTT Broker and Integration\\n- Zigbee2MQTT\\n- Robonomics Integration\\n\\n<robo-wiki-button label=\\\"Download image (~528 Mb)\\\" link=\\\"https://crustipfs.info/ipfs/QmeDPrNYLQKFCZgPmxyxDWSAXSjSaw7Dx46d9p3JSGM1hA?filename=robonomics_rpi.xz&download=true\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"For advanced users\\\">\\n\\nYou can check source code and download latest release of image on [GitHub](https://github.com/airalab/Robonomics-HomeAssistant-image/releases)\\n\\n</robo-wiki-note>\\n\\n\\n## 2. Configure the Image\\n\\nInstall [Raspberry Pi Imager](https://www.raspberrypi.com/software/) on your computer. Then, insert the SD card.\\n\\n<robo-wiki-picture src=\\\"home-assistant/insert-sd-card.gif\\\" alt=\\\"insert SD card\\\" />\\n\\n\\nRun the Raspberry Pi Imager program. Choose required image as the operating system and ensure to select your SD card from the storage dropdown menu. \\nIn settings:\\n- Set username and password (save default username \\\"pi\\\" to be easy to remember),  \\n- provide your Wi-Fi name and password, \\n- choose your country from drop-down list\\nand then `Write` image. \\n                   \\n<robo-wiki-note type=\\\"note\\\">Save Username and Password carefully, because these credentials will be needed in case of Troubleshooting</robo-wiki-note>\\n                        \\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSZM7uVizqQjLnKJy2kifs9uDZB91MgALDBARenkzU3mb', type:'mp4'}]\\\" cover=\\\"covers/cover-1.png\\\" />\\n\\nYou can find country codes [here](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).\\n\\n## 3. First Boot\\n\\n**Safely eject the SD card**, insert it into the Raspberry Pi. Then **insert Zigbee adapter** into the Raspberry Pi.\\n\\n<robo-wiki-note type=\\\"warning\\\">It's important to insert Zigbee adapter before first start of raspberry Pi! \\nIt's needed for autoconfiguration of zigbee network.</robo-wiki-note>\\n\\n**If you have the [JetHome USB JetStick Z2](https://jethome.ru/z2/?sl=en) (which has all the necessary firmware), you can simply proceed with these instructions. However, if you have another adapter, the first thing you need to do is to flash it with Zigbee2MQTT software. You can find instructions for your device [here](https://www.zigbee2mqtt.io/information/supported_adapters.html).**\\n\\nNext, connect the power cable to your device. It should connect to your Wi-Fi network. \\n\\n<robo-wiki-picture src=\\\"home-assistant/first-start.gif\\\" alt=\\\"first boot\\\" />\\n\\nOnce your Raspberry Pi is connected, the red LED will light up and the green LED will flash for some time. Wait up to 5 minutes for the Raspberry Pi to boot up and register on the network. \\n\\nNow find the IP address of Raspberry Pi. To find it you can use [Fing mobile app](https://www.fing.com/products) or \\n[nmap CLI tool](https://vitux.com/find-devices-connected-to-your-network-with-nmap/). Find the `robots-home` (optional name could be `Home(homeassistant)`) \\nname of the host machine in the IP list. \\n\\nIn this example the address is `192.168.43.56`. \\n\\nTo check that everything is working, open web browser and go to web page `http://%RASPBERRY_IP_ADDRESS%:8123`. In this example, it will be `192.168.43.56:8123`.\\nIf everything is fine, you will see Home Assistant web interface. If webpage doesn't open, wait up to 5 minutes for the Raspberry Pi to boot up and try again. \\n\\n<robo-wiki-video loop controls :videos=\\\"[{src: 'https://crustipfs.info/ipfs/QmXjFaTd81dLrMgADtENmSqbS2uJuLJUgQUrmDu2CsSuAq', type:'mp4'}]\\\"  cover=\\\"covers/cover-2.png\\\" />\\n\\n\\n## Troubleshooting\\n\\n1. To change Wi-Fi setting later you should login to your Raspberry Pi via `ssh` command. For this, open terminal on your computer\\nand type ssh command with your username, which you create on \\\"Configuring the Image\\\" step(default one is \\\"pi\\\"). \\n\\n<code-helper additionalLine=\\\"your_username@your_hostname\\\">\\n\\n```bash\\nssh <YOUR_USERNAME>@<Raspberry_PI_IP_ADDRESS>\\n```\\n</code-helper>\\n\\nand then use command `sudo raspi-config`. Find more information about this command on [the official site.](https://www.raspberrypi.com/documentation/computers/configuration.html)\\n\"}},{\"node\":{\"id\":\"0ad36878de5a3cd70a33383e3be423ef\",\"title\":\"Upgrade Your Home Assistant Docker for Unix-like OS\",\"path\":\"/docs/hass-docker-upgrade/\",\"content\":\"\\n**This article contains instructions to upgrade your existing Home Assistant Docker (on a Unix-like OS) with the Robonomics integration.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_docker.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. It is assumed that default Docker images and container of Home Assistant named <u>homeassistant</u> are used.\\n  2. IPFS will be installed and run as a <u>systemd</u> service on the host machine.\\n  3. It is assumed that you have [Python3.9](https://www.python.org/downloads/) or higher installed.\\n\\n</robo-wiki-note>\\n\\n## Install\\n\\nDownload the installation script and run it in the terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_docker.sh\\nbash install_integration_docker.sh\\n```\\n\\n</code-helper>\\n\\nYou will see the following output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\n<...>\\nadded /dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nExecuting subversion-1.14.2-r1.pre-install\\nExecuting busybox-1.35.0-r17.trigger\\nOK: 157 MiB in 165 packages\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 120.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  You may see an error like `mkdir: can't create directory 'custom_components': File exists`. This means that you have already have this folder with some custom components installed. Just ignore this message.\\n\\n</robo-wiki-note>\\n\\nRestart the container:\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Docker\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker restart homeassistant</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"Docker Compose\\\">\\n    <code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n    <pre>docker compose restart</pre>\\n    </code-helper>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n## Verify\\n\\nCheck that the IPFS service is up and running:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nYou will see the following output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"20e7142749e4cac34392eed3b6408f14\",\"title\":\"Upgrade Your Home Assistant Core\",\"path\":\"/docs/hass-core-upgrade/\",\"content\":\"\\n**This article contains instructions to upgrade your existing Home Assistant Core with the Robonomics integration.**\\n\\n<robo-wiki-picture src=\\\"home-assistant/ha_core.png\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"DISCLAIMER\\\">\\n\\n  1. It is assumed that the installation of your Home Assistant Core was completed in accordance to the [official instructions](https://www.home-assistant.io/installation/raspberrypi#install-home-assistant-core) and there is a <u>homeassistant</u> user and the `venv` environment. If it is not the case, follow instructions below, **but edit the script accordingly**.\\n  2. IPFS will be installed and run as a <u>systemd</u> service on the host machine.\\n  3. It is assumed that you have [Python3.10](https://www.python.org/downloads/) or higher installed.\\n\\n</robo-wiki-note>\\n\\n## Install\\n\\nDownload the installation script and run it in the terminal:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n  \\n```shell\\nwget https://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_integration_core.sh\\nbash install_integration_core.sh\\n```\\n\\n</code-helper>\\n\\nYou will see the following output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n\\n```shell\\n<...>\\nhttps://raw.githubusercontent.com/airalab/robonomics-hass-utils/main/raspberry_pi/install_ipfs_arc_dependent.sh\\n<...>\\nIPFS daemon installed and launched, use ipfs-daemon.service to manage.\\n<...>\\nA    robonomics/utils.py\\nChecked out revision 125.\\nIntegration downloaded!\\n```\\n\\n</code-helper>\\n\\nDuring the process, you will be asked to confirm the restart of several services. Navigating with `tab`, select the `yes` option.\\n  \\n<robo-wiki-note type=\\\"note\\\" title=\\\"Error: `custom_components` exists\\\">\\n\\n  You may see an error like `mkdir: can't create directory 'custom_components': File exists`. This means that you have already have this folder with some custom components installed. Just ignore this message.\\n\\n</robo-wiki-note>\\n  \\nAfter finishing, restart your Home Assistant.\\n\\n## Verify\\n\\nCheck that the IPFS service is up and running:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```shell\\nsystemctl status ipfs-daemon.service \\n```\\n\\n</code-helper>\\n\\nYou will see the following output:\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\">\\n\\n```\\n● ipfs-daemon.service - IPFS Daemon Service\\n     Loaded: loaded (/etc/systemd/system/ipfs-daemon.service; enabled; preset: enabled)\\n     Active: active (running) since Thu 2022-11-03 11:30:39 UTC; 14min ago\\n   Main PID: 4400 (ipfs)\\n      Tasks: 12 (limit: 4416)\\n     Memory: 141.9M\\n        CPU: 3min 5.031s\\n     CGroup: /system.slice/ipfs-daemon.service\\n             └─4400 /usr/local/bin/ipfs daemon\\n```\\n\\n</code-helper>\\n\"}},{\"node\":{\"id\":\"93b43322b6850bffa4b180dea301ab0d\",\"title\":\"Glossary\",\"path\":\"/docs/glossary/\",\"content\":\"\\n## A\\n\\n### Account (on Blockchain)\\na conjunction of a public-private keypair, the public part of which is the user's public address, and the private part is the secret key for accessing the control of this address.\\n\\n\\n### Auction (of Parachains)\\nmechanism of leasing slots for parachains in the Polkadot and Kusama ecosystems; a parachain have win a candle auction to get a slot.\\n\\n### Autonomous Agent\\na computational system that receives sensory data from its environment and decides how to respond to external stimuli in order to achieve its goals.\\n\\n### AIRA\\nor Autonomous Intelligent Robot Agent — a software, developed by Robonomics team in 2015, that implements the standard of economic human-machine and machine-machine interaction through an intellectual liability contract.\\n\\n\\n## B\\n\\n### Blockchain\\nin a broad sense, a distributed network that uses cryptography to allow a group of participants to trustlessly come to consensus on the changing state of a system.\\n\\n### Blockchain Explorer\\nan application that allows to explore the different blocks, transactions and addresses on a blockchain (e.g. Etherscan, Subscan).\\n\\n### Blueprint (Hass)\\na pre-made automation logic that can be easily added to a Home Assistant instance.\\n\\n### Bridge\\na technology and methods by which two economically sovereign and technologically diverse chains to communicate with each other. \\n\\n\\n## C\\n\\n### Coase (XRT)\\nor Cs — a millionth share of one XRT token, 1 XRT = 1 000 000 Cs; named after Ronald Coase, a British economist, one of the founders of institutional economics, a laureate of the Nobel Memorial Prize in Economic Sciences. \\n\\n### Collator\\na node that maintains a parachain by collecting parachain transactions and producing state transition proofs for the validators.\\n\\n### Consensus\\na process in which nodes of a blockchain network reach agreement about the present state of the data in the network (e.g. Proof-of-Work, Proof-of-Stake).\\n\\n### Crowdloan\\na crowdfunding campaign of collecting tokens to make a bid on the slots auction in the Polkadot / Kusama ecosystem.\\n\\n### Cybernetics\\nthe study of control and communication in the animal and the machine, according definition of N. Wiener.\\n\\n### Cyber-Physical System\\nor CPS — a strong unification and mutual integration of multiple computational, networking, and physical processes.\\n\\n\\n## D\\n\\n### DAO\\na collectively-owned, blockchain-governed organization, in which resource management is carried out in accordance with a pre-agreed and formalized set of rules, the enforcement of which is performed automatically.\\n\\n### Datalog (Function)\\na Robonomics parachain function, that stores device data on the blockchain.\\n\\n### Dapp\\nor decentralized application — an application that runs as part of a distributed network and provides access its functions in a user-friendly way.\\n\\n### Decentralized Cloud\\na cloud computing service based on a decentralized peer-to-peer network that users can join either to use services or to provide their resources such as for computing, networking, storage, etc.\\n\\n### Digital Twin\\na digital version of real equipment that copies its technical characteristics and historical data.\\n\\n\\n## E\\n\\n### Edge-system\\nan IoT device that acts as a link between locally accessible embedded systems and the global network, typically supporting communication protocols and transmitting telemetry and control signals.\\n\\n### Embedded System\\nan IoT device with limited computing and communication resources that provides basic functions (sensors, actuators, buttons) at the lowest level, usually without user interfaces.\\n\\n### Ethereum\\na decentralized open-source blockchain system that works as a platform for numerous other cryptocurrencies, as well as for the execution of decentralized smart contracts.\\n\\n### Ethereum Upgrade\\npreviously known as Ethereum 2.0 or Eth2 — a upgrades of Ethereum protocol that should make the network more scalable, secure and sustainable; for these purposes, it is proposed to change the consensus to Proof-of-Stake and add a sharding mechanism to increase network capacity.\\n\\n### Exodus\\nprocess of transfer XRT tokens from Ethereum network to the Robonomics parachain.\\n\\n### Extrinsic\\na function on the Polkadot and Kusama network, that can trigger network state transitions from outside of the state.\\n\\n\\n## G\\n\\n### Glushkov (XRT)\\nor Gk — a thousandth of one XRT token, 1 XRT = 1 000 Gk; named after Victor Glushkov, a Soviet mathematician, one of the founders of information technology and cybernetics in the Soviet Union.\\n\\n\\n## H\\n\\n### Home Assistant\\nor Hass — an open source control system software, designed to be a central hub for smart devices. \\n\\n### HRMP\\nor Horizontal Relay-routed Message Passing — a secure message passing between parachains, that stores all messages in the Relay Chain storage before sending it to parachains. \\n\\n### HMI\\nor Human-Machine Interface — a user interface or dashboard that connects the user to a machine, system, or device.\\n\\n\\n## I\\n\\n### Industry 4.0\\nor the Fourth Industrial Revolution — the ongoing automation of traditional manufacturing and industrial practices, using modern smart technology.\\n\\n### IPFS\\nor InterPlanetary File System — a peer-to-peer software for storing and sharing data in a distributed file system.\\n\\n### IoT\\nor Internet of Things — a connection to a global network of billions of devices, capable of collecting data and integrated into the environment.\\n\\n### IoT Gateway\\nan edge-system, that aggregates and transmits data from IoT devices to network and vice versa; often these devices are a more complex version of the WiFi router.\\n\\n### IoT Provider\\nan external service that provides IoT users with remote access to data and analytics, as well as control of smart devices over the Internet.\\n\\n### IoT Subscription\\nRobonomics parachain feature, that allows to use the all functions of the parachain for a certain period without fee.\\n\\n\\n## K\\n\\n### KSM\\na native token for Kusama network.\\n\\n### Kusama\\nthe \\\"canary network\\\" for Polkadot that consists of an early-release, unaudited version of the Polkadot software.\\n\\n\\n## L\\n\\n### Launch (Function)\\na Robonomics parachain function that starts or stops a device by sending a command through the blockchain.\\n\\n### Lease Period\\nan amount of time that a parachain can connect to the Relay Chain.\\n\\n### Libp2p\\nan open-source library for creating encrypted peer-to-peer networks.\\n\\n### Lights-out Factory\\nor Smart Factory — a factory that is fully automated and requires no human presence on-site.\\n\\n### Lighthouse\\na smart contract, in the robot economy concept, which performs a transaction when the Provider establishes a market match between the Promisor and the Promisee.\\n\\n### Liability\\na smart contract, made by cyber-physical systems with each other or with humans, to execute a task for payment.\\n\\n### Liability Market\\na platform, in the robot economy concept, in charge of matching offers and demands among the nodes of the system.\\n\\n\\n## M\\n\\n### MQTT\\nor Message Queuing Telemetry Transport — a publish-subscribe protocol designed for low-bandwidth, high latency, unreliable networks for operating high volumes of IoT devices messages.\\n\\n### MQTT Broker\\na service that receives all the messages from the MQTT clients and then routes the messages to the appropriate subscribing clients.\\n\\n\\n## N\\n\\n### NFT\\nor Non-Fungible Token — a token that cannot be interchangeable and indistinguishable from other tokens which allow the tokenization of unique items and provide exclusive ownership for those tokens.\\n\\n### Node (of Robonomics)\\na Substrate-based or Ethereum-based blockchain module with Robonomics extensions for connecting to Robonomics Network.\\n\\n\\n## O\\n\\n### On-chain Governance\\na process of determining what changes to the network are permissible, such as modifications to code or movement of funds, that exists in the network itself and can directly changes it.\\n\\n\\n## P\\n\\n### Pallet\\na Substrate module written in Rust that bundles specific logic or algorithm for runtime of Substrate-based blockchain. \\n\\n### Parachain\\na custom, application-specific data structure (usually, a blockchain) that is integrated to the Relay Chain and can be validated by the validators.\\n\\n### Parathread\\na parachain without a slot that can temporarily participate (on a block by block basis with a fee) in the Relay Chain security.\\n\\n### Polkadot\\na heterogeneous, multi-chain network allowing various blockchains of different characteristics to perform arbitrary, cross-chain communication under shared security.\\n\\n### Polkadot/Substrate Portal\\na basic Substrate UI for interacting with a Polkadot, Kusama and others Substrate network.\\n\\n### Proposal (on Polkadot / Kusama)\\na potential function call to be voted on in a Polkadot, Kusama or parachains referendum. \\n\\n### Proof-of-Work\\na consensus mechanism in which, in order to reach agreement, network participants are required to perform computational work.\\n\\n### Proof-of-Stake\\na consensus mechanism in which, in order to reach agreement, network participants are required to stake capital of the associated cryptocurrency that acts as collateral.\\n\\n### Promisee\\na node that places an order for execution of a task in the robot economy concept.\\n\\n### Promisor\\na node that agrees to execute a task for payment in the robot economy concept.\\n\\n### Provider (Robonomics)\\na node, in the robot economy concept, that monitors the messages of the Liability Market and matches an offer and a demand for a small fee. \\n\\n\\n## R\\n\\n### Referendum (on Polkadot / Kusama)\\na part of on-chain governance, vote on whether or not a proposal should be accepted by the network users. \\n\\n### Relay Chain\\nthe main chain that coordinates consensus of Polkadot / Kusama and communication between parachains.\\n\\n### Robofirm\\nan organization in which the entire business process cycle is fully automated and does not require human participation.\\n\\n### Rococo\\nthe testnet for testing parachains on Kusama\\n\\n### robonomics-interface\\na Python library which specializes in interfacing with Robonomics to convenient programming.\\n\\n### Robonomics on Ethereum\\na version of Robonomics Network running on top of Ethereum, released in 2018.\\n\\n### Robot Economy\\nan economic system in which devices act as independent agents capable of performing key economic activities previously unique to humans.\\n\\n### Robot-as-a-Service\\nor RaaS — a business model where companies rent their robotics equipment to clients and customers for short-term or long-term use.\\n\\n### ROS\\nor Robot Operating System — a framework for robot software development, that provides services designed for a heterogeneous computer cluster such as hardware abstraction, low-level device control, implementation of commonly used functionality, message-passing between processes, and package management.\\n\\n### ROS 2\\nan updated and rebuilt version of Robot Operating System with new features, such as support for multi-robot and small embedded systems, and integration with real-time.\\n\\n### ROS 2 Middleware\\nor RMW — a protocol that provides standard ROS 2 features such as discovery, serialization, and transportation; ROS 2 supports multiple middleware implementations that can chosen to best suit for project requirements.\\n\\n### RWS\\nor Robonomics Web Services — decentralized infrastructure services for robotics and IoT that lets connect devices easily and interact with user applications, cloud services, and other devices securely; it has its own token also called RWS, witch gives lifetime IoT subscription in Robonomics parachain.\\n\\n### Runtime\\na state transition function of a blockchain which defines a valid algorithm for determining the state of the next block given the previous state.\\n\\n\\n## S\\n\\n### Seed Phrase\\na human-readable private key created as a sequence of random words and required to get access to blockchain address and its tokens.\\n\\n### Shared Security\\nthe security model of Polkadot / Kusama whereby all chains are equally secured by placing proofs of the validity of parachain blocks into the Relay Chain such that a potential attacker would need to attack the entire system.\\n\\n### SLS Gateway\\nan open source IoT gateway for Zigbee devices based on the ESP32 microcontroller developed by Smart Logic System.\\n\\n### Slot (of Parachain)\\na scarce resource in Polkadot / Kusama ecosystem, that allows parachain to be connected to the Relay Chain without fee for each block.\\n\\n### Smart Leasing\\na Robot-as-a-Service model variant, in which rent is paid not by time, but for specific operations and their number.\\n\\n### Smart Contract\\na program or algorithm stored on a blockchain that run automatically when predetermined conditions are met.\\n\\n### SSH\\nor Secure Shell — a network protocol for operating network services securely over an unsecured network, that uses public-key cryptography to authenticate the remote computer. \\n\\n### Staking\\nthe part of the Proof-of-Stake consensus, an act of bonding tokens by depositing them as collateral for a chance to produce a valid block and obtain a reward.\\n\\n### Substrate\\na modular framework for building blockchains like Polkadot and Kusama.\\n\\n\\n## T\\n\\n### Treasury\\na pot of funds collected through a portion of block production rewards, transaction fees, staking, etc., that can be spent by making a spending proposal; if the Treasury ends a spend period without spending all of its funds, it suffers a burn of a percentage of the funds.\\n\\n### Transaction Costs\\nthe cost of collecting and processing information due to the bounded rationality of economic agents and complexity of the processes.\\n\\n\\n## V\\n\\n### Validator\\na node that secures the Relay Chain by staking its tokens, validating proofs from collators on parachains and voting on consensus along with other validators.\\n\\n\\n## W\\n\\n### Web3\\nan idea for a new iteration of the Web which incorporates concepts such as decentralization, blockchain technologies, and token-based economics.\\n\\n### Wiener (XRT)\\nor Wn — a billionth share of one XRT token, 1 XRT = 1 000 000 000 Wn; named after Norbert Wiener, an American mathematician, one of the founders of cybernetics and the theory of artificial intelligence.\\n\\n\\n## X\\n\\n### XCM\\nor Cross-Consensus Message Format — a format of messaging between different blockchain systems in Polkadot / Kusama.\\n\\n\\n### XRT\\na native token for Robonomics Network, that exists independently on the Ethereum and Kusama networks.\\n\\n\\n## Y\\n\\n### Yggdrasil\\nan overlay network implementation of a fully end-to-end encrypted routing scheme for mesh networks.\\n\\n\\n## Z\\n\\n### Zigbee\\na wireless communication protocol, very commonly used for connecting smart devices because of low power consumption, easability and flexibility of configuration, and support of self-organizing and self-recovering network topology.\\n\\n### Zigbee Adapter\\na device that transfers data between the Zigbee network and another network (i.e. Wi-Fi) for controlling Zigbee devices.\\n\\n### Zigbee2MQTT\\na software that allows connecting Zigbee to MQTT networks by translating messages from the one network to another. \"}},{\"node\":{\"id\":\"20fd80c63512e4dec1cc55d947b53805\",\"title\":\"Global Administration\",\"path\":\"/docs/global-administration/\",\"content\":\"\\n**This article will show you how to set up a new user to your Home Assistant.**\\n\\n## Adding Users to Subscription\\n\\nYou cannot use previously created accounts because `SUB_OWNER` and `SUB_CONTROLLER` provide security, and the first user you created when you first started Home Assistant does not have a Robonomics Parachain account.\\n\\n1. Create an account on Robonomics parachain, as you did in the [previous article](/docs/sub-activate/).\\n\\n2. Using `SUB_OWNER` account add new user account to the subscription in the [dapp](https://dapp.robonomics.network/#/subscription/devices). Now there should be three addresses in the access list: `SUB_OWNER`, `SUB_CONTROLLER` and `USER`.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmSxzram7CF4SXpVgEyv98XetjYsxNFQY2GY4PfyhJak7H', type:'mp4'}]\\\" />\\n\\n\\n## Granting Access to User\\n\\n1. Go to the dapp service called [Home Assistant Account](https://dapp.robonomics.network/#/home-assistant). Choose the account you've just created at the right sidebar (check that you have chosen the intended account by pressing the profile icon).\\n\\n2. Enter the `USER` seed in the required field. Add `SUB_OWNER` and `SUB_CONTROLLER` addresses in the administrator credits fields. If everything is correct, you will see verification status `VERIFIED`.\\n\\n3. Create a password for a new user which you have just registered and then confirm the transaction, that will now be without fee due to the subscription. Later you can restore the password in the Restore tab.\\n\\n4. After the registration process, log in to Home Assistant with your user address as login and a newly-created password.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmW2TXuwCYXzgcRfEUx4imZU5ZerEzkuD5P53u9g2WnxDh', type:'mp4'}]\\\" />\\n\\nNow you can use the dapp to control your home through Robonomics, check [**\\\"Get Smart Home Telemetry\\\"**](/docs/smart-home-telemetry/) article.\\n\\n## Troubleshooting\\n\\n1. If you forget a password to Home Assistant from your Robonomics account, [check the Dapp.](https://dapp.robonomics.network/#/home-assistant) \\nGo to \\\"Your Home Assistant password\\\" part and choose \\\"Restore\\\" tab.\\n\"}},{\"node\":{\"id\":\"39fcfe0df696631025ff0176e29d8413\",\"title\":\"Getting Started\",\"path\":\"/docs/getting-started/\",\"content\":\"\\n## What is Robonomics\\n\\nRobonomics platform provides tools for working with the robot economy network. Robonomics allow designers of smart cities and industry 4.0 zones to build trust among the [autonomous robots services](/docs/glossary#cyber-physical-system), provide [direct user access via dapp](/docs/glossary#dapp) for ordering products from autonomous factories and services of urban sensor networks. This in turn will allow us to put in place a decentralized system that globally monitors the activities of cyber physical systems.\\n\\nThe following chart describes what place Robonomics takes in the scenario:\\n\\n<robo-wiki-picture src=\\\"robonomics_network_basic_scheme.jpg\\\" alt=\\\"Robonomics Network scenario\\\" />\\n\\n<!-- ![Robonomics Chart](./images/robonomics_network_basic_scheme.jpg \\\"Robonomics Network scenario\\\") -->\\n\\nFind more in [Building dApps on Robonomics deck](https://gateway.pinata.cloud/ipfs/QmNNdLG3vuTsJtZtNByWaDTKRYPcBZSZcsJ1FY6rTYCixQ/Robonomics_keypoint_March_2021.pdf)\\n\\n## Robonomics Network quick start\\n**For newcomer's convenience core Robonomics developers came up with a [6 lessons learning curve](/docs/wschool2021-intro/)!**\\n\\nYou'll explore the serverless IoT architecture! Robonomics Web Services (RWS) is the basic infrastructural service for Robotics and IoT on top of Polkadot && IPFS.\\n\\nCourse graduates can launch a local relay chain and control a ROS-compatible device through cross-chain transaction.\\n\\n**[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.**\\n\\n### Benefits for Robonomics Academy graduates\\n- Intership for best students   Become a Robonomics team member and contribute to the development of the chosen product.\\n- Active community && regular events   Become a part of the learner's community, discuss your use-cases with industry experts. Team-up and participate in hackathons!\\n- Certificate of completion   Add a certificate for completing the course on building DAPPs for IoT to your portfolio.\\n- Assistance in admission to the ITMO university. Whether you are a bachelor or master, you'll get assistance in your admission to the university.\\n- Funding && acceleration opportunities: 1)Apply for up to $50.000 Academia - support grant; 2)Participate in Robonomics builders acceleration program supported by Web3 Foundation; 3)Deploy your stand-alone DAPP on top of Robonomics; 4)Monetize it && get marketing support from Robonomics team.\\n\\n\\n## What the documentation contains\\n\\n### I'm a Dapp developer\\n\\n- [Robonomics-js on GitHub](https://github.com/airalab/robonomics-js) - simple Javascript SDK for Robonomics Network dApp developers.\\n- [dApp template](https://github.com/airalab/vue-dapp-robonomics-template) - uses Vue.js\\n- [Wiki documentation](/docs/robonomics-js/)\\n\\n### I'm a robotics engineer\\n\\nCheck out [cases](/docs/iot-sensors-connectivity/) section and start developing by [examples](/docs/agent-development-examples).\\n\\n\"}},{\"node\":{\"id\":\"5b98aab4f8a8c988596942ab2372f6b3\",\"title\":\"How to Buy a Subscription\",\"path\":\"/docs/get-subscription/\",\"content\":\"\\n**Paying commissions for transactions in blockchain is annoying. Imagine an IoT device which sends telemetry every 5-10 minutes. This will make you pay quite a lot through month. One of the key features of Robonomics Network is RWS - Robonomics Web Service subscription. Pay monthly and forget about transaction cost! For theoretical background refer to [this](https://blog.aira.life/rws-overview-part-2-heterogeneous-tokenomics-afc209cc855) article.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Parachain\\\">\\n\\n  Pay attention that this tutorial demonstrates buying a subscription on Robonomics Kusama parachain. You can also perform all the same steps on your [local node](/docs/run-dev-node).\\n\\n  One more thing before start. This is a \\\"hard\\\" way of buying a subscription. There is a conventional way to do this through [Robonomics DApp](https://dapp.robonomics.network/#/).\\n\\n</robo-wiki-note>\\n\\n## Bid an Auction\\n\\nThe subscriptions in Robonomics are sold with an auction model. To get one, you need to bid an auction and win it (no worries, it's fast).\\n\\nIn `Developer/Chain state` you can see available auctions. \\nChoose `rws` and `auctionQueue` and press `+` button, you will see IDs of available auctions:\\n\\n![queue](./images/rws/queue.png)\\n\\nYou can see an information about any subscription with `rws` `auction` and ID of auction (the auction's ID in the picture is 79):\\n\\n![auction](./images/rws/auction.png)\\n\\nIn the information about the auction you can see `winner` field, at the moment it is `null` so nobody has this subscription and you can get it. For that go to `Developer/Extrinsic`, choose your account and `rws -> bid`. Also set auction ID (79) and the amount of units to bid (more than 1000000000 Wn):\\n\\n![bid](./images/rws/bid.png)\\n\\nSubmit the transaction and check the information about the auction with ID 79 (in `Chain state` choose `rws -> auction` and ID 79):\\n\\n![win](./images/rws/auc_win.png)\\n\\nNow in `winner` field you will see your account address, it means that this account has the subscription 79. An auction starts with the first bid and lasts a few blocks, so if somebody bids more tokens than you in the next few blocks this one will be the winner and will take the subscription.\\n\\nNow you can add devices. Devices are accounts that are able to use this subscription and submit extrinsics with no fee.\\nTo test it create a new account with no tokens and add it to devices. \\n\\nTo add devices choose `rws -> setDevices` in `Developer/Extrinsic`. Then press `Add Item` button and choose recently created account with no tokens:\\n\\n![set_devices](./images/rws/set_devices.png)\\n\\nSubmit the transaction. Now you can check the list of devices in `Chain state` with `rws -> devices`. There you will see the address of your account without tokens. Choose the account that has bought the subscription and press `+`:\\n\\n![devices](./images/rws/devices.png)\\n\\nNow you can try to [send launch](/docs/subscription-launch) extrinsic using the subscription.\"}},{\"node\":{\"id\":\"c269f813cf2d134fcc3ab427be966032\",\"title\":\"Connect an Amazon FreeRTOS Device to Robonomics by MQTT\",\"path\":\"/docs/freertos-mqtt/\",\"content\":\"\\nHere's the demonstration of how a microcontroller running [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) may be connected to Robonomics Network via MQTT. Please check [this repository](http://github.com/khssnv/freertos_mqtt_robonomics_example) for the project source code.\\n\\nWe use [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) with FreeRTOS distribution and MQTT implementation provided by [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) while Espressif is a vendor of the microcontroller used.\\n\\nAlso there is a [PMS-3003](http://www.plantower.com/en/content/?107.html) sensor for demonstration purposes. Sensor measures presence of particulated matter in the air and one may use it to estimate air quality.\\n\\nAir quality is not a topic of the article, you may find more about it at WHO's website: [Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). A goal of the system is to publish sensor measurements to Airalab's Robonomics network.\\n\\n## Hardware setup\\n\\nWe connect PMS3003 TXD PIN5 to ESP32 DevKitC IO17 to transfer measurements by UART.\\nAlso both devices require power and common ground.\\n\\n![Wiring Diagram](./images/freertos-mqtt/wiring.png)\\n\\n## Data Flow\\n\\nIn order to deliver sensor measurements to Robonomics network, on a firmware level our goal is to get data from a sensor by embedded communication protocol it supports (UART in our case) and pass it to AIRA instance by MQTT / TCP.\\n\\n![Sending](./images/freertos-mqtt/send.svg)\\n\\nIn our example we use AIRA cloud deployment available by public IP address and domain name assigned.\\nOn AIRA instance we setup `mosquitto` MQTT broker and subscribe to `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` topic to get messages from MQTT.\\n\\nThen we pass messages to `robonomics io` writer by pipe.\\n\\n![Receiving](./images/freertos-mqtt/recv.svg)\\n\\nNow data available in Robonomics Network and we can be read it with `robonomics io` again.\\n\\n## Firmware\\n\\nWe use [ESP-MQTT sample application with TCP transport](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) as a basis.\\n\\nWe only modify `main/app_main.c` for UART connection to the sensor, SNTP time synchronization and periodic MQTT publisher routine.\\n\\nIf you are trying to repeat the project, and it's your first ESP IDF based project, at first please follow [Espressif's ESP-IDF Programming guide](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) introduction in order to familiarize with firmware operations like configuration, build and upload with `idf.py` tool.\\n\\n### Wi-Fi Configuration\\n\\nIn order to communicate with AIRA instance deployed in cloud, our microcontroller requires Internet connection.\\nWe use ESP32's Wi-Fi for it.\\nEspressif provides utilities to configure on-board Wi-Fi.\\nIn our example we use development environment with Ubuntu 20.04 GNU/Linux.\\nTo configure Wi-Fi we go to project folder and run SDK configuration tool.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nThen we set Wi-Fi access point SSID and password in `Example Connection Configuration` section.\\n\\n![Menuconfig Wi-Fi](./images/freertos-mqtt/menuconfig-wi-fi.png)\\n\\n### MQTT Endpoint Configuration\\n\\nThere are two things to configure for MQTT.\\nThe first is a MQTT broker address.\\nIt is configurable with SDK configuration tool.\\n\\n```console\\ncd freertos_mqtt_robonomics_example/firmware\\nidf.py menuconfig\\n```\\n\\nSet `Broker URL` in `Example Configuration` section.\\n\\n![Menuconfig MQTT](./images/freertos-mqtt/menuconfig-mqtt.png)\\n\\nThe second thing is a MQTT topic.\\nWe set it in the firmware with the project name prefix followed with our ESP32 MAC address.\\nIt gives us `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` for our particular microchip.\\n\\n## From MQTT to Robonomics\\n\\nAt first let's check we receive data by MQTT.\\nWe can subscribe to our Mosquitto MQTT broker topic device publish to.\\n\\n```console\\n$ nix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\"\\nts=1615651809, PM1=2, PM2.5=6, PM10=3\\n```\\n\\nHere we bring `mosquitto` package into our environment to use `mosquitto_sub` utility.\\nThen we subscribe to the topic set in the firmware.\\nWe got our measurements that means AIRA receives data by MQTT correctly.\\nNow let's pipe these messages to Robonomics Network.\\n\\n```console\\nnix-shell -p mosquitto --run \\\"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\\\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n```\\n\\nHere we use `robonomics` utility to publish messages in pubsub channel `/freertos_mqtt_robonomics_example`.\\nWe specify `bootnodes` to ensure at least one connection established.\\n\\nNow we are read these messages from the same pubsub channel.\\n\\n```console\\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\\n2021-03-27 15:15:56  New peer connected: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\")\\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\\\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\\\") in topic: TopicHash { hash: \\\"_robonomics_pubsub_peer_discovery\\\" }\\nts=1616843855, PM1=3, PM2.5=4, PM10=3\\n```\\n\\n## Original Resources Used\\n\\n* ESP32 DevKitC pinout from GoJimmy's blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\\n* PSM3003 data structure and decoder from OpenAirProject https://github.com/openairproject/sensor-esp32\\n\\n**Thank you all!**\\n\"}},{\"node\":{\"id\":\"b5688171357b9dbae6d3e956d31f2752\",\"title\":\"Gaka-Chu setup and software Installation\",\"path\":\"/docs/gaka-chu/\",\"content\":\"\\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\\n\\n**In this article we will go through some installation and launching steps to set up a robot-painter. Requirements:**\\n- KUKA KR6 R900 sixx with KRC4 and a SmartPad;\\n- Intel NUC with [ROS melodic](http://wiki.ros.org/melodic/Installation/Ubuntu) installed;\\n- Table, paint, brush, water.\\n\\n## Software installation on KRC4\\nEKI interface is required on both, KRC4 and NUC. Detailed information on how to set it up on KRC4 is presented [here](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Launch it on robot's controller.\\n\\n## Software installation on NUC\\nCreate a catkin workspace:\\n```\\nmkdir -p ~/catkin_ws/src\\ncd ~/catkin_ws/\\ncatkin build\\n```\\nDownload ROS packages. All the scripts are stored [here](https://github.com/airalab/robot_painter/tree/test_branch). Clone the repository:\\n```\\ncd src\\ngit clone --branch test_branch https://github.com/airalab/robot_painter\\ncd robot_painter\\nrm -rf scenes\\nmv * ../\\ncd ..\\nrmdir robot_painter\\n```\\nYou may need some header files and libraries to make it all work correctly. Download them:\\n```\\ncd ~\\ngit clone https://github.com/PaTara43/kuka_moveit_webots\\ncd kuka_moveit_webots\\nsudo mv -r headers/* usr/include/c++/7/\\nsudo mv libs/* usr/local/lib/\\ncd ~\\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\\nmv matrix -r /usr/include/c++/7/\\nsudo apt-get install ros-melodic-brics-actuator\\ncd ~/catkin_ws\\ncatkin build\\n```\\nAdd source command to `.bashrc` file:\\n```\\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\\nsource ~/.bashrc\\n```\\nUp to now. you should be able to launch the scripts. If something goes wrong, try some [troubleshooting](https://github.com/airalab/robot_painter/issues)\\n\\n## Filling in constants\\nFirst of all, the robot needs to know canvas location and orientation as well as the paint tin position. All of this is specified in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Let's take a look into it.\\n```\\n// Plane constants\\nconst double A = -0.0641;\\nconst double B = 0.0214;\\nconst double C = 0.9977;\\nconst double D = -0.2198;\\n\\n// Canvas transform\\nconst double px = 0.52;\\nconst double py = -0.24;\\nconst double qx = -0.011;\\nconst double qy = -0.032;\\nconst double qz = 0.0;\\nconst double qw = 0.999;\\n```\\nThese are the plane equation constants which specify canvas position in 3-D space. They are to be obtained during a calibration process described below. Next goes the paint.\\n```\\ncolorTransform.transform.translation.x = 0.5;\\ncolorTransform.transform.translation.y = 0.2;\\ncolorTransform.transform.translation.z = 0.258;\\n```\\nThese are paint tin coordinates. They also may be specified while calibrating. Canvas size is specified in\\n```\\ncanvas.width = 0.5;\\ncanvas.height = 0.4;\\n```\\nSeveral more important constants are stored in `local_task_planner/src/Drawing.cpp`:\\n```\\nconst double COLOR_BOTLE_HEIGHT = 0.06;\\nconst double COLOR_HEIGHT = 0.045;\\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\\nconst double BRUSH_HEIGHT = 0.01;\\nconst double BRUSH_WIDTH = 0.01;\\n```\\nTheir names say it all, so fill them in according to the situation.\\n\\n## Calibrating Gaka-Chu\\nThe calibration process itself is pretty simple.\\n\\n1) Start EKI interface on the KRC4:\\n\\nLog in in 'AUT' mode, turn on drivers and launch the script `eki_hw_interface`\\n\\n2) Start EKI interface on the NUC\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\nIt should output endless logs.\\n\\n3) Start RViz\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\nYou should see the following:\\n\\n![KUKA in RViz](./images/kuka-real/kuka_rviz.png \\\"KUKA in RViz\\\")\\n\\nTry moving the end effector and clicking 'Plan and Execute'. The robot should move. On SmartPad go to **Display -> Actual position** and observe end effector's coordinate. Place a canvas horizontally to the robot base. Plug a brush into the brush holder and carefully move it till it barely touches the canvas. At this position, save end effector's coordinates. Repeat 12-15 times. Also, save the coordinates of the canvas center and paint tin.\\nWhen you have a set of coordinates, use [these](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab scripts to resolve the missing constants and quaternion. Paste them. Rebuild your workspace with\\n```\\ncd ~/catkin_workspace\\nrm -rf build logs devel\\ncatkin build\\n```\\n\\n## Testing Gaka-Chu calibration\\nWhen calibrated, Gaka-Chu needs to be tested by drawing the borders of canvas. To make him do so execute each in new terminal:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\nroslaunch kuka_moveit_config demo.launch\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\nrosrun local_task_planner draw_workspace\\n```\\nAfter this, you should see a canvas contour in RViz:\\n\\n![KUKA in RViz canvas](./images/kuka-real/kuka_rviz_canvas.png \\\"KUKA in RViz canvas\\\")\\n\\nIn terminal press \\\"S\\\" to perform testing. Robot's end effector should move right above the borders of the canvas and the brush should gently touch the canvas during the entire movement. If not so, try recalibrating. If the canvas model is rotated wrong, you can rotate it by changing quaternion in Matlab.\\n\\n## Making art\\nYou need 6 basic modules to make it all work:\\n- EKI interface;\\n- MOVEit + RViz;\\n- Environment frames broadcasting;\\n- Picture converter service;\\n- Trajectories drawing module;\\n- Starting trigger.\\n\\nLet's launch them one by one.\\n\\n### Eki interface\\nOn KRC4 launch `eki_hw_interface`, on NUC in a new terminal do:\\n```\\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\\n```\\n\\n### RViz and MOVEit\\nYou need a planner and a simulation. Launch them with\\n```\\nroslaunch kuka_moveit_config demo.launch\\n```\\n\\n### Environment\\nTell the robot where the paint tin and the canvas are. Note that it is not necessary to launch `draw workspace` node, the `tf_broadcaster` shares the canvas size. It just doesn't show it in RViz.\\n```\\nrosrun fake_painter_enviroment_tf tf_broadcaster\\n```\\n\\n### Pictures processor\\nAll incoming pictures need to be processed. Launch the service.\\n```\\nrosrun picture_preprocessing TextConverter.py\\n```\\nWhen it receives the call, it processes a picture with a HP filter and creates a rosbag file with trajectories.\\n\\n### Trajectories drawer\\nThe mainest script here is the trajectories drawer itself. It waits for the picture, calls TextConverter service and draws the painting.\\n```\\nrosrun local_task_planner trajectory_drawing\\n```\\n\\n## Send the robot a picture to draw\\nThe robot listens to a specific ROS-topic where you need to pass the path to a desired picture. The picture should be square (width equals height) and made of lines. Send the path:\\n```\\nrostopic pub /run std_msgs/String \\\"data: '<path_to_picture>'\\\"\\n```\\nAfter that. Two windows pop up showing the contours and the tracks. Close them and see Gaka-Chu drawing. Watch out for safety and always be ready to press emergency stop button.\\nWhen Gaka-Chu finishes his art, you can send another path to picture and painter repeats the whole process.\\n\"}},{\"node\":{\"id\":\"33630dbe7de4a91f0f48f309c640672a\",\"title\":\"How to Edit Wiki\",\"path\":\"/docs/edit-wiki/\",\"content\":\"\\n**Robonomics Wiki is open source. Any corrections are welcome: fixing errors, typos, some unclear or outdated information, translation into any language. You'll need a [GitHub](https://github.com/) account.**\\n\\n\\n## How to edit\\n\\nIf you need to edit docs of Robonomics Wiki, please, follow these steps\\n\\nMake sure, you have [Node.js](https://nodejs.org/en/download/package-manager/) and [Gridsome](https://gridsome.org/docs/#1-install-gridsome-cli-tool) installed.\\n\\n### 1. Clone repo\\n\\nAt first, you need to clone the wiki repository:\\n\\n```\\ngit clone https://github.com/airalab/robonomics-wiki.git\\n```\\n\\nGo to the directory of the repository and run the following commands:\\n\\n`using npm`\\n```\\ncd robonomics-wiki\\nnpm install \\n```\\n\\n`using yarn`\\n```\\ncd robonomics-wiki\\nyarn install\\n```\\n\\n### 2. Serve locally (develop, develop-m1)\\n\\nThen deploy the project locally: \\n\\n```\\ngridsome develop\\n```\\n\\n> If you have the error `node: --openssl-legacy-provider is not allowed in NODE_OPTIONS`, run the following command:\\n```\\ngridsome develop-m1\\n```\\n\\n### 3. Make PR\\n\\n[Make pull request](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) to [wiki repo](https://github.com/airalab/robonomics-wiki)\\n\\n## Components\\n\\n### Asciinema\\nRobonomics Wiki has support for Asciinema. To insert Asciinema, please, follow these instructions:\\n* Import component after frontmatter block `import Asciinema from '~/components/Asciinema.vue'`\\n* Insert as separate paragraph `<Asciinema vid=\\\"WCFcx8C6M8e52UKDNei1xZloU\\\"/>`, where is vid is ID of specific asciicast\\n\\n> You can get the widget script for a specific asciicast by clicking on “Embed” link on asciicast page.\\n> It looks like this:\\n> `<script src=\\\"https://asciinema.org/a/14.js\\\" id=\\\"asciicast-14\\\" async></script>`\\n[Asciinema docs](https://asciinema.org/docs/embedding)\\n\\nIn the example above vid is 14.\\n\\n### Code\\n\\nYou can add helpful extras to your code: \\n\\n`code with copy button`\\n\\n```c\\n<code-helper copy>\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\nor `code with additional line`\\n\\n```c\\n<code-helper additionalLine=\\\"this line will be added above your code :)\\\">\\n  YOUR CODE HERE\\n</code-helper>\\n```\\n\\n**Properties for code-helper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'copy', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add a copy button for your code'}]}, { id: 1, items: [{ name: 'additional line', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `additional line for you code that will be displayed above`}]}]\\\" />\\n\\n<code-helper copy>\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n<code-helper copy additionalLine=\\\"your@helper\\\">\\n\\n```bash\\n$ ls -l /dev/serial/by-id\\n```\\n\\n</code-helper>\\n\\n\\n### Frontmatter\\nDocs in Robonomics Wiki contain frontmatter block. It must be at the top of the Markdown file, and must take the form of valid YAML set between triple-dashed lines. Between the triple-dashed lines, you can set or edit folowing options:\\n\\n```YAML\\n---\\ntitle: How to contribute # Title for the page, you do not need to duplicate it in text\\ncontributors: [positivecrash] # Main contributors (who actively curates this page). GitHub nickname required, without any additional symbols\\ntools:   \\n  - rust 1.62.0 \\n    https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html\\n  - Robonomics 1.4.0\\n  - baxter\\n    http://wiki.ros.org/melodic/Installation\\n    # Tools that were used for technology testing\\n---\\n```\\n\\n### Grid \\nHelps to add grid layout to elements:\\n\\n- Use grid wrapper component first: \\n\\n```c\\n<robo-wiki-grid-element-wrapper></robo-wiki-grid-element-wrapper>\\n```\\n\\n- And then use as many grid items components as you like inside wrapper:\\n\\n```c\\n  <robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n      <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n    </robo-wiki-grid-element>\\n    <robo-wiki-grid-element>\\n      <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n      <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n      <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n    </robo-wiki-grid-element/>\\n  </robo-wiki-grid-element-wrapper>\\n```\\n\\n**Properties for robo-wiki-grid-element-wrapper**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'columns', code: true}, {name: 'Number', code: true}, {name: false, code: true}, {name: 4, code: true}, {name: [{text: 'you can choose column number:'}, {text: `from`, codeText: ' 1 to 5'}]}]}, { id: 1, items: [{ name: 'align', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the block axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 2, items: [{ name: 'justify', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: [{text: 'align items on the inline axis:'}, {text: `options:`, codeText: 'start, center, end'}]}]}, { id: 3, items: [{ name: 'textAlign', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'left', code: true}, {name: [{text: 'align text inside grid'}, {text: `options:`, codeText: 'left, center, right'}]}]}, ]\\\" />\\n\\n\\n<robo-wiki-grid-element-wrapper textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_1.png\\\" /> \\n    <p><a href=\\\"https://www.home-assistant.io/\\\">Home Assistant</a> as control system software</p> \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_2.png\\\" /> \\n    <p>Raspberry Pi 4 (at least 2 GB RAM)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_3.png\\\" /> \\n    <p>SD card (minimum 16 GB)</p>  \\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_4.png\\\" /> \\n    <p>SD adapter</p>\\n  </robo-wiki-grid-element>\\n</robo-wiki-grid-element-wrapper>\\n\\n<robo-wiki-grid-element-wrapper :columns=\\\"2\\\" textAlign=\\\"center\\\">\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_5.png\\\" />\\n    <p>Zigbee smart devices (any from <a href=\\\"https://slsys.io/action/supported_devices.html\\\">supported devices</a>)</p>\\n  </robo-wiki-grid-element>\\n  <robo-wiki-grid-element>\\n    <robo-wiki-picture src=\\\"home-assistant/need_6.png\\\" /> \\n    <p>Zigbee adapter <a href=\\\"https://jethome.ru/z2/\\\">JetHome USB JetStick Z2</a> (or one of <a href=\\\"https://www.zigbee2mqtt.io/information/supported_adapters.html\\\">supported</a>) or \\n    <a href=\\\"https://easyeda.com/ludovich88/robonomics_sls_gateway_v01\\\">Robonomics SLS Gateway</a></p>\\n  </robo-wiki-grid-element/>\\n</robo-wiki-grid-element-wrapper>\\n\\n\\n### Images\\n\\n#### How to upload \\nUpload image in folder `/docs/images/url-of-your-doc`\\n* If image needs to be localized, insert all of them in one folder\\n* Use locale appendix in name of images if it's localized, e.g. `image_en.jpg`\\n* Make sure your image is web optimized and at the same time it looks good\\n\\n#### How to insert \\n\\nThere are two ways for inserting pictures in your documents:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nIt is recommended to insert pictures with built-in tag `<robo-wiki-picture>`, however you may also use standard way for Markdown files.\\n\\n</robo-wiki-note>\\n\\n`with caption`\\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`or without caption` \\n\\n```c\\n<robo-wiki-picture link=\\\"/docs/community\\\" src=\\\"example_image.jpg\\\" />\\n```\\n\\n`or simple image` \\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" />\\n```\\n\\n`or simple image with caption`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" />\\n```\\n\\n`image with alt`\\n\\n```c\\n<robo-wiki-picture src=\\\"example_image.jpg\\\" caption=\\\"EXPLORE ROBONOMICS WIKI\\\" alt=\\\"this is alternative text for image\\\" />\\n```\\n**Properties for robo-wiki-picture:**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'src', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `path to the image:`}, {text: `if you uploaded your image directly to the /docs/images/ use:`, codeText: 'url-of-your-doc'}, {text: `if you uploaded image in one of the folders than use:`, codeText:  `folder-name/url-of-your-doc`}]}]}, { id: 1, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `link to the needed page`}]}, {id: 2, items: [{ name: 'caption', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `caption for the image`}]}]\\\" />\\n\\n### Notes & warnings\\nYou can add notes and give them specific types:\\n* warning (<span style=\\\"color:#f08432\\\">**orange color**</span>)\\n* okay (<span style=\\\"color:#3eaf7c\\\">**green color**</span>)\\n* note (<span style=\\\"color:#90a4b7\\\">**grey color**</span>)\\n\\n`note with title`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Some information about robots\\\" />\\n```\\n\\n`note with content`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\">Fascinating information about robonomics here only</robo-wiki-note>\\n```\\n\\n`note with title and content`\\n\\n```c\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Robonomics for you\\\">\\n  Fascinating information about robonomics here only\\n</robo-wiki-note>\\n```\\n\\n<robo-wiki-note type=\\\"okay\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Join Discord\\\">\\n\\n[Join Robonomics Developers Discord](https://discord.gg/jTxqGeF5Qy) to connect with community and get technical support.\\n\\n</robo-wiki-note>\\n\\n**Properties for robo-wiki-note**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'note', code: false}, {name: [{text: `there are three types in total:`, codeText: 'note, warning, okay'}]}]}, { id: 1, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `adds title to your note`}]}]\\\" />\\n\\n### Tabs\\nYou can add tabs to the doc:\\n\\n- Use tabs wrapper component: \\n\\n```c\\n<robo-wiki-tabs></robo-wiki-tabs>\\n```\\n\\n- And then use as many tab items components as you like inside wrapper:\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n\\n`horizontal tabs`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`vertical tabs`\\n\\n```c\\n  <robo-wiki-tabs mode=\\\"vertical\\\">\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\">\\n      <pre>ifconfig</pre>\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n`tab item with border`\\n\\n```c\\n  <robo-wiki-tabs>\\n    <robo-wiki-tab title=\\\"Linux\\\">\\n      <pre>ip a</pre>\\n    </robo-wiki-tab>\\n    <robo-wiki-tab title=\\\"OSX\\\" border>\\n      ifconfig\\n    </robo-wiki-tab>\\n  </robo-wiki-tabs>\\n```\\n\\n**Properties for robo-wiki-tabs (wrapper)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'mode', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: 'horizontal', code: false}, {name: [{text: 'you can choose tabs mode:'}, {text: ``, codeText: ' horizontal'}, {text: ``, codeText: 'vertical'}]}]}]\\\" />\\n\\n**Properties for robo-wiki-tab (item)**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'title', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'title for the tab'}]}, { id: 1, items: [{ name: 'border', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: 'add border to the content wrapper'}]}]\\\" />\\n\\n\\n<robo-wiki-tabs>\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\" border >\\n      ifconfig \\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n<robo-wiki-tabs mode=\\\"vertical\\\">\\n  <robo-wiki-tab title=\\\"Linux\\\">\\n    <pre>ip a</pre>\\n  </robo-wiki-tab>\\n  <robo-wiki-tab title=\\\"OSX\\\">\\n    <pre>ifconfig</pre>\\n  </robo-wiki-tab>\\n</robo-wiki-tabs>\\n\\n\\n### Title with anchors\\nYou can create custom titles with anchors and give them certain value\\n\\n`title with anchor`\\n\\n```c\\n<robo-wiki-title :type=\\\"2\\\" anchor=\\\"Some information about robots\\\"> \\n  Learn Robonomics :)\\n</robo-wiki-title>\\n```\\n\\nor\\n\\n`title without anchor`\\n\\n```c\\n<robo-wiki-title :type=\\\"5\\\"> \\n  Learn with us ;)\\n</robo-wiki-title>\\n```\\n\\n**Properties for robo-wiki-title**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'type', code: true}, {name: 'Number (from 2 to 6)', code: true}, {name: true, code: true}, {name: null, code: false}, {name: 'choose heading level'}]}, { id: 1, items: [{ name: 'anchor', code: true}, {name: 'String', code: true}, {name: false, code: true}, {name: null, code: false}, {name: `value for the anchor`}]}]\\\" />\\n\\n<robo-wiki-title :type=\\\"6\\\"> \\n I'm custom title :)\\n</robo-wiki-title>\\n\\n### Videos\\n\\nThere are two ways for inserting videos in your documents:\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nIt is recommended to insert videos with built-in tag `<robo-wiki-video>`, however you may also use standard way for Markdown files.\\n\\n</robo-wiki-note>\\n\\n#### IPFS / Server\\nYou need to specify format of video\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmdZKkPJCa9GEN43iUBX81jfrFTDxcn7J6wWURrwNVwcKx', type:'webm'}, {src: 'https://cloudflare-ipfs.com/ipfs/QmStCDsEHCYwVYvnDdmZBMnobPmrgZx3iJLm65b8XNzKQa', type:'mp4'}]\\\" />\\n```\\n\\n#### Local\\n\\n```c\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: '/videos/add-ext.mp4', type:'mp4'}]\\\" />\\n```\\n\\n##### Properties\\n\\n- If you adding a file with the size of more than <span style=\\\"color:#af1c1c\\\">10MB</span>, please, upload it on server, not in repo.\\n\\n- You may use any properties for [HTML5 video tag](https://www.w3schools.com/tags/tag_video.asp).\\n\\n- Acceptable formats - mp4, webm, ogg.\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'videos', code: true}, {name: 'Array', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `Array of objects [{src: 'path to video', type: 'type of video'}]`}]}]}]\\\" />\\n\\n\\n#### YouTube \\nYou can embed any YouTube video in doc by inserting share link as separate paragraph without any additional quotes or tags, e.g.: `https://youtu.be/kQaSwNYHJQ8`\\n\\nHowever, if you need an autoplay you must use special component: \\n\\n```c\\n<robo-wiki-youtube autoplay link=\\\"https://www.youtube.com/watch?v=5s4-S_z4VYE\\\" />\\n```\\n\\n**Properties for robo-wiki-youtube**\\n\\n<probs-table :items=\\\"[{ id: 0, items: [{ name: 'link', code: true}, {name: 'String', code: true}, {name: true, code: true}, {name: null, code: false}, {name: [{text: `link to youtube video`}]}]}, { id: 1, items: [{ name: 'autoplay', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `autoplays youtube video`}]}]}, { id: 2, items: [{ name: 'loop', code: true}, {name: 'Boolean', code: true}, {name: false, code: true}, {name: false, code: true}, {name: [{text: `loop youtube video`}]}]}]\\\" />\\n\\n\\n## How to edit sidebar navigation\\n\\nIf you need to edit sidebar navigation of Robonomics Wiki, please, follow these steps:\\n\\n* Edit file `/data/sidebar_docs.yaml`.\\n\\n* Decide where to place your doc\\n\\n* Use valid YAML for `/data/sidebar_docs.yaml` and rely on the existing file structure\\n\\n* **IMPORTANT NOTE:** if you're using the same doc in different sections/subsections e.g: \\n\\n```\\n\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n\\n```\\n\\nMAKE SURE TO ADD `topic` PARAMETER LIKE THIS: \\n\\n(for navigation to work properly) \\n\\n```\\n    - title_en: Upgrade Home Assistant OS\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Upgrade Home Assistant OS\\n    - title_en: Pre-installed Image For Raspberry Pi\\n      items:\\n        - title_en: Buying a Subscription\\n          link: /docs/sub-activate\\n          topic: Pre-installed Image For Raspberry Pi\\n\\n```\\n\\n## How to add custom navigation for docs \\n\\n* Edit file `/data/sidebar_docs.yaml`.\\n\\n* Find the right doc and add parameters `prev` and `next` like this: \\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      prev: \\n        - title: title of the previous page\\n          link: /docs/prev_page_url\\n      next: \\n        - title: title of the next page\\n          link: /docs/next_page_url\\n\\n```\\n\\n* If you want to remove navigation completely than add `withoutNav` parameter:\\n\\n```\\n    - title_en: How to Edit Wiki\\n      link: /docs/edit-wiki\\n      withoutNav: true\\n```\\n\\n* If you want to remove just `previous page` or `next page` navigation than add `withoutPrev` or `withoutNext` parameter:\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutPrev: true\\n```\\n\\nor\\n\\n```\\n- title_en: How to Edit Wiki\\nlink: /docs/edit-wiki\\nwithoutNext: true\\n```\"}},{\"node\":{\"id\":\"4880febaad35269fd72b5b916dcc3c3b\",\"title\":\"Get Notified When Door Opens\",\"path\":\"/docs/door-notification/\",\"content\":\"\\nIn this article you will install the Telegram bot notifier integration and configure an automation, which will send to your Telegram account notification when a door is open.\\n\\n## Telegram Bot Notifications\\n\\nFirst, you need to create a personal Telegram bot. For this go to the [special Telegram bot @BotFather](https://t.me/botfather) and follow instruction. \\nSave your token for accessing the HTTP API.\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/bot-father.mp4\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\">\\n\\nKeep your token **secure** and store it **safely**, it can be used by anyone to control your bot \\n\\n</robo-wiki-note>\\n\\nNext step is find your ***User Chat ID***. For this use the next [GetIdsBot](https://t.me/getidsbot). \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/get-id-bot.mp4\\\" />\\n\\nNow let's install \\\"Telegram broadcast\\\" integration. This integration will send messages to your Telegram.\\n\\nFor Robonomics pre-installed image, Home Assistant Docker or Home Assistant Core you have to edit `configuration.yaml`. Connect to your Raspberry Pi via `ssh`:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/open-config.mp4\\\" />\\n\\n<code-helper additionalLine=\\\"rasppi_username@rasppi_hostname\\\" >\\n\\n```shell\\nsudo -u homeassistant -H -s\\ncd\\ncd .homeassistant \\nnano configuration.yaml\\n```\\n\\n</code-helper >\\n\\nPaste next lines to the end of file. Insert your **bot API key** and **your User Chat ID**. Also create a name for your notify service:\\n\\n\\n<code-helper copy >\\n\\n```shell\\ntelegram_bot:\\n  - platform: broadcast\\n    api_key: <YOUR_API_KEY>\\n    allowed_chat_ids:\\n      -  <YOUR_USER_CHAT_ID> # 123456789  example id of a user\\n      \\nnotify:\\n  - platform: telegram\\n    name: <NOTIFIER_NAME>\\n    chat_id: <YOUR_USER_CHAT_ID>\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-config.mp4\\\" />\\n\\n**Save configuration and reload Home Assistant.**\\n\\n\\nAs result, in your Home Assistant service will be created service, which will send any message to the Telegram chat with you. \\nYou can check it in Developer Tools menu on Home Assistant web interface. \\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/telegram-result.mp4\\\" />\\n\\n##  Door Open Notification\\n\\nNow it's time to create automation. First, you import blueprint to your Home Assistant from this link:\\n\\n<code-helper copy>\\n\\n```shell\\nhttps://github.com/airalab/home-assistant-blueprints/blob/main/door-opened-notifications/door-notifications.yaml\\n```\\n\\n</code-helper >\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/insert-blue.mp4\\\" />\\n\\nAnd create automation:\\n\\n<robo-wiki-video controls src=\\\"https://static.robonomics.network/wiki/create-automation.mp4\\\" />\\n\\nNow you will receive message from Telegram bot every time the door is open.\\n\\n<robo-wiki-note type=\\\"okay\\\">\\nYou can use this automation with any doors/windows in your home.\\n</robo-wiki-note>\\n\\n\"}},{\"node\":{\"id\":\"d911b3cc8a9d53b95952a35cae02e42f\",\"title\":\"Digital Twins\",\"path\":\"/docs/digital-twins/\",\"content\":\"  \\n**Imagine having a complicated device or system which has several modules to maintain and requires a few accounts to use. To keep all of them in one place or to encode some functionality with separate accounts or, for example, to set different datalog sources for different information flows, Digital Twin module is to be used.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Please pay attention that this and following tutorials are demonstrated on a local instance of Robonomics Node. Set up yours with [these instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## Theory overview\\nAny account can create and manage a Digital Twin. The Twin may be imagined as some sort of table with the following contents:\\n\\n| DT id  | Topic Name \\t| Source    \\t|\\n|--------|------------\\t|-----------\\t|\\n| 0      | 0x00...000 \\t| 4Gz...hQJ \\t|\\n| 1      | 0x00...001 \\t| 4GVi...Bn \\t|\\n| \\t      | 0x00...002 \\t| 4Hm...vLS \\t|\\n| \\t      | 0x00...... \\t| 4HQ...RQY \\t|\\n| n\\t  | 0xFF...FFF \\t| 4Hw...CyK \\t|\\n\\n\\nWhere:\\n* **DT id** is unsigned integer unique Digital Twin index.\\n* **Topic name** is a hex `H256` or ASCII data of 32 bytes length, same as [`Launch`](/docs/launch) extrinsic parameter. \\nFor example: `0x1234....FF` or  `hello.parachain.robonomics.world`.\\n* **Source** - is some Account address.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Topics\\\">\\n\\n  As have been discussed previously in Launch extrinsic overview, the `H256` may be represented as an encoded IPFS CID (see\\n  [Python tool](https://multi-agent-io.github.io/robonomics-interface/modules.html#robonomicsinterface.utils.ipfs_qm_hash_to_32_bytes) for that).\\n  Therefore, topics may be used as some data storage as well, say, a Twin's module description.\\n\\n</robo-wiki-note>\\n\\n\\n## Create Digital Twin\\n\\n### 1. Navigate to Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/extrinsics.jpg\\\" />\\n\\n### 2. Choose digitalTwin -> create from the dropdown list of possible extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/twin-create.jpg\\\" />\\n\\nSubmit the transaction. Here, no parameters needed to create a Twin. It will be granted an index and only the Digital Twin owner is able to add/modify topics of the Twin from now on.\\n\\nTwin ID may be found on the Explorer overview page.\\n\\n<robo-wiki-picture src=\\\"digital-twin/create-log.jpg\\\" />\\n\\n## Add Topic\\n\\n### Choose digitalTwin -> setSource from the dropdown list of possible extrinsics\\n\\n<robo-wiki-picture src=\\\"digital-twin/set-topic.jpg\\\" />\\n\\n* `id` - Digital Twin ID, which has been obtained on the Explorer page.\\n* `topic` - previously discussed `H256` topic name. In this picture it's a string of 32 symbols.\\n* `source` - account address to be associated with the topic.\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Overwrite\\\">\\n\\n  Pay attention that the topic may be overwritten with another source address if needed.\\n\\n</robo-wiki-note>\\n\\nSign and submit the extrinsic.\\n\\n## Explore\\n\\nYou can find all information about existing Digital Twins in `Developer -> Chain state` storage module `digitalTwin`.\\n\\n- Total number of Twins - `total()`;\\n- Digital Twin owner - `owner(u32)`;\\n- Information about topics of a Digital Twin - `digitalTwin(u32)`.\\n\\n<robo-wiki-picture src=\\\"digital-twin/chain-state.jpg\\\" />\"}},{\"node\":{\"id\":\"c288be24eabf36856bdd36e478c532aa\",\"title\":\"Datalog\",\"path\":\"/docs/datalog/\",\"content\":\"\\n**Now that you have some funds on your account you can submit extrinsics. The first to try is a Datalog. It allows you to store data in the blockchain persistently. Imagine a distributed and crypto-protected storage for your data and this is it!**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Please pay attention that this and following tutorials are demonstrated on a local instance of Robonomics Node. Set\\n up yours with [these instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navigate to Developer -> Extrinsics\\n\\n<robo-wiki-picture src=\\\"datalog/extrinsics.jpg\\\" />\\n\\n## 2. Choose datalog -> record from the dropdown list of possible extrinsics\\n\\nAlso choose an account you want to submit the extrinsic with. Fill in the record field.\\n\\n<robo-wiki-picture src=\\\"datalog/record.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Large amount of data\\\">\\n\\n  Datalog supports a string with a maximum of 512 bytes. To store large amount of data one may use [IPFS](https://ipfs.tech/).\\n\\n</robo-wiki-note>\\n\\n## 3. Submit transaction\\n\\nSign and submit the transaction with an account created previously using the extension or the DApp.\\n\\n<robo-wiki-picture src=\\\"datalog/submit.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Erase\\\">\\n\\n  You may also erase **ALL** of your records with *datalog -> erase* call.\\n\\n</robo-wiki-note>\\n\\n## 4. Review your datalog in the storage\\n\\nFor this, navigate to *Developer -> Chain state*, select *datalog -> datalogIndex*, specify your account and press the \\n\\\"+\\\" button to get the indexes of your account's records and then explore the one you need with *datalog -> datalogItem*.\\n\\n<robo-wiki-picture src=\\\"datalog/item.jpg\\\" />\\n\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Explorer\\\">\\n\\n  All the events including datalog record may be seen in the events flow in the *Explorer*.\\n\\n</robo-wiki-note>\"}},{\"node\":{\"id\":\"a4f9f7326687843b80644b49ecf5b648\",\"title\":\"Create digital identity run by Ethereum\",\"path\":\"/docs/create-digital-identity-run-by-ethereum/\",\"content\":\"\\nOne of the Robonomics services is [Digital Passport Registration](https://dapp.robonomics.network/#/passport/) for arbitrary data. The service allows you to create a digital identity saving the hashes of the data to the public blockchain and assigning a unique address.\\n\\nYou may find \\\"Digital passport registration\\\" service in [Robonomics DApp](https://dapp.robonomics.network/) in the \\\"Services\\\" section or just follow this [direct link](https://dapp.robonomics.network/#/passport/).\\n\\n\\n## Video walkthrough\\n\\nThe following video shows a progress of Robonomics Whitepaper registration:\\n\\nhttps://www.youtube.com/embed/E8R6VbZvf9w\\n\\n## Step-by-step in pictures\\n\\n### 1. Open the service\\n\\n![Digital passport registration applying form](./images/case_digital_passport_1.jpg \\\"Digital passport registration applying form\\\")\\n\\n### 2. Add necessary information and files\\n\\nPlease note, it is possible to add multiple images.\\n\\n![Filled Form](./images/case_digital_passport_2.jpg \\\"Filled Form\\\")\\n\\n### 3. Sign the demand\\n\\n![Sign the demand for digital passport creation](./images/case_digital_passport_3.jpg \\\"Sign the demand for digital passport creation\\\")\\n\\n\\n### 4. Approve tokens\\n\\nThe service charges a small fee. But first you must approve the required amount of tokens to be spent from your account.\\n\\n![Approve Tokens](./images/case_digital_passport_4.jpg \\\"Approve Tokens\\\")\\n\\n\\n### 5. Accept the offer and sign the message again\\n\\n![Send Order](./images/case_digital_passport_5.jpg \\\"Send Order\\\")\\n\\n### 6. Have a look at the created passport\\n\\n![The Digital Identity](./images/case_digital_passport_6.jpg \\\"The Digital Identity\\\") \\n\\nThe process of registration takes some time. In the end you will see a link to the created identity.\\n\"}},{\"node\":{\"id\":\"186ef2c734330a94116f16de215ff48a\",\"title\":\"Create Account for Robonomics Parachain\",\"path\":\"/docs/create-account-in-dapp/\",\"content\":\"\\n**In order to interact and operate with Robonomics Parachain, developers and users need to create an account on the Polkadot / Substrate Portal. The account performs basic functions for the network: your public network address(the public key), the access control to the address and funds (the private key), sending transactions to the network, showing your tokens and their amount, etc. Below are two main ways to create an account for Robonomics Parachain.**\\n\\n## 1. Using Polkadot{.js} Browser Extension\\n\\nThe Polkadot Extension provides a mechanism to generate the account and interact with all Polkadot / Kusama projects including Robonomics Parachain. This is not the safest way to manage your account, but it is the most convenient in terms of security / usability balance.\\n\\n## 1.1. Install Browser Extension\\n\\nThe browser extension is available for [FireFox](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension) and [Google Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en) (plus Chromium-based browsers).\\n\\n![Browser Extension](./images/creating-an-account/1.1-polkadot-extension.png \\\"Browser Extension\\\")\\n\\n## 1.2. Open Robonomics Parachain App\\n\\nGo to [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) on Polkadot / Substrate Portal. If this is the first time you entered the portal, it will request access to the browser extension, so allow access. \\n\\nOnce you've opened the app, take a look at the top left corner. The name of the network, its icon and the number of the last block are displayed there. Clicking on this area will open a list of all Polkadot / Kusama networks, including test networks and local nodes. You can switch between networks by selecting the required one and pressing the `Switch` button. **Make sure you are connected to Robonomics Parachain now**. \\n\\n![Robonomics Parachain app](./images/creating-an-account/1.2-robonomics-app.png \\\"Robonomics Parachain app\\\")\\n\\n## 1.3. Update Extension Metadata\\n\\nIt is very likely that the app will ask you to update the metadata for the extension to display the correct information about the chain you are connected to. Go to **Settings -> Metadata**, press `Update metadata` button and then, in the pop-up window, allow the extension to do it. \\n\\n![Updating metadata](./images/creating-an-account/1.3-metadata-update.png \\\"Updating metadata\\\")\\n\\n## 1.4. Create Account in Extension\\n\\nOpen the Polkadot{.js} browser extension. Click the big plus button or select `Create new account` from the small plus icon in the top right. You should see the following menu, with generated mnemonic seed in the form of twelve words and the address. \\n\\n![Account creation, step one](./images/creating-an-account/1.4-create-account-step-1.png \\\"Account creation, step one\\\")\\n\\nThe seed is your key to the account. Knowing the seed allows you (or anyone else who knows the seed) to get control on this account and even re-create it, if you forget the password. **It's very important to store it somewhere securely**, preferably on paper or other non-digital device, not in digital storage or on a computer. \\n\\nSave the seed and press `Next step`. You should see the following menu.\\n\\n![Account creation, step two](./images/creating-an-account/1.5-create-account-step-2.png \\\"Account creation, step two\\\")\\n\\n- *Network* allows you to choose which of the networks this account will be exclusively used for. You can use the same address on multiple networks, however, for privacy reasons, it is recommended that you create a new address for each network you use. \\nSelect the Robonomics network from the drop-down list. If you could not find the Robonomics network, then most likely you did not update the metadata, go back and do it.\\n\\n    - You will notice that the format of the address and the account icon will change — this is normal. Different network formats are merely other representations of the same public key. \\n\\n- *Name* is just account's name for your use only. It is not stored on the blockchain and will not be visible to other users. \\n\\n- *Password* is used to encrypt your account's information. You will need to re-enter it when signing transactions on the portal. Create one and remember it.\\n\\nAs a result, after creating an account, you will see it in the list of accounts in Polkadot{.js} extension. By clicking on three dots, you can rename the account, export it, remove it from the extension and change the network used for the account. \\n\\nAlso, the account will appear in the **Accounts -> Accounts** menu on the portal, where it will be noted that it was injected using the extension.\\n\\n![Successful account creation](./images/creating-an-account/1.6-account-injected.png \\\"Successful account creation\\\")\\n\\n\\n## 2. Directly on Robonomics Parachain App\\n\\nYou can use the user interface on the Polkadot / Substrate Portal to create an account. It could be used for development and tests. \\n\\n## 2.1. Open Robonomics Parachain App\\n\\nGo to [Robonomics Parachain app](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/) on Polkadot / Substrate Portal. **Check at the top left corner that you are connected to Robonomics Parachain**.  \\n\\nGo to **Accounts -> Accounts** and press `Add account` button. \\n\\n![Robonomics Parachain App](./images/creating-an-account/2.1-robonomics-app-main-view.png \\\"Robonomics Parachain App\\\")\\n\\n## 2.2. Create Account\\n\\nYou should see the following popup menu with account seed. \\n\\n![Generating account seed](./images/creating-an-account/2.2-robonomics-app-seed.png \\\"Generating account seed\\\")\\n\\nIt has two forms: *Mnemonic* (human-readable) and *Raw* (a sequence of digits and letters). Save the seed phrase securely and press `Next`.\\n\\n> Also you can change the crypto type of creating account, for that open `Advanced creation options` and choose the type (`ed25519` on the picture).\\n\\n![ed25519 crypto type account](./images/creating-an-account/ed-account.jpg)\\n\\nIn the next menu, you need to set the account name and password, similar to the extension instructions described above.\\n\\n![Generating account name and password](./images/creating-an-account/2.3-robonomics-app-name-pass.png \\\"Generating account name and password\\\")\\n\\nClicking on the `Next` button will take you to the last window. Click `Save` to finish account creation. It will also generate a backup JSON-files that you should safely store. You can later use this file to recover your account if you remember the password.\\n\\n![Successful account creation](./images/creating-an-account/2.4-robonomics-app-account-created.png \\\"Successful account creation\\\")\\n\\n## 2.3 Add ed25519 account to Polkadot extension\\n\\nYou may need to add created account to Polkadot.js extension (for ed25519 account you can do that only with backup JSON file). For that you need to create backup file of the account. Press on three dots on your account and choose `Create a backup file for this account` and write your password.\\n\\n![Backup file](./images/creating-an-account/backup-file.jpg)\\n\\nThen open an extension and press `+` button on the top right, then choose `Restore account from backup JSON file`.\\n\\n![Restore backup in extension](./images/creating-an-account/extention-add-backup.jpg)\\n\\nIn opened window drop saved file, enter the password and press `Restore`.\\n\\n![Restore backup in extension 2](./images/creating-an-account/file-backup.jpg)\\n\\n## 3. Account Сreated Successfully \\n\\nNow you can fully operate with your fresh-created account. Send and receive tokens, messages, write datalog and more. Feel free to explore all the features of app. To copy your account's address simply click on its icon, address will be copied to clipboard. \\n\\nIf you would like to know more about Polkadot / Kusama accounts and additional ways to create them, more information can be found [here](https://wiki.polkadot.network/docs/learn-accounts) and [here](https://wiki.polkadot.network/docs/learn-account-generation).\\n\"}},{\"node\":{\"id\":\"04a1703849a87814837e1bb68ccf21cd\",\"title\":\"How to Contribute to Robonomics Resources\",\"path\":\"/docs/contributing/\",\"content\":\"\\nRobonomics Network is an open-source project and we want to make it easy for anyone to contribute. You may create articles, suggest changes, improve documentation or run tests. If you want to contribute, please, open a new issue or create a pull request in the same repository.\\n\\n## Main Robonomics Repositories \\n\\n- [Robonomics Wiki](https://github.com/airalab/robonomics-wiki) — Main wiki project\\n- [Robonomics Main](https://github.com/airalab/robonomics.network) —  Official main website of Robonomics Network \\n- [Robonomics.cloud](https://github.com/airalab/robonomics.cloud) — Home for Robonomics Web Services\\n- [Robonomics Dapp](https://github.com/airalab/dapp.robonomics.network) — Official dapp\\n- [Robonomics Academy](https://github.com/airalab/robonomics.academy) — Official website of Robonomics Academy\\n\\n### Rules for Reporting\\n\\nWhen opening a new issue, do not forget about a few basic rules for reporting:\\n\\n1. Choose exact repository, that you want to submit an issue.\\n\\n2. If you are reporting bug, make sure the bug was not already reported.\\n\\n3. Be sure to include title and clear description, as much relevant information as possible.\\n\\n4. Please, prefix your issue with one of the following: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\\n\\n\\n## Pull Requests\\n\\nAny Robonomics repository may be subject to pull requests or changes by contributors, where you believe you have something valuable to add or change. Please, do not forget about basic rules for contributors.\\n\\n### Rules for contributing\\n\\n1. Pull requests are preferred to issues, if you have some fixes, especially for small changes such as typos.\\n\\n2. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable.\\n\\n3. Please, do not fix whitespace, format code, or make a purely cosmetic patch.\\n\\n4. Please, attempt to adhere to the prevailing Markdown style, language, and layout.\\n\\n\\n\"}},{\"node\":{\"id\":\"2acc72053db6120411e8523fc919e1cb\",\"title\":\"Offsetting Service\",\"path\":\"/docs/carbon-footprint-service/\",\"content\":\"\\nExample of work is in the video:\\n\\nhttps://youtu.be/Ha9wN6bjh64\\n\\nService to offset CO2 footprint by burning tokens in Statemine network. \\nProduced CO2 calculates as follows: data from device in Wh multiply by  coeffcients depends on the region. 1 ton of C02 is covered by consuption of 1 token. [Here](/docs/carbon-footprint-sensor) is the unstructions for connecting device.\\n\\n## Scenario\\n\\n1. Register a new deivce in Digital Twin in Robonomics network \\n2. Once in an interval getting last data from all device and multiply by the coefficient depending on the region\\n3. Sum data and convert them to CO2 tons\\n4. Subtract the total number of burning tokens from current data \\n5. Burn integer number of tokens in Statemine network \\n6. Saved total number of burning tokens in local DB and Datalog \\n\\n\\n## Installing\\n\\nClone the repository and edit config file.\\n\\n```\\ngir clone https://github.com/tubleronchik/service-robonomics-carbon-footprint.git\\ncd service-robonomics-carbon-footprint\\ncp config/config_template.yaml config/config.yaml \\n```\\n\\n## Configuration description\\n\\nDo not edit `config/config_template.yaml`!\\n\\n```\\nrobonomics:\\n  seed: <seed for account in Robonomics Network where Digital Twin will be created>\\nstatemine:\\n  seed: <seed for admin account with green tokens in Statemine Netowrk>\\n  endpoint: <statemine endpoint>\\n  token_id: <id of the token which will be burned>\\n  ss58_format: <format of address in Polkadot (for Statemine Network is 2)>\\n\\nservice:\\n  interval: <how often data from devices will be collected>\\n```\\nCoefficients for non-renewable energy have been taken from [Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=File:Renewable_energy_2020_infographic_18-01-2022.jpg) and stored in `utils/coefficients.py`. \\n\\n## Launch\\n\\n```\\ndocker-compose up\\n```\"}},{\"node\":{\"id\":\"3e25d2e757fc04687191665f6f6cdf41\",\"title\":\"Connect sensor\",\"path\":\"/docs/carbon-footprint-sensor/\",\"content\":\"\\nExample of work is in the video:\\n\\nhttps://youtu.be/jsaFCVAx2sA\\n\\n## Requirements\\n\\n* [Aqara Smart Plug](https://aqara.ru/product/aqara-smart-plug/?yclid=462434430312045270)\\n* Raspberry Pi\\n* Zigbee adapter [JetHome USB JetStick Z2](https://jhome.ru/catalog/parts/PCBA/293/) (or one of [supported](https://www.zigbee2mqtt.io/information/supported_adapters.html))\\n\\nService is running on Raspberry Pi and contact the smart plug via zigbee protocol.\\n\\n## Zigbee stick\\n\\nIf you have JetHome USB JetStick Z2 it already has necessary firmware so you don't need to flash it. But if you have another adapter firstly you need to flash it with zigbee2MQTT software. You can find instructions for you device [here](https://www.zigbee2mqtt.io/information/supported_adapters.html).\\n\\nConnect the adapter and verify the adapter address (it also may be `/dev/ttyUSB1`):\\n```bash\\n$ ls -l /dev/ttyUSB0\\ncrw-rw---- 1 root dialout 166, 0 May 16 19:15 /dev/ttyUSB0 \\n```\\n\\nYou might need to get access to the USB port first. Add your user to `dialout` group (it works for ubuntu, but the name of the group may be different on other OS).\\nFor ubuntu:\\n```bash\\nsudo usermod -a -G dialout $USER\\n```\\nFor arch:\\n```bash\\nsudo usermod -a -G uucp $USER\\n```\\nThen logout and login or restart the computer.\\n\\n## Installation\\n\\nClone the repository:\\n\\n```\\ngit clone https://github.com/makyul/robonomics-carbon-footprint.git\\ncd robonomics-carbon-footprint\\n```\\n\\n## Configuration\\n\\nGo to `data/configuration.yaml` and set `permit_join: true`:\\n\\n```\\n# Home Assistant integration (MQTT discovery)\\nhomeassistant: false\\n\\n# allow new devices to join\\npermit_join: true\\n\\n# MQTT settings\\nmqtt:\\n  # MQTT base topic for zigbee2mqtt MQTT messages\\n  base_topic: zigbee2mqtt\\n  # MQTT server URL\\n  server: 'mqtt://172.17.0.1'\\n  # MQTT server authentication, uncomment if required:\\n  # user: my_user\\n  # password: my_password\\n\\n# Serial settings\\nserial:\\n  # Location of CC2531 USB sniffer\\n  port: /dev/ttyUSB0\\n```\\nAlso you might want to fill fields `server` and `port` with corresponding information. In `server` field use the IP of the `docker0` bridge to establish the connection: \\n\\n```bash\\n$ ip a                                                 127\\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n\\n...\\n\\n5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \\n    link/ether 02:42:0d:ff:5f:a3 brd ff:ff:ff:ff:ff:ff\\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\\n       valid_lft forever preferred_lft forever\\n    inet6 fe80::42:dff:feff:5fa3/64 scope link \\n       valid_lft forever preferred_lft forever\\n```\\nHere your address is `172.17.0.1`.\\n\\nThen create file config/config.yaml with following information and set your location (you can look up to https://countrycode.org/ for 3-letters ISO-code):\\n\\n```\\nlocation: RUS\\nservice_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\ntwin_id: 5\\nsending_timeout: 3600\\nbroker_address: \\\"172.17.0.1\\\"\\nbroker_port: 1883\\n```\\n\\n## Connect Plug\\n\\nFirst run:\\n\\n```\\ndocker-compose up     \\n```\\n\\nTo switch to the pairing mode on plug long press the power button for a few seconds until the light starts flashing blue rapidly. \\n\\nIn logs you should see now your plug started publishing to mqtt. \\n\\n\\n## After pairing\\n\\nIf you don't wont to let other devices to pair with your stick, now you should go to `data/configuration.yaml` and set `permit_join: false`. Restart service (use 'Ctrl+C' and \\n\\n```bash\\ndocker-compose up     \\n```\\nonce again to submit changes).\\n\\n## Running\\nAt first start the account for the plug will be created. \\n> If you already have an account you should add its seed to `config.config.yaml` file in `device_seed` section:\\n>\\n> ```\\n> location: RUS\\n> service_address: 4GdHeLbmio2noKCQM5mfxswXfPoW2PcbpYKKkM4NQiqSqJMd\\n> twin_id: 5\\n> sending_timeout: 3600\\n> broker_address: \\\"172.17.0.1\\\"\\n> broker_port: 1883\\n> device_seed: <device_seed>\\n>```\\n\\nAfter creating account you will see the address in logs (seed will be added to `config/config.yaml`):\\n```\\nplug               | Generated account with address: 4GuP82BMAgrbtU8GhnKhgzP827sJEaBXeMX38pZZKPSpcWeT\\n```\\nYou need to transfer some tokens to this account for transaction fees, you can do it on [Robonomics Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama.rpc.robonomics.network%2F#/accounts). \\n\\nService will see that you have enough tokens, in logs you will see:\\n```\\nplug               | Balance is OK\\n```\\nService will see mqtt messages from the plug and safe power usage. Every hour (you can change timeout in `config/config.yaml` in `sending_timeout` section, timeout is on seconds) it will create datalog with the following information:\\n```\\n{'geo': 'RUS', 'power_usage': 1.021237391233444, 'timestamp': 1644494860.5860083}\\n```\\n\"}},{\"node\":{\"id\":\"5c95cdeabd41575011fefb91cf8af3e8\",\"title\":\"Backup Services\",\"path\":\"/docs/backup-services/\",\"content\":\"\\n**In this article, you will learn how to generate backups of your Home Assistant configuration and restore it when needed. To create backups, a service is called that generates a secure archive with configuration files. Also service adds Mosquitto brocker and Zigbee2MQTT configuration  to backup if exist. This service then adds the archive to IPFS and stores the resulting CID in Robonomics Digital Twin.**\\n## Creating Home Assistant Configuration's Backup\\n\\nCreating a backup allows you to easily restore your Home Assistant configuration in the event of a failure.\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmZN5LfWR4XwAiZ3jEcw7xbCnT81NsF5XE3XFaNhMm5ba1', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nIn order to backup and restore your configuration, it is necessary to use a **custom IPFS gateway** such as Pinata. Without it, your backup will be stored solely on your local IPFS node, which may prevent you from restoring your Home Assistant configuration in the event of a local node failure.\\n\\n</robo-wiki-note>\\n\\n1. In the web interface of Home Assistant go to `Developer Tools` -> `Services`. Search for `Robonomics: Save Backup to Robonomics` and press `CALL SERVICE`.\\n\\n2. Wait until you see the notification `Backup was updated in Robonomics` appear in `Notification`.\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nDo not attempt to create a backup or restore configuration immediately after loading Home Assistant and Robonomics Integration. Please **wait for approximately 5 minutes** to allow for the initial setup to complete.\\n\\n</robo-wiki-note>\\n\\nService arguments:\\n- **Full Backup**  (default: False) - add database to the backup, so history of entity states will be stored too.\\n- **Path to mosquitto password file** (default: `/etc/mosquitto`) - If you used Home Assistant Core or Docker installation methods and don't have default path to Mosquitto brocker, you should change this parameter. *Not needed for Home Assistant OS or Superviser*.\\n\\n## Restoring Home Assistant Configuration from Backup\\n\\nIn order to restore your configuration, you will need an installed Home Assistant and Robonomics Integration. \\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/QmNcJpHWWuZzwNCQryTw5kcki49oNTjEb8xvnfffSYfRVa', type:'mp4'}]\\\" />\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"WARNING\\\">\\n\\nTo ensure successful restoration of your configuration in Home Assistant Core and Docker installation methods, you need to perform additional setup steps as described at the end of the page.\\n\\n</robo-wiki-note>\\n\\n1. Install Home Assisntant with Robonomics Integration (if it is not installed yet), following the steps from the article for the [desired installation method](https://wiki.robonomics.network/docs/robonomics-smart-home-overview/#start-here-your-smart-home).\\n\\n2.  [Set up Robonomics Integration](https://wiki.robonomics.network/docs/robonomics-hass-integration) using **the same seeds** you used in previous Robonomics configuration. If you subscription has ended, [reactivate it](https://wiki.robonomics.network/docs/sub-activate).\\n\\n3. In the web interface of Home Assistant go to `Developer Tools` -> `Services`. Search for `Robonomics: Restore from the Backup in Robonomics` and press `CALL SERVICE`. Navigate to the `Overview` page, to check the status of your backup, .\\n\\n4. After restoring, Home Assistant will automatically restart. If for some reason Home Assistant does not restart, you can check the restoration status by monitoring the state of the `robonomics.backup` entity. If the status is `restored` you will need to manually restart Home Assistant by navigating to `Settings` > `System` and clicking on the `RESTART` button located in the upper right corner.\\n\\n5. If your backup includes the Zigbee2MQTT or Mosquitto configuration, you need to restart these services to enable the new configuration. You can do this manually by restarting the services individually, or you can simply restart the Home Assistant computer to ensure all services are restarted.\\n\\nService arguments:\\n- **Path to mosquitto password file** (default: `/etc/mosquitto`) - If you used Home Assistant Core or Docker installation methods and have not default path to Mosquitto brocker, you should change this parameter. *Not needed for Home Assistant OS or Superviser*.\\n- **Path to Zigbee2MQTT config**  (default: `/opt/zigbee2mqtt`) - If you used Home Assistant Core or Docker installation methods and have not default path to Zigbee2MQTT, you should change this parameter. *Not needed for Home Assistant OS or Superviser*.\\n\\n## Restore Mosquitto and Zigbee2MQTT Configuration for Home Assistant Core Installation Method\\n\\nIf the backup includes the configuration for Mosquitto or Zigbee2MQTT, during the restore process, they will be placed in the default path or in the path specified in the arguments. However, if you installed the Robonomics integration in an existing Home Assistant Core *(not from the preinstalled Robonomics image)*, the `homeassistant` user may not have access to this path.\\n\\nSo to restore the configuration of Mosquitto and Zigbee2MQTT, you need to grant the necessary read permissions to the user `homeassistant`:\\n```bash\\nsudo chmod a+w /opt/zigbee2mqtt /etc/mosquitto\\n```\\n\\n## Backup Mosquitto and Zigbee2MQTT Configuration for Home Assistant Docker Installation Method\\n\\nTo backup the Mosquitto and Zigbee2MQTT configurations from a Docker container, you need to create volumes for their respective configurations. This can be achieved by running your Home Assistant container with additional arguments:\\n\\n```bash\\ndocker run -d \\\\\\n  --name homeassistant \\\\\\n  --privileged \\\\\\n  --restart=unless-stopped \\\\\\n  -e TZ=MY_TIME_ZONE \\\\\\n  -v /PATH_TO_YOUR_CONFIG:/config \\\\\\n  -v /etc/mosquitto:/etc/mosquitto \\\\\\n  -v /etc/mosquitto:/opt/zigbee2mqtt \\\\\\n  --network=host \\\\\\n  ghcr.io/home-assistant/home-assistant:stable\\n```\\n\\nor make changes in your `compose.yaml` file:\\n\\n```yaml\\nversion: '3'\\nservices:\\n  homeassistant:\\n    container_name: homeassistant\\n    image: \\\"ghcr.io/home-assistant/home-assistant:stable\\\"\\n    volumes:\\n      - /PATH_TO_YOUR_CONFIG:/config\\n      - /etc/localtime:/etc/localtime:ro\\n      - /etc/mosquitto:/etc/mosquitto\\n      - /etc/mosquitto:/opt/zigbee2mqtt\\n    restart: unless-stopped\\n    privileged: true\\n    network_mode: host\\n```\\n<robo-wiki-note type=\\\"note\\\" title=\\\"Note\\\">\\n\\nPlease note that the default paths for Mosquitto and Zigbee2MQTT configurations are `/etc/mosquitto` and `/opt/zigbee2mqtt`, respectively. However, these paths may vary depending on your specific setup.\\n\\n</robo-wiki-note>\\n\\n## Backup Buttons\\n\\nIn addition to using services to work with backups, you can simplify the process by using the `button.create_backup` and `button.restore_from_backup` buttons from the Robonomics integration. These buttons invoke the respective services with default parameters (the backup button creates a backup without history).\\n\\n<robo-wiki-video autoplay loop controls :videos=\\\"[{src: 'https://cloudflare-ipfs.com/ipfs/Qmc1fexYaJMsK6ch6JhjL6aqnAwqYNAzo5nEwYgDpnp4gj', type:'mp4'}]\\\" />\\n\\nTo add buttons to your dashboard, follow these steps:\\n\\n1. Click on the three dots in the top right corner of the dashboard.\\n2. Select `Edit Dashboard`.\\n3. Click on the `Add Card` button in the bottom right corner.\\n4. Choose the `Entities` card.\\n5. In the `Entities` field, search for the button.create_backup and button.restore_from_backup entities.\\n6. Press `Save` to add the entities to the card.\\n7. Finish editing by clicking the `Done` button in the top right corner.\"}},{\"node\":{\"id\":\"5f6a4ef1dcf293a2070803f07dbd2817\",\"title\":\"Adding funds to your account on Robonomics Portal\",\"path\":\"/docs/adding-funds-to-account-in-dapp/\",\"content\":\"\\n**After successfully creating your accounts on Robonomics portal, it is time to add funds to them so that you would be able to initiate transactions.**\\n\\n<robo-wiki-note type=\\\"warning\\\" title=\\\"Dev Node\\\">\\n\\n  Please pay attention that this and following tutorials are demonstrated on a local instance of Robonomics Node. Set\\n up yours with [these instructions](/docs/run-dev-node).\\n\\n</robo-wiki-note>\\n\\n## 1. Navigate to Accounts section on Robonomics portal \\n\\n![Accounts](./images/creating-an-account/portal-top-left.jpg \\\"Accounts\\\")\\n\\n## 2. Choose the account you want to transfer funds from\\n\\nIn the development mode, there exist several accounts, with 10000 Units worth of funds each, that can be used to transfer funds to other accounts created in the development network. These accounts are indicated by wrench signs <img alt=\\\"wrench sign\\\" src=\\\"./images/adding-funds/wrench.png\\\" width=\\\"20\\\" /> next to them.\\n\\n![Accounts-for-sending](./images/adding-funds/accounts-for-sending.svg \\\"Accounts-for-sending\\\")\\n\\n- Click on the \\\"send\\\" button of the account you want to transfer funds from, for example BOB\\n\\n## 3. Choose the account you want to transfer funds into\\nAfter clicking on the \\\"send\\\" button, you would be prompted with the \\\"send funds window\\\". In the prompted window:\\n\\n- From the list of available accounts, choose the account you want to send funds into.\\n- Enter the number of Units you want to send.\\n- Press \\\"make transfer\\\"\\n\\n![Transfer-Funds](./images/adding-funds/send-funds.png \\\"Transfer-Funds\\\")\\n\\n## 4. Authorize the transaction\\n\\nAfter pressing \\\"make transfer\\\" in the previous stage, you would be prompted with \\\"authorize transaction window\\\".<br/>\\nReview the details of the transaction and finally click on \\\"sign and submit\\\" button.\\n\\n![sign-transaction](./images/adding-funds/sign-transaction.png \\\"sign-transaction\\\")\\nIn this example, we transferred 500 units of funds from \\\"BOB\\\" to \\\"EMPLOYER\\\". You can see that EMPLOYER's account, which initially did not have any funds, has 500 Units of fund now.\\n\\n![funds-added](./images/adding-funds/funds-added.svg \\\"funds-added\\\")\\n\\n**Make sure that you have enough funds in the accounts you want to use in the playground.**\"}}]}};/* harmony default export */ __webpack_exports__[\"default\"] = (({options})=>{if(options.__staticData){options.__staticData.data=data;return;}options.__staticData=vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].observable({data});options.computed=computed({$static:()=>options.__staticData.data},options.computed);});\n\n//# sourceURL=webpack:///./src/components/Search.vue?./node_modules/babel-loader/lib??ref--14-0!./node_modules/gridsome/lib/plugins/vue-components/lib/loaders/static-query.js!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "sYzg":
/*!************************************************************************************************!*\
  !*** ./src/components/Search.vue?vue&type=style&index=0&id=667ceb10&prod&scoped=true&lang=css ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_ref_2_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_style_index_0_id_667ceb10_prod_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??ref--2-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src??ref--2-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib??vue-loader-options!./Search.vue?vue&type=style&index=0&id=667ceb10&prod&scoped=true&lang=css */ \"AmrW\");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_ref_2_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_style_index_0_id_667ceb10_prod_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_ref_2_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_style_index_0_id_667ceb10_prod_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_ref_2_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_style_index_0_id_667ceb10_prod_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_ref_2_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Search_vue_vue_type_style_index_0_id_667ceb10_prod_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n//# sourceURL=webpack:///./src/components/Search.vue?");

/***/ }),

/***/ "wQbG":
/*!***********************************!*\
  !*** ./src/components/Search.vue ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Search_vue_vue_type_template_id_667ceb10_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Search.vue?vue&type=template&id=667ceb10&scoped=true */ \"Umzq\");\n/* harmony import */ var _Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Search.vue?vue&type=script&lang=js */ \"abJ6\");\n/* empty/unused harmony star reexport *//* harmony import */ var _Search_vue_vue_type_style_index_0_id_667ceb10_prod_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Search.vue?vue&type=style&index=0&id=667ceb10&prod&scoped=true&lang=css */ \"sYzg\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"KHd+\");\n/* harmony import */ var _Search_vue_vue_type_custom_index_0_blockType_static_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Search.vue?vue&type=custom&index=0&blockType=static-query */ \"A2fM\");\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Search_vue_vue_type_template_id_667ceb10_scoped_true__WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _Search_vue_vue_type_template_id_667ceb10_scoped_true__WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  \"667ceb10\",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof _Search_vue_vue_type_custom_index_0_blockType_static_query__WEBPACK_IMPORTED_MODULE_4__[\"default\"] === 'function') Object(_Search_vue_vue_type_custom_index_0_blockType_static_query__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(component)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/components/Search.vue?");

/***/ })

}]);