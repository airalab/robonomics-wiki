---
title: Тестовий набір Substrate Cumulus Parachain для міжланцюжкового обміну повідомленнями

contributors: [ddulesov, boogerwooger, tubleronchik] 
---


Основною метою цього проекту є спрощення розробки часу виконання ланцюжка, коли використовуються міжланцюжкові повідомлення.
Це дозволяє розробляти код часу виконання з інтеграційними тестами з високим рівнем повторюваності та простим використанням.
Це автоматизує побудову, створення попередньо встановленої конфігурації мережі (тобто 1 реле-ланцюжок + 2 підланцюжки), налаштування каналів передачі повідомлень між підланцюжками та запуск тестів повідомлень, відправлення повідомлень, використання виклику до часу виконання, все це побудовано та скомпоновано в Python.

Тестовий набір XCM використовується для тестування виробничого циклу Robobank - набору підланцюжков Substrate, які дозволяють роботам реєструватися на зовнішніх підланцюжках, отримувати передоплачені замовлення, виконувати їх та отримувати платежі за допомогою зовнішніх токенів. Це дозволяє роботам працювати в мережі Robonomics з усією необхідною інфраструктурою, але в той же час пропонувати свої послуги на будь-якому іншому підланцюжку.

Приклад відео доступний на [YouTube](https://www.youtube.com/watch?v=S_bZgsxngiM)

Основні кроки в демонстраційному сценарії:
- запуск реле-ланцюжка та двох підланцюжків у пакеті з 6 процесів
- налаштування каналів передачі повідомлень XCM між підланцюжками
- реєстрація робота в обох підланцюжках
- створення замовлення для цього робота в клієнтському підланцюжку (резервування платежу за виконання замовлення)
- відправлення повідомлення XCM на підланцюжок Robonomics
- створення запису "дзеркального" замовлення на підланцюжці Robonomics
- робот приймає замовлення на підланцюжці Robonomics
- відправлення повідомлення XCM про прийняття замовлення назад на клієнтський підланцюжок
- прийняття замовлення на клієнтському підланцюжку (резервування штрафу за невиконання замовлення до кінцевого терміну)
- робот виконує замовлення на підланцюжці Robonomics
- відправлення повідомлення XCM про завершення замовлення на клієнтський підланцюжок
- розрахунок всіх платежів (платіж клієнта переказується роботу, а також не використаний штраф за невиконання замовлення)
- закриття замовлення

## Вгору по течії
Цей проект є форком
[Шаблону вузла Центру розробника Substrate](https://github.com/substrate-developer-hub/substrate-node-template).
Він містить код часу виконання палеток, які тестуються.
Як у вихідному файлоКод вузлів параблоків знаходиться в каталогах "./pallets", "./runtime", "./node".

Відмінності від оригінального "substrate-node-template":
- цей рантайм колатора має модуль обробника HRMP та може обробляти повідомлення від сусідніх параблоків
- готовий макет тестування рантайму для внутрішніх тестів XCM

## Збірка та Запуск
Рекомендоване(високо) обладнання: 
```
Ubuntu 20, 16 Гб ОЗП, 8 CPU, 120 Гб SSD
```
[ПРИМІТКА] Перша збірка може зайняти багато часу, до кількох годин на неоптимальних машинах.

[ПРИМІТКА] Скрипт працює з ФІКСОВАНИМИ версіями (хешами комітів) Polkadot(Rococo) у реле-ланцюжку та параблоках.

[ПРИМІТКА] За замовчуванням скрипт перестворює те саме середовище кожен запуск, видаляючи всі попередні стани. Цю поведінку можна змінити в "config.sh", використовуючи параметр "PERSISTENT".

Запустіть скрипт збірки та налаштування.  
```bash
git clone https://github.com/airalab/xcm-robobank-prototype.git
cd xcm-robobank-prototype
./scripts/init.sh
```

Основні дії скрипту "init.sh":
 - читає конфігурацію (файл "config.sh" з номером ревізії, початковими ключами вузла та ідентифікаторами, параметром збереження даних ланцюжка тощо)
 - налаштовує пакети ОС, Rust та Python
 - збирає окремі бінарні файли для реле-ланцюжка та для обох параблоків
    - бінарні файли будуть згенеровані в підкаталозі ./bin. 
 - (необов'язково) видаляє всі попередні дані ланцюжка для всіх ланцюжків
    - вимкнено, якщо "PERSISTENT=1" встановлено в "config.sh"
 - запускається як окремі процеси (з окремими PID та каналами введення/виведення):
    - валідатори реле-ланцюжка (тобто 4 валідатори, які працюють на стабільній ревізії Rococo)
    - колатори для параблока-100 (тобто один колатор для першого параблока, який ви розробляєте)
    - колатори для параблока-200 (тобто один колатор для другого параблока, який ви розробляєте)
 - виводить всі кінцеві точки, порти на консоль, що дозволяє вам вивчати будь-який ланцюжок за допомогою додатків фронтенду (дослідник, DApp)
 - продовжує виводити всі вихідні дані всіх ланцюжків на консоль

[УВАГА] Після запуску зачекайте, доки мережа буде активна, переконайтеся, що фіналізація блоку розпочалася, і що параблоки зареєстровані. Ці процеси повинніпотрібно приблизно 5 хв (50 блоків x 6 сек).

## Перевірка роботи початкового налаштування

Використовуйте стандартний фронтенд Polkadot та згенеровані кінцеві точки "--ws-port" для підключення до кожного вузла.
Відкрийте [додаток Polkadot](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/) для моніторингу ланцюжків.

### Приклад:
Localhost, 4 валідатори ретрансляційного ланцюжка, один колатор parachain-100, один колатор parachain-200:
- [Валідатор ретрансляції 1](https://polkadot.js.org/apps/?rpc=ws://localhost:9500/)
- [Валідатор ретрансляції 2](https://polkadot.js.org/apps/?rpc=ws://localhost:9501/)
- [Валідатор ретрансляції 3](https://polkadot.js.org/apps/?rpc=ws://localhost:9502/)
- [Валідатор ретрансляції 4](https://polkadot.js.org/apps/?rpc=ws://localhost:9503/)
- [Колатор Parachain-100](https://polkadot.js.org/apps/?rpc=ws://localhost:10054/)
- [Колатор Parachain-200](https://polkadot.js.org/apps/?rpc=ws://localhost:10055/)

Якщо все працює і консенсус розпочато, ми можемо перейти до запуску наших тестових випадків (у новому терміналі).

### Тестування передачі повідомлень UMP
```bash
./scripts/init.sh ump
```
Це створює повідомлення `Balance.transfer` в `parachain-100` та передає його на ретрансляційний ланцюжок.
Коли ретрансляційний ланцюжок отримає повідомлення, він передасть 15 токенів з рахунку `para 100` на рахунок Чарлі.

### Тестування передачі повідомлень HRMP
```bash
./scripts/init.sh ump
```
Це створює повідомлення `Balance.transfer` в `parachain-100` та передає його на `сусідній 200`.
Перед цим воно надає рахунок `subl 100` 1000 токенами та встановлює комунікаційний канал між паралелізованими ланцюжками.
```bash
./scripts/init.sh hrmp
```
Наступні повідомлення можна відправити, запустивши підкоманду `hrmpm`. Воно не створює канал і тому працює швидше.
```bash
./scripts/init.sh hrmpm
```

### Ще варіанти
```bash
./scripts/init.sh help
```

## Локальна тестова мережа### Створення власної специфікації ланцюжка

```
./bin/polkadot build-spec --chain rococo-local --disable-default-bootnode > rococo_local.json
```

Відредагуйте файл rococo_local.json, замініть параметри балансів та авторитетів на свої.
```json
  "keys": [
    [
      "",
      "",
      {
        "grandpa": "",
        "babe": "",
        "im_online": "",
        "para_validator": "",
        "para_assignment": "",
        "authority_discovery": ""
      }
    ]
```

Polkadot-адреса для //Alice//stash (криптографія sr25519).
```bash
$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice//stash
```

```text
Секретний ключ URI `//Alice//stash` належить обліковому запису:
Секретне насіння:      

Публічний ключ (hex): 

ID облікового запису:       

SS58 Адреса:     
```

Ключ сесії grandpa Polkadot для //Alice (криптографія ed25519).
```bash
$ polkadot key inspect-key --scheme ed25519 --network substrate //Alice
```
```text
Секретний ключ URI `//Alice` належить обліковому запису:
Секретне насіння:      

Публічний ключ (hex): 

ID облікового запису:       

SS58 Адреса:     
```

Polkadot-адреса для //Alice (криптографія sr25519).
```
$ polkadot key inspect-key --scheme sr25519 --network substrate //Alice
```
```text
Секретний ключ URI `//Alice` належить обліковому запису:
Секретне насіння:      

Публічний ключ (hex): 

ID облікового запису:       

SS58 Адреса:     
```

Конвертувати rococo_local.json у формат raw.
```
./bin/polkadot build-spec --chain rococo_local.json --raw --disable-default-bootnode > rococo_local.json
```
Для використання нової специфікації ланцюжка замініть файл rococo.json у каталозі ./config/ на цей новий та перезапустіть ланцюжок.
```bash
./scripts/init.sh run
```
Ви можете вільно редагувати код. Вищезазначена команда перебудує проект та оновлює вузол коллатора перед запуском.
Cumulus - це передвипускне програмне забезпечення, яке все ще знаходиться в активній розробці.
Ми використовуємо конкретний коміт polkadot [46c826f595021475fa5dbcd0987ed53f104e6e15  18 березня 2021](https://github.com/paritytech/polkadot/tree/46c826f595021475fa5dbcd0987ed53f104e6e15)

Ви можете використовувати більш нові версії програмного забезпечення. Для цього змініть  POLKADOT_COMMIT  в ./scipt/config.sh
на останній коміт гілки `rococo-v1`, видаліть ./bin/polkadot, і запустіть 
```bash
./scripts/init.sh run
```

Оновіть залежності проекту коллектора 
```bash
cargo update
./scripts/init.sh build
```
Деякі залежності, ймовірно, вимагають нових функцій інструментарію rust.
Цей проект базується на rust `nightly-2021-01-26`
Оновіть версію інструментарію rust в ./scripts/config.sh перед збіркою.

## Взламати парачейн
[Додати зовнішній палет](https://substrate.dev/docs/en/tutorials/add-a-pallet/) - можливо, це краще розмістити в "дізнатися більше"?
## Дізнатися більше

Зверніться до вихідного
[Шаблону вузла розробника Substrate](https://github.com/substrate-developer-hub/substrate-node-template)
щоб дізнатися більше про структуру цього проекту, можливості, які він включає, та спосіб, яким ці можливості реалізовані. Ви можете дізнатися більше про
[Шлях блоку парачейну](https://polkadot.network/the-path-of-a-parachain-block/) на
офіційному блозі Polkadot.
[Паритетний семінар Cumulus](https://substrate.dev/cumulus-workshop/#/)